
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Org
 * 
 */
export type Org = $Result.DefaultSelection<Prisma.$OrgPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserRecoveryCode
 * Recovery codes for self-service account recovery (Layer 1)
 */
export type UserRecoveryCode = $Result.DefaultSelection<Prisma.$UserRecoveryCodePayload>
/**
 * Model UserSecurityQuestion
 * Security questions for additional verification (Layer 2)
 */
export type UserSecurityQuestion = $Result.DefaultSelection<Prisma.$UserSecurityQuestionPayload>
/**
 * Model UserBreakglassAccount
 * Breakglass account for automated emergency access (Layer 3)
 */
export type UserBreakglassAccount = $Result.DefaultSelection<Prisma.$UserBreakglassAccountPayload>
/**
 * Model UserDeviceFingerprint
 * Device fingerprinting for trust scoring
 */
export type UserDeviceFingerprint = $Result.DefaultSelection<Prisma.$UserDeviceFingerprintPayload>
/**
 * Model UserLoginHistory
 * Comprehensive login history for audit trail
 */
export type UserLoginHistory = $Result.DefaultSelection<Prisma.$UserLoginHistoryPayload>
/**
 * Model BreakglassActivationLog
 * Breakglass activation log for automated actions
 */
export type BreakglassActivationLog = $Result.DefaultSelection<Prisma.$BreakglassActivationLogPayload>
/**
 * Model RecoveryRequest
 * Pending recovery requests with automated delay timers
 */
export type RecoveryRequest = $Result.DefaultSelection<Prisma.$RecoveryRequestPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Opportunity
 * 
 */
export type Opportunity = $Result.DefaultSelection<Prisma.$OpportunityPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Rfp
 * 
 */
export type Rfp = $Result.DefaultSelection<Prisma.$RfpPayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model BillingLedger
 * 
 */
export type BillingLedger = $Result.DefaultSelection<Prisma.$BillingLedgerPayload>
/**
 * Model LeadInvoice
 * LeadInvoice represents a monthly invoice for converted leads. This is separate from the
 * existing Invoice model used for customers/jobs. It aggregates lead conversions and
 * includes metadata to support billing and optional Stripe integration.
 */
export type LeadInvoice = $Result.DefaultSelection<Prisma.$LeadInvoicePayload>
/**
 * Model LeadInvoiceLine
 * LeadInvoiceLine represents an individual line item on a LeadInvoice. Each line is typically
 * associated with a converted lead, but generic fee/credit lines are also supported.
 */
export type LeadInvoiceLine = $Result.DefaultSelection<Prisma.$LeadInvoiceLinePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model RbacPermission
 * 
 */
export type RbacPermission = $Result.DefaultSelection<Prisma.$RbacPermissionPayload>
/**
 * Model RbacRole
 * 
 */
export type RbacRole = $Result.DefaultSelection<Prisma.$RbacRolePayload>
/**
 * Model RbacRolePermission
 * 
 */
export type RbacRolePermission = $Result.DefaultSelection<Prisma.$RbacRolePermissionPayload>
/**
 * Model RbacUserRole
 * 
 */
export type RbacUserRole = $Result.DefaultSelection<Prisma.$RbacUserRolePayload>
/**
 * Model ProviderConfig
 * ProviderConfig holds provider-level secrets and configuration separate from any organization.
 * These values are used for system integrations that the provider controls, such as SAM.gov or
 * Stripe secrets used when billing clients.  Only one row is typically used.  Use a simple
 * admin interface to update these values.
 */
export type ProviderConfig = $Result.DefaultSelection<Prisma.$ProviderConfigPayload>
/**
 * Model PricingPlan
 * PricingPlan defines how an organization is billed for leads. Each org can have only
 * one pricing plan record. A plan specifies the billing model (e.g. per-lead fixed fee)
 * and can include tiered structures or prepaid units via includedUnits and tiersJson.
 */
export type PricingPlan = $Result.DefaultSelection<Prisma.$PricingPlanPayload>
/**
 * Model AiUsageEvent
 * 
 */
export type AiUsageEvent = $Result.DefaultSelection<Prisma.$AiUsageEventPayload>
/**
 * Model AiMonthlySummary
 * 
 */
export type AiMonthlySummary = $Result.DefaultSelection<Prisma.$AiMonthlySummaryPayload>
/**
 * Model Activity
 * Activity tracks cross-entity timeline events for provider operations
 * Used for unified activity feeds across leads, invoices, incidents, etc.
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Subscription
 * Subscription tracks plan lifecycle for provider billing operations
 * Supports MRR/ARR calculations, churn analysis, and plan changes
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model UsageMeter
 * UsageMeter records raw usage units before rating/billing
 * Used for usage-based billing and cost tracking
 */
export type UsageMeter = $Result.DefaultSelection<Prisma.$UsageMeterPayload>
/**
 * Model AddonPurchase
 * AddonPurchase tracks one-off purchases and refunds
 * Used for add-on revenue tracking and reconciliation
 */
export type AddonPurchase = $Result.DefaultSelection<Prisma.$AddonPurchasePayload>
/**
 * Model FederationKey
 * FederationKey stores HMAC keys for provider-side federation
 * Used for secure machine-to-machine authentication
 */
export type FederationKey = $Result.DefaultSelection<Prisma.$FederationKeyPayload>
/**
 * Model OIDCConfig
 * OIDCConfig stores OIDC/OAuth provider configuration for federation
 */
export type OIDCConfig = $Result.DefaultSelection<Prisma.$OIDCConfigPayload>
/**
 * Model ProviderIntegration
 * ProviderIntegration tracks external provider connections
 */
export type ProviderIntegration = $Result.DefaultSelection<Prisma.$ProviderIntegrationPayload>
/**
 * Model AuditEvent
 * AuditEvent stores provider-side audit trail
 */
export type AuditEvent = $Result.DefaultSelection<Prisma.$AuditEventPayload>
/**
 * Model AnalyticsSnapshot
 * AnalyticsSnapshot stores daily aggregated metrics for caching
 */
export type AnalyticsSnapshot = $Result.DefaultSelection<Prisma.$AnalyticsSnapshotPayload>
/**
 * Model Incident
 * Incident lifecycle tracking with SLA fields
 */
export type Incident = $Result.DefaultSelection<Prisma.$IncidentPayload>
/**
 * Model InvoiceLine
 * InvoiceLine ties granular charges to Invoices
 */
export type InvoiceLine = $Result.DefaultSelection<Prisma.$InvoiceLinePayload>
/**
 * Model Notification
 * Provider in-app notifications
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model PricePlan
 * 
 */
export type PricePlan = $Result.DefaultSelection<Prisma.$PricePlanPayload>
/**
 * Model PlanPrice
 * 
 */
export type PlanPrice = $Result.DefaultSelection<Prisma.$PlanPricePayload>
/**
 * Model Offer
 * 
 */
export type Offer = $Result.DefaultSelection<Prisma.$OfferPayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model TenantPriceOverride
 * 
 */
export type TenantPriceOverride = $Result.DefaultSelection<Prisma.$TenantPriceOverridePayload>
/**
 * Model GlobalMonetizationConfig
 * 
 */
export type GlobalMonetizationConfig = $Result.DefaultSelection<Prisma.$GlobalMonetizationConfigPayload>
/**
 * Model OnboardingInvite
 * 
 */
export type OnboardingInvite = $Result.DefaultSelection<Prisma.$OnboardingInvitePayload>
/**
 * Model InfrastructureMetric
 * 
 */
export type InfrastructureMetric = $Result.DefaultSelection<Prisma.$InfrastructureMetricPayload>
/**
 * Model InfrastructureLimit
 * 
 */
export type InfrastructureLimit = $Result.DefaultSelection<Prisma.$InfrastructureLimitPayload>
/**
 * Model ImportJob
 * 
 */
export type ImportJob = $Result.DefaultSelection<Prisma.$ImportJobPayload>
/**
 * Model ImportMapping
 * 
 */
export type ImportMapping = $Result.DefaultSelection<Prisma.$ImportMappingPayload>
/**
 * Model ImportError
 * 
 */
export type ImportError = $Result.DefaultSelection<Prisma.$ImportErrorPayload>
/**
 * Model UpgradeRecommendation
 * 
 */
export type UpgradeRecommendation = $Result.DefaultSelection<Prisma.$UpgradeRecommendationPayload>
/**
 * Model RefreshToken
 * RefreshToken stores long-lived refresh tokens for token rotation
 * Used with short-lived access tokens for improved security
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  OWNER: 'OWNER',
  MANAGER: 'MANAGER',
  STAFF: 'STAFF',
  PROVIDER: 'PROVIDER',
  ACCOUNTANT: 'ACCOUNTANT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const LeadSource: {
  COLD: 'COLD',
  HOT: 'HOT',
  RFP: 'RFP',
  MANUAL_EMPLOYEE_REFERRAL: 'MANUAL_EMPLOYEE_REFERRAL',
  MANUAL_EXISTING_CUSTOMER: 'MANUAL_EXISTING_CUSTOMER',
  MANUAL_NEW_CUSTOMER: 'MANUAL_NEW_CUSTOMER',
  MANUAL_OTHER: 'MANUAL_OTHER',
  SYSTEM: 'SYSTEM',
  EMPLOYEE_REFERRAL: 'EMPLOYEE_REFERRAL',
  MANUAL: 'MANUAL',
  LSA: 'LSA'
};

export type LeadSource = (typeof LeadSource)[keyof typeof LeadSource]


export const ValueType: {
  RELATIONSHIP: 'RELATIONSHIP',
  JOB: 'JOB'
};

export type ValueType = (typeof ValueType)[keyof typeof ValueType]


export const LedgerType: {
  CONVERSION_FEE: 'CONVERSION_FEE',
  PACK_PURCHASE: 'PACK_PURCHASE'
};

export type LedgerType = (typeof LedgerType)[keyof typeof LedgerType]


export const PricingModel: {
  PER_LEAD_FIXED: 'PER_LEAD_FIXED',
  TIERED: 'TIERED',
  SUBSCRIPTION: 'SUBSCRIPTION',
  HYBRID: 'HYBRID'
};

export type PricingModel = (typeof PricingModel)[keyof typeof PricingModel]


export const LeadStatus: {
  NEW: 'NEW',
  CONVERTED: 'CONVERTED'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const AiPlan: {
  BASE: 'BASE',
  PRO: 'PRO',
  ELITE: 'ELITE'
};

export type AiPlan = (typeof AiPlan)[keyof typeof AiPlan]


export const IncidentSeverity: {
  P1: 'P1',
  P2: 'P2',
  P3: 'P3'
};

export type IncidentSeverity = (typeof IncidentSeverity)[keyof typeof IncidentSeverity]


export const IncidentStatus: {
  OPEN: 'OPEN',
  ACK: 'ACK',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type IncidentStatus = (typeof IncidentStatus)[keyof typeof IncidentStatus]


export const InvoiceLineType: {
  subscription: 'subscription',
  usage: 'usage',
  addon: 'addon',
  one_time: 'one_time'
};

export type InvoiceLineType = (typeof InvoiceLineType)[keyof typeof InvoiceLineType]


export const BillingCadence: {
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY'
};

export type BillingCadence = (typeof BillingCadence)[keyof typeof BillingCadence]


export const OverrideType: {
  FREE: 'FREE',
  DISCOUNT: 'DISCOUNT',
  CUSTOM_AMOUNT: 'CUSTOM_AMOUNT'
};

export type OverrideType = (typeof OverrideType)[keyof typeof OverrideType]


export const InfrastructureService: {
  VERCEL_KV: 'VERCEL_KV',
  VERCEL_POSTGRES: 'VERCEL_POSTGRES',
  VERCEL_PLATFORM: 'VERCEL_PLATFORM',
  VERCEL_BUILD: 'VERCEL_BUILD',
  VERCEL_FUNCTIONS: 'VERCEL_FUNCTIONS',
  VERCEL_BANDWIDTH: 'VERCEL_BANDWIDTH',
  VERCEL_EDGE_REQUESTS: 'VERCEL_EDGE_REQUESTS',
  VERCEL_ISR_READS: 'VERCEL_ISR_READS',
  AI_OPENAI: 'AI_OPENAI',
  AI_CREDITS: 'AI_CREDITS'
};

export type InfrastructureService = (typeof InfrastructureService)[keyof typeof InfrastructureService]


export const MetricType: {
  STORAGE_MB: 'STORAGE_MB',
  STORAGE_GB: 'STORAGE_GB',
  COMMANDS_PER_DAY: 'COMMANDS_PER_DAY',
  CONNECTIONS: 'CONNECTIONS',
  LATENCY_MS: 'LATENCY_MS',
  BANDWIDTH_GB: 'BANDWIDTH_GB',
  INVOCATIONS: 'INVOCATIONS',
  BUILD_MINUTES: 'BUILD_MINUTES',
  REQUEST_COUNT: 'REQUEST_COUNT',
  COST_USD: 'COST_USD',
  USAGE_PERCENT: 'USAGE_PERCENT'
};

export type MetricType = (typeof MetricType)[keyof typeof MetricType]


export const RecommendationPriority: {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type RecommendationPriority = (typeof RecommendationPriority)[keyof typeof RecommendationPriority]


export const RecommendationStatus: {
  PENDING: 'PENDING',
  REVIEWED: 'REVIEWED',
  ACKNOWLEDGED: 'ACKNOWLEDGED',
  IMPLEMENTED: 'IMPLEMENTED',
  DISMISSED: 'DISMISSED'
};

export type RecommendationStatus = (typeof RecommendationStatus)[keyof typeof RecommendationStatus]


export const ImportStatus: {
  PENDING: 'PENDING',
  ANALYZING: 'ANALYZING',
  MAPPING: 'MAPPING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type ImportStatus = (typeof ImportStatus)[keyof typeof ImportStatus]


export const ImportEntityType: {
  CUSTOMERS: 'CUSTOMERS',
  JOBS: 'JOBS',
  INVOICES: 'INVOICES',
  ESTIMATES: 'ESTIMATES',
  CONTACTS: 'CONTACTS',
  ADDRESSES: 'ADDRESSES',
  NOTES: 'NOTES'
};

export type ImportEntityType = (typeof ImportEntityType)[keyof typeof ImportEntityType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type LeadSource = $Enums.LeadSource

export const LeadSource: typeof $Enums.LeadSource

export type ValueType = $Enums.ValueType

export const ValueType: typeof $Enums.ValueType

export type LedgerType = $Enums.LedgerType

export const LedgerType: typeof $Enums.LedgerType

export type PricingModel = $Enums.PricingModel

export const PricingModel: typeof $Enums.PricingModel

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type AiPlan = $Enums.AiPlan

export const AiPlan: typeof $Enums.AiPlan

export type IncidentSeverity = $Enums.IncidentSeverity

export const IncidentSeverity: typeof $Enums.IncidentSeverity

export type IncidentStatus = $Enums.IncidentStatus

export const IncidentStatus: typeof $Enums.IncidentStatus

export type InvoiceLineType = $Enums.InvoiceLineType

export const InvoiceLineType: typeof $Enums.InvoiceLineType

export type BillingCadence = $Enums.BillingCadence

export const BillingCadence: typeof $Enums.BillingCadence

export type OverrideType = $Enums.OverrideType

export const OverrideType: typeof $Enums.OverrideType

export type InfrastructureService = $Enums.InfrastructureService

export const InfrastructureService: typeof $Enums.InfrastructureService

export type MetricType = $Enums.MetricType

export const MetricType: typeof $Enums.MetricType

export type RecommendationPriority = $Enums.RecommendationPriority

export const RecommendationPriority: typeof $Enums.RecommendationPriority

export type RecommendationStatus = $Enums.RecommendationStatus

export const RecommendationStatus: typeof $Enums.RecommendationStatus

export type ImportStatus = $Enums.ImportStatus

export const ImportStatus: typeof $Enums.ImportStatus

export type ImportEntityType = $Enums.ImportEntityType

export const ImportEntityType: typeof $Enums.ImportEntityType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Orgs
 * const orgs = await prisma.org.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Orgs
   * const orgs = await prisma.org.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.org`: Exposes CRUD operations for the **Org** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orgs
    * const orgs = await prisma.org.findMany()
    * ```
    */
  get org(): Prisma.OrgDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRecoveryCode`: Exposes CRUD operations for the **UserRecoveryCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRecoveryCodes
    * const userRecoveryCodes = await prisma.userRecoveryCode.findMany()
    * ```
    */
  get userRecoveryCode(): Prisma.UserRecoveryCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSecurityQuestion`: Exposes CRUD operations for the **UserSecurityQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSecurityQuestions
    * const userSecurityQuestions = await prisma.userSecurityQuestion.findMany()
    * ```
    */
  get userSecurityQuestion(): Prisma.UserSecurityQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBreakglassAccount`: Exposes CRUD operations for the **UserBreakglassAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBreakglassAccounts
    * const userBreakglassAccounts = await prisma.userBreakglassAccount.findMany()
    * ```
    */
  get userBreakglassAccount(): Prisma.UserBreakglassAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userDeviceFingerprint`: Exposes CRUD operations for the **UserDeviceFingerprint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDeviceFingerprints
    * const userDeviceFingerprints = await prisma.userDeviceFingerprint.findMany()
    * ```
    */
  get userDeviceFingerprint(): Prisma.UserDeviceFingerprintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLoginHistory`: Exposes CRUD operations for the **UserLoginHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLoginHistories
    * const userLoginHistories = await prisma.userLoginHistory.findMany()
    * ```
    */
  get userLoginHistory(): Prisma.UserLoginHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.breakglassActivationLog`: Exposes CRUD operations for the **BreakglassActivationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreakglassActivationLogs
    * const breakglassActivationLogs = await prisma.breakglassActivationLog.findMany()
    * ```
    */
  get breakglassActivationLog(): Prisma.BreakglassActivationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recoveryRequest`: Exposes CRUD operations for the **RecoveryRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecoveryRequests
    * const recoveryRequests = await prisma.recoveryRequest.findMany()
    * ```
    */
  get recoveryRequest(): Prisma.RecoveryRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.opportunity`: Exposes CRUD operations for the **Opportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Opportunities
    * const opportunities = await prisma.opportunity.findMany()
    * ```
    */
  get opportunity(): Prisma.OpportunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rfp`: Exposes CRUD operations for the **Rfp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rfps
    * const rfps = await prisma.rfp.findMany()
    * ```
    */
  get rfp(): Prisma.RfpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingLedger`: Exposes CRUD operations for the **BillingLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingLedgers
    * const billingLedgers = await prisma.billingLedger.findMany()
    * ```
    */
  get billingLedger(): Prisma.BillingLedgerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadInvoice`: Exposes CRUD operations for the **LeadInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadInvoices
    * const leadInvoices = await prisma.leadInvoice.findMany()
    * ```
    */
  get leadInvoice(): Prisma.LeadInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadInvoiceLine`: Exposes CRUD operations for the **LeadInvoiceLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadInvoiceLines
    * const leadInvoiceLines = await prisma.leadInvoiceLine.findMany()
    * ```
    */
  get leadInvoiceLine(): Prisma.LeadInvoiceLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rbacPermission`: Exposes CRUD operations for the **RbacPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RbacPermissions
    * const rbacPermissions = await prisma.rbacPermission.findMany()
    * ```
    */
  get rbacPermission(): Prisma.RbacPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rbacRole`: Exposes CRUD operations for the **RbacRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RbacRoles
    * const rbacRoles = await prisma.rbacRole.findMany()
    * ```
    */
  get rbacRole(): Prisma.RbacRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rbacRolePermission`: Exposes CRUD operations for the **RbacRolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RbacRolePermissions
    * const rbacRolePermissions = await prisma.rbacRolePermission.findMany()
    * ```
    */
  get rbacRolePermission(): Prisma.RbacRolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rbacUserRole`: Exposes CRUD operations for the **RbacUserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RbacUserRoles
    * const rbacUserRoles = await prisma.rbacUserRole.findMany()
    * ```
    */
  get rbacUserRole(): Prisma.RbacUserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providerConfig`: Exposes CRUD operations for the **ProviderConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderConfigs
    * const providerConfigs = await prisma.providerConfig.findMany()
    * ```
    */
  get providerConfig(): Prisma.ProviderConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pricingPlan`: Exposes CRUD operations for the **PricingPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingPlans
    * const pricingPlans = await prisma.pricingPlan.findMany()
    * ```
    */
  get pricingPlan(): Prisma.PricingPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiUsageEvent`: Exposes CRUD operations for the **AiUsageEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiUsageEvents
    * const aiUsageEvents = await prisma.aiUsageEvent.findMany()
    * ```
    */
  get aiUsageEvent(): Prisma.AiUsageEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiMonthlySummary`: Exposes CRUD operations for the **AiMonthlySummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiMonthlySummaries
    * const aiMonthlySummaries = await prisma.aiMonthlySummary.findMany()
    * ```
    */
  get aiMonthlySummary(): Prisma.AiMonthlySummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageMeter`: Exposes CRUD operations for the **UsageMeter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageMeters
    * const usageMeters = await prisma.usageMeter.findMany()
    * ```
    */
  get usageMeter(): Prisma.UsageMeterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addonPurchase`: Exposes CRUD operations for the **AddonPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddonPurchases
    * const addonPurchases = await prisma.addonPurchase.findMany()
    * ```
    */
  get addonPurchase(): Prisma.AddonPurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.federationKey`: Exposes CRUD operations for the **FederationKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FederationKeys
    * const federationKeys = await prisma.federationKey.findMany()
    * ```
    */
  get federationKey(): Prisma.FederationKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oIDCConfig`: Exposes CRUD operations for the **OIDCConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OIDCConfigs
    * const oIDCConfigs = await prisma.oIDCConfig.findMany()
    * ```
    */
  get oIDCConfig(): Prisma.OIDCConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providerIntegration`: Exposes CRUD operations for the **ProviderIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderIntegrations
    * const providerIntegrations = await prisma.providerIntegration.findMany()
    * ```
    */
  get providerIntegration(): Prisma.ProviderIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditEvent`: Exposes CRUD operations for the **AuditEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditEvents
    * const auditEvents = await prisma.auditEvent.findMany()
    * ```
    */
  get auditEvent(): Prisma.AuditEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsSnapshot`: Exposes CRUD operations for the **AnalyticsSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsSnapshots
    * const analyticsSnapshots = await prisma.analyticsSnapshot.findMany()
    * ```
    */
  get analyticsSnapshot(): Prisma.AnalyticsSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceLine`: Exposes CRUD operations for the **InvoiceLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLines
    * const invoiceLines = await prisma.invoiceLine.findMany()
    * ```
    */
  get invoiceLine(): Prisma.InvoiceLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pricePlan`: Exposes CRUD operations for the **PricePlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricePlans
    * const pricePlans = await prisma.pricePlan.findMany()
    * ```
    */
  get pricePlan(): Prisma.PricePlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planPrice`: Exposes CRUD operations for the **PlanPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanPrices
    * const planPrices = await prisma.planPrice.findMany()
    * ```
    */
  get planPrice(): Prisma.PlanPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantPriceOverride`: Exposes CRUD operations for the **TenantPriceOverride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantPriceOverrides
    * const tenantPriceOverrides = await prisma.tenantPriceOverride.findMany()
    * ```
    */
  get tenantPriceOverride(): Prisma.TenantPriceOverrideDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.globalMonetizationConfig`: Exposes CRUD operations for the **GlobalMonetizationConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlobalMonetizationConfigs
    * const globalMonetizationConfigs = await prisma.globalMonetizationConfig.findMany()
    * ```
    */
  get globalMonetizationConfig(): Prisma.GlobalMonetizationConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.onboardingInvite`: Exposes CRUD operations for the **OnboardingInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnboardingInvites
    * const onboardingInvites = await prisma.onboardingInvite.findMany()
    * ```
    */
  get onboardingInvite(): Prisma.OnboardingInviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.infrastructureMetric`: Exposes CRUD operations for the **InfrastructureMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InfrastructureMetrics
    * const infrastructureMetrics = await prisma.infrastructureMetric.findMany()
    * ```
    */
  get infrastructureMetric(): Prisma.InfrastructureMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.infrastructureLimit`: Exposes CRUD operations for the **InfrastructureLimit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InfrastructureLimits
    * const infrastructureLimits = await prisma.infrastructureLimit.findMany()
    * ```
    */
  get infrastructureLimit(): Prisma.InfrastructureLimitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.importJob`: Exposes CRUD operations for the **ImportJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportJobs
    * const importJobs = await prisma.importJob.findMany()
    * ```
    */
  get importJob(): Prisma.ImportJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.importMapping`: Exposes CRUD operations for the **ImportMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportMappings
    * const importMappings = await prisma.importMapping.findMany()
    * ```
    */
  get importMapping(): Prisma.ImportMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.importError`: Exposes CRUD operations for the **ImportError** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportErrors
    * const importErrors = await prisma.importError.findMany()
    * ```
    */
  get importError(): Prisma.ImportErrorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.upgradeRecommendation`: Exposes CRUD operations for the **UpgradeRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UpgradeRecommendations
    * const upgradeRecommendations = await prisma.upgradeRecommendation.findMany()
    * ```
    */
  get upgradeRecommendation(): Prisma.UpgradeRecommendationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Org: 'Org',
    User: 'User',
    UserRecoveryCode: 'UserRecoveryCode',
    UserSecurityQuestion: 'UserSecurityQuestion',
    UserBreakglassAccount: 'UserBreakglassAccount',
    UserDeviceFingerprint: 'UserDeviceFingerprint',
    UserLoginHistory: 'UserLoginHistory',
    BreakglassActivationLog: 'BreakglassActivationLog',
    RecoveryRequest: 'RecoveryRequest',
    Lead: 'Lead',
    Customer: 'Customer',
    Opportunity: 'Opportunity',
    Invoice: 'Invoice',
    Payment: 'Payment',
    Rfp: 'Rfp',
    Job: 'Job',
    Referral: 'Referral',
    BillingLedger: 'BillingLedger',
    LeadInvoice: 'LeadInvoice',
    LeadInvoiceLine: 'LeadInvoiceLine',
    AuditLog: 'AuditLog',
    RbacPermission: 'RbacPermission',
    RbacRole: 'RbacRole',
    RbacRolePermission: 'RbacRolePermission',
    RbacUserRole: 'RbacUserRole',
    ProviderConfig: 'ProviderConfig',
    PricingPlan: 'PricingPlan',
    AiUsageEvent: 'AiUsageEvent',
    AiMonthlySummary: 'AiMonthlySummary',
    Activity: 'Activity',
    Subscription: 'Subscription',
    UsageMeter: 'UsageMeter',
    AddonPurchase: 'AddonPurchase',
    FederationKey: 'FederationKey',
    OIDCConfig: 'OIDCConfig',
    ProviderIntegration: 'ProviderIntegration',
    AuditEvent: 'AuditEvent',
    AnalyticsSnapshot: 'AnalyticsSnapshot',
    Incident: 'Incident',
    InvoiceLine: 'InvoiceLine',
    Notification: 'Notification',
    PricePlan: 'PricePlan',
    PlanPrice: 'PlanPrice',
    Offer: 'Offer',
    Coupon: 'Coupon',
    TenantPriceOverride: 'TenantPriceOverride',
    GlobalMonetizationConfig: 'GlobalMonetizationConfig',
    OnboardingInvite: 'OnboardingInvite',
    InfrastructureMetric: 'InfrastructureMetric',
    InfrastructureLimit: 'InfrastructureLimit',
    ImportJob: 'ImportJob',
    ImportMapping: 'ImportMapping',
    ImportError: 'ImportError',
    UpgradeRecommendation: 'UpgradeRecommendation',
    RefreshToken: 'RefreshToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "org" | "user" | "userRecoveryCode" | "userSecurityQuestion" | "userBreakglassAccount" | "userDeviceFingerprint" | "userLoginHistory" | "breakglassActivationLog" | "recoveryRequest" | "lead" | "customer" | "opportunity" | "invoice" | "payment" | "rfp" | "job" | "referral" | "billingLedger" | "leadInvoice" | "leadInvoiceLine" | "auditLog" | "rbacPermission" | "rbacRole" | "rbacRolePermission" | "rbacUserRole" | "providerConfig" | "pricingPlan" | "aiUsageEvent" | "aiMonthlySummary" | "activity" | "subscription" | "usageMeter" | "addonPurchase" | "federationKey" | "oIDCConfig" | "providerIntegration" | "auditEvent" | "analyticsSnapshot" | "incident" | "invoiceLine" | "notification" | "pricePlan" | "planPrice" | "offer" | "coupon" | "tenantPriceOverride" | "globalMonetizationConfig" | "onboardingInvite" | "infrastructureMetric" | "infrastructureLimit" | "importJob" | "importMapping" | "importError" | "upgradeRecommendation" | "refreshToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Org: {
        payload: Prisma.$OrgPayload<ExtArgs>
        fields: Prisma.OrgFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrgFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrgFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload>
          }
          findFirst: {
            args: Prisma.OrgFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrgFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload>
          }
          findMany: {
            args: Prisma.OrgFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload>[]
          }
          create: {
            args: Prisma.OrgCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload>
          }
          createMany: {
            args: Prisma.OrgCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrgCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload>[]
          }
          delete: {
            args: Prisma.OrgDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload>
          }
          update: {
            args: Prisma.OrgUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload>
          }
          deleteMany: {
            args: Prisma.OrgDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrgUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrgUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload>[]
          }
          upsert: {
            args: Prisma.OrgUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgPayload>
          }
          aggregate: {
            args: Prisma.OrgAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrg>
          }
          groupBy: {
            args: Prisma.OrgGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrgGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrgCountArgs<ExtArgs>
            result: $Utils.Optional<OrgCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserRecoveryCode: {
        payload: Prisma.$UserRecoveryCodePayload<ExtArgs>
        fields: Prisma.UserRecoveryCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRecoveryCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRecoveryCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload>
          }
          findFirst: {
            args: Prisma.UserRecoveryCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRecoveryCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload>
          }
          findMany: {
            args: Prisma.UserRecoveryCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload>[]
          }
          create: {
            args: Prisma.UserRecoveryCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload>
          }
          createMany: {
            args: Prisma.UserRecoveryCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRecoveryCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload>[]
          }
          delete: {
            args: Prisma.UserRecoveryCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload>
          }
          update: {
            args: Prisma.UserRecoveryCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload>
          }
          deleteMany: {
            args: Prisma.UserRecoveryCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRecoveryCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRecoveryCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload>[]
          }
          upsert: {
            args: Prisma.UserRecoveryCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecoveryCodePayload>
          }
          aggregate: {
            args: Prisma.UserRecoveryCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRecoveryCode>
          }
          groupBy: {
            args: Prisma.UserRecoveryCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRecoveryCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRecoveryCodeCountArgs<ExtArgs>
            result: $Utils.Optional<UserRecoveryCodeCountAggregateOutputType> | number
          }
        }
      }
      UserSecurityQuestion: {
        payload: Prisma.$UserSecurityQuestionPayload<ExtArgs>
        fields: Prisma.UserSecurityQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSecurityQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSecurityQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload>
          }
          findFirst: {
            args: Prisma.UserSecurityQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSecurityQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload>
          }
          findMany: {
            args: Prisma.UserSecurityQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload>[]
          }
          create: {
            args: Prisma.UserSecurityQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload>
          }
          createMany: {
            args: Prisma.UserSecurityQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSecurityQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload>[]
          }
          delete: {
            args: Prisma.UserSecurityQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload>
          }
          update: {
            args: Prisma.UserSecurityQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload>
          }
          deleteMany: {
            args: Prisma.UserSecurityQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSecurityQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSecurityQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload>[]
          }
          upsert: {
            args: Prisma.UserSecurityQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSecurityQuestionPayload>
          }
          aggregate: {
            args: Prisma.UserSecurityQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSecurityQuestion>
          }
          groupBy: {
            args: Prisma.UserSecurityQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSecurityQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSecurityQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSecurityQuestionCountAggregateOutputType> | number
          }
        }
      }
      UserBreakglassAccount: {
        payload: Prisma.$UserBreakglassAccountPayload<ExtArgs>
        fields: Prisma.UserBreakglassAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBreakglassAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBreakglassAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload>
          }
          findFirst: {
            args: Prisma.UserBreakglassAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBreakglassAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload>
          }
          findMany: {
            args: Prisma.UserBreakglassAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload>[]
          }
          create: {
            args: Prisma.UserBreakglassAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload>
          }
          createMany: {
            args: Prisma.UserBreakglassAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBreakglassAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload>[]
          }
          delete: {
            args: Prisma.UserBreakglassAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload>
          }
          update: {
            args: Prisma.UserBreakglassAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload>
          }
          deleteMany: {
            args: Prisma.UserBreakglassAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBreakglassAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBreakglassAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload>[]
          }
          upsert: {
            args: Prisma.UserBreakglassAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakglassAccountPayload>
          }
          aggregate: {
            args: Prisma.UserBreakglassAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBreakglassAccount>
          }
          groupBy: {
            args: Prisma.UserBreakglassAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBreakglassAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBreakglassAccountCountArgs<ExtArgs>
            result: $Utils.Optional<UserBreakglassAccountCountAggregateOutputType> | number
          }
        }
      }
      UserDeviceFingerprint: {
        payload: Prisma.$UserDeviceFingerprintPayload<ExtArgs>
        fields: Prisma.UserDeviceFingerprintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserDeviceFingerprintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDeviceFingerprintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload>
          }
          findFirst: {
            args: Prisma.UserDeviceFingerprintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDeviceFingerprintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload>
          }
          findMany: {
            args: Prisma.UserDeviceFingerprintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload>[]
          }
          create: {
            args: Prisma.UserDeviceFingerprintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload>
          }
          createMany: {
            args: Prisma.UserDeviceFingerprintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserDeviceFingerprintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload>[]
          }
          delete: {
            args: Prisma.UserDeviceFingerprintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload>
          }
          update: {
            args: Prisma.UserDeviceFingerprintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload>
          }
          deleteMany: {
            args: Prisma.UserDeviceFingerprintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserDeviceFingerprintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserDeviceFingerprintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload>[]
          }
          upsert: {
            args: Prisma.UserDeviceFingerprintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceFingerprintPayload>
          }
          aggregate: {
            args: Prisma.UserDeviceFingerprintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDeviceFingerprint>
          }
          groupBy: {
            args: Prisma.UserDeviceFingerprintGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDeviceFingerprintGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDeviceFingerprintCountArgs<ExtArgs>
            result: $Utils.Optional<UserDeviceFingerprintCountAggregateOutputType> | number
          }
        }
      }
      UserLoginHistory: {
        payload: Prisma.$UserLoginHistoryPayload<ExtArgs>
        fields: Prisma.UserLoginHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLoginHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLoginHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload>
          }
          findFirst: {
            args: Prisma.UserLoginHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLoginHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload>
          }
          findMany: {
            args: Prisma.UserLoginHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload>[]
          }
          create: {
            args: Prisma.UserLoginHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload>
          }
          createMany: {
            args: Prisma.UserLoginHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLoginHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload>[]
          }
          delete: {
            args: Prisma.UserLoginHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload>
          }
          update: {
            args: Prisma.UserLoginHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UserLoginHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLoginHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLoginHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload>[]
          }
          upsert: {
            args: Prisma.UserLoginHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserLoginHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLoginHistory>
          }
          groupBy: {
            args: Prisma.UserLoginHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLoginHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLoginHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserLoginHistoryCountAggregateOutputType> | number
          }
        }
      }
      BreakglassActivationLog: {
        payload: Prisma.$BreakglassActivationLogPayload<ExtArgs>
        fields: Prisma.BreakglassActivationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreakglassActivationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreakglassActivationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload>
          }
          findFirst: {
            args: Prisma.BreakglassActivationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreakglassActivationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload>
          }
          findMany: {
            args: Prisma.BreakglassActivationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload>[]
          }
          create: {
            args: Prisma.BreakglassActivationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload>
          }
          createMany: {
            args: Prisma.BreakglassActivationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BreakglassActivationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload>[]
          }
          delete: {
            args: Prisma.BreakglassActivationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload>
          }
          update: {
            args: Prisma.BreakglassActivationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload>
          }
          deleteMany: {
            args: Prisma.BreakglassActivationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreakglassActivationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BreakglassActivationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload>[]
          }
          upsert: {
            args: Prisma.BreakglassActivationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakglassActivationLogPayload>
          }
          aggregate: {
            args: Prisma.BreakglassActivationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreakglassActivationLog>
          }
          groupBy: {
            args: Prisma.BreakglassActivationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreakglassActivationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BreakglassActivationLogCountArgs<ExtArgs>
            result: $Utils.Optional<BreakglassActivationLogCountAggregateOutputType> | number
          }
        }
      }
      RecoveryRequest: {
        payload: Prisma.$RecoveryRequestPayload<ExtArgs>
        fields: Prisma.RecoveryRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecoveryRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecoveryRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload>
          }
          findFirst: {
            args: Prisma.RecoveryRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecoveryRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload>
          }
          findMany: {
            args: Prisma.RecoveryRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload>[]
          }
          create: {
            args: Prisma.RecoveryRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload>
          }
          createMany: {
            args: Prisma.RecoveryRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecoveryRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload>[]
          }
          delete: {
            args: Prisma.RecoveryRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload>
          }
          update: {
            args: Prisma.RecoveryRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload>
          }
          deleteMany: {
            args: Prisma.RecoveryRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecoveryRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecoveryRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload>[]
          }
          upsert: {
            args: Prisma.RecoveryRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryRequestPayload>
          }
          aggregate: {
            args: Prisma.RecoveryRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecoveryRequest>
          }
          groupBy: {
            args: Prisma.RecoveryRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecoveryRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecoveryRequestCountArgs<ExtArgs>
            result: $Utils.Optional<RecoveryRequestCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Opportunity: {
        payload: Prisma.$OpportunityPayload<ExtArgs>
        fields: Prisma.OpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findFirst: {
            args: Prisma.OpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findMany: {
            args: Prisma.OpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          create: {
            args: Prisma.OpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          createMany: {
            args: Prisma.OpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          delete: {
            args: Prisma.OpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          update: {
            args: Prisma.OpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpportunityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          upsert: {
            args: Prisma.OpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          aggregate: {
            args: Prisma.OpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunity>
          }
          groupBy: {
            args: Prisma.OpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Rfp: {
        payload: Prisma.$RfpPayload<ExtArgs>
        fields: Prisma.RfpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RfpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RfpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload>
          }
          findFirst: {
            args: Prisma.RfpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RfpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload>
          }
          findMany: {
            args: Prisma.RfpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload>[]
          }
          create: {
            args: Prisma.RfpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload>
          }
          createMany: {
            args: Prisma.RfpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RfpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload>[]
          }
          delete: {
            args: Prisma.RfpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload>
          }
          update: {
            args: Prisma.RfpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload>
          }
          deleteMany: {
            args: Prisma.RfpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RfpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RfpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload>[]
          }
          upsert: {
            args: Prisma.RfpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfpPayload>
          }
          aggregate: {
            args: Prisma.RfpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRfp>
          }
          groupBy: {
            args: Prisma.RfpGroupByArgs<ExtArgs>
            result: $Utils.Optional<RfpGroupByOutputType>[]
          }
          count: {
            args: Prisma.RfpCountArgs<ExtArgs>
            result: $Utils.Optional<RfpCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      BillingLedger: {
        payload: Prisma.$BillingLedgerPayload<ExtArgs>
        fields: Prisma.BillingLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload>
          }
          findFirst: {
            args: Prisma.BillingLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload>
          }
          findMany: {
            args: Prisma.BillingLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload>[]
          }
          create: {
            args: Prisma.BillingLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload>
          }
          createMany: {
            args: Prisma.BillingLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload>[]
          }
          delete: {
            args: Prisma.BillingLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload>
          }
          update: {
            args: Prisma.BillingLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload>
          }
          deleteMany: {
            args: Prisma.BillingLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingLedgerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload>[]
          }
          upsert: {
            args: Prisma.BillingLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingLedgerPayload>
          }
          aggregate: {
            args: Prisma.BillingLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingLedger>
          }
          groupBy: {
            args: Prisma.BillingLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<BillingLedgerCountAggregateOutputType> | number
          }
        }
      }
      LeadInvoice: {
        payload: Prisma.$LeadInvoicePayload<ExtArgs>
        fields: Prisma.LeadInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload>
          }
          findFirst: {
            args: Prisma.LeadInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload>
          }
          findMany: {
            args: Prisma.LeadInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload>[]
          }
          create: {
            args: Prisma.LeadInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload>
          }
          createMany: {
            args: Prisma.LeadInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload>[]
          }
          delete: {
            args: Prisma.LeadInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload>
          }
          update: {
            args: Prisma.LeadInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload>
          }
          deleteMany: {
            args: Prisma.LeadInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload>[]
          }
          upsert: {
            args: Prisma.LeadInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoicePayload>
          }
          aggregate: {
            args: Prisma.LeadInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadInvoice>
          }
          groupBy: {
            args: Prisma.LeadInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<LeadInvoiceCountAggregateOutputType> | number
          }
        }
      }
      LeadInvoiceLine: {
        payload: Prisma.$LeadInvoiceLinePayload<ExtArgs>
        fields: Prisma.LeadInvoiceLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadInvoiceLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadInvoiceLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload>
          }
          findFirst: {
            args: Prisma.LeadInvoiceLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadInvoiceLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload>
          }
          findMany: {
            args: Prisma.LeadInvoiceLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload>[]
          }
          create: {
            args: Prisma.LeadInvoiceLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload>
          }
          createMany: {
            args: Prisma.LeadInvoiceLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadInvoiceLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload>[]
          }
          delete: {
            args: Prisma.LeadInvoiceLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload>
          }
          update: {
            args: Prisma.LeadInvoiceLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload>
          }
          deleteMany: {
            args: Prisma.LeadInvoiceLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadInvoiceLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadInvoiceLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload>[]
          }
          upsert: {
            args: Prisma.LeadInvoiceLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadInvoiceLinePayload>
          }
          aggregate: {
            args: Prisma.LeadInvoiceLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadInvoiceLine>
          }
          groupBy: {
            args: Prisma.LeadInvoiceLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadInvoiceLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadInvoiceLineCountArgs<ExtArgs>
            result: $Utils.Optional<LeadInvoiceLineCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      RbacPermission: {
        payload: Prisma.$RbacPermissionPayload<ExtArgs>
        fields: Prisma.RbacPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RbacPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RbacPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload>
          }
          findFirst: {
            args: Prisma.RbacPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RbacPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload>
          }
          findMany: {
            args: Prisma.RbacPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload>[]
          }
          create: {
            args: Prisma.RbacPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload>
          }
          createMany: {
            args: Prisma.RbacPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RbacPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload>[]
          }
          delete: {
            args: Prisma.RbacPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload>
          }
          update: {
            args: Prisma.RbacPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload>
          }
          deleteMany: {
            args: Prisma.RbacPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RbacPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RbacPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload>[]
          }
          upsert: {
            args: Prisma.RbacPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacPermissionPayload>
          }
          aggregate: {
            args: Prisma.RbacPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRbacPermission>
          }
          groupBy: {
            args: Prisma.RbacPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RbacPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RbacPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RbacPermissionCountAggregateOutputType> | number
          }
        }
      }
      RbacRole: {
        payload: Prisma.$RbacRolePayload<ExtArgs>
        fields: Prisma.RbacRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RbacRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RbacRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload>
          }
          findFirst: {
            args: Prisma.RbacRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RbacRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload>
          }
          findMany: {
            args: Prisma.RbacRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload>[]
          }
          create: {
            args: Prisma.RbacRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload>
          }
          createMany: {
            args: Prisma.RbacRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RbacRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload>[]
          }
          delete: {
            args: Prisma.RbacRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload>
          }
          update: {
            args: Prisma.RbacRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload>
          }
          deleteMany: {
            args: Prisma.RbacRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RbacRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RbacRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload>[]
          }
          upsert: {
            args: Prisma.RbacRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePayload>
          }
          aggregate: {
            args: Prisma.RbacRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRbacRole>
          }
          groupBy: {
            args: Prisma.RbacRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RbacRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RbacRoleCountArgs<ExtArgs>
            result: $Utils.Optional<RbacRoleCountAggregateOutputType> | number
          }
        }
      }
      RbacRolePermission: {
        payload: Prisma.$RbacRolePermissionPayload<ExtArgs>
        fields: Prisma.RbacRolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RbacRolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RbacRolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RbacRolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RbacRolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload>
          }
          findMany: {
            args: Prisma.RbacRolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload>[]
          }
          create: {
            args: Prisma.RbacRolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload>
          }
          createMany: {
            args: Prisma.RbacRolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RbacRolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RbacRolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload>
          }
          update: {
            args: Prisma.RbacRolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RbacRolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RbacRolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RbacRolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RbacRolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacRolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RbacRolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRbacRolePermission>
          }
          groupBy: {
            args: Prisma.RbacRolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RbacRolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RbacRolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RbacRolePermissionCountAggregateOutputType> | number
          }
        }
      }
      RbacUserRole: {
        payload: Prisma.$RbacUserRolePayload<ExtArgs>
        fields: Prisma.RbacUserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RbacUserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RbacUserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload>
          }
          findFirst: {
            args: Prisma.RbacUserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RbacUserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload>
          }
          findMany: {
            args: Prisma.RbacUserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload>[]
          }
          create: {
            args: Prisma.RbacUserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload>
          }
          createMany: {
            args: Prisma.RbacUserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RbacUserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload>[]
          }
          delete: {
            args: Prisma.RbacUserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload>
          }
          update: {
            args: Prisma.RbacUserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload>
          }
          deleteMany: {
            args: Prisma.RbacUserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RbacUserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RbacUserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload>[]
          }
          upsert: {
            args: Prisma.RbacUserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RbacUserRolePayload>
          }
          aggregate: {
            args: Prisma.RbacUserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRbacUserRole>
          }
          groupBy: {
            args: Prisma.RbacUserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RbacUserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RbacUserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<RbacUserRoleCountAggregateOutputType> | number
          }
        }
      }
      ProviderConfig: {
        payload: Prisma.$ProviderConfigPayload<ExtArgs>
        fields: Prisma.ProviderConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload>
          }
          findFirst: {
            args: Prisma.ProviderConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload>
          }
          findMany: {
            args: Prisma.ProviderConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload>[]
          }
          create: {
            args: Prisma.ProviderConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload>
          }
          createMany: {
            args: Prisma.ProviderConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload>[]
          }
          delete: {
            args: Prisma.ProviderConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload>
          }
          update: {
            args: Prisma.ProviderConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload>
          }
          deleteMany: {
            args: Prisma.ProviderConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload>[]
          }
          upsert: {
            args: Prisma.ProviderConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderConfigPayload>
          }
          aggregate: {
            args: Prisma.ProviderConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviderConfig>
          }
          groupBy: {
            args: Prisma.ProviderConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderConfigCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderConfigCountAggregateOutputType> | number
          }
        }
      }
      PricingPlan: {
        payload: Prisma.$PricingPlanPayload<ExtArgs>
        fields: Prisma.PricingPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PricingPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PricingPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          findFirst: {
            args: Prisma.PricingPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PricingPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          findMany: {
            args: Prisma.PricingPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>[]
          }
          create: {
            args: Prisma.PricingPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          createMany: {
            args: Prisma.PricingPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PricingPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>[]
          }
          delete: {
            args: Prisma.PricingPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          update: {
            args: Prisma.PricingPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          deleteMany: {
            args: Prisma.PricingPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PricingPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PricingPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>[]
          }
          upsert: {
            args: Prisma.PricingPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          aggregate: {
            args: Prisma.PricingPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricingPlan>
          }
          groupBy: {
            args: Prisma.PricingPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricingPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PricingPlanCountArgs<ExtArgs>
            result: $Utils.Optional<PricingPlanCountAggregateOutputType> | number
          }
        }
      }
      AiUsageEvent: {
        payload: Prisma.$AiUsageEventPayload<ExtArgs>
        fields: Prisma.AiUsageEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiUsageEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiUsageEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload>
          }
          findFirst: {
            args: Prisma.AiUsageEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiUsageEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload>
          }
          findMany: {
            args: Prisma.AiUsageEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload>[]
          }
          create: {
            args: Prisma.AiUsageEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload>
          }
          createMany: {
            args: Prisma.AiUsageEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiUsageEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload>[]
          }
          delete: {
            args: Prisma.AiUsageEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload>
          }
          update: {
            args: Prisma.AiUsageEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload>
          }
          deleteMany: {
            args: Prisma.AiUsageEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiUsageEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiUsageEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload>[]
          }
          upsert: {
            args: Prisma.AiUsageEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiUsageEventPayload>
          }
          aggregate: {
            args: Prisma.AiUsageEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiUsageEvent>
          }
          groupBy: {
            args: Prisma.AiUsageEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiUsageEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiUsageEventCountArgs<ExtArgs>
            result: $Utils.Optional<AiUsageEventCountAggregateOutputType> | number
          }
        }
      }
      AiMonthlySummary: {
        payload: Prisma.$AiMonthlySummaryPayload<ExtArgs>
        fields: Prisma.AiMonthlySummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiMonthlySummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiMonthlySummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload>
          }
          findFirst: {
            args: Prisma.AiMonthlySummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiMonthlySummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload>
          }
          findMany: {
            args: Prisma.AiMonthlySummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload>[]
          }
          create: {
            args: Prisma.AiMonthlySummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload>
          }
          createMany: {
            args: Prisma.AiMonthlySummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiMonthlySummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload>[]
          }
          delete: {
            args: Prisma.AiMonthlySummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload>
          }
          update: {
            args: Prisma.AiMonthlySummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload>
          }
          deleteMany: {
            args: Prisma.AiMonthlySummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiMonthlySummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiMonthlySummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload>[]
          }
          upsert: {
            args: Prisma.AiMonthlySummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMonthlySummaryPayload>
          }
          aggregate: {
            args: Prisma.AiMonthlySummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiMonthlySummary>
          }
          groupBy: {
            args: Prisma.AiMonthlySummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiMonthlySummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiMonthlySummaryCountArgs<ExtArgs>
            result: $Utils.Optional<AiMonthlySummaryCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      UsageMeter: {
        payload: Prisma.$UsageMeterPayload<ExtArgs>
        fields: Prisma.UsageMeterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageMeterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageMeterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload>
          }
          findFirst: {
            args: Prisma.UsageMeterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageMeterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload>
          }
          findMany: {
            args: Prisma.UsageMeterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload>[]
          }
          create: {
            args: Prisma.UsageMeterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload>
          }
          createMany: {
            args: Prisma.UsageMeterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageMeterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload>[]
          }
          delete: {
            args: Prisma.UsageMeterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload>
          }
          update: {
            args: Prisma.UsageMeterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload>
          }
          deleteMany: {
            args: Prisma.UsageMeterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageMeterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsageMeterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload>[]
          }
          upsert: {
            args: Prisma.UsageMeterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMeterPayload>
          }
          aggregate: {
            args: Prisma.UsageMeterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageMeter>
          }
          groupBy: {
            args: Prisma.UsageMeterGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageMeterGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageMeterCountArgs<ExtArgs>
            result: $Utils.Optional<UsageMeterCountAggregateOutputType> | number
          }
        }
      }
      AddonPurchase: {
        payload: Prisma.$AddonPurchasePayload<ExtArgs>
        fields: Prisma.AddonPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddonPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddonPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload>
          }
          findFirst: {
            args: Prisma.AddonPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddonPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload>
          }
          findMany: {
            args: Prisma.AddonPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload>[]
          }
          create: {
            args: Prisma.AddonPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload>
          }
          createMany: {
            args: Prisma.AddonPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddonPurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload>[]
          }
          delete: {
            args: Prisma.AddonPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload>
          }
          update: {
            args: Prisma.AddonPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload>
          }
          deleteMany: {
            args: Prisma.AddonPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddonPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddonPurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload>[]
          }
          upsert: {
            args: Prisma.AddonPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPurchasePayload>
          }
          aggregate: {
            args: Prisma.AddonPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddonPurchase>
          }
          groupBy: {
            args: Prisma.AddonPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddonPurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddonPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<AddonPurchaseCountAggregateOutputType> | number
          }
        }
      }
      FederationKey: {
        payload: Prisma.$FederationKeyPayload<ExtArgs>
        fields: Prisma.FederationKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FederationKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FederationKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload>
          }
          findFirst: {
            args: Prisma.FederationKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FederationKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload>
          }
          findMany: {
            args: Prisma.FederationKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload>[]
          }
          create: {
            args: Prisma.FederationKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload>
          }
          createMany: {
            args: Prisma.FederationKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FederationKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload>[]
          }
          delete: {
            args: Prisma.FederationKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload>
          }
          update: {
            args: Prisma.FederationKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload>
          }
          deleteMany: {
            args: Prisma.FederationKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FederationKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FederationKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload>[]
          }
          upsert: {
            args: Prisma.FederationKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FederationKeyPayload>
          }
          aggregate: {
            args: Prisma.FederationKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFederationKey>
          }
          groupBy: {
            args: Prisma.FederationKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FederationKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.FederationKeyCountArgs<ExtArgs>
            result: $Utils.Optional<FederationKeyCountAggregateOutputType> | number
          }
        }
      }
      OIDCConfig: {
        payload: Prisma.$OIDCConfigPayload<ExtArgs>
        fields: Prisma.OIDCConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OIDCConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OIDCConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload>
          }
          findFirst: {
            args: Prisma.OIDCConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OIDCConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload>
          }
          findMany: {
            args: Prisma.OIDCConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload>[]
          }
          create: {
            args: Prisma.OIDCConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload>
          }
          createMany: {
            args: Prisma.OIDCConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OIDCConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload>[]
          }
          delete: {
            args: Prisma.OIDCConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload>
          }
          update: {
            args: Prisma.OIDCConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload>
          }
          deleteMany: {
            args: Prisma.OIDCConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OIDCConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OIDCConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload>[]
          }
          upsert: {
            args: Prisma.OIDCConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OIDCConfigPayload>
          }
          aggregate: {
            args: Prisma.OIDCConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOIDCConfig>
          }
          groupBy: {
            args: Prisma.OIDCConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<OIDCConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.OIDCConfigCountArgs<ExtArgs>
            result: $Utils.Optional<OIDCConfigCountAggregateOutputType> | number
          }
        }
      }
      ProviderIntegration: {
        payload: Prisma.$ProviderIntegrationPayload<ExtArgs>
        fields: Prisma.ProviderIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload>
          }
          findFirst: {
            args: Prisma.ProviderIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload>
          }
          findMany: {
            args: Prisma.ProviderIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload>[]
          }
          create: {
            args: Prisma.ProviderIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload>
          }
          createMany: {
            args: Prisma.ProviderIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload>[]
          }
          delete: {
            args: Prisma.ProviderIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload>
          }
          update: {
            args: Prisma.ProviderIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.ProviderIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.ProviderIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderIntegrationPayload>
          }
          aggregate: {
            args: Prisma.ProviderIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviderIntegration>
          }
          groupBy: {
            args: Prisma.ProviderIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderIntegrationCountAggregateOutputType> | number
          }
        }
      }
      AuditEvent: {
        payload: Prisma.$AuditEventPayload<ExtArgs>
        fields: Prisma.AuditEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findFirst: {
            args: Prisma.AuditEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findMany: {
            args: Prisma.AuditEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          create: {
            args: Prisma.AuditEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          createMany: {
            args: Prisma.AuditEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          delete: {
            args: Prisma.AuditEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          update: {
            args: Prisma.AuditEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          deleteMany: {
            args: Prisma.AuditEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          upsert: {
            args: Prisma.AuditEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          aggregate: {
            args: Prisma.AuditEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditEvent>
          }
          groupBy: {
            args: Prisma.AuditEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditEventCountArgs<ExtArgs>
            result: $Utils.Optional<AuditEventCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsSnapshot: {
        payload: Prisma.$AnalyticsSnapshotPayload<ExtArgs>
        fields: Prisma.AnalyticsSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload>
          }
          findMany: {
            args: Prisma.AnalyticsSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload>[]
          }
          create: {
            args: Prisma.AnalyticsSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload>
          }
          createMany: {
            args: Prisma.AnalyticsSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload>
          }
          update: {
            args: Prisma.AnalyticsSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSnapshotPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsSnapshot>
          }
          groupBy: {
            args: Prisma.AnalyticsSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsSnapshotCountAggregateOutputType> | number
          }
        }
      }
      Incident: {
        payload: Prisma.$IncidentPayload<ExtArgs>
        fields: Prisma.IncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findFirst: {
            args: Prisma.IncidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findMany: {
            args: Prisma.IncidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          create: {
            args: Prisma.IncidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          createMany: {
            args: Prisma.IncidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          delete: {
            args: Prisma.IncidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          update: {
            args: Prisma.IncidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncidentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          upsert: {
            args: Prisma.IncidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          aggregate: {
            args: Prisma.IncidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncident>
          }
          groupBy: {
            args: Prisma.IncidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLine: {
        payload: Prisma.$InvoiceLinePayload<ExtArgs>
        fields: Prisma.InvoiceLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findFirst: {
            args: Prisma.InvoiceLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findMany: {
            args: Prisma.InvoiceLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          create: {
            args: Prisma.InvoiceLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          createMany: {
            args: Prisma.InvoiceLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          delete: {
            args: Prisma.InvoiceLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          update: {
            args: Prisma.InvoiceLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          aggregate: {
            args: Prisma.InvoiceLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceLine>
          }
          groupBy: {
            args: Prisma.InvoiceLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLineCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      PricePlan: {
        payload: Prisma.$PricePlanPayload<ExtArgs>
        fields: Prisma.PricePlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PricePlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PricePlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload>
          }
          findFirst: {
            args: Prisma.PricePlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PricePlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload>
          }
          findMany: {
            args: Prisma.PricePlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload>[]
          }
          create: {
            args: Prisma.PricePlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload>
          }
          createMany: {
            args: Prisma.PricePlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PricePlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload>[]
          }
          delete: {
            args: Prisma.PricePlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload>
          }
          update: {
            args: Prisma.PricePlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload>
          }
          deleteMany: {
            args: Prisma.PricePlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PricePlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PricePlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload>[]
          }
          upsert: {
            args: Prisma.PricePlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePlanPayload>
          }
          aggregate: {
            args: Prisma.PricePlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricePlan>
          }
          groupBy: {
            args: Prisma.PricePlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricePlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PricePlanCountArgs<ExtArgs>
            result: $Utils.Optional<PricePlanCountAggregateOutputType> | number
          }
        }
      }
      PlanPrice: {
        payload: Prisma.$PlanPricePayload<ExtArgs>
        fields: Prisma.PlanPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload>
          }
          findFirst: {
            args: Prisma.PlanPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload>
          }
          findMany: {
            args: Prisma.PlanPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload>[]
          }
          create: {
            args: Prisma.PlanPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload>
          }
          createMany: {
            args: Prisma.PlanPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload>[]
          }
          delete: {
            args: Prisma.PlanPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload>
          }
          update: {
            args: Prisma.PlanPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload>
          }
          deleteMany: {
            args: Prisma.PlanPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanPriceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload>[]
          }
          upsert: {
            args: Prisma.PlanPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPricePayload>
          }
          aggregate: {
            args: Prisma.PlanPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanPrice>
          }
          groupBy: {
            args: Prisma.PlanPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanPriceCountArgs<ExtArgs>
            result: $Utils.Optional<PlanPriceCountAggregateOutputType> | number
          }
        }
      }
      Offer: {
        payload: Prisma.$OfferPayload<ExtArgs>
        fields: Prisma.OfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffer>
          }
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>
            result: $Utils.Optional<OfferCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      TenantPriceOverride: {
        payload: Prisma.$TenantPriceOverridePayload<ExtArgs>
        fields: Prisma.TenantPriceOverrideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantPriceOverrideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantPriceOverrideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload>
          }
          findFirst: {
            args: Prisma.TenantPriceOverrideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantPriceOverrideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload>
          }
          findMany: {
            args: Prisma.TenantPriceOverrideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload>[]
          }
          create: {
            args: Prisma.TenantPriceOverrideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload>
          }
          createMany: {
            args: Prisma.TenantPriceOverrideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantPriceOverrideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload>[]
          }
          delete: {
            args: Prisma.TenantPriceOverrideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload>
          }
          update: {
            args: Prisma.TenantPriceOverrideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload>
          }
          deleteMany: {
            args: Prisma.TenantPriceOverrideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantPriceOverrideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantPriceOverrideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload>[]
          }
          upsert: {
            args: Prisma.TenantPriceOverrideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPriceOverridePayload>
          }
          aggregate: {
            args: Prisma.TenantPriceOverrideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantPriceOverride>
          }
          groupBy: {
            args: Prisma.TenantPriceOverrideGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantPriceOverrideGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantPriceOverrideCountArgs<ExtArgs>
            result: $Utils.Optional<TenantPriceOverrideCountAggregateOutputType> | number
          }
        }
      }
      GlobalMonetizationConfig: {
        payload: Prisma.$GlobalMonetizationConfigPayload<ExtArgs>
        fields: Prisma.GlobalMonetizationConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlobalMonetizationConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlobalMonetizationConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload>
          }
          findFirst: {
            args: Prisma.GlobalMonetizationConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlobalMonetizationConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload>
          }
          findMany: {
            args: Prisma.GlobalMonetizationConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload>[]
          }
          create: {
            args: Prisma.GlobalMonetizationConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload>
          }
          createMany: {
            args: Prisma.GlobalMonetizationConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlobalMonetizationConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload>[]
          }
          delete: {
            args: Prisma.GlobalMonetizationConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload>
          }
          update: {
            args: Prisma.GlobalMonetizationConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload>
          }
          deleteMany: {
            args: Prisma.GlobalMonetizationConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlobalMonetizationConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GlobalMonetizationConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload>[]
          }
          upsert: {
            args: Prisma.GlobalMonetizationConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalMonetizationConfigPayload>
          }
          aggregate: {
            args: Prisma.GlobalMonetizationConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlobalMonetizationConfig>
          }
          groupBy: {
            args: Prisma.GlobalMonetizationConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlobalMonetizationConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlobalMonetizationConfigCountArgs<ExtArgs>
            result: $Utils.Optional<GlobalMonetizationConfigCountAggregateOutputType> | number
          }
        }
      }
      OnboardingInvite: {
        payload: Prisma.$OnboardingInvitePayload<ExtArgs>
        fields: Prisma.OnboardingInviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnboardingInviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnboardingInviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload>
          }
          findFirst: {
            args: Prisma.OnboardingInviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnboardingInviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload>
          }
          findMany: {
            args: Prisma.OnboardingInviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload>[]
          }
          create: {
            args: Prisma.OnboardingInviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload>
          }
          createMany: {
            args: Prisma.OnboardingInviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnboardingInviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload>[]
          }
          delete: {
            args: Prisma.OnboardingInviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload>
          }
          update: {
            args: Prisma.OnboardingInviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload>
          }
          deleteMany: {
            args: Prisma.OnboardingInviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnboardingInviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OnboardingInviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload>[]
          }
          upsert: {
            args: Prisma.OnboardingInviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitePayload>
          }
          aggregate: {
            args: Prisma.OnboardingInviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnboardingInvite>
          }
          groupBy: {
            args: Prisma.OnboardingInviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnboardingInviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnboardingInviteCountArgs<ExtArgs>
            result: $Utils.Optional<OnboardingInviteCountAggregateOutputType> | number
          }
        }
      }
      InfrastructureMetric: {
        payload: Prisma.$InfrastructureMetricPayload<ExtArgs>
        fields: Prisma.InfrastructureMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InfrastructureMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InfrastructureMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload>
          }
          findFirst: {
            args: Prisma.InfrastructureMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InfrastructureMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload>
          }
          findMany: {
            args: Prisma.InfrastructureMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload>[]
          }
          create: {
            args: Prisma.InfrastructureMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload>
          }
          createMany: {
            args: Prisma.InfrastructureMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InfrastructureMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload>[]
          }
          delete: {
            args: Prisma.InfrastructureMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload>
          }
          update: {
            args: Prisma.InfrastructureMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload>
          }
          deleteMany: {
            args: Prisma.InfrastructureMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InfrastructureMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InfrastructureMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload>[]
          }
          upsert: {
            args: Prisma.InfrastructureMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureMetricPayload>
          }
          aggregate: {
            args: Prisma.InfrastructureMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfrastructureMetric>
          }
          groupBy: {
            args: Prisma.InfrastructureMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfrastructureMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.InfrastructureMetricCountArgs<ExtArgs>
            result: $Utils.Optional<InfrastructureMetricCountAggregateOutputType> | number
          }
        }
      }
      InfrastructureLimit: {
        payload: Prisma.$InfrastructureLimitPayload<ExtArgs>
        fields: Prisma.InfrastructureLimitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InfrastructureLimitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InfrastructureLimitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload>
          }
          findFirst: {
            args: Prisma.InfrastructureLimitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InfrastructureLimitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload>
          }
          findMany: {
            args: Prisma.InfrastructureLimitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload>[]
          }
          create: {
            args: Prisma.InfrastructureLimitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload>
          }
          createMany: {
            args: Prisma.InfrastructureLimitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InfrastructureLimitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload>[]
          }
          delete: {
            args: Prisma.InfrastructureLimitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload>
          }
          update: {
            args: Prisma.InfrastructureLimitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload>
          }
          deleteMany: {
            args: Prisma.InfrastructureLimitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InfrastructureLimitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InfrastructureLimitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload>[]
          }
          upsert: {
            args: Prisma.InfrastructureLimitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfrastructureLimitPayload>
          }
          aggregate: {
            args: Prisma.InfrastructureLimitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfrastructureLimit>
          }
          groupBy: {
            args: Prisma.InfrastructureLimitGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfrastructureLimitGroupByOutputType>[]
          }
          count: {
            args: Prisma.InfrastructureLimitCountArgs<ExtArgs>
            result: $Utils.Optional<InfrastructureLimitCountAggregateOutputType> | number
          }
        }
      }
      ImportJob: {
        payload: Prisma.$ImportJobPayload<ExtArgs>
        fields: Prisma.ImportJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          findFirst: {
            args: Prisma.ImportJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          findMany: {
            args: Prisma.ImportJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>[]
          }
          create: {
            args: Prisma.ImportJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          createMany: {
            args: Prisma.ImportJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>[]
          }
          delete: {
            args: Prisma.ImportJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          update: {
            args: Prisma.ImportJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          deleteMany: {
            args: Prisma.ImportJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImportJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>[]
          }
          upsert: {
            args: Prisma.ImportJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          aggregate: {
            args: Prisma.ImportJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportJob>
          }
          groupBy: {
            args: Prisma.ImportJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportJobCountArgs<ExtArgs>
            result: $Utils.Optional<ImportJobCountAggregateOutputType> | number
          }
        }
      }
      ImportMapping: {
        payload: Prisma.$ImportMappingPayload<ExtArgs>
        fields: Prisma.ImportMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload>
          }
          findFirst: {
            args: Prisma.ImportMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload>
          }
          findMany: {
            args: Prisma.ImportMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload>[]
          }
          create: {
            args: Prisma.ImportMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload>
          }
          createMany: {
            args: Prisma.ImportMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload>[]
          }
          delete: {
            args: Prisma.ImportMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload>
          }
          update: {
            args: Prisma.ImportMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload>
          }
          deleteMany: {
            args: Prisma.ImportMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImportMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload>[]
          }
          upsert: {
            args: Prisma.ImportMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMappingPayload>
          }
          aggregate: {
            args: Prisma.ImportMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportMapping>
          }
          groupBy: {
            args: Prisma.ImportMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportMappingCountArgs<ExtArgs>
            result: $Utils.Optional<ImportMappingCountAggregateOutputType> | number
          }
        }
      }
      ImportError: {
        payload: Prisma.$ImportErrorPayload<ExtArgs>
        fields: Prisma.ImportErrorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportErrorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportErrorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload>
          }
          findFirst: {
            args: Prisma.ImportErrorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportErrorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload>
          }
          findMany: {
            args: Prisma.ImportErrorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload>[]
          }
          create: {
            args: Prisma.ImportErrorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload>
          }
          createMany: {
            args: Prisma.ImportErrorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportErrorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload>[]
          }
          delete: {
            args: Prisma.ImportErrorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload>
          }
          update: {
            args: Prisma.ImportErrorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload>
          }
          deleteMany: {
            args: Prisma.ImportErrorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportErrorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImportErrorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload>[]
          }
          upsert: {
            args: Prisma.ImportErrorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportErrorPayload>
          }
          aggregate: {
            args: Prisma.ImportErrorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportError>
          }
          groupBy: {
            args: Prisma.ImportErrorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportErrorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportErrorCountArgs<ExtArgs>
            result: $Utils.Optional<ImportErrorCountAggregateOutputType> | number
          }
        }
      }
      UpgradeRecommendation: {
        payload: Prisma.$UpgradeRecommendationPayload<ExtArgs>
        fields: Prisma.UpgradeRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UpgradeRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UpgradeRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload>
          }
          findFirst: {
            args: Prisma.UpgradeRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UpgradeRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload>
          }
          findMany: {
            args: Prisma.UpgradeRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload>[]
          }
          create: {
            args: Prisma.UpgradeRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload>
          }
          createMany: {
            args: Prisma.UpgradeRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UpgradeRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload>[]
          }
          delete: {
            args: Prisma.UpgradeRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload>
          }
          update: {
            args: Prisma.UpgradeRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.UpgradeRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UpgradeRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UpgradeRecommendationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload>[]
          }
          upsert: {
            args: Prisma.UpgradeRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpgradeRecommendationPayload>
          }
          aggregate: {
            args: Prisma.UpgradeRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpgradeRecommendation>
          }
          groupBy: {
            args: Prisma.UpgradeRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UpgradeRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UpgradeRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<UpgradeRecommendationCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    org?: OrgOmit
    user?: UserOmit
    userRecoveryCode?: UserRecoveryCodeOmit
    userSecurityQuestion?: UserSecurityQuestionOmit
    userBreakglassAccount?: UserBreakglassAccountOmit
    userDeviceFingerprint?: UserDeviceFingerprintOmit
    userLoginHistory?: UserLoginHistoryOmit
    breakglassActivationLog?: BreakglassActivationLogOmit
    recoveryRequest?: RecoveryRequestOmit
    lead?: LeadOmit
    customer?: CustomerOmit
    opportunity?: OpportunityOmit
    invoice?: InvoiceOmit
    payment?: PaymentOmit
    rfp?: RfpOmit
    job?: JobOmit
    referral?: ReferralOmit
    billingLedger?: BillingLedgerOmit
    leadInvoice?: LeadInvoiceOmit
    leadInvoiceLine?: LeadInvoiceLineOmit
    auditLog?: AuditLogOmit
    rbacPermission?: RbacPermissionOmit
    rbacRole?: RbacRoleOmit
    rbacRolePermission?: RbacRolePermissionOmit
    rbacUserRole?: RbacUserRoleOmit
    providerConfig?: ProviderConfigOmit
    pricingPlan?: PricingPlanOmit
    aiUsageEvent?: AiUsageEventOmit
    aiMonthlySummary?: AiMonthlySummaryOmit
    activity?: ActivityOmit
    subscription?: SubscriptionOmit
    usageMeter?: UsageMeterOmit
    addonPurchase?: AddonPurchaseOmit
    federationKey?: FederationKeyOmit
    oIDCConfig?: OIDCConfigOmit
    providerIntegration?: ProviderIntegrationOmit
    auditEvent?: AuditEventOmit
    analyticsSnapshot?: AnalyticsSnapshotOmit
    incident?: IncidentOmit
    invoiceLine?: InvoiceLineOmit
    notification?: NotificationOmit
    pricePlan?: PricePlanOmit
    planPrice?: PlanPriceOmit
    offer?: OfferOmit
    coupon?: CouponOmit
    tenantPriceOverride?: TenantPriceOverrideOmit
    globalMonetizationConfig?: GlobalMonetizationConfigOmit
    onboardingInvite?: OnboardingInviteOmit
    infrastructureMetric?: InfrastructureMetricOmit
    infrastructureLimit?: InfrastructureLimitOmit
    importJob?: ImportJobOmit
    importMapping?: ImportMappingOmit
    importError?: ImportErrorOmit
    upgradeRecommendation?: UpgradeRecommendationOmit
    refreshToken?: RefreshTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrgCountOutputType
   */

  export type OrgCountOutputType = {
    auditLogs: number
    ledger: number
    customers: number
    invoices: number
    jobs: number
    leads: number
    opportunities: number
    payments: number
    referrals: number
    rfps: number
    users: number
    rbacRoles: number
    rbacUserRoles: number
    leadInvoices: number
    aiUsageEvents: number
    aiMonthlySummaries: number
    activities: number
    subscriptions: number
    usageMeters: number
    addonPurchases: number
    tenantOverrides: number
    incidents: number
    notifications: number
    importJobs: number
    importMappings: number
  }

  export type OrgCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | OrgCountOutputTypeCountAuditLogsArgs
    ledger?: boolean | OrgCountOutputTypeCountLedgerArgs
    customers?: boolean | OrgCountOutputTypeCountCustomersArgs
    invoices?: boolean | OrgCountOutputTypeCountInvoicesArgs
    jobs?: boolean | OrgCountOutputTypeCountJobsArgs
    leads?: boolean | OrgCountOutputTypeCountLeadsArgs
    opportunities?: boolean | OrgCountOutputTypeCountOpportunitiesArgs
    payments?: boolean | OrgCountOutputTypeCountPaymentsArgs
    referrals?: boolean | OrgCountOutputTypeCountReferralsArgs
    rfps?: boolean | OrgCountOutputTypeCountRfpsArgs
    users?: boolean | OrgCountOutputTypeCountUsersArgs
    rbacRoles?: boolean | OrgCountOutputTypeCountRbacRolesArgs
    rbacUserRoles?: boolean | OrgCountOutputTypeCountRbacUserRolesArgs
    leadInvoices?: boolean | OrgCountOutputTypeCountLeadInvoicesArgs
    aiUsageEvents?: boolean | OrgCountOutputTypeCountAiUsageEventsArgs
    aiMonthlySummaries?: boolean | OrgCountOutputTypeCountAiMonthlySummariesArgs
    activities?: boolean | OrgCountOutputTypeCountActivitiesArgs
    subscriptions?: boolean | OrgCountOutputTypeCountSubscriptionsArgs
    usageMeters?: boolean | OrgCountOutputTypeCountUsageMetersArgs
    addonPurchases?: boolean | OrgCountOutputTypeCountAddonPurchasesArgs
    tenantOverrides?: boolean | OrgCountOutputTypeCountTenantOverridesArgs
    incidents?: boolean | OrgCountOutputTypeCountIncidentsArgs
    notifications?: boolean | OrgCountOutputTypeCountNotificationsArgs
    importJobs?: boolean | OrgCountOutputTypeCountImportJobsArgs
    importMappings?: boolean | OrgCountOutputTypeCountImportMappingsArgs
  }

  // Custom InputTypes
  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgCountOutputType
     */
    select?: OrgCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingLedgerWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountRfpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RfpWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountRbacRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RbacRoleWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountRbacUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RbacUserRoleWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountLeadInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadInvoiceWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountAiUsageEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiUsageEventWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountAiMonthlySummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiMonthlySummaryWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountUsageMetersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageMeterWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountAddonPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddonPurchaseWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountTenantOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantPriceOverrideWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountImportJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportJobWhereInput
  }

  /**
   * OrgCountOutputType without action
   */
  export type OrgCountOutputTypeCountImportMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportMappingWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    rbacUserRoles: number
    recoveryCodes: number
    securityQuestions: number
    loginHistory: number
    deviceFingerprints: number
    importJobs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rbacUserRoles?: boolean | UserCountOutputTypeCountRbacUserRolesArgs
    recoveryCodes?: boolean | UserCountOutputTypeCountRecoveryCodesArgs
    securityQuestions?: boolean | UserCountOutputTypeCountSecurityQuestionsArgs
    loginHistory?: boolean | UserCountOutputTypeCountLoginHistoryArgs
    deviceFingerprints?: boolean | UserCountOutputTypeCountDeviceFingerprintsArgs
    importJobs?: boolean | UserCountOutputTypeCountImportJobsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRbacUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RbacUserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecoveryCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRecoveryCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSecurityQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSecurityQuestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLoginHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLoginHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeviceFingerprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDeviceFingerprintWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountImportJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportJobWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    LeadInvoiceLine: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LeadInvoiceLine?: boolean | LeadCountOutputTypeCountLeadInvoiceLineArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountLeadInvoiceLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadInvoiceLineWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    invoices: number
    jobs: number
    opportunities: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | CustomerCountOutputTypeCountInvoicesArgs
    jobs?: boolean | CustomerCountOutputTypeCountJobsArgs
    opportunities?: boolean | CustomerCountOutputTypeCountOpportunitiesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    lineItems: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | InvoiceCountOutputTypeCountLineItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type RfpCountOutputType
   */

  export type RfpCountOutputType = {
    jobs: number
  }

  export type RfpCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | RfpCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * RfpCountOutputType without action
   */
  export type RfpCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfpCountOutputType
     */
    select?: RfpCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RfpCountOutputType without action
   */
  export type RfpCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }


  /**
   * Count Type LeadInvoiceCountOutputType
   */

  export type LeadInvoiceCountOutputType = {
    lines: number
  }

  export type LeadInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | LeadInvoiceCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * LeadInvoiceCountOutputType without action
   */
  export type LeadInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceCountOutputType
     */
    select?: LeadInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadInvoiceCountOutputType without action
   */
  export type LeadInvoiceCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadInvoiceLineWhereInput
  }


  /**
   * Count Type RbacPermissionCountOutputType
   */

  export type RbacPermissionCountOutputType = {
    rolePerms: number
  }

  export type RbacPermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePerms?: boolean | RbacPermissionCountOutputTypeCountRolePermsArgs
  }

  // Custom InputTypes
  /**
   * RbacPermissionCountOutputType without action
   */
  export type RbacPermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermissionCountOutputType
     */
    select?: RbacPermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RbacPermissionCountOutputType without action
   */
  export type RbacPermissionCountOutputTypeCountRolePermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RbacRolePermissionWhereInput
  }


  /**
   * Count Type RbacRoleCountOutputType
   */

  export type RbacRoleCountOutputType = {
    rolePerms: number
    userRoles: number
  }

  export type RbacRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePerms?: boolean | RbacRoleCountOutputTypeCountRolePermsArgs
    userRoles?: boolean | RbacRoleCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RbacRoleCountOutputType without action
   */
  export type RbacRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRoleCountOutputType
     */
    select?: RbacRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RbacRoleCountOutputType without action
   */
  export type RbacRoleCountOutputTypeCountRolePermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RbacRolePermissionWhereInput
  }

  /**
   * RbacRoleCountOutputType without action
   */
  export type RbacRoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RbacUserRoleWhereInput
  }


  /**
   * Count Type PricePlanCountOutputType
   */

  export type PricePlanCountOutputType = {
    prices: number
    offers: number
    overrides: number
    asDefaultFor: number
    invites: number
  }

  export type PricePlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prices?: boolean | PricePlanCountOutputTypeCountPricesArgs
    offers?: boolean | PricePlanCountOutputTypeCountOffersArgs
    overrides?: boolean | PricePlanCountOutputTypeCountOverridesArgs
    asDefaultFor?: boolean | PricePlanCountOutputTypeCountAsDefaultForArgs
    invites?: boolean | PricePlanCountOutputTypeCountInvitesArgs
  }

  // Custom InputTypes
  /**
   * PricePlanCountOutputType without action
   */
  export type PricePlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlanCountOutputType
     */
    select?: PricePlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PricePlanCountOutputType without action
   */
  export type PricePlanCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanPriceWhereInput
  }

  /**
   * PricePlanCountOutputType without action
   */
  export type PricePlanCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }

  /**
   * PricePlanCountOutputType without action
   */
  export type PricePlanCountOutputTypeCountOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantPriceOverrideWhereInput
  }

  /**
   * PricePlanCountOutputType without action
   */
  export type PricePlanCountOutputTypeCountAsDefaultForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlobalMonetizationConfigWhereInput
  }

  /**
   * PricePlanCountOutputType without action
   */
  export type PricePlanCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingInviteWhereInput
  }


  /**
   * Count Type PlanPriceCountOutputType
   */

  export type PlanPriceCountOutputType = {
    overrides: number
    asDefaultFor: number
    invites: number
  }

  export type PlanPriceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    overrides?: boolean | PlanPriceCountOutputTypeCountOverridesArgs
    asDefaultFor?: boolean | PlanPriceCountOutputTypeCountAsDefaultForArgs
    invites?: boolean | PlanPriceCountOutputTypeCountInvitesArgs
  }

  // Custom InputTypes
  /**
   * PlanPriceCountOutputType without action
   */
  export type PlanPriceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPriceCountOutputType
     */
    select?: PlanPriceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanPriceCountOutputType without action
   */
  export type PlanPriceCountOutputTypeCountOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantPriceOverrideWhereInput
  }

  /**
   * PlanPriceCountOutputType without action
   */
  export type PlanPriceCountOutputTypeCountAsDefaultForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlobalMonetizationConfigWhereInput
  }

  /**
   * PlanPriceCountOutputType without action
   */
  export type PlanPriceCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingInviteWhereInput
  }


  /**
   * Count Type OfferCountOutputType
   */

  export type OfferCountOutputType = {
    invites: number
  }

  export type OfferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invites?: boolean | OfferCountOutputTypeCountInvitesArgs
  }

  // Custom InputTypes
  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     */
    select?: OfferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingInviteWhereInput
  }


  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    invites: number
  }

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invites?: boolean | CouponCountOutputTypeCountInvitesArgs
  }

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingInviteWhereInput
  }


  /**
   * Count Type ImportJobCountOutputType
   */

  export type ImportJobCountOutputType = {
    errors: number
  }

  export type ImportJobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    errors?: boolean | ImportJobCountOutputTypeCountErrorsArgs
  }

  // Custom InputTypes
  /**
   * ImportJobCountOutputType without action
   */
  export type ImportJobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJobCountOutputType
     */
    select?: ImportJobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImportJobCountOutputType without action
   */
  export type ImportJobCountOutputTypeCountErrorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportErrorWhereInput
  }


  /**
   * Count Type ImportMappingCountOutputType
   */

  export type ImportMappingCountOutputType = {
    jobs: number
  }

  export type ImportMappingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | ImportMappingCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * ImportMappingCountOutputType without action
   */
  export type ImportMappingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMappingCountOutputType
     */
    select?: ImportMappingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImportMappingCountOutputType without action
   */
  export type ImportMappingCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportJobWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Org
   */

  export type AggregateOrg = {
    _count: OrgCountAggregateOutputType | null
    _avg: OrgAvgAggregateOutputType | null
    _sum: OrgSumAggregateOutputType | null
    _min: OrgMinAggregateOutputType | null
    _max: OrgMaxAggregateOutputType | null
  }

  export type OrgAvgAggregateOutputType = {
    aiMonthlyBudgetCents: number | null
    aiCreditBalance: number | null
  }

  export type OrgSumAggregateOutputType = {
    aiMonthlyBudgetCents: number | null
    aiCreditBalance: number | null
  }

  export type OrgMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    aiMonthlyBudgetCents: number | null
    aiCreditBalance: number | null
    aiPlan: $Enums.AiPlan | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: string | null
    subscriptionStartDate: Date | null
    subscriptionEndDate: Date | null
  }

  export type OrgMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    aiMonthlyBudgetCents: number | null
    aiCreditBalance: number | null
    aiPlan: $Enums.AiPlan | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: string | null
    subscriptionStartDate: Date | null
    subscriptionEndDate: Date | null
  }

  export type OrgCountAggregateOutputType = {
    id: number
    name: number
    featureFlags: number
    createdAt: number
    updatedAt: number
    aiMonthlyBudgetCents: number
    aiCreditBalance: number
    aiPlan: number
    aiAlerts: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    subscriptionStatus: number
    subscriptionStartDate: number
    subscriptionEndDate: number
    brandConfig: number
    settingsJson: number
    _all: number
  }


  export type OrgAvgAggregateInputType = {
    aiMonthlyBudgetCents?: true
    aiCreditBalance?: true
  }

  export type OrgSumAggregateInputType = {
    aiMonthlyBudgetCents?: true
    aiCreditBalance?: true
  }

  export type OrgMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    aiMonthlyBudgetCents?: true
    aiCreditBalance?: true
    aiPlan?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    subscriptionStartDate?: true
    subscriptionEndDate?: true
  }

  export type OrgMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    aiMonthlyBudgetCents?: true
    aiCreditBalance?: true
    aiPlan?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    subscriptionStartDate?: true
    subscriptionEndDate?: true
  }

  export type OrgCountAggregateInputType = {
    id?: true
    name?: true
    featureFlags?: true
    createdAt?: true
    updatedAt?: true
    aiMonthlyBudgetCents?: true
    aiCreditBalance?: true
    aiPlan?: true
    aiAlerts?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    subscriptionStartDate?: true
    subscriptionEndDate?: true
    brandConfig?: true
    settingsJson?: true
    _all?: true
  }

  export type OrgAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Org to aggregate.
     */
    where?: OrgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orgs to fetch.
     */
    orderBy?: OrgOrderByWithRelationInput | OrgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orgs
    **/
    _count?: true | OrgCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrgAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrgSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrgMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrgMaxAggregateInputType
  }

  export type GetOrgAggregateType<T extends OrgAggregateArgs> = {
        [P in keyof T & keyof AggregateOrg]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrg[P]>
      : GetScalarType<T[P], AggregateOrg[P]>
  }




  export type OrgGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgWhereInput
    orderBy?: OrgOrderByWithAggregationInput | OrgOrderByWithAggregationInput[]
    by: OrgScalarFieldEnum[] | OrgScalarFieldEnum
    having?: OrgScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrgCountAggregateInputType | true
    _avg?: OrgAvgAggregateInputType
    _sum?: OrgSumAggregateInputType
    _min?: OrgMinAggregateInputType
    _max?: OrgMaxAggregateInputType
  }

  export type OrgGroupByOutputType = {
    id: string
    name: string
    featureFlags: JsonValue
    createdAt: Date
    updatedAt: Date
    aiMonthlyBudgetCents: number
    aiCreditBalance: number
    aiPlan: $Enums.AiPlan
    aiAlerts: JsonValue
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: string | null
    subscriptionStartDate: Date | null
    subscriptionEndDate: Date | null
    brandConfig: JsonValue | null
    settingsJson: JsonValue | null
    _count: OrgCountAggregateOutputType | null
    _avg: OrgAvgAggregateOutputType | null
    _sum: OrgSumAggregateOutputType | null
    _min: OrgMinAggregateOutputType | null
    _max: OrgMaxAggregateOutputType | null
  }

  type GetOrgGroupByPayload<T extends OrgGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrgGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrgGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrgGroupByOutputType[P]>
            : GetScalarType<T[P], OrgGroupByOutputType[P]>
        }
      >
    >


  export type OrgSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    featureFlags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiMonthlyBudgetCents?: boolean
    aiCreditBalance?: boolean
    aiPlan?: boolean
    aiAlerts?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    brandConfig?: boolean
    settingsJson?: boolean
    auditLogs?: boolean | Org$auditLogsArgs<ExtArgs>
    ledger?: boolean | Org$ledgerArgs<ExtArgs>
    customers?: boolean | Org$customersArgs<ExtArgs>
    invoices?: boolean | Org$invoicesArgs<ExtArgs>
    jobs?: boolean | Org$jobsArgs<ExtArgs>
    leads?: boolean | Org$leadsArgs<ExtArgs>
    opportunities?: boolean | Org$opportunitiesArgs<ExtArgs>
    payments?: boolean | Org$paymentsArgs<ExtArgs>
    referrals?: boolean | Org$referralsArgs<ExtArgs>
    rfps?: boolean | Org$rfpsArgs<ExtArgs>
    users?: boolean | Org$usersArgs<ExtArgs>
    rbacRoles?: boolean | Org$rbacRolesArgs<ExtArgs>
    rbacUserRoles?: boolean | Org$rbacUserRolesArgs<ExtArgs>
    leadInvoices?: boolean | Org$leadInvoicesArgs<ExtArgs>
    pricingPlan?: boolean | Org$pricingPlanArgs<ExtArgs>
    aiUsageEvents?: boolean | Org$aiUsageEventsArgs<ExtArgs>
    aiMonthlySummaries?: boolean | Org$aiMonthlySummariesArgs<ExtArgs>
    activities?: boolean | Org$activitiesArgs<ExtArgs>
    subscriptions?: boolean | Org$subscriptionsArgs<ExtArgs>
    usageMeters?: boolean | Org$usageMetersArgs<ExtArgs>
    addonPurchases?: boolean | Org$addonPurchasesArgs<ExtArgs>
    tenantOverrides?: boolean | Org$tenantOverridesArgs<ExtArgs>
    incidents?: boolean | Org$incidentsArgs<ExtArgs>
    notifications?: boolean | Org$notificationsArgs<ExtArgs>
    importJobs?: boolean | Org$importJobsArgs<ExtArgs>
    importMappings?: boolean | Org$importMappingsArgs<ExtArgs>
    _count?: boolean | OrgCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["org"]>

  export type OrgSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    featureFlags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiMonthlyBudgetCents?: boolean
    aiCreditBalance?: boolean
    aiPlan?: boolean
    aiAlerts?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    brandConfig?: boolean
    settingsJson?: boolean
  }, ExtArgs["result"]["org"]>

  export type OrgSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    featureFlags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiMonthlyBudgetCents?: boolean
    aiCreditBalance?: boolean
    aiPlan?: boolean
    aiAlerts?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    brandConfig?: boolean
    settingsJson?: boolean
  }, ExtArgs["result"]["org"]>

  export type OrgSelectScalar = {
    id?: boolean
    name?: boolean
    featureFlags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiMonthlyBudgetCents?: boolean
    aiCreditBalance?: boolean
    aiPlan?: boolean
    aiAlerts?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    brandConfig?: boolean
    settingsJson?: boolean
  }

  export type OrgOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "featureFlags" | "createdAt" | "updatedAt" | "aiMonthlyBudgetCents" | "aiCreditBalance" | "aiPlan" | "aiAlerts" | "stripeCustomerId" | "stripeSubscriptionId" | "subscriptionStatus" | "subscriptionStartDate" | "subscriptionEndDate" | "brandConfig" | "settingsJson", ExtArgs["result"]["org"]>
  export type OrgInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | Org$auditLogsArgs<ExtArgs>
    ledger?: boolean | Org$ledgerArgs<ExtArgs>
    customers?: boolean | Org$customersArgs<ExtArgs>
    invoices?: boolean | Org$invoicesArgs<ExtArgs>
    jobs?: boolean | Org$jobsArgs<ExtArgs>
    leads?: boolean | Org$leadsArgs<ExtArgs>
    opportunities?: boolean | Org$opportunitiesArgs<ExtArgs>
    payments?: boolean | Org$paymentsArgs<ExtArgs>
    referrals?: boolean | Org$referralsArgs<ExtArgs>
    rfps?: boolean | Org$rfpsArgs<ExtArgs>
    users?: boolean | Org$usersArgs<ExtArgs>
    rbacRoles?: boolean | Org$rbacRolesArgs<ExtArgs>
    rbacUserRoles?: boolean | Org$rbacUserRolesArgs<ExtArgs>
    leadInvoices?: boolean | Org$leadInvoicesArgs<ExtArgs>
    pricingPlan?: boolean | Org$pricingPlanArgs<ExtArgs>
    aiUsageEvents?: boolean | Org$aiUsageEventsArgs<ExtArgs>
    aiMonthlySummaries?: boolean | Org$aiMonthlySummariesArgs<ExtArgs>
    activities?: boolean | Org$activitiesArgs<ExtArgs>
    subscriptions?: boolean | Org$subscriptionsArgs<ExtArgs>
    usageMeters?: boolean | Org$usageMetersArgs<ExtArgs>
    addonPurchases?: boolean | Org$addonPurchasesArgs<ExtArgs>
    tenantOverrides?: boolean | Org$tenantOverridesArgs<ExtArgs>
    incidents?: boolean | Org$incidentsArgs<ExtArgs>
    notifications?: boolean | Org$notificationsArgs<ExtArgs>
    importJobs?: boolean | Org$importJobsArgs<ExtArgs>
    importMappings?: boolean | Org$importMappingsArgs<ExtArgs>
    _count?: boolean | OrgCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrgIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrgIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrgPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Org"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      ledger: Prisma.$BillingLedgerPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      jobs: Prisma.$JobPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      opportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
      rfps: Prisma.$RfpPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      rbacRoles: Prisma.$RbacRolePayload<ExtArgs>[]
      rbacUserRoles: Prisma.$RbacUserRolePayload<ExtArgs>[]
      leadInvoices: Prisma.$LeadInvoicePayload<ExtArgs>[]
      pricingPlan: Prisma.$PricingPlanPayload<ExtArgs> | null
      aiUsageEvents: Prisma.$AiUsageEventPayload<ExtArgs>[]
      aiMonthlySummaries: Prisma.$AiMonthlySummaryPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      usageMeters: Prisma.$UsageMeterPayload<ExtArgs>[]
      addonPurchases: Prisma.$AddonPurchasePayload<ExtArgs>[]
      tenantOverrides: Prisma.$TenantPriceOverridePayload<ExtArgs>[]
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      importJobs: Prisma.$ImportJobPayload<ExtArgs>[]
      importMappings: Prisma.$ImportMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      featureFlags: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      aiMonthlyBudgetCents: number
      aiCreditBalance: number
      aiPlan: $Enums.AiPlan
      aiAlerts: Prisma.JsonValue
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      subscriptionStatus: string | null
      subscriptionStartDate: Date | null
      subscriptionEndDate: Date | null
      /**
       * brandConfig stores white-label brand settings such as name, colors, and logo URL.
       * It is JSON to allow arbitrary keys like { name: "Mountain Vista", color: "#123456", logoUrl: "https://..." }
       */
      brandConfig: Prisma.JsonValue | null
      /**
       * settingsJson stores arbitrary organization-level settings.  This can be used
       * by owners to configure API keys or other preferences needed at runtime.
       */
      settingsJson: Prisma.JsonValue | null
    }, ExtArgs["result"]["org"]>
    composites: {}
  }

  type OrgGetPayload<S extends boolean | null | undefined | OrgDefaultArgs> = $Result.GetResult<Prisma.$OrgPayload, S>

  type OrgCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrgFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrgCountAggregateInputType | true
    }

  export interface OrgDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Org'], meta: { name: 'Org' } }
    /**
     * Find zero or one Org that matches the filter.
     * @param {OrgFindUniqueArgs} args - Arguments to find a Org
     * @example
     * // Get one Org
     * const org = await prisma.org.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrgFindUniqueArgs>(args: SelectSubset<T, OrgFindUniqueArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Org that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrgFindUniqueOrThrowArgs} args - Arguments to find a Org
     * @example
     * // Get one Org
     * const org = await prisma.org.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrgFindUniqueOrThrowArgs>(args: SelectSubset<T, OrgFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Org that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgFindFirstArgs} args - Arguments to find a Org
     * @example
     * // Get one Org
     * const org = await prisma.org.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrgFindFirstArgs>(args?: SelectSubset<T, OrgFindFirstArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Org that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgFindFirstOrThrowArgs} args - Arguments to find a Org
     * @example
     * // Get one Org
     * const org = await prisma.org.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrgFindFirstOrThrowArgs>(args?: SelectSubset<T, OrgFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orgs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orgs
     * const orgs = await prisma.org.findMany()
     * 
     * // Get first 10 Orgs
     * const orgs = await prisma.org.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orgWithIdOnly = await prisma.org.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrgFindManyArgs>(args?: SelectSubset<T, OrgFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Org.
     * @param {OrgCreateArgs} args - Arguments to create a Org.
     * @example
     * // Create one Org
     * const Org = await prisma.org.create({
     *   data: {
     *     // ... data to create a Org
     *   }
     * })
     * 
     */
    create<T extends OrgCreateArgs>(args: SelectSubset<T, OrgCreateArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orgs.
     * @param {OrgCreateManyArgs} args - Arguments to create many Orgs.
     * @example
     * // Create many Orgs
     * const org = await prisma.org.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrgCreateManyArgs>(args?: SelectSubset<T, OrgCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orgs and returns the data saved in the database.
     * @param {OrgCreateManyAndReturnArgs} args - Arguments to create many Orgs.
     * @example
     * // Create many Orgs
     * const org = await prisma.org.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orgs and only return the `id`
     * const orgWithIdOnly = await prisma.org.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrgCreateManyAndReturnArgs>(args?: SelectSubset<T, OrgCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Org.
     * @param {OrgDeleteArgs} args - Arguments to delete one Org.
     * @example
     * // Delete one Org
     * const Org = await prisma.org.delete({
     *   where: {
     *     // ... filter to delete one Org
     *   }
     * })
     * 
     */
    delete<T extends OrgDeleteArgs>(args: SelectSubset<T, OrgDeleteArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Org.
     * @param {OrgUpdateArgs} args - Arguments to update one Org.
     * @example
     * // Update one Org
     * const org = await prisma.org.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrgUpdateArgs>(args: SelectSubset<T, OrgUpdateArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orgs.
     * @param {OrgDeleteManyArgs} args - Arguments to filter Orgs to delete.
     * @example
     * // Delete a few Orgs
     * const { count } = await prisma.org.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrgDeleteManyArgs>(args?: SelectSubset<T, OrgDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orgs
     * const org = await prisma.org.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrgUpdateManyArgs>(args: SelectSubset<T, OrgUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orgs and returns the data updated in the database.
     * @param {OrgUpdateManyAndReturnArgs} args - Arguments to update many Orgs.
     * @example
     * // Update many Orgs
     * const org = await prisma.org.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orgs and only return the `id`
     * const orgWithIdOnly = await prisma.org.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrgUpdateManyAndReturnArgs>(args: SelectSubset<T, OrgUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Org.
     * @param {OrgUpsertArgs} args - Arguments to update or create a Org.
     * @example
     * // Update or create a Org
     * const org = await prisma.org.upsert({
     *   create: {
     *     // ... data to create a Org
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Org we want to update
     *   }
     * })
     */
    upsert<T extends OrgUpsertArgs>(args: SelectSubset<T, OrgUpsertArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgCountArgs} args - Arguments to filter Orgs to count.
     * @example
     * // Count the number of Orgs
     * const count = await prisma.org.count({
     *   where: {
     *     // ... the filter for the Orgs we want to count
     *   }
     * })
    **/
    count<T extends OrgCountArgs>(
      args?: Subset<T, OrgCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrgCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Org.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrgAggregateArgs>(args: Subset<T, OrgAggregateArgs>): Prisma.PrismaPromise<GetOrgAggregateType<T>>

    /**
     * Group by Org.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrgGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrgGroupByArgs['orderBy'] }
        : { orderBy?: OrgGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrgGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrgGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Org model
   */
  readonly fields: OrgFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Org.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrgClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends Org$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Org$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ledger<T extends Org$ledgerArgs<ExtArgs> = {}>(args?: Subset<T, Org$ledgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends Org$customersArgs<ExtArgs> = {}>(args?: Subset<T, Org$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Org$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Org$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends Org$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Org$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leads<T extends Org$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Org$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    opportunities<T extends Org$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Org$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Org$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Org$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referrals<T extends Org$referralsArgs<ExtArgs> = {}>(args?: Subset<T, Org$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rfps<T extends Org$rfpsArgs<ExtArgs> = {}>(args?: Subset<T, Org$rfpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Org$usersArgs<ExtArgs> = {}>(args?: Subset<T, Org$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rbacRoles<T extends Org$rbacRolesArgs<ExtArgs> = {}>(args?: Subset<T, Org$rbacRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rbacUserRoles<T extends Org$rbacUserRolesArgs<ExtArgs> = {}>(args?: Subset<T, Org$rbacUserRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leadInvoices<T extends Org$leadInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Org$leadInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pricingPlan<T extends Org$pricingPlanArgs<ExtArgs> = {}>(args?: Subset<T, Org$pricingPlanArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    aiUsageEvents<T extends Org$aiUsageEventsArgs<ExtArgs> = {}>(args?: Subset<T, Org$aiUsageEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiMonthlySummaries<T extends Org$aiMonthlySummariesArgs<ExtArgs> = {}>(args?: Subset<T, Org$aiMonthlySummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Org$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Org$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Org$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Org$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageMeters<T extends Org$usageMetersArgs<ExtArgs> = {}>(args?: Subset<T, Org$usageMetersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addonPurchases<T extends Org$addonPurchasesArgs<ExtArgs> = {}>(args?: Subset<T, Org$addonPurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenantOverrides<T extends Org$tenantOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Org$tenantOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incidents<T extends Org$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Org$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Org$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Org$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    importJobs<T extends Org$importJobsArgs<ExtArgs> = {}>(args?: Subset<T, Org$importJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    importMappings<T extends Org$importMappingsArgs<ExtArgs> = {}>(args?: Subset<T, Org$importMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Org model
   */
  interface OrgFieldRefs {
    readonly id: FieldRef<"Org", 'String'>
    readonly name: FieldRef<"Org", 'String'>
    readonly featureFlags: FieldRef<"Org", 'Json'>
    readonly createdAt: FieldRef<"Org", 'DateTime'>
    readonly updatedAt: FieldRef<"Org", 'DateTime'>
    readonly aiMonthlyBudgetCents: FieldRef<"Org", 'Int'>
    readonly aiCreditBalance: FieldRef<"Org", 'Int'>
    readonly aiPlan: FieldRef<"Org", 'AiPlan'>
    readonly aiAlerts: FieldRef<"Org", 'Json'>
    readonly stripeCustomerId: FieldRef<"Org", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Org", 'String'>
    readonly subscriptionStatus: FieldRef<"Org", 'String'>
    readonly subscriptionStartDate: FieldRef<"Org", 'DateTime'>
    readonly subscriptionEndDate: FieldRef<"Org", 'DateTime'>
    readonly brandConfig: FieldRef<"Org", 'Json'>
    readonly settingsJson: FieldRef<"Org", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Org findUnique
   */
  export type OrgFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    /**
     * Filter, which Org to fetch.
     */
    where: OrgWhereUniqueInput
  }

  /**
   * Org findUniqueOrThrow
   */
  export type OrgFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    /**
     * Filter, which Org to fetch.
     */
    where: OrgWhereUniqueInput
  }

  /**
   * Org findFirst
   */
  export type OrgFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    /**
     * Filter, which Org to fetch.
     */
    where?: OrgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orgs to fetch.
     */
    orderBy?: OrgOrderByWithRelationInput | OrgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orgs.
     */
    cursor?: OrgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orgs.
     */
    distinct?: OrgScalarFieldEnum | OrgScalarFieldEnum[]
  }

  /**
   * Org findFirstOrThrow
   */
  export type OrgFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    /**
     * Filter, which Org to fetch.
     */
    where?: OrgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orgs to fetch.
     */
    orderBy?: OrgOrderByWithRelationInput | OrgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orgs.
     */
    cursor?: OrgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orgs.
     */
    distinct?: OrgScalarFieldEnum | OrgScalarFieldEnum[]
  }

  /**
   * Org findMany
   */
  export type OrgFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    /**
     * Filter, which Orgs to fetch.
     */
    where?: OrgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orgs to fetch.
     */
    orderBy?: OrgOrderByWithRelationInput | OrgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orgs.
     */
    cursor?: OrgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orgs.
     */
    skip?: number
    distinct?: OrgScalarFieldEnum | OrgScalarFieldEnum[]
  }

  /**
   * Org create
   */
  export type OrgCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    /**
     * The data needed to create a Org.
     */
    data: XOR<OrgCreateInput, OrgUncheckedCreateInput>
  }

  /**
   * Org createMany
   */
  export type OrgCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orgs.
     */
    data: OrgCreateManyInput | OrgCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Org createManyAndReturn
   */
  export type OrgCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * The data used to create many Orgs.
     */
    data: OrgCreateManyInput | OrgCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Org update
   */
  export type OrgUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    /**
     * The data needed to update a Org.
     */
    data: XOR<OrgUpdateInput, OrgUncheckedUpdateInput>
    /**
     * Choose, which Org to update.
     */
    where: OrgWhereUniqueInput
  }

  /**
   * Org updateMany
   */
  export type OrgUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orgs.
     */
    data: XOR<OrgUpdateManyMutationInput, OrgUncheckedUpdateManyInput>
    /**
     * Filter which Orgs to update
     */
    where?: OrgWhereInput
    /**
     * Limit how many Orgs to update.
     */
    limit?: number
  }

  /**
   * Org updateManyAndReturn
   */
  export type OrgUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * The data used to update Orgs.
     */
    data: XOR<OrgUpdateManyMutationInput, OrgUncheckedUpdateManyInput>
    /**
     * Filter which Orgs to update
     */
    where?: OrgWhereInput
    /**
     * Limit how many Orgs to update.
     */
    limit?: number
  }

  /**
   * Org upsert
   */
  export type OrgUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    /**
     * The filter to search for the Org to update in case it exists.
     */
    where: OrgWhereUniqueInput
    /**
     * In case the Org found by the `where` argument doesn't exist, create a new Org with this data.
     */
    create: XOR<OrgCreateInput, OrgUncheckedCreateInput>
    /**
     * In case the Org was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrgUpdateInput, OrgUncheckedUpdateInput>
  }

  /**
   * Org delete
   */
  export type OrgDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    /**
     * Filter which Org to delete.
     */
    where: OrgWhereUniqueInput
  }

  /**
   * Org deleteMany
   */
  export type OrgDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orgs to delete
     */
    where?: OrgWhereInput
    /**
     * Limit how many Orgs to delete.
     */
    limit?: number
  }

  /**
   * Org.auditLogs
   */
  export type Org$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Org.ledger
   */
  export type Org$ledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
    where?: BillingLedgerWhereInput
    orderBy?: BillingLedgerOrderByWithRelationInput | BillingLedgerOrderByWithRelationInput[]
    cursor?: BillingLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingLedgerScalarFieldEnum | BillingLedgerScalarFieldEnum[]
  }

  /**
   * Org.customers
   */
  export type Org$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Org.invoices
   */
  export type Org$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Org.jobs
   */
  export type Org$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Org.leads
   */
  export type Org$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Org.opportunities
   */
  export type Org$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Org.payments
   */
  export type Org$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Org.referrals
   */
  export type Org$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Org.rfps
   */
  export type Org$rfpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    where?: RfpWhereInput
    orderBy?: RfpOrderByWithRelationInput | RfpOrderByWithRelationInput[]
    cursor?: RfpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RfpScalarFieldEnum | RfpScalarFieldEnum[]
  }

  /**
   * Org.users
   */
  export type Org$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Org.rbacRoles
   */
  export type Org$rbacRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
    where?: RbacRoleWhereInput
    orderBy?: RbacRoleOrderByWithRelationInput | RbacRoleOrderByWithRelationInput[]
    cursor?: RbacRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RbacRoleScalarFieldEnum | RbacRoleScalarFieldEnum[]
  }

  /**
   * Org.rbacUserRoles
   */
  export type Org$rbacUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    where?: RbacUserRoleWhereInput
    orderBy?: RbacUserRoleOrderByWithRelationInput | RbacUserRoleOrderByWithRelationInput[]
    cursor?: RbacUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RbacUserRoleScalarFieldEnum | RbacUserRoleScalarFieldEnum[]
  }

  /**
   * Org.leadInvoices
   */
  export type Org$leadInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
    where?: LeadInvoiceWhereInput
    orderBy?: LeadInvoiceOrderByWithRelationInput | LeadInvoiceOrderByWithRelationInput[]
    cursor?: LeadInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadInvoiceScalarFieldEnum | LeadInvoiceScalarFieldEnum[]
  }

  /**
   * Org.pricingPlan
   */
  export type Org$pricingPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    where?: PricingPlanWhereInput
  }

  /**
   * Org.aiUsageEvents
   */
  export type Org$aiUsageEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
    where?: AiUsageEventWhereInput
    orderBy?: AiUsageEventOrderByWithRelationInput | AiUsageEventOrderByWithRelationInput[]
    cursor?: AiUsageEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiUsageEventScalarFieldEnum | AiUsageEventScalarFieldEnum[]
  }

  /**
   * Org.aiMonthlySummaries
   */
  export type Org$aiMonthlySummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
    where?: AiMonthlySummaryWhereInput
    orderBy?: AiMonthlySummaryOrderByWithRelationInput | AiMonthlySummaryOrderByWithRelationInput[]
    cursor?: AiMonthlySummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiMonthlySummaryScalarFieldEnum | AiMonthlySummaryScalarFieldEnum[]
  }

  /**
   * Org.activities
   */
  export type Org$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Org.subscriptions
   */
  export type Org$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Org.usageMeters
   */
  export type Org$usageMetersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
    where?: UsageMeterWhereInput
    orderBy?: UsageMeterOrderByWithRelationInput | UsageMeterOrderByWithRelationInput[]
    cursor?: UsageMeterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageMeterScalarFieldEnum | UsageMeterScalarFieldEnum[]
  }

  /**
   * Org.addonPurchases
   */
  export type Org$addonPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
    where?: AddonPurchaseWhereInput
    orderBy?: AddonPurchaseOrderByWithRelationInput | AddonPurchaseOrderByWithRelationInput[]
    cursor?: AddonPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddonPurchaseScalarFieldEnum | AddonPurchaseScalarFieldEnum[]
  }

  /**
   * Org.tenantOverrides
   */
  export type Org$tenantOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    where?: TenantPriceOverrideWhereInput
    orderBy?: TenantPriceOverrideOrderByWithRelationInput | TenantPriceOverrideOrderByWithRelationInput[]
    cursor?: TenantPriceOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantPriceOverrideScalarFieldEnum | TenantPriceOverrideScalarFieldEnum[]
  }

  /**
   * Org.incidents
   */
  export type Org$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Org.notifications
   */
  export type Org$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Org.importJobs
   */
  export type Org$importJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    where?: ImportJobWhereInput
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    cursor?: ImportJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * Org.importMappings
   */
  export type Org$importMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    where?: ImportMappingWhereInput
    orderBy?: ImportMappingOrderByWithRelationInput | ImportMappingOrderByWithRelationInput[]
    cursor?: ImportMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportMappingScalarFieldEnum | ImportMappingScalarFieldEnum[]
  }

  /**
   * Org without action
   */
  export type OrgDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    passwordHash: string | null
    mustChangePassword: boolean | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    isLocked: boolean | null
    lockedUntil: Date | null
    failedLoginAttempts: number | null
    lastFailedLogin: Date | null
    lastSuccessfulLogin: Date | null
    lastPasswordChange: Date | null
    totpSecret: string | null
    totpEnabled: boolean | null
    backupCodesHash: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    passwordHash: string | null
    mustChangePassword: boolean | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    isLocked: boolean | null
    lockedUntil: Date | null
    failedLoginAttempts: number | null
    lastFailedLogin: Date | null
    lastSuccessfulLogin: Date | null
    lastPasswordChange: Date | null
    totpSecret: string | null
    totpEnabled: boolean | null
    backupCodesHash: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    orgId: number
    email: number
    name: number
    role: number
    passwordHash: number
    mustChangePassword: number
    status: number
    createdAt: number
    updatedAt: number
    isActive: number
    isLocked: number
    lockedUntil: number
    failedLoginAttempts: number
    lastFailedLogin: number
    lastSuccessfulLogin: number
    lastPasswordChange: number
    totpSecret: number
    totpEnabled: number
    backupCodesHash: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    orgId?: true
    email?: true
    name?: true
    role?: true
    passwordHash?: true
    mustChangePassword?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    isLocked?: true
    lockedUntil?: true
    failedLoginAttempts?: true
    lastFailedLogin?: true
    lastSuccessfulLogin?: true
    lastPasswordChange?: true
    totpSecret?: true
    totpEnabled?: true
    backupCodesHash?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    orgId?: true
    email?: true
    name?: true
    role?: true
    passwordHash?: true
    mustChangePassword?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    isLocked?: true
    lockedUntil?: true
    failedLoginAttempts?: true
    lastFailedLogin?: true
    lastSuccessfulLogin?: true
    lastPasswordChange?: true
    totpSecret?: true
    totpEnabled?: true
    backupCodesHash?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    orgId?: true
    email?: true
    name?: true
    role?: true
    passwordHash?: true
    mustChangePassword?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    isLocked?: true
    lockedUntil?: true
    failedLoginAttempts?: true
    lastFailedLogin?: true
    lastSuccessfulLogin?: true
    lastPasswordChange?: true
    totpSecret?: true
    totpEnabled?: true
    backupCodesHash?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    orgId: string
    email: string
    name: string | null
    role: $Enums.Role
    passwordHash: string | null
    mustChangePassword: boolean
    status: string
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    isLocked: boolean
    lockedUntil: Date | null
    failedLoginAttempts: number
    lastFailedLogin: Date | null
    lastSuccessfulLogin: Date | null
    lastPasswordChange: Date | null
    totpSecret: string | null
    totpEnabled: boolean
    backupCodesHash: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    mustChangePassword?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: boolean
    failedLoginAttempts?: boolean
    lastFailedLogin?: boolean
    lastSuccessfulLogin?: boolean
    lastPasswordChange?: boolean
    totpSecret?: boolean
    totpEnabled?: boolean
    backupCodesHash?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
    rbacUserRoles?: boolean | User$rbacUserRolesArgs<ExtArgs>
    recoveryCodes?: boolean | User$recoveryCodesArgs<ExtArgs>
    breakglassAccount?: boolean | User$breakglassAccountArgs<ExtArgs>
    securityQuestions?: boolean | User$securityQuestionsArgs<ExtArgs>
    loginHistory?: boolean | User$loginHistoryArgs<ExtArgs>
    deviceFingerprints?: boolean | User$deviceFingerprintsArgs<ExtArgs>
    importJobs?: boolean | User$importJobsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    mustChangePassword?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: boolean
    failedLoginAttempts?: boolean
    lastFailedLogin?: boolean
    lastSuccessfulLogin?: boolean
    lastPasswordChange?: boolean
    totpSecret?: boolean
    totpEnabled?: boolean
    backupCodesHash?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    mustChangePassword?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: boolean
    failedLoginAttempts?: boolean
    lastFailedLogin?: boolean
    lastSuccessfulLogin?: boolean
    lastPasswordChange?: boolean
    totpSecret?: boolean
    totpEnabled?: boolean
    backupCodesHash?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    orgId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    mustChangePassword?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: boolean
    failedLoginAttempts?: boolean
    lastFailedLogin?: boolean
    lastSuccessfulLogin?: boolean
    lastPasswordChange?: boolean
    totpSecret?: boolean
    totpEnabled?: boolean
    backupCodesHash?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "email" | "name" | "role" | "passwordHash" | "mustChangePassword" | "status" | "createdAt" | "updatedAt" | "isActive" | "isLocked" | "lockedUntil" | "failedLoginAttempts" | "lastFailedLogin" | "lastSuccessfulLogin" | "lastPasswordChange" | "totpSecret" | "totpEnabled" | "backupCodesHash", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
    rbacUserRoles?: boolean | User$rbacUserRolesArgs<ExtArgs>
    recoveryCodes?: boolean | User$recoveryCodesArgs<ExtArgs>
    breakglassAccount?: boolean | User$breakglassAccountArgs<ExtArgs>
    securityQuestions?: boolean | User$securityQuestionsArgs<ExtArgs>
    loginHistory?: boolean | User$loginHistoryArgs<ExtArgs>
    deviceFingerprints?: boolean | User$deviceFingerprintsArgs<ExtArgs>
    importJobs?: boolean | User$importJobsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
      rbacUserRoles: Prisma.$RbacUserRolePayload<ExtArgs>[]
      recoveryCodes: Prisma.$UserRecoveryCodePayload<ExtArgs>[]
      breakglassAccount: Prisma.$UserBreakglassAccountPayload<ExtArgs> | null
      securityQuestions: Prisma.$UserSecurityQuestionPayload<ExtArgs>[]
      loginHistory: Prisma.$UserLoginHistoryPayload<ExtArgs>[]
      deviceFingerprints: Prisma.$UserDeviceFingerprintPayload<ExtArgs>[]
      importJobs: Prisma.$ImportJobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      email: string
      name: string | null
      role: $Enums.Role
      passwordHash: string | null
      mustChangePassword: boolean
      status: string
      createdAt: Date
      updatedAt: Date
      isActive: boolean
      isLocked: boolean
      lockedUntil: Date | null
      failedLoginAttempts: number
      lastFailedLogin: Date | null
      lastSuccessfulLogin: Date | null
      lastPasswordChange: Date | null
      totpSecret: string | null
      totpEnabled: boolean
      backupCodesHash: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rbacUserRoles<T extends User$rbacUserRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rbacUserRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recoveryCodes<T extends User$recoveryCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$recoveryCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    breakglassAccount<T extends User$breakglassAccountArgs<ExtArgs> = {}>(args?: Subset<T, User$breakglassAccountArgs<ExtArgs>>): Prisma__UserBreakglassAccountClient<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    securityQuestions<T extends User$securityQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, User$securityQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loginHistory<T extends User$loginHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$loginHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deviceFingerprints<T extends User$deviceFingerprintsArgs<ExtArgs> = {}>(args?: Subset<T, User$deviceFingerprintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    importJobs<T extends User$importJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$importJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly orgId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly mustChangePassword: FieldRef<"User", 'Boolean'>
    readonly status: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isLocked: FieldRef<"User", 'Boolean'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly failedLoginAttempts: FieldRef<"User", 'Int'>
    readonly lastFailedLogin: FieldRef<"User", 'DateTime'>
    readonly lastSuccessfulLogin: FieldRef<"User", 'DateTime'>
    readonly lastPasswordChange: FieldRef<"User", 'DateTime'>
    readonly totpSecret: FieldRef<"User", 'String'>
    readonly totpEnabled: FieldRef<"User", 'Boolean'>
    readonly backupCodesHash: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.rbacUserRoles
   */
  export type User$rbacUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    where?: RbacUserRoleWhereInput
    orderBy?: RbacUserRoleOrderByWithRelationInput | RbacUserRoleOrderByWithRelationInput[]
    cursor?: RbacUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RbacUserRoleScalarFieldEnum | RbacUserRoleScalarFieldEnum[]
  }

  /**
   * User.recoveryCodes
   */
  export type User$recoveryCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
    where?: UserRecoveryCodeWhereInput
    orderBy?: UserRecoveryCodeOrderByWithRelationInput | UserRecoveryCodeOrderByWithRelationInput[]
    cursor?: UserRecoveryCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRecoveryCodeScalarFieldEnum | UserRecoveryCodeScalarFieldEnum[]
  }

  /**
   * User.breakglassAccount
   */
  export type User$breakglassAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
    where?: UserBreakglassAccountWhereInput
  }

  /**
   * User.securityQuestions
   */
  export type User$securityQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
    where?: UserSecurityQuestionWhereInput
    orderBy?: UserSecurityQuestionOrderByWithRelationInput | UserSecurityQuestionOrderByWithRelationInput[]
    cursor?: UserSecurityQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSecurityQuestionScalarFieldEnum | UserSecurityQuestionScalarFieldEnum[]
  }

  /**
   * User.loginHistory
   */
  export type User$loginHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
    where?: UserLoginHistoryWhereInput
    orderBy?: UserLoginHistoryOrderByWithRelationInput | UserLoginHistoryOrderByWithRelationInput[]
    cursor?: UserLoginHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLoginHistoryScalarFieldEnum | UserLoginHistoryScalarFieldEnum[]
  }

  /**
   * User.deviceFingerprints
   */
  export type User$deviceFingerprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
    where?: UserDeviceFingerprintWhereInput
    orderBy?: UserDeviceFingerprintOrderByWithRelationInput | UserDeviceFingerprintOrderByWithRelationInput[]
    cursor?: UserDeviceFingerprintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDeviceFingerprintScalarFieldEnum | UserDeviceFingerprintScalarFieldEnum[]
  }

  /**
   * User.importJobs
   */
  export type User$importJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    where?: ImportJobWhereInput
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    cursor?: ImportJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserRecoveryCode
   */

  export type AggregateUserRecoveryCode = {
    _count: UserRecoveryCodeCountAggregateOutputType | null
    _min: UserRecoveryCodeMinAggregateOutputType | null
    _max: UserRecoveryCodeMaxAggregateOutputType | null
  }

  export type UserRecoveryCodeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    codeHash: string | null
    usedAt: Date | null
    usedFrom: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type UserRecoveryCodeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    codeHash: string | null
    usedAt: Date | null
    usedFrom: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type UserRecoveryCodeCountAggregateOutputType = {
    id: number
    userId: number
    codeHash: number
    usedAt: number
    usedFrom: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type UserRecoveryCodeMinAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    usedAt?: true
    usedFrom?: true
    createdAt?: true
    expiresAt?: true
  }

  export type UserRecoveryCodeMaxAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    usedAt?: true
    usedFrom?: true
    createdAt?: true
    expiresAt?: true
  }

  export type UserRecoveryCodeCountAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    usedAt?: true
    usedFrom?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type UserRecoveryCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRecoveryCode to aggregate.
     */
    where?: UserRecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecoveryCodes to fetch.
     */
    orderBy?: UserRecoveryCodeOrderByWithRelationInput | UserRecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecoveryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRecoveryCodes
    **/
    _count?: true | UserRecoveryCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRecoveryCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRecoveryCodeMaxAggregateInputType
  }

  export type GetUserRecoveryCodeAggregateType<T extends UserRecoveryCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRecoveryCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRecoveryCode[P]>
      : GetScalarType<T[P], AggregateUserRecoveryCode[P]>
  }




  export type UserRecoveryCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRecoveryCodeWhereInput
    orderBy?: UserRecoveryCodeOrderByWithAggregationInput | UserRecoveryCodeOrderByWithAggregationInput[]
    by: UserRecoveryCodeScalarFieldEnum[] | UserRecoveryCodeScalarFieldEnum
    having?: UserRecoveryCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRecoveryCodeCountAggregateInputType | true
    _min?: UserRecoveryCodeMinAggregateInputType
    _max?: UserRecoveryCodeMaxAggregateInputType
  }

  export type UserRecoveryCodeGroupByOutputType = {
    id: string
    userId: string
    codeHash: string
    usedAt: Date | null
    usedFrom: string | null
    createdAt: Date
    expiresAt: Date
    _count: UserRecoveryCodeCountAggregateOutputType | null
    _min: UserRecoveryCodeMinAggregateOutputType | null
    _max: UserRecoveryCodeMaxAggregateOutputType | null
  }

  type GetUserRecoveryCodeGroupByPayload<T extends UserRecoveryCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRecoveryCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRecoveryCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRecoveryCodeGroupByOutputType[P]>
            : GetScalarType<T[P], UserRecoveryCodeGroupByOutputType[P]>
        }
      >
    >


  export type UserRecoveryCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    usedAt?: boolean
    usedFrom?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRecoveryCode"]>

  export type UserRecoveryCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    usedAt?: boolean
    usedFrom?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRecoveryCode"]>

  export type UserRecoveryCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    usedAt?: boolean
    usedFrom?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRecoveryCode"]>

  export type UserRecoveryCodeSelectScalar = {
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    usedAt?: boolean
    usedFrom?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type UserRecoveryCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "codeHash" | "usedAt" | "usedFrom" | "createdAt" | "expiresAt", ExtArgs["result"]["userRecoveryCode"]>
  export type UserRecoveryCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRecoveryCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRecoveryCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRecoveryCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRecoveryCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      codeHash: string
      usedAt: Date | null
      usedFrom: string | null
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["userRecoveryCode"]>
    composites: {}
  }

  type UserRecoveryCodeGetPayload<S extends boolean | null | undefined | UserRecoveryCodeDefaultArgs> = $Result.GetResult<Prisma.$UserRecoveryCodePayload, S>

  type UserRecoveryCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRecoveryCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRecoveryCodeCountAggregateInputType | true
    }

  export interface UserRecoveryCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRecoveryCode'], meta: { name: 'UserRecoveryCode' } }
    /**
     * Find zero or one UserRecoveryCode that matches the filter.
     * @param {UserRecoveryCodeFindUniqueArgs} args - Arguments to find a UserRecoveryCode
     * @example
     * // Get one UserRecoveryCode
     * const userRecoveryCode = await prisma.userRecoveryCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRecoveryCodeFindUniqueArgs>(args: SelectSubset<T, UserRecoveryCodeFindUniqueArgs<ExtArgs>>): Prisma__UserRecoveryCodeClient<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRecoveryCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRecoveryCodeFindUniqueOrThrowArgs} args - Arguments to find a UserRecoveryCode
     * @example
     * // Get one UserRecoveryCode
     * const userRecoveryCode = await prisma.userRecoveryCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRecoveryCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRecoveryCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRecoveryCodeClient<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRecoveryCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecoveryCodeFindFirstArgs} args - Arguments to find a UserRecoveryCode
     * @example
     * // Get one UserRecoveryCode
     * const userRecoveryCode = await prisma.userRecoveryCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRecoveryCodeFindFirstArgs>(args?: SelectSubset<T, UserRecoveryCodeFindFirstArgs<ExtArgs>>): Prisma__UserRecoveryCodeClient<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRecoveryCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecoveryCodeFindFirstOrThrowArgs} args - Arguments to find a UserRecoveryCode
     * @example
     * // Get one UserRecoveryCode
     * const userRecoveryCode = await prisma.userRecoveryCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRecoveryCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRecoveryCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRecoveryCodeClient<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRecoveryCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecoveryCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRecoveryCodes
     * const userRecoveryCodes = await prisma.userRecoveryCode.findMany()
     * 
     * // Get first 10 UserRecoveryCodes
     * const userRecoveryCodes = await prisma.userRecoveryCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRecoveryCodeWithIdOnly = await prisma.userRecoveryCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRecoveryCodeFindManyArgs>(args?: SelectSubset<T, UserRecoveryCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRecoveryCode.
     * @param {UserRecoveryCodeCreateArgs} args - Arguments to create a UserRecoveryCode.
     * @example
     * // Create one UserRecoveryCode
     * const UserRecoveryCode = await prisma.userRecoveryCode.create({
     *   data: {
     *     // ... data to create a UserRecoveryCode
     *   }
     * })
     * 
     */
    create<T extends UserRecoveryCodeCreateArgs>(args: SelectSubset<T, UserRecoveryCodeCreateArgs<ExtArgs>>): Prisma__UserRecoveryCodeClient<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRecoveryCodes.
     * @param {UserRecoveryCodeCreateManyArgs} args - Arguments to create many UserRecoveryCodes.
     * @example
     * // Create many UserRecoveryCodes
     * const userRecoveryCode = await prisma.userRecoveryCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRecoveryCodeCreateManyArgs>(args?: SelectSubset<T, UserRecoveryCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRecoveryCodes and returns the data saved in the database.
     * @param {UserRecoveryCodeCreateManyAndReturnArgs} args - Arguments to create many UserRecoveryCodes.
     * @example
     * // Create many UserRecoveryCodes
     * const userRecoveryCode = await prisma.userRecoveryCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRecoveryCodes and only return the `id`
     * const userRecoveryCodeWithIdOnly = await prisma.userRecoveryCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRecoveryCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRecoveryCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRecoveryCode.
     * @param {UserRecoveryCodeDeleteArgs} args - Arguments to delete one UserRecoveryCode.
     * @example
     * // Delete one UserRecoveryCode
     * const UserRecoveryCode = await prisma.userRecoveryCode.delete({
     *   where: {
     *     // ... filter to delete one UserRecoveryCode
     *   }
     * })
     * 
     */
    delete<T extends UserRecoveryCodeDeleteArgs>(args: SelectSubset<T, UserRecoveryCodeDeleteArgs<ExtArgs>>): Prisma__UserRecoveryCodeClient<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRecoveryCode.
     * @param {UserRecoveryCodeUpdateArgs} args - Arguments to update one UserRecoveryCode.
     * @example
     * // Update one UserRecoveryCode
     * const userRecoveryCode = await prisma.userRecoveryCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRecoveryCodeUpdateArgs>(args: SelectSubset<T, UserRecoveryCodeUpdateArgs<ExtArgs>>): Prisma__UserRecoveryCodeClient<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRecoveryCodes.
     * @param {UserRecoveryCodeDeleteManyArgs} args - Arguments to filter UserRecoveryCodes to delete.
     * @example
     * // Delete a few UserRecoveryCodes
     * const { count } = await prisma.userRecoveryCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRecoveryCodeDeleteManyArgs>(args?: SelectSubset<T, UserRecoveryCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRecoveryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecoveryCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRecoveryCodes
     * const userRecoveryCode = await prisma.userRecoveryCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRecoveryCodeUpdateManyArgs>(args: SelectSubset<T, UserRecoveryCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRecoveryCodes and returns the data updated in the database.
     * @param {UserRecoveryCodeUpdateManyAndReturnArgs} args - Arguments to update many UserRecoveryCodes.
     * @example
     * // Update many UserRecoveryCodes
     * const userRecoveryCode = await prisma.userRecoveryCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRecoveryCodes and only return the `id`
     * const userRecoveryCodeWithIdOnly = await prisma.userRecoveryCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRecoveryCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRecoveryCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRecoveryCode.
     * @param {UserRecoveryCodeUpsertArgs} args - Arguments to update or create a UserRecoveryCode.
     * @example
     * // Update or create a UserRecoveryCode
     * const userRecoveryCode = await prisma.userRecoveryCode.upsert({
     *   create: {
     *     // ... data to create a UserRecoveryCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRecoveryCode we want to update
     *   }
     * })
     */
    upsert<T extends UserRecoveryCodeUpsertArgs>(args: SelectSubset<T, UserRecoveryCodeUpsertArgs<ExtArgs>>): Prisma__UserRecoveryCodeClient<$Result.GetResult<Prisma.$UserRecoveryCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRecoveryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecoveryCodeCountArgs} args - Arguments to filter UserRecoveryCodes to count.
     * @example
     * // Count the number of UserRecoveryCodes
     * const count = await prisma.userRecoveryCode.count({
     *   where: {
     *     // ... the filter for the UserRecoveryCodes we want to count
     *   }
     * })
    **/
    count<T extends UserRecoveryCodeCountArgs>(
      args?: Subset<T, UserRecoveryCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRecoveryCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRecoveryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecoveryCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRecoveryCodeAggregateArgs>(args: Subset<T, UserRecoveryCodeAggregateArgs>): Prisma.PrismaPromise<GetUserRecoveryCodeAggregateType<T>>

    /**
     * Group by UserRecoveryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecoveryCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRecoveryCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRecoveryCodeGroupByArgs['orderBy'] }
        : { orderBy?: UserRecoveryCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRecoveryCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRecoveryCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRecoveryCode model
   */
  readonly fields: UserRecoveryCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRecoveryCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRecoveryCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRecoveryCode model
   */
  interface UserRecoveryCodeFieldRefs {
    readonly id: FieldRef<"UserRecoveryCode", 'String'>
    readonly userId: FieldRef<"UserRecoveryCode", 'String'>
    readonly codeHash: FieldRef<"UserRecoveryCode", 'String'>
    readonly usedAt: FieldRef<"UserRecoveryCode", 'DateTime'>
    readonly usedFrom: FieldRef<"UserRecoveryCode", 'String'>
    readonly createdAt: FieldRef<"UserRecoveryCode", 'DateTime'>
    readonly expiresAt: FieldRef<"UserRecoveryCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRecoveryCode findUnique
   */
  export type UserRecoveryCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which UserRecoveryCode to fetch.
     */
    where: UserRecoveryCodeWhereUniqueInput
  }

  /**
   * UserRecoveryCode findUniqueOrThrow
   */
  export type UserRecoveryCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which UserRecoveryCode to fetch.
     */
    where: UserRecoveryCodeWhereUniqueInput
  }

  /**
   * UserRecoveryCode findFirst
   */
  export type UserRecoveryCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which UserRecoveryCode to fetch.
     */
    where?: UserRecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecoveryCodes to fetch.
     */
    orderBy?: UserRecoveryCodeOrderByWithRelationInput | UserRecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRecoveryCodes.
     */
    cursor?: UserRecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecoveryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRecoveryCodes.
     */
    distinct?: UserRecoveryCodeScalarFieldEnum | UserRecoveryCodeScalarFieldEnum[]
  }

  /**
   * UserRecoveryCode findFirstOrThrow
   */
  export type UserRecoveryCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which UserRecoveryCode to fetch.
     */
    where?: UserRecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecoveryCodes to fetch.
     */
    orderBy?: UserRecoveryCodeOrderByWithRelationInput | UserRecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRecoveryCodes.
     */
    cursor?: UserRecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecoveryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRecoveryCodes.
     */
    distinct?: UserRecoveryCodeScalarFieldEnum | UserRecoveryCodeScalarFieldEnum[]
  }

  /**
   * UserRecoveryCode findMany
   */
  export type UserRecoveryCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which UserRecoveryCodes to fetch.
     */
    where?: UserRecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecoveryCodes to fetch.
     */
    orderBy?: UserRecoveryCodeOrderByWithRelationInput | UserRecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRecoveryCodes.
     */
    cursor?: UserRecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecoveryCodes.
     */
    skip?: number
    distinct?: UserRecoveryCodeScalarFieldEnum | UserRecoveryCodeScalarFieldEnum[]
  }

  /**
   * UserRecoveryCode create
   */
  export type UserRecoveryCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRecoveryCode.
     */
    data: XOR<UserRecoveryCodeCreateInput, UserRecoveryCodeUncheckedCreateInput>
  }

  /**
   * UserRecoveryCode createMany
   */
  export type UserRecoveryCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRecoveryCodes.
     */
    data: UserRecoveryCodeCreateManyInput | UserRecoveryCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRecoveryCode createManyAndReturn
   */
  export type UserRecoveryCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * The data used to create many UserRecoveryCodes.
     */
    data: UserRecoveryCodeCreateManyInput | UserRecoveryCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRecoveryCode update
   */
  export type UserRecoveryCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRecoveryCode.
     */
    data: XOR<UserRecoveryCodeUpdateInput, UserRecoveryCodeUncheckedUpdateInput>
    /**
     * Choose, which UserRecoveryCode to update.
     */
    where: UserRecoveryCodeWhereUniqueInput
  }

  /**
   * UserRecoveryCode updateMany
   */
  export type UserRecoveryCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRecoveryCodes.
     */
    data: XOR<UserRecoveryCodeUpdateManyMutationInput, UserRecoveryCodeUncheckedUpdateManyInput>
    /**
     * Filter which UserRecoveryCodes to update
     */
    where?: UserRecoveryCodeWhereInput
    /**
     * Limit how many UserRecoveryCodes to update.
     */
    limit?: number
  }

  /**
   * UserRecoveryCode updateManyAndReturn
   */
  export type UserRecoveryCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * The data used to update UserRecoveryCodes.
     */
    data: XOR<UserRecoveryCodeUpdateManyMutationInput, UserRecoveryCodeUncheckedUpdateManyInput>
    /**
     * Filter which UserRecoveryCodes to update
     */
    where?: UserRecoveryCodeWhereInput
    /**
     * Limit how many UserRecoveryCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRecoveryCode upsert
   */
  export type UserRecoveryCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRecoveryCode to update in case it exists.
     */
    where: UserRecoveryCodeWhereUniqueInput
    /**
     * In case the UserRecoveryCode found by the `where` argument doesn't exist, create a new UserRecoveryCode with this data.
     */
    create: XOR<UserRecoveryCodeCreateInput, UserRecoveryCodeUncheckedCreateInput>
    /**
     * In case the UserRecoveryCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRecoveryCodeUpdateInput, UserRecoveryCodeUncheckedUpdateInput>
  }

  /**
   * UserRecoveryCode delete
   */
  export type UserRecoveryCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter which UserRecoveryCode to delete.
     */
    where: UserRecoveryCodeWhereUniqueInput
  }

  /**
   * UserRecoveryCode deleteMany
   */
  export type UserRecoveryCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRecoveryCodes to delete
     */
    where?: UserRecoveryCodeWhereInput
    /**
     * Limit how many UserRecoveryCodes to delete.
     */
    limit?: number
  }

  /**
   * UserRecoveryCode without action
   */
  export type UserRecoveryCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecoveryCode
     */
    select?: UserRecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecoveryCode
     */
    omit?: UserRecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecoveryCodeInclude<ExtArgs> | null
  }


  /**
   * Model UserSecurityQuestion
   */

  export type AggregateUserSecurityQuestion = {
    _count: UserSecurityQuestionCountAggregateOutputType | null
    _min: UserSecurityQuestionMinAggregateOutputType | null
    _max: UserSecurityQuestionMaxAggregateOutputType | null
  }

  export type UserSecurityQuestionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    question: string | null
    answerHash: string | null
    createdAt: Date | null
  }

  export type UserSecurityQuestionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    question: string | null
    answerHash: string | null
    createdAt: Date | null
  }

  export type UserSecurityQuestionCountAggregateOutputType = {
    id: number
    userId: number
    question: number
    answerHash: number
    createdAt: number
    _all: number
  }


  export type UserSecurityQuestionMinAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    answerHash?: true
    createdAt?: true
  }

  export type UserSecurityQuestionMaxAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    answerHash?: true
    createdAt?: true
  }

  export type UserSecurityQuestionCountAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    answerHash?: true
    createdAt?: true
    _all?: true
  }

  export type UserSecurityQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSecurityQuestion to aggregate.
     */
    where?: UserSecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSecurityQuestions to fetch.
     */
    orderBy?: UserSecurityQuestionOrderByWithRelationInput | UserSecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSecurityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSecurityQuestions
    **/
    _count?: true | UserSecurityQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSecurityQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSecurityQuestionMaxAggregateInputType
  }

  export type GetUserSecurityQuestionAggregateType<T extends UserSecurityQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSecurityQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSecurityQuestion[P]>
      : GetScalarType<T[P], AggregateUserSecurityQuestion[P]>
  }




  export type UserSecurityQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSecurityQuestionWhereInput
    orderBy?: UserSecurityQuestionOrderByWithAggregationInput | UserSecurityQuestionOrderByWithAggregationInput[]
    by: UserSecurityQuestionScalarFieldEnum[] | UserSecurityQuestionScalarFieldEnum
    having?: UserSecurityQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSecurityQuestionCountAggregateInputType | true
    _min?: UserSecurityQuestionMinAggregateInputType
    _max?: UserSecurityQuestionMaxAggregateInputType
  }

  export type UserSecurityQuestionGroupByOutputType = {
    id: string
    userId: string
    question: string
    answerHash: string
    createdAt: Date
    _count: UserSecurityQuestionCountAggregateOutputType | null
    _min: UserSecurityQuestionMinAggregateOutputType | null
    _max: UserSecurityQuestionMaxAggregateOutputType | null
  }

  type GetUserSecurityQuestionGroupByPayload<T extends UserSecurityQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSecurityQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSecurityQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSecurityQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSecurityQuestionGroupByOutputType[P]>
        }
      >
    >


  export type UserSecurityQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSecurityQuestion"]>

  export type UserSecurityQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSecurityQuestion"]>

  export type UserSecurityQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSecurityQuestion"]>

  export type UserSecurityQuestionSelectScalar = {
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
  }

  export type UserSecurityQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "question" | "answerHash" | "createdAt", ExtArgs["result"]["userSecurityQuestion"]>
  export type UserSecurityQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSecurityQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSecurityQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSecurityQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSecurityQuestion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      question: string
      answerHash: string
      createdAt: Date
    }, ExtArgs["result"]["userSecurityQuestion"]>
    composites: {}
  }

  type UserSecurityQuestionGetPayload<S extends boolean | null | undefined | UserSecurityQuestionDefaultArgs> = $Result.GetResult<Prisma.$UserSecurityQuestionPayload, S>

  type UserSecurityQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSecurityQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSecurityQuestionCountAggregateInputType | true
    }

  export interface UserSecurityQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSecurityQuestion'], meta: { name: 'UserSecurityQuestion' } }
    /**
     * Find zero or one UserSecurityQuestion that matches the filter.
     * @param {UserSecurityQuestionFindUniqueArgs} args - Arguments to find a UserSecurityQuestion
     * @example
     * // Get one UserSecurityQuestion
     * const userSecurityQuestion = await prisma.userSecurityQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSecurityQuestionFindUniqueArgs>(args: SelectSubset<T, UserSecurityQuestionFindUniqueArgs<ExtArgs>>): Prisma__UserSecurityQuestionClient<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSecurityQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSecurityQuestionFindUniqueOrThrowArgs} args - Arguments to find a UserSecurityQuestion
     * @example
     * // Get one UserSecurityQuestion
     * const userSecurityQuestion = await prisma.userSecurityQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSecurityQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSecurityQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSecurityQuestionClient<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSecurityQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSecurityQuestionFindFirstArgs} args - Arguments to find a UserSecurityQuestion
     * @example
     * // Get one UserSecurityQuestion
     * const userSecurityQuestion = await prisma.userSecurityQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSecurityQuestionFindFirstArgs>(args?: SelectSubset<T, UserSecurityQuestionFindFirstArgs<ExtArgs>>): Prisma__UserSecurityQuestionClient<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSecurityQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSecurityQuestionFindFirstOrThrowArgs} args - Arguments to find a UserSecurityQuestion
     * @example
     * // Get one UserSecurityQuestion
     * const userSecurityQuestion = await prisma.userSecurityQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSecurityQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSecurityQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSecurityQuestionClient<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSecurityQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSecurityQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSecurityQuestions
     * const userSecurityQuestions = await prisma.userSecurityQuestion.findMany()
     * 
     * // Get first 10 UserSecurityQuestions
     * const userSecurityQuestions = await prisma.userSecurityQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSecurityQuestionWithIdOnly = await prisma.userSecurityQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSecurityQuestionFindManyArgs>(args?: SelectSubset<T, UserSecurityQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSecurityQuestion.
     * @param {UserSecurityQuestionCreateArgs} args - Arguments to create a UserSecurityQuestion.
     * @example
     * // Create one UserSecurityQuestion
     * const UserSecurityQuestion = await prisma.userSecurityQuestion.create({
     *   data: {
     *     // ... data to create a UserSecurityQuestion
     *   }
     * })
     * 
     */
    create<T extends UserSecurityQuestionCreateArgs>(args: SelectSubset<T, UserSecurityQuestionCreateArgs<ExtArgs>>): Prisma__UserSecurityQuestionClient<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSecurityQuestions.
     * @param {UserSecurityQuestionCreateManyArgs} args - Arguments to create many UserSecurityQuestions.
     * @example
     * // Create many UserSecurityQuestions
     * const userSecurityQuestion = await prisma.userSecurityQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSecurityQuestionCreateManyArgs>(args?: SelectSubset<T, UserSecurityQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSecurityQuestions and returns the data saved in the database.
     * @param {UserSecurityQuestionCreateManyAndReturnArgs} args - Arguments to create many UserSecurityQuestions.
     * @example
     * // Create many UserSecurityQuestions
     * const userSecurityQuestion = await prisma.userSecurityQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSecurityQuestions and only return the `id`
     * const userSecurityQuestionWithIdOnly = await prisma.userSecurityQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSecurityQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSecurityQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSecurityQuestion.
     * @param {UserSecurityQuestionDeleteArgs} args - Arguments to delete one UserSecurityQuestion.
     * @example
     * // Delete one UserSecurityQuestion
     * const UserSecurityQuestion = await prisma.userSecurityQuestion.delete({
     *   where: {
     *     // ... filter to delete one UserSecurityQuestion
     *   }
     * })
     * 
     */
    delete<T extends UserSecurityQuestionDeleteArgs>(args: SelectSubset<T, UserSecurityQuestionDeleteArgs<ExtArgs>>): Prisma__UserSecurityQuestionClient<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSecurityQuestion.
     * @param {UserSecurityQuestionUpdateArgs} args - Arguments to update one UserSecurityQuestion.
     * @example
     * // Update one UserSecurityQuestion
     * const userSecurityQuestion = await prisma.userSecurityQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSecurityQuestionUpdateArgs>(args: SelectSubset<T, UserSecurityQuestionUpdateArgs<ExtArgs>>): Prisma__UserSecurityQuestionClient<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSecurityQuestions.
     * @param {UserSecurityQuestionDeleteManyArgs} args - Arguments to filter UserSecurityQuestions to delete.
     * @example
     * // Delete a few UserSecurityQuestions
     * const { count } = await prisma.userSecurityQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSecurityQuestionDeleteManyArgs>(args?: SelectSubset<T, UserSecurityQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSecurityQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSecurityQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSecurityQuestions
     * const userSecurityQuestion = await prisma.userSecurityQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSecurityQuestionUpdateManyArgs>(args: SelectSubset<T, UserSecurityQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSecurityQuestions and returns the data updated in the database.
     * @param {UserSecurityQuestionUpdateManyAndReturnArgs} args - Arguments to update many UserSecurityQuestions.
     * @example
     * // Update many UserSecurityQuestions
     * const userSecurityQuestion = await prisma.userSecurityQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSecurityQuestions and only return the `id`
     * const userSecurityQuestionWithIdOnly = await prisma.userSecurityQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSecurityQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSecurityQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSecurityQuestion.
     * @param {UserSecurityQuestionUpsertArgs} args - Arguments to update or create a UserSecurityQuestion.
     * @example
     * // Update or create a UserSecurityQuestion
     * const userSecurityQuestion = await prisma.userSecurityQuestion.upsert({
     *   create: {
     *     // ... data to create a UserSecurityQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSecurityQuestion we want to update
     *   }
     * })
     */
    upsert<T extends UserSecurityQuestionUpsertArgs>(args: SelectSubset<T, UserSecurityQuestionUpsertArgs<ExtArgs>>): Prisma__UserSecurityQuestionClient<$Result.GetResult<Prisma.$UserSecurityQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSecurityQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSecurityQuestionCountArgs} args - Arguments to filter UserSecurityQuestions to count.
     * @example
     * // Count the number of UserSecurityQuestions
     * const count = await prisma.userSecurityQuestion.count({
     *   where: {
     *     // ... the filter for the UserSecurityQuestions we want to count
     *   }
     * })
    **/
    count<T extends UserSecurityQuestionCountArgs>(
      args?: Subset<T, UserSecurityQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSecurityQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSecurityQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSecurityQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSecurityQuestionAggregateArgs>(args: Subset<T, UserSecurityQuestionAggregateArgs>): Prisma.PrismaPromise<GetUserSecurityQuestionAggregateType<T>>

    /**
     * Group by UserSecurityQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSecurityQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSecurityQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSecurityQuestionGroupByArgs['orderBy'] }
        : { orderBy?: UserSecurityQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSecurityQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSecurityQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSecurityQuestion model
   */
  readonly fields: UserSecurityQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSecurityQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSecurityQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSecurityQuestion model
   */
  interface UserSecurityQuestionFieldRefs {
    readonly id: FieldRef<"UserSecurityQuestion", 'String'>
    readonly userId: FieldRef<"UserSecurityQuestion", 'String'>
    readonly question: FieldRef<"UserSecurityQuestion", 'String'>
    readonly answerHash: FieldRef<"UserSecurityQuestion", 'String'>
    readonly createdAt: FieldRef<"UserSecurityQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSecurityQuestion findUnique
   */
  export type UserSecurityQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which UserSecurityQuestion to fetch.
     */
    where: UserSecurityQuestionWhereUniqueInput
  }

  /**
   * UserSecurityQuestion findUniqueOrThrow
   */
  export type UserSecurityQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which UserSecurityQuestion to fetch.
     */
    where: UserSecurityQuestionWhereUniqueInput
  }

  /**
   * UserSecurityQuestion findFirst
   */
  export type UserSecurityQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which UserSecurityQuestion to fetch.
     */
    where?: UserSecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSecurityQuestions to fetch.
     */
    orderBy?: UserSecurityQuestionOrderByWithRelationInput | UserSecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSecurityQuestions.
     */
    cursor?: UserSecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSecurityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSecurityQuestions.
     */
    distinct?: UserSecurityQuestionScalarFieldEnum | UserSecurityQuestionScalarFieldEnum[]
  }

  /**
   * UserSecurityQuestion findFirstOrThrow
   */
  export type UserSecurityQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which UserSecurityQuestion to fetch.
     */
    where?: UserSecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSecurityQuestions to fetch.
     */
    orderBy?: UserSecurityQuestionOrderByWithRelationInput | UserSecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSecurityQuestions.
     */
    cursor?: UserSecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSecurityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSecurityQuestions.
     */
    distinct?: UserSecurityQuestionScalarFieldEnum | UserSecurityQuestionScalarFieldEnum[]
  }

  /**
   * UserSecurityQuestion findMany
   */
  export type UserSecurityQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which UserSecurityQuestions to fetch.
     */
    where?: UserSecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSecurityQuestions to fetch.
     */
    orderBy?: UserSecurityQuestionOrderByWithRelationInput | UserSecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSecurityQuestions.
     */
    cursor?: UserSecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSecurityQuestions.
     */
    skip?: number
    distinct?: UserSecurityQuestionScalarFieldEnum | UserSecurityQuestionScalarFieldEnum[]
  }

  /**
   * UserSecurityQuestion create
   */
  export type UserSecurityQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSecurityQuestion.
     */
    data: XOR<UserSecurityQuestionCreateInput, UserSecurityQuestionUncheckedCreateInput>
  }

  /**
   * UserSecurityQuestion createMany
   */
  export type UserSecurityQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSecurityQuestions.
     */
    data: UserSecurityQuestionCreateManyInput | UserSecurityQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSecurityQuestion createManyAndReturn
   */
  export type UserSecurityQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSecurityQuestions.
     */
    data: UserSecurityQuestionCreateManyInput | UserSecurityQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSecurityQuestion update
   */
  export type UserSecurityQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSecurityQuestion.
     */
    data: XOR<UserSecurityQuestionUpdateInput, UserSecurityQuestionUncheckedUpdateInput>
    /**
     * Choose, which UserSecurityQuestion to update.
     */
    where: UserSecurityQuestionWhereUniqueInput
  }

  /**
   * UserSecurityQuestion updateMany
   */
  export type UserSecurityQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSecurityQuestions.
     */
    data: XOR<UserSecurityQuestionUpdateManyMutationInput, UserSecurityQuestionUncheckedUpdateManyInput>
    /**
     * Filter which UserSecurityQuestions to update
     */
    where?: UserSecurityQuestionWhereInput
    /**
     * Limit how many UserSecurityQuestions to update.
     */
    limit?: number
  }

  /**
   * UserSecurityQuestion updateManyAndReturn
   */
  export type UserSecurityQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * The data used to update UserSecurityQuestions.
     */
    data: XOR<UserSecurityQuestionUpdateManyMutationInput, UserSecurityQuestionUncheckedUpdateManyInput>
    /**
     * Filter which UserSecurityQuestions to update
     */
    where?: UserSecurityQuestionWhereInput
    /**
     * Limit how many UserSecurityQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSecurityQuestion upsert
   */
  export type UserSecurityQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSecurityQuestion to update in case it exists.
     */
    where: UserSecurityQuestionWhereUniqueInput
    /**
     * In case the UserSecurityQuestion found by the `where` argument doesn't exist, create a new UserSecurityQuestion with this data.
     */
    create: XOR<UserSecurityQuestionCreateInput, UserSecurityQuestionUncheckedCreateInput>
    /**
     * In case the UserSecurityQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSecurityQuestionUpdateInput, UserSecurityQuestionUncheckedUpdateInput>
  }

  /**
   * UserSecurityQuestion delete
   */
  export type UserSecurityQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter which UserSecurityQuestion to delete.
     */
    where: UserSecurityQuestionWhereUniqueInput
  }

  /**
   * UserSecurityQuestion deleteMany
   */
  export type UserSecurityQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSecurityQuestions to delete
     */
    where?: UserSecurityQuestionWhereInput
    /**
     * Limit how many UserSecurityQuestions to delete.
     */
    limit?: number
  }

  /**
   * UserSecurityQuestion without action
   */
  export type UserSecurityQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSecurityQuestion
     */
    select?: UserSecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSecurityQuestion
     */
    omit?: UserSecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSecurityQuestionInclude<ExtArgs> | null
  }


  /**
   * Model UserBreakglassAccount
   */

  export type AggregateUserBreakglassAccount = {
    _count: UserBreakglassAccountCountAggregateOutputType | null
    _avg: UserBreakglassAccountAvgAggregateOutputType | null
    _sum: UserBreakglassAccountSumAggregateOutputType | null
    _min: UserBreakglassAccountMinAggregateOutputType | null
    _max: UserBreakglassAccountMaxAggregateOutputType | null
  }

  export type UserBreakglassAccountAvgAggregateOutputType = {
    activationCount: number | null
    minDelayMinutes: number | null
  }

  export type UserBreakglassAccountSumAggregateOutputType = {
    activationCount: number | null
    minDelayMinutes: number | null
  }

  export type UserBreakglassAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    orgId: string | null
    encryptedEmail: string | null
    encryptedPasswordHash: string | null
    encryptionIV: string | null
    createdAt: Date | null
    lastActivatedAt: Date | null
    activationCount: number | null
    isEnabled: boolean | null
    canAutoActivate: boolean | null
    minDelayMinutes: number | null
  }

  export type UserBreakglassAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    orgId: string | null
    encryptedEmail: string | null
    encryptedPasswordHash: string | null
    encryptionIV: string | null
    createdAt: Date | null
    lastActivatedAt: Date | null
    activationCount: number | null
    isEnabled: boolean | null
    canAutoActivate: boolean | null
    minDelayMinutes: number | null
  }

  export type UserBreakglassAccountCountAggregateOutputType = {
    id: number
    userId: number
    orgId: number
    encryptedEmail: number
    encryptedPasswordHash: number
    encryptionIV: number
    createdAt: number
    lastActivatedAt: number
    activationCount: number
    isEnabled: number
    canAutoActivate: number
    minDelayMinutes: number
    _all: number
  }


  export type UserBreakglassAccountAvgAggregateInputType = {
    activationCount?: true
    minDelayMinutes?: true
  }

  export type UserBreakglassAccountSumAggregateInputType = {
    activationCount?: true
    minDelayMinutes?: true
  }

  export type UserBreakglassAccountMinAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    encryptedEmail?: true
    encryptedPasswordHash?: true
    encryptionIV?: true
    createdAt?: true
    lastActivatedAt?: true
    activationCount?: true
    isEnabled?: true
    canAutoActivate?: true
    minDelayMinutes?: true
  }

  export type UserBreakglassAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    encryptedEmail?: true
    encryptedPasswordHash?: true
    encryptionIV?: true
    createdAt?: true
    lastActivatedAt?: true
    activationCount?: true
    isEnabled?: true
    canAutoActivate?: true
    minDelayMinutes?: true
  }

  export type UserBreakglassAccountCountAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    encryptedEmail?: true
    encryptedPasswordHash?: true
    encryptionIV?: true
    createdAt?: true
    lastActivatedAt?: true
    activationCount?: true
    isEnabled?: true
    canAutoActivate?: true
    minDelayMinutes?: true
    _all?: true
  }

  export type UserBreakglassAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBreakglassAccount to aggregate.
     */
    where?: UserBreakglassAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBreakglassAccounts to fetch.
     */
    orderBy?: UserBreakglassAccountOrderByWithRelationInput | UserBreakglassAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBreakglassAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBreakglassAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBreakglassAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBreakglassAccounts
    **/
    _count?: true | UserBreakglassAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBreakglassAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBreakglassAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBreakglassAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBreakglassAccountMaxAggregateInputType
  }

  export type GetUserBreakglassAccountAggregateType<T extends UserBreakglassAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBreakglassAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBreakglassAccount[P]>
      : GetScalarType<T[P], AggregateUserBreakglassAccount[P]>
  }




  export type UserBreakglassAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBreakglassAccountWhereInput
    orderBy?: UserBreakglassAccountOrderByWithAggregationInput | UserBreakglassAccountOrderByWithAggregationInput[]
    by: UserBreakglassAccountScalarFieldEnum[] | UserBreakglassAccountScalarFieldEnum
    having?: UserBreakglassAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBreakglassAccountCountAggregateInputType | true
    _avg?: UserBreakglassAccountAvgAggregateInputType
    _sum?: UserBreakglassAccountSumAggregateInputType
    _min?: UserBreakglassAccountMinAggregateInputType
    _max?: UserBreakglassAccountMaxAggregateInputType
  }

  export type UserBreakglassAccountGroupByOutputType = {
    id: string
    userId: string
    orgId: string
    encryptedEmail: string
    encryptedPasswordHash: string
    encryptionIV: string
    createdAt: Date
    lastActivatedAt: Date | null
    activationCount: number
    isEnabled: boolean
    canAutoActivate: boolean
    minDelayMinutes: number
    _count: UserBreakglassAccountCountAggregateOutputType | null
    _avg: UserBreakglassAccountAvgAggregateOutputType | null
    _sum: UserBreakglassAccountSumAggregateOutputType | null
    _min: UserBreakglassAccountMinAggregateOutputType | null
    _max: UserBreakglassAccountMaxAggregateOutputType | null
  }

  type GetUserBreakglassAccountGroupByPayload<T extends UserBreakglassAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBreakglassAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBreakglassAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBreakglassAccountGroupByOutputType[P]>
            : GetScalarType<T[P], UserBreakglassAccountGroupByOutputType[P]>
        }
      >
    >


  export type UserBreakglassAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    encryptedEmail?: boolean
    encryptedPasswordHash?: boolean
    encryptionIV?: boolean
    createdAt?: boolean
    lastActivatedAt?: boolean
    activationCount?: boolean
    isEnabled?: boolean
    canAutoActivate?: boolean
    minDelayMinutes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBreakglassAccount"]>

  export type UserBreakglassAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    encryptedEmail?: boolean
    encryptedPasswordHash?: boolean
    encryptionIV?: boolean
    createdAt?: boolean
    lastActivatedAt?: boolean
    activationCount?: boolean
    isEnabled?: boolean
    canAutoActivate?: boolean
    minDelayMinutes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBreakglassAccount"]>

  export type UserBreakglassAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    encryptedEmail?: boolean
    encryptedPasswordHash?: boolean
    encryptionIV?: boolean
    createdAt?: boolean
    lastActivatedAt?: boolean
    activationCount?: boolean
    isEnabled?: boolean
    canAutoActivate?: boolean
    minDelayMinutes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBreakglassAccount"]>

  export type UserBreakglassAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    orgId?: boolean
    encryptedEmail?: boolean
    encryptedPasswordHash?: boolean
    encryptionIV?: boolean
    createdAt?: boolean
    lastActivatedAt?: boolean
    activationCount?: boolean
    isEnabled?: boolean
    canAutoActivate?: boolean
    minDelayMinutes?: boolean
  }

  export type UserBreakglassAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "orgId" | "encryptedEmail" | "encryptedPasswordHash" | "encryptionIV" | "createdAt" | "lastActivatedAt" | "activationCount" | "isEnabled" | "canAutoActivate" | "minDelayMinutes", ExtArgs["result"]["userBreakglassAccount"]>
  export type UserBreakglassAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserBreakglassAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserBreakglassAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserBreakglassAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBreakglassAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      orgId: string
      encryptedEmail: string
      encryptedPasswordHash: string
      encryptionIV: string
      createdAt: Date
      lastActivatedAt: Date | null
      activationCount: number
      isEnabled: boolean
      canAutoActivate: boolean
      minDelayMinutes: number
    }, ExtArgs["result"]["userBreakglassAccount"]>
    composites: {}
  }

  type UserBreakglassAccountGetPayload<S extends boolean | null | undefined | UserBreakglassAccountDefaultArgs> = $Result.GetResult<Prisma.$UserBreakglassAccountPayload, S>

  type UserBreakglassAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBreakglassAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBreakglassAccountCountAggregateInputType | true
    }

  export interface UserBreakglassAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBreakglassAccount'], meta: { name: 'UserBreakglassAccount' } }
    /**
     * Find zero or one UserBreakglassAccount that matches the filter.
     * @param {UserBreakglassAccountFindUniqueArgs} args - Arguments to find a UserBreakglassAccount
     * @example
     * // Get one UserBreakglassAccount
     * const userBreakglassAccount = await prisma.userBreakglassAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBreakglassAccountFindUniqueArgs>(args: SelectSubset<T, UserBreakglassAccountFindUniqueArgs<ExtArgs>>): Prisma__UserBreakglassAccountClient<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBreakglassAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBreakglassAccountFindUniqueOrThrowArgs} args - Arguments to find a UserBreakglassAccount
     * @example
     * // Get one UserBreakglassAccount
     * const userBreakglassAccount = await prisma.userBreakglassAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBreakglassAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBreakglassAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBreakglassAccountClient<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBreakglassAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakglassAccountFindFirstArgs} args - Arguments to find a UserBreakglassAccount
     * @example
     * // Get one UserBreakglassAccount
     * const userBreakglassAccount = await prisma.userBreakglassAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBreakglassAccountFindFirstArgs>(args?: SelectSubset<T, UserBreakglassAccountFindFirstArgs<ExtArgs>>): Prisma__UserBreakglassAccountClient<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBreakglassAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakglassAccountFindFirstOrThrowArgs} args - Arguments to find a UserBreakglassAccount
     * @example
     * // Get one UserBreakglassAccount
     * const userBreakglassAccount = await prisma.userBreakglassAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBreakglassAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBreakglassAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBreakglassAccountClient<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBreakglassAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakglassAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBreakglassAccounts
     * const userBreakglassAccounts = await prisma.userBreakglassAccount.findMany()
     * 
     * // Get first 10 UserBreakglassAccounts
     * const userBreakglassAccounts = await prisma.userBreakglassAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBreakglassAccountWithIdOnly = await prisma.userBreakglassAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBreakglassAccountFindManyArgs>(args?: SelectSubset<T, UserBreakglassAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBreakglassAccount.
     * @param {UserBreakglassAccountCreateArgs} args - Arguments to create a UserBreakglassAccount.
     * @example
     * // Create one UserBreakglassAccount
     * const UserBreakglassAccount = await prisma.userBreakglassAccount.create({
     *   data: {
     *     // ... data to create a UserBreakglassAccount
     *   }
     * })
     * 
     */
    create<T extends UserBreakglassAccountCreateArgs>(args: SelectSubset<T, UserBreakglassAccountCreateArgs<ExtArgs>>): Prisma__UserBreakglassAccountClient<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBreakglassAccounts.
     * @param {UserBreakglassAccountCreateManyArgs} args - Arguments to create many UserBreakglassAccounts.
     * @example
     * // Create many UserBreakglassAccounts
     * const userBreakglassAccount = await prisma.userBreakglassAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBreakglassAccountCreateManyArgs>(args?: SelectSubset<T, UserBreakglassAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBreakglassAccounts and returns the data saved in the database.
     * @param {UserBreakglassAccountCreateManyAndReturnArgs} args - Arguments to create many UserBreakglassAccounts.
     * @example
     * // Create many UserBreakglassAccounts
     * const userBreakglassAccount = await prisma.userBreakglassAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBreakglassAccounts and only return the `id`
     * const userBreakglassAccountWithIdOnly = await prisma.userBreakglassAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBreakglassAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBreakglassAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBreakglassAccount.
     * @param {UserBreakglassAccountDeleteArgs} args - Arguments to delete one UserBreakglassAccount.
     * @example
     * // Delete one UserBreakglassAccount
     * const UserBreakglassAccount = await prisma.userBreakglassAccount.delete({
     *   where: {
     *     // ... filter to delete one UserBreakglassAccount
     *   }
     * })
     * 
     */
    delete<T extends UserBreakglassAccountDeleteArgs>(args: SelectSubset<T, UserBreakglassAccountDeleteArgs<ExtArgs>>): Prisma__UserBreakglassAccountClient<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBreakglassAccount.
     * @param {UserBreakglassAccountUpdateArgs} args - Arguments to update one UserBreakglassAccount.
     * @example
     * // Update one UserBreakglassAccount
     * const userBreakglassAccount = await prisma.userBreakglassAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBreakglassAccountUpdateArgs>(args: SelectSubset<T, UserBreakglassAccountUpdateArgs<ExtArgs>>): Prisma__UserBreakglassAccountClient<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBreakglassAccounts.
     * @param {UserBreakglassAccountDeleteManyArgs} args - Arguments to filter UserBreakglassAccounts to delete.
     * @example
     * // Delete a few UserBreakglassAccounts
     * const { count } = await prisma.userBreakglassAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBreakglassAccountDeleteManyArgs>(args?: SelectSubset<T, UserBreakglassAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBreakglassAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakglassAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBreakglassAccounts
     * const userBreakglassAccount = await prisma.userBreakglassAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBreakglassAccountUpdateManyArgs>(args: SelectSubset<T, UserBreakglassAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBreakglassAccounts and returns the data updated in the database.
     * @param {UserBreakglassAccountUpdateManyAndReturnArgs} args - Arguments to update many UserBreakglassAccounts.
     * @example
     * // Update many UserBreakglassAccounts
     * const userBreakglassAccount = await prisma.userBreakglassAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBreakglassAccounts and only return the `id`
     * const userBreakglassAccountWithIdOnly = await prisma.userBreakglassAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBreakglassAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBreakglassAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBreakglassAccount.
     * @param {UserBreakglassAccountUpsertArgs} args - Arguments to update or create a UserBreakglassAccount.
     * @example
     * // Update or create a UserBreakglassAccount
     * const userBreakglassAccount = await prisma.userBreakglassAccount.upsert({
     *   create: {
     *     // ... data to create a UserBreakglassAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBreakglassAccount we want to update
     *   }
     * })
     */
    upsert<T extends UserBreakglassAccountUpsertArgs>(args: SelectSubset<T, UserBreakglassAccountUpsertArgs<ExtArgs>>): Prisma__UserBreakglassAccountClient<$Result.GetResult<Prisma.$UserBreakglassAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBreakglassAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakglassAccountCountArgs} args - Arguments to filter UserBreakglassAccounts to count.
     * @example
     * // Count the number of UserBreakglassAccounts
     * const count = await prisma.userBreakglassAccount.count({
     *   where: {
     *     // ... the filter for the UserBreakglassAccounts we want to count
     *   }
     * })
    **/
    count<T extends UserBreakglassAccountCountArgs>(
      args?: Subset<T, UserBreakglassAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBreakglassAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBreakglassAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakglassAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBreakglassAccountAggregateArgs>(args: Subset<T, UserBreakglassAccountAggregateArgs>): Prisma.PrismaPromise<GetUserBreakglassAccountAggregateType<T>>

    /**
     * Group by UserBreakglassAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakglassAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBreakglassAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBreakglassAccountGroupByArgs['orderBy'] }
        : { orderBy?: UserBreakglassAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBreakglassAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBreakglassAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBreakglassAccount model
   */
  readonly fields: UserBreakglassAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBreakglassAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBreakglassAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBreakglassAccount model
   */
  interface UserBreakglassAccountFieldRefs {
    readonly id: FieldRef<"UserBreakglassAccount", 'String'>
    readonly userId: FieldRef<"UserBreakglassAccount", 'String'>
    readonly orgId: FieldRef<"UserBreakglassAccount", 'String'>
    readonly encryptedEmail: FieldRef<"UserBreakglassAccount", 'String'>
    readonly encryptedPasswordHash: FieldRef<"UserBreakglassAccount", 'String'>
    readonly encryptionIV: FieldRef<"UserBreakglassAccount", 'String'>
    readonly createdAt: FieldRef<"UserBreakglassAccount", 'DateTime'>
    readonly lastActivatedAt: FieldRef<"UserBreakglassAccount", 'DateTime'>
    readonly activationCount: FieldRef<"UserBreakglassAccount", 'Int'>
    readonly isEnabled: FieldRef<"UserBreakglassAccount", 'Boolean'>
    readonly canAutoActivate: FieldRef<"UserBreakglassAccount", 'Boolean'>
    readonly minDelayMinutes: FieldRef<"UserBreakglassAccount", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserBreakglassAccount findUnique
   */
  export type UserBreakglassAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserBreakglassAccount to fetch.
     */
    where: UserBreakglassAccountWhereUniqueInput
  }

  /**
   * UserBreakglassAccount findUniqueOrThrow
   */
  export type UserBreakglassAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserBreakglassAccount to fetch.
     */
    where: UserBreakglassAccountWhereUniqueInput
  }

  /**
   * UserBreakglassAccount findFirst
   */
  export type UserBreakglassAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserBreakglassAccount to fetch.
     */
    where?: UserBreakglassAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBreakglassAccounts to fetch.
     */
    orderBy?: UserBreakglassAccountOrderByWithRelationInput | UserBreakglassAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBreakglassAccounts.
     */
    cursor?: UserBreakglassAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBreakglassAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBreakglassAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBreakglassAccounts.
     */
    distinct?: UserBreakglassAccountScalarFieldEnum | UserBreakglassAccountScalarFieldEnum[]
  }

  /**
   * UserBreakglassAccount findFirstOrThrow
   */
  export type UserBreakglassAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserBreakglassAccount to fetch.
     */
    where?: UserBreakglassAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBreakglassAccounts to fetch.
     */
    orderBy?: UserBreakglassAccountOrderByWithRelationInput | UserBreakglassAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBreakglassAccounts.
     */
    cursor?: UserBreakglassAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBreakglassAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBreakglassAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBreakglassAccounts.
     */
    distinct?: UserBreakglassAccountScalarFieldEnum | UserBreakglassAccountScalarFieldEnum[]
  }

  /**
   * UserBreakglassAccount findMany
   */
  export type UserBreakglassAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserBreakglassAccounts to fetch.
     */
    where?: UserBreakglassAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBreakglassAccounts to fetch.
     */
    orderBy?: UserBreakglassAccountOrderByWithRelationInput | UserBreakglassAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBreakglassAccounts.
     */
    cursor?: UserBreakglassAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBreakglassAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBreakglassAccounts.
     */
    skip?: number
    distinct?: UserBreakglassAccountScalarFieldEnum | UserBreakglassAccountScalarFieldEnum[]
  }

  /**
   * UserBreakglassAccount create
   */
  export type UserBreakglassAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBreakglassAccount.
     */
    data: XOR<UserBreakglassAccountCreateInput, UserBreakglassAccountUncheckedCreateInput>
  }

  /**
   * UserBreakglassAccount createMany
   */
  export type UserBreakglassAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBreakglassAccounts.
     */
    data: UserBreakglassAccountCreateManyInput | UserBreakglassAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBreakglassAccount createManyAndReturn
   */
  export type UserBreakglassAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * The data used to create many UserBreakglassAccounts.
     */
    data: UserBreakglassAccountCreateManyInput | UserBreakglassAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBreakglassAccount update
   */
  export type UserBreakglassAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBreakglassAccount.
     */
    data: XOR<UserBreakglassAccountUpdateInput, UserBreakglassAccountUncheckedUpdateInput>
    /**
     * Choose, which UserBreakglassAccount to update.
     */
    where: UserBreakglassAccountWhereUniqueInput
  }

  /**
   * UserBreakglassAccount updateMany
   */
  export type UserBreakglassAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBreakglassAccounts.
     */
    data: XOR<UserBreakglassAccountUpdateManyMutationInput, UserBreakglassAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserBreakglassAccounts to update
     */
    where?: UserBreakglassAccountWhereInput
    /**
     * Limit how many UserBreakglassAccounts to update.
     */
    limit?: number
  }

  /**
   * UserBreakglassAccount updateManyAndReturn
   */
  export type UserBreakglassAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * The data used to update UserBreakglassAccounts.
     */
    data: XOR<UserBreakglassAccountUpdateManyMutationInput, UserBreakglassAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserBreakglassAccounts to update
     */
    where?: UserBreakglassAccountWhereInput
    /**
     * Limit how many UserBreakglassAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBreakglassAccount upsert
   */
  export type UserBreakglassAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBreakglassAccount to update in case it exists.
     */
    where: UserBreakglassAccountWhereUniqueInput
    /**
     * In case the UserBreakglassAccount found by the `where` argument doesn't exist, create a new UserBreakglassAccount with this data.
     */
    create: XOR<UserBreakglassAccountCreateInput, UserBreakglassAccountUncheckedCreateInput>
    /**
     * In case the UserBreakglassAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBreakglassAccountUpdateInput, UserBreakglassAccountUncheckedUpdateInput>
  }

  /**
   * UserBreakglassAccount delete
   */
  export type UserBreakglassAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
    /**
     * Filter which UserBreakglassAccount to delete.
     */
    where: UserBreakglassAccountWhereUniqueInput
  }

  /**
   * UserBreakglassAccount deleteMany
   */
  export type UserBreakglassAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBreakglassAccounts to delete
     */
    where?: UserBreakglassAccountWhereInput
    /**
     * Limit how many UserBreakglassAccounts to delete.
     */
    limit?: number
  }

  /**
   * UserBreakglassAccount without action
   */
  export type UserBreakglassAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakglassAccount
     */
    select?: UserBreakglassAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreakglassAccount
     */
    omit?: UserBreakglassAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakglassAccountInclude<ExtArgs> | null
  }


  /**
   * Model UserDeviceFingerprint
   */

  export type AggregateUserDeviceFingerprint = {
    _count: UserDeviceFingerprintCountAggregateOutputType | null
    _avg: UserDeviceFingerprintAvgAggregateOutputType | null
    _sum: UserDeviceFingerprintSumAggregateOutputType | null
    _min: UserDeviceFingerprintMinAggregateOutputType | null
    _max: UserDeviceFingerprintMaxAggregateOutputType | null
  }

  export type UserDeviceFingerprintAvgAggregateOutputType = {
    trustScore: number | null
    loginCount: number | null
  }

  export type UserDeviceFingerprintSumAggregateOutputType = {
    trustScore: number | null
    loginCount: number | null
  }

  export type UserDeviceFingerprintMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fingerprint: string | null
    ipAddress: string | null
    userAgent: string | null
    isTrusted: boolean | null
    trustScore: number | null
    firstSeenAt: Date | null
    lastSeenAt: Date | null
    loginCount: number | null
  }

  export type UserDeviceFingerprintMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fingerprint: string | null
    ipAddress: string | null
    userAgent: string | null
    isTrusted: boolean | null
    trustScore: number | null
    firstSeenAt: Date | null
    lastSeenAt: Date | null
    loginCount: number | null
  }

  export type UserDeviceFingerprintCountAggregateOutputType = {
    id: number
    userId: number
    fingerprint: number
    ipAddress: number
    userAgent: number
    isTrusted: number
    trustScore: number
    firstSeenAt: number
    lastSeenAt: number
    loginCount: number
    _all: number
  }


  export type UserDeviceFingerprintAvgAggregateInputType = {
    trustScore?: true
    loginCount?: true
  }

  export type UserDeviceFingerprintSumAggregateInputType = {
    trustScore?: true
    loginCount?: true
  }

  export type UserDeviceFingerprintMinAggregateInputType = {
    id?: true
    userId?: true
    fingerprint?: true
    ipAddress?: true
    userAgent?: true
    isTrusted?: true
    trustScore?: true
    firstSeenAt?: true
    lastSeenAt?: true
    loginCount?: true
  }

  export type UserDeviceFingerprintMaxAggregateInputType = {
    id?: true
    userId?: true
    fingerprint?: true
    ipAddress?: true
    userAgent?: true
    isTrusted?: true
    trustScore?: true
    firstSeenAt?: true
    lastSeenAt?: true
    loginCount?: true
  }

  export type UserDeviceFingerprintCountAggregateInputType = {
    id?: true
    userId?: true
    fingerprint?: true
    ipAddress?: true
    userAgent?: true
    isTrusted?: true
    trustScore?: true
    firstSeenAt?: true
    lastSeenAt?: true
    loginCount?: true
    _all?: true
  }

  export type UserDeviceFingerprintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDeviceFingerprint to aggregate.
     */
    where?: UserDeviceFingerprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceFingerprints to fetch.
     */
    orderBy?: UserDeviceFingerprintOrderByWithRelationInput | UserDeviceFingerprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDeviceFingerprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceFingerprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceFingerprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDeviceFingerprints
    **/
    _count?: true | UserDeviceFingerprintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserDeviceFingerprintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserDeviceFingerprintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDeviceFingerprintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDeviceFingerprintMaxAggregateInputType
  }

  export type GetUserDeviceFingerprintAggregateType<T extends UserDeviceFingerprintAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDeviceFingerprint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDeviceFingerprint[P]>
      : GetScalarType<T[P], AggregateUserDeviceFingerprint[P]>
  }




  export type UserDeviceFingerprintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDeviceFingerprintWhereInput
    orderBy?: UserDeviceFingerprintOrderByWithAggregationInput | UserDeviceFingerprintOrderByWithAggregationInput[]
    by: UserDeviceFingerprintScalarFieldEnum[] | UserDeviceFingerprintScalarFieldEnum
    having?: UserDeviceFingerprintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDeviceFingerprintCountAggregateInputType | true
    _avg?: UserDeviceFingerprintAvgAggregateInputType
    _sum?: UserDeviceFingerprintSumAggregateInputType
    _min?: UserDeviceFingerprintMinAggregateInputType
    _max?: UserDeviceFingerprintMaxAggregateInputType
  }

  export type UserDeviceFingerprintGroupByOutputType = {
    id: string
    userId: string
    fingerprint: string
    ipAddress: string
    userAgent: string
    isTrusted: boolean
    trustScore: number
    firstSeenAt: Date
    lastSeenAt: Date
    loginCount: number
    _count: UserDeviceFingerprintCountAggregateOutputType | null
    _avg: UserDeviceFingerprintAvgAggregateOutputType | null
    _sum: UserDeviceFingerprintSumAggregateOutputType | null
    _min: UserDeviceFingerprintMinAggregateOutputType | null
    _max: UserDeviceFingerprintMaxAggregateOutputType | null
  }

  type GetUserDeviceFingerprintGroupByPayload<T extends UserDeviceFingerprintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDeviceFingerprintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDeviceFingerprintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDeviceFingerprintGroupByOutputType[P]>
            : GetScalarType<T[P], UserDeviceFingerprintGroupByOutputType[P]>
        }
      >
    >


  export type UserDeviceFingerprintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fingerprint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isTrusted?: boolean
    trustScore?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    loginCount?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDeviceFingerprint"]>

  export type UserDeviceFingerprintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fingerprint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isTrusted?: boolean
    trustScore?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    loginCount?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDeviceFingerprint"]>

  export type UserDeviceFingerprintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fingerprint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isTrusted?: boolean
    trustScore?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    loginCount?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDeviceFingerprint"]>

  export type UserDeviceFingerprintSelectScalar = {
    id?: boolean
    userId?: boolean
    fingerprint?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isTrusted?: boolean
    trustScore?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    loginCount?: boolean
  }

  export type UserDeviceFingerprintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fingerprint" | "ipAddress" | "userAgent" | "isTrusted" | "trustScore" | "firstSeenAt" | "lastSeenAt" | "loginCount", ExtArgs["result"]["userDeviceFingerprint"]>
  export type UserDeviceFingerprintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDeviceFingerprintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDeviceFingerprintIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserDeviceFingerprintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserDeviceFingerprint"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fingerprint: string
      ipAddress: string
      userAgent: string
      isTrusted: boolean
      trustScore: number
      firstSeenAt: Date
      lastSeenAt: Date
      loginCount: number
    }, ExtArgs["result"]["userDeviceFingerprint"]>
    composites: {}
  }

  type UserDeviceFingerprintGetPayload<S extends boolean | null | undefined | UserDeviceFingerprintDefaultArgs> = $Result.GetResult<Prisma.$UserDeviceFingerprintPayload, S>

  type UserDeviceFingerprintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserDeviceFingerprintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserDeviceFingerprintCountAggregateInputType | true
    }

  export interface UserDeviceFingerprintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDeviceFingerprint'], meta: { name: 'UserDeviceFingerprint' } }
    /**
     * Find zero or one UserDeviceFingerprint that matches the filter.
     * @param {UserDeviceFingerprintFindUniqueArgs} args - Arguments to find a UserDeviceFingerprint
     * @example
     * // Get one UserDeviceFingerprint
     * const userDeviceFingerprint = await prisma.userDeviceFingerprint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserDeviceFingerprintFindUniqueArgs>(args: SelectSubset<T, UserDeviceFingerprintFindUniqueArgs<ExtArgs>>): Prisma__UserDeviceFingerprintClient<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserDeviceFingerprint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserDeviceFingerprintFindUniqueOrThrowArgs} args - Arguments to find a UserDeviceFingerprint
     * @example
     * // Get one UserDeviceFingerprint
     * const userDeviceFingerprint = await prisma.userDeviceFingerprint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserDeviceFingerprintFindUniqueOrThrowArgs>(args: SelectSubset<T, UserDeviceFingerprintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserDeviceFingerprintClient<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDeviceFingerprint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceFingerprintFindFirstArgs} args - Arguments to find a UserDeviceFingerprint
     * @example
     * // Get one UserDeviceFingerprint
     * const userDeviceFingerprint = await prisma.userDeviceFingerprint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserDeviceFingerprintFindFirstArgs>(args?: SelectSubset<T, UserDeviceFingerprintFindFirstArgs<ExtArgs>>): Prisma__UserDeviceFingerprintClient<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDeviceFingerprint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceFingerprintFindFirstOrThrowArgs} args - Arguments to find a UserDeviceFingerprint
     * @example
     * // Get one UserDeviceFingerprint
     * const userDeviceFingerprint = await prisma.userDeviceFingerprint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserDeviceFingerprintFindFirstOrThrowArgs>(args?: SelectSubset<T, UserDeviceFingerprintFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserDeviceFingerprintClient<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserDeviceFingerprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceFingerprintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDeviceFingerprints
     * const userDeviceFingerprints = await prisma.userDeviceFingerprint.findMany()
     * 
     * // Get first 10 UserDeviceFingerprints
     * const userDeviceFingerprints = await prisma.userDeviceFingerprint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDeviceFingerprintWithIdOnly = await prisma.userDeviceFingerprint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserDeviceFingerprintFindManyArgs>(args?: SelectSubset<T, UserDeviceFingerprintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserDeviceFingerprint.
     * @param {UserDeviceFingerprintCreateArgs} args - Arguments to create a UserDeviceFingerprint.
     * @example
     * // Create one UserDeviceFingerprint
     * const UserDeviceFingerprint = await prisma.userDeviceFingerprint.create({
     *   data: {
     *     // ... data to create a UserDeviceFingerprint
     *   }
     * })
     * 
     */
    create<T extends UserDeviceFingerprintCreateArgs>(args: SelectSubset<T, UserDeviceFingerprintCreateArgs<ExtArgs>>): Prisma__UserDeviceFingerprintClient<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserDeviceFingerprints.
     * @param {UserDeviceFingerprintCreateManyArgs} args - Arguments to create many UserDeviceFingerprints.
     * @example
     * // Create many UserDeviceFingerprints
     * const userDeviceFingerprint = await prisma.userDeviceFingerprint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserDeviceFingerprintCreateManyArgs>(args?: SelectSubset<T, UserDeviceFingerprintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDeviceFingerprints and returns the data saved in the database.
     * @param {UserDeviceFingerprintCreateManyAndReturnArgs} args - Arguments to create many UserDeviceFingerprints.
     * @example
     * // Create many UserDeviceFingerprints
     * const userDeviceFingerprint = await prisma.userDeviceFingerprint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDeviceFingerprints and only return the `id`
     * const userDeviceFingerprintWithIdOnly = await prisma.userDeviceFingerprint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserDeviceFingerprintCreateManyAndReturnArgs>(args?: SelectSubset<T, UserDeviceFingerprintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserDeviceFingerprint.
     * @param {UserDeviceFingerprintDeleteArgs} args - Arguments to delete one UserDeviceFingerprint.
     * @example
     * // Delete one UserDeviceFingerprint
     * const UserDeviceFingerprint = await prisma.userDeviceFingerprint.delete({
     *   where: {
     *     // ... filter to delete one UserDeviceFingerprint
     *   }
     * })
     * 
     */
    delete<T extends UserDeviceFingerprintDeleteArgs>(args: SelectSubset<T, UserDeviceFingerprintDeleteArgs<ExtArgs>>): Prisma__UserDeviceFingerprintClient<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserDeviceFingerprint.
     * @param {UserDeviceFingerprintUpdateArgs} args - Arguments to update one UserDeviceFingerprint.
     * @example
     * // Update one UserDeviceFingerprint
     * const userDeviceFingerprint = await prisma.userDeviceFingerprint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserDeviceFingerprintUpdateArgs>(args: SelectSubset<T, UserDeviceFingerprintUpdateArgs<ExtArgs>>): Prisma__UserDeviceFingerprintClient<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserDeviceFingerprints.
     * @param {UserDeviceFingerprintDeleteManyArgs} args - Arguments to filter UserDeviceFingerprints to delete.
     * @example
     * // Delete a few UserDeviceFingerprints
     * const { count } = await prisma.userDeviceFingerprint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeviceFingerprintDeleteManyArgs>(args?: SelectSubset<T, UserDeviceFingerprintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDeviceFingerprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceFingerprintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDeviceFingerprints
     * const userDeviceFingerprint = await prisma.userDeviceFingerprint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserDeviceFingerprintUpdateManyArgs>(args: SelectSubset<T, UserDeviceFingerprintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDeviceFingerprints and returns the data updated in the database.
     * @param {UserDeviceFingerprintUpdateManyAndReturnArgs} args - Arguments to update many UserDeviceFingerprints.
     * @example
     * // Update many UserDeviceFingerprints
     * const userDeviceFingerprint = await prisma.userDeviceFingerprint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserDeviceFingerprints and only return the `id`
     * const userDeviceFingerprintWithIdOnly = await prisma.userDeviceFingerprint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserDeviceFingerprintUpdateManyAndReturnArgs>(args: SelectSubset<T, UserDeviceFingerprintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserDeviceFingerprint.
     * @param {UserDeviceFingerprintUpsertArgs} args - Arguments to update or create a UserDeviceFingerprint.
     * @example
     * // Update or create a UserDeviceFingerprint
     * const userDeviceFingerprint = await prisma.userDeviceFingerprint.upsert({
     *   create: {
     *     // ... data to create a UserDeviceFingerprint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDeviceFingerprint we want to update
     *   }
     * })
     */
    upsert<T extends UserDeviceFingerprintUpsertArgs>(args: SelectSubset<T, UserDeviceFingerprintUpsertArgs<ExtArgs>>): Prisma__UserDeviceFingerprintClient<$Result.GetResult<Prisma.$UserDeviceFingerprintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserDeviceFingerprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceFingerprintCountArgs} args - Arguments to filter UserDeviceFingerprints to count.
     * @example
     * // Count the number of UserDeviceFingerprints
     * const count = await prisma.userDeviceFingerprint.count({
     *   where: {
     *     // ... the filter for the UserDeviceFingerprints we want to count
     *   }
     * })
    **/
    count<T extends UserDeviceFingerprintCountArgs>(
      args?: Subset<T, UserDeviceFingerprintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDeviceFingerprintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDeviceFingerprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceFingerprintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDeviceFingerprintAggregateArgs>(args: Subset<T, UserDeviceFingerprintAggregateArgs>): Prisma.PrismaPromise<GetUserDeviceFingerprintAggregateType<T>>

    /**
     * Group by UserDeviceFingerprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceFingerprintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDeviceFingerprintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDeviceFingerprintGroupByArgs['orderBy'] }
        : { orderBy?: UserDeviceFingerprintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDeviceFingerprintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDeviceFingerprintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserDeviceFingerprint model
   */
  readonly fields: UserDeviceFingerprintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDeviceFingerprint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserDeviceFingerprintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserDeviceFingerprint model
   */
  interface UserDeviceFingerprintFieldRefs {
    readonly id: FieldRef<"UserDeviceFingerprint", 'String'>
    readonly userId: FieldRef<"UserDeviceFingerprint", 'String'>
    readonly fingerprint: FieldRef<"UserDeviceFingerprint", 'String'>
    readonly ipAddress: FieldRef<"UserDeviceFingerprint", 'String'>
    readonly userAgent: FieldRef<"UserDeviceFingerprint", 'String'>
    readonly isTrusted: FieldRef<"UserDeviceFingerprint", 'Boolean'>
    readonly trustScore: FieldRef<"UserDeviceFingerprint", 'Int'>
    readonly firstSeenAt: FieldRef<"UserDeviceFingerprint", 'DateTime'>
    readonly lastSeenAt: FieldRef<"UserDeviceFingerprint", 'DateTime'>
    readonly loginCount: FieldRef<"UserDeviceFingerprint", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserDeviceFingerprint findUnique
   */
  export type UserDeviceFingerprintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceFingerprint to fetch.
     */
    where: UserDeviceFingerprintWhereUniqueInput
  }

  /**
   * UserDeviceFingerprint findUniqueOrThrow
   */
  export type UserDeviceFingerprintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceFingerprint to fetch.
     */
    where: UserDeviceFingerprintWhereUniqueInput
  }

  /**
   * UserDeviceFingerprint findFirst
   */
  export type UserDeviceFingerprintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceFingerprint to fetch.
     */
    where?: UserDeviceFingerprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceFingerprints to fetch.
     */
    orderBy?: UserDeviceFingerprintOrderByWithRelationInput | UserDeviceFingerprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDeviceFingerprints.
     */
    cursor?: UserDeviceFingerprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceFingerprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceFingerprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDeviceFingerprints.
     */
    distinct?: UserDeviceFingerprintScalarFieldEnum | UserDeviceFingerprintScalarFieldEnum[]
  }

  /**
   * UserDeviceFingerprint findFirstOrThrow
   */
  export type UserDeviceFingerprintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceFingerprint to fetch.
     */
    where?: UserDeviceFingerprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceFingerprints to fetch.
     */
    orderBy?: UserDeviceFingerprintOrderByWithRelationInput | UserDeviceFingerprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDeviceFingerprints.
     */
    cursor?: UserDeviceFingerprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceFingerprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceFingerprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDeviceFingerprints.
     */
    distinct?: UserDeviceFingerprintScalarFieldEnum | UserDeviceFingerprintScalarFieldEnum[]
  }

  /**
   * UserDeviceFingerprint findMany
   */
  export type UserDeviceFingerprintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceFingerprints to fetch.
     */
    where?: UserDeviceFingerprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceFingerprints to fetch.
     */
    orderBy?: UserDeviceFingerprintOrderByWithRelationInput | UserDeviceFingerprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDeviceFingerprints.
     */
    cursor?: UserDeviceFingerprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceFingerprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceFingerprints.
     */
    skip?: number
    distinct?: UserDeviceFingerprintScalarFieldEnum | UserDeviceFingerprintScalarFieldEnum[]
  }

  /**
   * UserDeviceFingerprint create
   */
  export type UserDeviceFingerprintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDeviceFingerprint.
     */
    data: XOR<UserDeviceFingerprintCreateInput, UserDeviceFingerprintUncheckedCreateInput>
  }

  /**
   * UserDeviceFingerprint createMany
   */
  export type UserDeviceFingerprintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDeviceFingerprints.
     */
    data: UserDeviceFingerprintCreateManyInput | UserDeviceFingerprintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDeviceFingerprint createManyAndReturn
   */
  export type UserDeviceFingerprintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * The data used to create many UserDeviceFingerprints.
     */
    data: UserDeviceFingerprintCreateManyInput | UserDeviceFingerprintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDeviceFingerprint update
   */
  export type UserDeviceFingerprintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDeviceFingerprint.
     */
    data: XOR<UserDeviceFingerprintUpdateInput, UserDeviceFingerprintUncheckedUpdateInput>
    /**
     * Choose, which UserDeviceFingerprint to update.
     */
    where: UserDeviceFingerprintWhereUniqueInput
  }

  /**
   * UserDeviceFingerprint updateMany
   */
  export type UserDeviceFingerprintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDeviceFingerprints.
     */
    data: XOR<UserDeviceFingerprintUpdateManyMutationInput, UserDeviceFingerprintUncheckedUpdateManyInput>
    /**
     * Filter which UserDeviceFingerprints to update
     */
    where?: UserDeviceFingerprintWhereInput
    /**
     * Limit how many UserDeviceFingerprints to update.
     */
    limit?: number
  }

  /**
   * UserDeviceFingerprint updateManyAndReturn
   */
  export type UserDeviceFingerprintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * The data used to update UserDeviceFingerprints.
     */
    data: XOR<UserDeviceFingerprintUpdateManyMutationInput, UserDeviceFingerprintUncheckedUpdateManyInput>
    /**
     * Filter which UserDeviceFingerprints to update
     */
    where?: UserDeviceFingerprintWhereInput
    /**
     * Limit how many UserDeviceFingerprints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDeviceFingerprint upsert
   */
  export type UserDeviceFingerprintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDeviceFingerprint to update in case it exists.
     */
    where: UserDeviceFingerprintWhereUniqueInput
    /**
     * In case the UserDeviceFingerprint found by the `where` argument doesn't exist, create a new UserDeviceFingerprint with this data.
     */
    create: XOR<UserDeviceFingerprintCreateInput, UserDeviceFingerprintUncheckedCreateInput>
    /**
     * In case the UserDeviceFingerprint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDeviceFingerprintUpdateInput, UserDeviceFingerprintUncheckedUpdateInput>
  }

  /**
   * UserDeviceFingerprint delete
   */
  export type UserDeviceFingerprintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
    /**
     * Filter which UserDeviceFingerprint to delete.
     */
    where: UserDeviceFingerprintWhereUniqueInput
  }

  /**
   * UserDeviceFingerprint deleteMany
   */
  export type UserDeviceFingerprintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDeviceFingerprints to delete
     */
    where?: UserDeviceFingerprintWhereInput
    /**
     * Limit how many UserDeviceFingerprints to delete.
     */
    limit?: number
  }

  /**
   * UserDeviceFingerprint without action
   */
  export type UserDeviceFingerprintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceFingerprint
     */
    select?: UserDeviceFingerprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceFingerprint
     */
    omit?: UserDeviceFingerprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceFingerprintInclude<ExtArgs> | null
  }


  /**
   * Model UserLoginHistory
   */

  export type AggregateUserLoginHistory = {
    _count: UserLoginHistoryCountAggregateOutputType | null
    _avg: UserLoginHistoryAvgAggregateOutputType | null
    _sum: UserLoginHistorySumAggregateOutputType | null
    _min: UserLoginHistoryMinAggregateOutputType | null
    _max: UserLoginHistoryMaxAggregateOutputType | null
  }

  export type UserLoginHistoryAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type UserLoginHistorySumAggregateOutputType = {
    riskScore: number | null
  }

  export type UserLoginHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    success: boolean | null
    method: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceFingerprint: string | null
    riskScore: number | null
    riskFactors: string | null
    country: string | null
    city: string | null
    timestamp: Date | null
  }

  export type UserLoginHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    success: boolean | null
    method: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceFingerprint: string | null
    riskScore: number | null
    riskFactors: string | null
    country: string | null
    city: string | null
    timestamp: Date | null
  }

  export type UserLoginHistoryCountAggregateOutputType = {
    id: number
    userId: number
    success: number
    method: number
    ipAddress: number
    userAgent: number
    deviceFingerprint: number
    riskScore: number
    riskFactors: number
    country: number
    city: number
    timestamp: number
    _all: number
  }


  export type UserLoginHistoryAvgAggregateInputType = {
    riskScore?: true
  }

  export type UserLoginHistorySumAggregateInputType = {
    riskScore?: true
  }

  export type UserLoginHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    success?: true
    method?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    riskScore?: true
    riskFactors?: true
    country?: true
    city?: true
    timestamp?: true
  }

  export type UserLoginHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    success?: true
    method?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    riskScore?: true
    riskFactors?: true
    country?: true
    city?: true
    timestamp?: true
  }

  export type UserLoginHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    success?: true
    method?: true
    ipAddress?: true
    userAgent?: true
    deviceFingerprint?: true
    riskScore?: true
    riskFactors?: true
    country?: true
    city?: true
    timestamp?: true
    _all?: true
  }

  export type UserLoginHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLoginHistory to aggregate.
     */
    where?: UserLoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginHistories to fetch.
     */
    orderBy?: UserLoginHistoryOrderByWithRelationInput | UserLoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLoginHistories
    **/
    _count?: true | UserLoginHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLoginHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLoginHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLoginHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLoginHistoryMaxAggregateInputType
  }

  export type GetUserLoginHistoryAggregateType<T extends UserLoginHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLoginHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLoginHistory[P]>
      : GetScalarType<T[P], AggregateUserLoginHistory[P]>
  }




  export type UserLoginHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLoginHistoryWhereInput
    orderBy?: UserLoginHistoryOrderByWithAggregationInput | UserLoginHistoryOrderByWithAggregationInput[]
    by: UserLoginHistoryScalarFieldEnum[] | UserLoginHistoryScalarFieldEnum
    having?: UserLoginHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLoginHistoryCountAggregateInputType | true
    _avg?: UserLoginHistoryAvgAggregateInputType
    _sum?: UserLoginHistorySumAggregateInputType
    _min?: UserLoginHistoryMinAggregateInputType
    _max?: UserLoginHistoryMaxAggregateInputType
  }

  export type UserLoginHistoryGroupByOutputType = {
    id: string
    userId: string
    success: boolean
    method: string
    ipAddress: string
    userAgent: string
    deviceFingerprint: string | null
    riskScore: number
    riskFactors: string | null
    country: string | null
    city: string | null
    timestamp: Date
    _count: UserLoginHistoryCountAggregateOutputType | null
    _avg: UserLoginHistoryAvgAggregateOutputType | null
    _sum: UserLoginHistorySumAggregateOutputType | null
    _min: UserLoginHistoryMinAggregateOutputType | null
    _max: UserLoginHistoryMaxAggregateOutputType | null
  }

  type GetUserLoginHistoryGroupByPayload<T extends UserLoginHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLoginHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLoginHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLoginHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserLoginHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UserLoginHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    success?: boolean
    method?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    country?: boolean
    city?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLoginHistory"]>

  export type UserLoginHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    success?: boolean
    method?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    country?: boolean
    city?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLoginHistory"]>

  export type UserLoginHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    success?: boolean
    method?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    country?: boolean
    city?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLoginHistory"]>

  export type UserLoginHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    success?: boolean
    method?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceFingerprint?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    country?: boolean
    city?: boolean
    timestamp?: boolean
  }

  export type UserLoginHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "success" | "method" | "ipAddress" | "userAgent" | "deviceFingerprint" | "riskScore" | "riskFactors" | "country" | "city" | "timestamp", ExtArgs["result"]["userLoginHistory"]>
  export type UserLoginHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLoginHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLoginHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserLoginHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLoginHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      success: boolean
      method: string
      ipAddress: string
      userAgent: string
      deviceFingerprint: string | null
      riskScore: number
      riskFactors: string | null
      country: string | null
      city: string | null
      timestamp: Date
    }, ExtArgs["result"]["userLoginHistory"]>
    composites: {}
  }

  type UserLoginHistoryGetPayload<S extends boolean | null | undefined | UserLoginHistoryDefaultArgs> = $Result.GetResult<Prisma.$UserLoginHistoryPayload, S>

  type UserLoginHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLoginHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLoginHistoryCountAggregateInputType | true
    }

  export interface UserLoginHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLoginHistory'], meta: { name: 'UserLoginHistory' } }
    /**
     * Find zero or one UserLoginHistory that matches the filter.
     * @param {UserLoginHistoryFindUniqueArgs} args - Arguments to find a UserLoginHistory
     * @example
     * // Get one UserLoginHistory
     * const userLoginHistory = await prisma.userLoginHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLoginHistoryFindUniqueArgs>(args: SelectSubset<T, UserLoginHistoryFindUniqueArgs<ExtArgs>>): Prisma__UserLoginHistoryClient<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLoginHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLoginHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserLoginHistory
     * @example
     * // Get one UserLoginHistory
     * const userLoginHistory = await prisma.userLoginHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLoginHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLoginHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLoginHistoryClient<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLoginHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginHistoryFindFirstArgs} args - Arguments to find a UserLoginHistory
     * @example
     * // Get one UserLoginHistory
     * const userLoginHistory = await prisma.userLoginHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLoginHistoryFindFirstArgs>(args?: SelectSubset<T, UserLoginHistoryFindFirstArgs<ExtArgs>>): Prisma__UserLoginHistoryClient<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLoginHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginHistoryFindFirstOrThrowArgs} args - Arguments to find a UserLoginHistory
     * @example
     * // Get one UserLoginHistory
     * const userLoginHistory = await prisma.userLoginHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLoginHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLoginHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLoginHistoryClient<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLoginHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLoginHistories
     * const userLoginHistories = await prisma.userLoginHistory.findMany()
     * 
     * // Get first 10 UserLoginHistories
     * const userLoginHistories = await prisma.userLoginHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLoginHistoryWithIdOnly = await prisma.userLoginHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLoginHistoryFindManyArgs>(args?: SelectSubset<T, UserLoginHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLoginHistory.
     * @param {UserLoginHistoryCreateArgs} args - Arguments to create a UserLoginHistory.
     * @example
     * // Create one UserLoginHistory
     * const UserLoginHistory = await prisma.userLoginHistory.create({
     *   data: {
     *     // ... data to create a UserLoginHistory
     *   }
     * })
     * 
     */
    create<T extends UserLoginHistoryCreateArgs>(args: SelectSubset<T, UserLoginHistoryCreateArgs<ExtArgs>>): Prisma__UserLoginHistoryClient<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLoginHistories.
     * @param {UserLoginHistoryCreateManyArgs} args - Arguments to create many UserLoginHistories.
     * @example
     * // Create many UserLoginHistories
     * const userLoginHistory = await prisma.userLoginHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLoginHistoryCreateManyArgs>(args?: SelectSubset<T, UserLoginHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLoginHistories and returns the data saved in the database.
     * @param {UserLoginHistoryCreateManyAndReturnArgs} args - Arguments to create many UserLoginHistories.
     * @example
     * // Create many UserLoginHistories
     * const userLoginHistory = await prisma.userLoginHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLoginHistories and only return the `id`
     * const userLoginHistoryWithIdOnly = await prisma.userLoginHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLoginHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLoginHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLoginHistory.
     * @param {UserLoginHistoryDeleteArgs} args - Arguments to delete one UserLoginHistory.
     * @example
     * // Delete one UserLoginHistory
     * const UserLoginHistory = await prisma.userLoginHistory.delete({
     *   where: {
     *     // ... filter to delete one UserLoginHistory
     *   }
     * })
     * 
     */
    delete<T extends UserLoginHistoryDeleteArgs>(args: SelectSubset<T, UserLoginHistoryDeleteArgs<ExtArgs>>): Prisma__UserLoginHistoryClient<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLoginHistory.
     * @param {UserLoginHistoryUpdateArgs} args - Arguments to update one UserLoginHistory.
     * @example
     * // Update one UserLoginHistory
     * const userLoginHistory = await prisma.userLoginHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLoginHistoryUpdateArgs>(args: SelectSubset<T, UserLoginHistoryUpdateArgs<ExtArgs>>): Prisma__UserLoginHistoryClient<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLoginHistories.
     * @param {UserLoginHistoryDeleteManyArgs} args - Arguments to filter UserLoginHistories to delete.
     * @example
     * // Delete a few UserLoginHistories
     * const { count } = await prisma.userLoginHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLoginHistoryDeleteManyArgs>(args?: SelectSubset<T, UserLoginHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLoginHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLoginHistories
     * const userLoginHistory = await prisma.userLoginHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLoginHistoryUpdateManyArgs>(args: SelectSubset<T, UserLoginHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLoginHistories and returns the data updated in the database.
     * @param {UserLoginHistoryUpdateManyAndReturnArgs} args - Arguments to update many UserLoginHistories.
     * @example
     * // Update many UserLoginHistories
     * const userLoginHistory = await prisma.userLoginHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLoginHistories and only return the `id`
     * const userLoginHistoryWithIdOnly = await prisma.userLoginHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLoginHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLoginHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLoginHistory.
     * @param {UserLoginHistoryUpsertArgs} args - Arguments to update or create a UserLoginHistory.
     * @example
     * // Update or create a UserLoginHistory
     * const userLoginHistory = await prisma.userLoginHistory.upsert({
     *   create: {
     *     // ... data to create a UserLoginHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLoginHistory we want to update
     *   }
     * })
     */
    upsert<T extends UserLoginHistoryUpsertArgs>(args: SelectSubset<T, UserLoginHistoryUpsertArgs<ExtArgs>>): Prisma__UserLoginHistoryClient<$Result.GetResult<Prisma.$UserLoginHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLoginHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginHistoryCountArgs} args - Arguments to filter UserLoginHistories to count.
     * @example
     * // Count the number of UserLoginHistories
     * const count = await prisma.userLoginHistory.count({
     *   where: {
     *     // ... the filter for the UserLoginHistories we want to count
     *   }
     * })
    **/
    count<T extends UserLoginHistoryCountArgs>(
      args?: Subset<T, UserLoginHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLoginHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLoginHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLoginHistoryAggregateArgs>(args: Subset<T, UserLoginHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserLoginHistoryAggregateType<T>>

    /**
     * Group by UserLoginHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLoginHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLoginHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UserLoginHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLoginHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLoginHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLoginHistory model
   */
  readonly fields: UserLoginHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLoginHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLoginHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLoginHistory model
   */
  interface UserLoginHistoryFieldRefs {
    readonly id: FieldRef<"UserLoginHistory", 'String'>
    readonly userId: FieldRef<"UserLoginHistory", 'String'>
    readonly success: FieldRef<"UserLoginHistory", 'Boolean'>
    readonly method: FieldRef<"UserLoginHistory", 'String'>
    readonly ipAddress: FieldRef<"UserLoginHistory", 'String'>
    readonly userAgent: FieldRef<"UserLoginHistory", 'String'>
    readonly deviceFingerprint: FieldRef<"UserLoginHistory", 'String'>
    readonly riskScore: FieldRef<"UserLoginHistory", 'Int'>
    readonly riskFactors: FieldRef<"UserLoginHistory", 'String'>
    readonly country: FieldRef<"UserLoginHistory", 'String'>
    readonly city: FieldRef<"UserLoginHistory", 'String'>
    readonly timestamp: FieldRef<"UserLoginHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLoginHistory findUnique
   */
  export type UserLoginHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginHistory to fetch.
     */
    where: UserLoginHistoryWhereUniqueInput
  }

  /**
   * UserLoginHistory findUniqueOrThrow
   */
  export type UserLoginHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginHistory to fetch.
     */
    where: UserLoginHistoryWhereUniqueInput
  }

  /**
   * UserLoginHistory findFirst
   */
  export type UserLoginHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginHistory to fetch.
     */
    where?: UserLoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginHistories to fetch.
     */
    orderBy?: UserLoginHistoryOrderByWithRelationInput | UserLoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLoginHistories.
     */
    cursor?: UserLoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLoginHistories.
     */
    distinct?: UserLoginHistoryScalarFieldEnum | UserLoginHistoryScalarFieldEnum[]
  }

  /**
   * UserLoginHistory findFirstOrThrow
   */
  export type UserLoginHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginHistory to fetch.
     */
    where?: UserLoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginHistories to fetch.
     */
    orderBy?: UserLoginHistoryOrderByWithRelationInput | UserLoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLoginHistories.
     */
    cursor?: UserLoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLoginHistories.
     */
    distinct?: UserLoginHistoryScalarFieldEnum | UserLoginHistoryScalarFieldEnum[]
  }

  /**
   * UserLoginHistory findMany
   */
  export type UserLoginHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginHistories to fetch.
     */
    where?: UserLoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginHistories to fetch.
     */
    orderBy?: UserLoginHistoryOrderByWithRelationInput | UserLoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLoginHistories.
     */
    cursor?: UserLoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginHistories.
     */
    skip?: number
    distinct?: UserLoginHistoryScalarFieldEnum | UserLoginHistoryScalarFieldEnum[]
  }

  /**
   * UserLoginHistory create
   */
  export type UserLoginHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLoginHistory.
     */
    data: XOR<UserLoginHistoryCreateInput, UserLoginHistoryUncheckedCreateInput>
  }

  /**
   * UserLoginHistory createMany
   */
  export type UserLoginHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLoginHistories.
     */
    data: UserLoginHistoryCreateManyInput | UserLoginHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLoginHistory createManyAndReturn
   */
  export type UserLoginHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many UserLoginHistories.
     */
    data: UserLoginHistoryCreateManyInput | UserLoginHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLoginHistory update
   */
  export type UserLoginHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLoginHistory.
     */
    data: XOR<UserLoginHistoryUpdateInput, UserLoginHistoryUncheckedUpdateInput>
    /**
     * Choose, which UserLoginHistory to update.
     */
    where: UserLoginHistoryWhereUniqueInput
  }

  /**
   * UserLoginHistory updateMany
   */
  export type UserLoginHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLoginHistories.
     */
    data: XOR<UserLoginHistoryUpdateManyMutationInput, UserLoginHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserLoginHistories to update
     */
    where?: UserLoginHistoryWhereInput
    /**
     * Limit how many UserLoginHistories to update.
     */
    limit?: number
  }

  /**
   * UserLoginHistory updateManyAndReturn
   */
  export type UserLoginHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * The data used to update UserLoginHistories.
     */
    data: XOR<UserLoginHistoryUpdateManyMutationInput, UserLoginHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserLoginHistories to update
     */
    where?: UserLoginHistoryWhereInput
    /**
     * Limit how many UserLoginHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLoginHistory upsert
   */
  export type UserLoginHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLoginHistory to update in case it exists.
     */
    where: UserLoginHistoryWhereUniqueInput
    /**
     * In case the UserLoginHistory found by the `where` argument doesn't exist, create a new UserLoginHistory with this data.
     */
    create: XOR<UserLoginHistoryCreateInput, UserLoginHistoryUncheckedCreateInput>
    /**
     * In case the UserLoginHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLoginHistoryUpdateInput, UserLoginHistoryUncheckedUpdateInput>
  }

  /**
   * UserLoginHistory delete
   */
  export type UserLoginHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
    /**
     * Filter which UserLoginHistory to delete.
     */
    where: UserLoginHistoryWhereUniqueInput
  }

  /**
   * UserLoginHistory deleteMany
   */
  export type UserLoginHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLoginHistories to delete
     */
    where?: UserLoginHistoryWhereInput
    /**
     * Limit how many UserLoginHistories to delete.
     */
    limit?: number
  }

  /**
   * UserLoginHistory without action
   */
  export type UserLoginHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginHistory
     */
    select?: UserLoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginHistory
     */
    omit?: UserLoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginHistoryInclude<ExtArgs> | null
  }


  /**
   * Model BreakglassActivationLog
   */

  export type AggregateBreakglassActivationLog = {
    _count: BreakglassActivationLogCountAggregateOutputType | null
    _avg: BreakglassActivationLogAvgAggregateOutputType | null
    _sum: BreakglassActivationLogSumAggregateOutputType | null
    _min: BreakglassActivationLogMinAggregateOutputType | null
    _max: BreakglassActivationLogMaxAggregateOutputType | null
  }

  export type BreakglassActivationLogAvgAggregateOutputType = {
    riskScore: number | null
    delayMinutes: number | null
  }

  export type BreakglassActivationLogSumAggregateOutputType = {
    riskScore: number | null
    delayMinutes: number | null
  }

  export type BreakglassActivationLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    orgId: string | null
    reason: string | null
    method: string | null
    riskScore: number | null
    riskFactors: string | null
    delayMinutes: number | null
    verificationSteps: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    notifiedAdmins: string | null
    timestamp: Date | null
  }

  export type BreakglassActivationLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    orgId: string | null
    reason: string | null
    method: string | null
    riskScore: number | null
    riskFactors: string | null
    delayMinutes: number | null
    verificationSteps: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    notifiedAdmins: string | null
    timestamp: Date | null
  }

  export type BreakglassActivationLogCountAggregateOutputType = {
    id: number
    userId: number
    orgId: number
    reason: number
    method: number
    riskScore: number
    riskFactors: number
    delayMinutes: number
    verificationSteps: number
    ipAddress: number
    userAgent: number
    success: number
    errorMessage: number
    notifiedAdmins: number
    timestamp: number
    _all: number
  }


  export type BreakglassActivationLogAvgAggregateInputType = {
    riskScore?: true
    delayMinutes?: true
  }

  export type BreakglassActivationLogSumAggregateInputType = {
    riskScore?: true
    delayMinutes?: true
  }

  export type BreakglassActivationLogMinAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    reason?: true
    method?: true
    riskScore?: true
    riskFactors?: true
    delayMinutes?: true
    verificationSteps?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    notifiedAdmins?: true
    timestamp?: true
  }

  export type BreakglassActivationLogMaxAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    reason?: true
    method?: true
    riskScore?: true
    riskFactors?: true
    delayMinutes?: true
    verificationSteps?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    notifiedAdmins?: true
    timestamp?: true
  }

  export type BreakglassActivationLogCountAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    reason?: true
    method?: true
    riskScore?: true
    riskFactors?: true
    delayMinutes?: true
    verificationSteps?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    notifiedAdmins?: true
    timestamp?: true
    _all?: true
  }

  export type BreakglassActivationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreakglassActivationLog to aggregate.
     */
    where?: BreakglassActivationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakglassActivationLogs to fetch.
     */
    orderBy?: BreakglassActivationLogOrderByWithRelationInput | BreakglassActivationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreakglassActivationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakglassActivationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakglassActivationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreakglassActivationLogs
    **/
    _count?: true | BreakglassActivationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BreakglassActivationLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BreakglassActivationLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreakglassActivationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreakglassActivationLogMaxAggregateInputType
  }

  export type GetBreakglassActivationLogAggregateType<T extends BreakglassActivationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBreakglassActivationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreakglassActivationLog[P]>
      : GetScalarType<T[P], AggregateBreakglassActivationLog[P]>
  }




  export type BreakglassActivationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreakglassActivationLogWhereInput
    orderBy?: BreakglassActivationLogOrderByWithAggregationInput | BreakglassActivationLogOrderByWithAggregationInput[]
    by: BreakglassActivationLogScalarFieldEnum[] | BreakglassActivationLogScalarFieldEnum
    having?: BreakglassActivationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreakglassActivationLogCountAggregateInputType | true
    _avg?: BreakglassActivationLogAvgAggregateInputType
    _sum?: BreakglassActivationLogSumAggregateInputType
    _min?: BreakglassActivationLogMinAggregateInputType
    _max?: BreakglassActivationLogMaxAggregateInputType
  }

  export type BreakglassActivationLogGroupByOutputType = {
    id: string
    userId: string
    orgId: string
    reason: string
    method: string
    riskScore: number
    riskFactors: string
    delayMinutes: number
    verificationSteps: string
    ipAddress: string
    userAgent: string
    success: boolean
    errorMessage: string | null
    notifiedAdmins: string
    timestamp: Date
    _count: BreakglassActivationLogCountAggregateOutputType | null
    _avg: BreakglassActivationLogAvgAggregateOutputType | null
    _sum: BreakglassActivationLogSumAggregateOutputType | null
    _min: BreakglassActivationLogMinAggregateOutputType | null
    _max: BreakglassActivationLogMaxAggregateOutputType | null
  }

  type GetBreakglassActivationLogGroupByPayload<T extends BreakglassActivationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreakglassActivationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreakglassActivationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreakglassActivationLogGroupByOutputType[P]>
            : GetScalarType<T[P], BreakglassActivationLogGroupByOutputType[P]>
        }
      >
    >


  export type BreakglassActivationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    reason?: boolean
    method?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    delayMinutes?: boolean
    verificationSteps?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    notifiedAdmins?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["breakglassActivationLog"]>

  export type BreakglassActivationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    reason?: boolean
    method?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    delayMinutes?: boolean
    verificationSteps?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    notifiedAdmins?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["breakglassActivationLog"]>

  export type BreakglassActivationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    reason?: boolean
    method?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    delayMinutes?: boolean
    verificationSteps?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    notifiedAdmins?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["breakglassActivationLog"]>

  export type BreakglassActivationLogSelectScalar = {
    id?: boolean
    userId?: boolean
    orgId?: boolean
    reason?: boolean
    method?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    delayMinutes?: boolean
    verificationSteps?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    notifiedAdmins?: boolean
    timestamp?: boolean
  }

  export type BreakglassActivationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "orgId" | "reason" | "method" | "riskScore" | "riskFactors" | "delayMinutes" | "verificationSteps" | "ipAddress" | "userAgent" | "success" | "errorMessage" | "notifiedAdmins" | "timestamp", ExtArgs["result"]["breakglassActivationLog"]>

  export type $BreakglassActivationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreakglassActivationLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      orgId: string
      reason: string
      method: string
      riskScore: number
      riskFactors: string
      delayMinutes: number
      verificationSteps: string
      ipAddress: string
      userAgent: string
      success: boolean
      errorMessage: string | null
      notifiedAdmins: string
      timestamp: Date
    }, ExtArgs["result"]["breakglassActivationLog"]>
    composites: {}
  }

  type BreakglassActivationLogGetPayload<S extends boolean | null | undefined | BreakglassActivationLogDefaultArgs> = $Result.GetResult<Prisma.$BreakglassActivationLogPayload, S>

  type BreakglassActivationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BreakglassActivationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BreakglassActivationLogCountAggregateInputType | true
    }

  export interface BreakglassActivationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreakglassActivationLog'], meta: { name: 'BreakglassActivationLog' } }
    /**
     * Find zero or one BreakglassActivationLog that matches the filter.
     * @param {BreakglassActivationLogFindUniqueArgs} args - Arguments to find a BreakglassActivationLog
     * @example
     * // Get one BreakglassActivationLog
     * const breakglassActivationLog = await prisma.breakglassActivationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreakglassActivationLogFindUniqueArgs>(args: SelectSubset<T, BreakglassActivationLogFindUniqueArgs<ExtArgs>>): Prisma__BreakglassActivationLogClient<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BreakglassActivationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BreakglassActivationLogFindUniqueOrThrowArgs} args - Arguments to find a BreakglassActivationLog
     * @example
     * // Get one BreakglassActivationLog
     * const breakglassActivationLog = await prisma.breakglassActivationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreakglassActivationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, BreakglassActivationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreakglassActivationLogClient<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BreakglassActivationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakglassActivationLogFindFirstArgs} args - Arguments to find a BreakglassActivationLog
     * @example
     * // Get one BreakglassActivationLog
     * const breakglassActivationLog = await prisma.breakglassActivationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreakglassActivationLogFindFirstArgs>(args?: SelectSubset<T, BreakglassActivationLogFindFirstArgs<ExtArgs>>): Prisma__BreakglassActivationLogClient<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BreakglassActivationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakglassActivationLogFindFirstOrThrowArgs} args - Arguments to find a BreakglassActivationLog
     * @example
     * // Get one BreakglassActivationLog
     * const breakglassActivationLog = await prisma.breakglassActivationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreakglassActivationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, BreakglassActivationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreakglassActivationLogClient<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BreakglassActivationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakglassActivationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreakglassActivationLogs
     * const breakglassActivationLogs = await prisma.breakglassActivationLog.findMany()
     * 
     * // Get first 10 BreakglassActivationLogs
     * const breakglassActivationLogs = await prisma.breakglassActivationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breakglassActivationLogWithIdOnly = await prisma.breakglassActivationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreakglassActivationLogFindManyArgs>(args?: SelectSubset<T, BreakglassActivationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BreakglassActivationLog.
     * @param {BreakglassActivationLogCreateArgs} args - Arguments to create a BreakglassActivationLog.
     * @example
     * // Create one BreakglassActivationLog
     * const BreakglassActivationLog = await prisma.breakglassActivationLog.create({
     *   data: {
     *     // ... data to create a BreakglassActivationLog
     *   }
     * })
     * 
     */
    create<T extends BreakglassActivationLogCreateArgs>(args: SelectSubset<T, BreakglassActivationLogCreateArgs<ExtArgs>>): Prisma__BreakglassActivationLogClient<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BreakglassActivationLogs.
     * @param {BreakglassActivationLogCreateManyArgs} args - Arguments to create many BreakglassActivationLogs.
     * @example
     * // Create many BreakglassActivationLogs
     * const breakglassActivationLog = await prisma.breakglassActivationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreakglassActivationLogCreateManyArgs>(args?: SelectSubset<T, BreakglassActivationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BreakglassActivationLogs and returns the data saved in the database.
     * @param {BreakglassActivationLogCreateManyAndReturnArgs} args - Arguments to create many BreakglassActivationLogs.
     * @example
     * // Create many BreakglassActivationLogs
     * const breakglassActivationLog = await prisma.breakglassActivationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BreakglassActivationLogs and only return the `id`
     * const breakglassActivationLogWithIdOnly = await prisma.breakglassActivationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BreakglassActivationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, BreakglassActivationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BreakglassActivationLog.
     * @param {BreakglassActivationLogDeleteArgs} args - Arguments to delete one BreakglassActivationLog.
     * @example
     * // Delete one BreakglassActivationLog
     * const BreakglassActivationLog = await prisma.breakglassActivationLog.delete({
     *   where: {
     *     // ... filter to delete one BreakglassActivationLog
     *   }
     * })
     * 
     */
    delete<T extends BreakglassActivationLogDeleteArgs>(args: SelectSubset<T, BreakglassActivationLogDeleteArgs<ExtArgs>>): Prisma__BreakglassActivationLogClient<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BreakglassActivationLog.
     * @param {BreakglassActivationLogUpdateArgs} args - Arguments to update one BreakglassActivationLog.
     * @example
     * // Update one BreakglassActivationLog
     * const breakglassActivationLog = await prisma.breakglassActivationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreakglassActivationLogUpdateArgs>(args: SelectSubset<T, BreakglassActivationLogUpdateArgs<ExtArgs>>): Prisma__BreakglassActivationLogClient<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BreakglassActivationLogs.
     * @param {BreakglassActivationLogDeleteManyArgs} args - Arguments to filter BreakglassActivationLogs to delete.
     * @example
     * // Delete a few BreakglassActivationLogs
     * const { count } = await prisma.breakglassActivationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreakglassActivationLogDeleteManyArgs>(args?: SelectSubset<T, BreakglassActivationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreakglassActivationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakglassActivationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreakglassActivationLogs
     * const breakglassActivationLog = await prisma.breakglassActivationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreakglassActivationLogUpdateManyArgs>(args: SelectSubset<T, BreakglassActivationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreakglassActivationLogs and returns the data updated in the database.
     * @param {BreakglassActivationLogUpdateManyAndReturnArgs} args - Arguments to update many BreakglassActivationLogs.
     * @example
     * // Update many BreakglassActivationLogs
     * const breakglassActivationLog = await prisma.breakglassActivationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BreakglassActivationLogs and only return the `id`
     * const breakglassActivationLogWithIdOnly = await prisma.breakglassActivationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BreakglassActivationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, BreakglassActivationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BreakglassActivationLog.
     * @param {BreakglassActivationLogUpsertArgs} args - Arguments to update or create a BreakglassActivationLog.
     * @example
     * // Update or create a BreakglassActivationLog
     * const breakglassActivationLog = await prisma.breakglassActivationLog.upsert({
     *   create: {
     *     // ... data to create a BreakglassActivationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreakglassActivationLog we want to update
     *   }
     * })
     */
    upsert<T extends BreakglassActivationLogUpsertArgs>(args: SelectSubset<T, BreakglassActivationLogUpsertArgs<ExtArgs>>): Prisma__BreakglassActivationLogClient<$Result.GetResult<Prisma.$BreakglassActivationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BreakglassActivationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakglassActivationLogCountArgs} args - Arguments to filter BreakglassActivationLogs to count.
     * @example
     * // Count the number of BreakglassActivationLogs
     * const count = await prisma.breakglassActivationLog.count({
     *   where: {
     *     // ... the filter for the BreakglassActivationLogs we want to count
     *   }
     * })
    **/
    count<T extends BreakglassActivationLogCountArgs>(
      args?: Subset<T, BreakglassActivationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreakglassActivationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreakglassActivationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakglassActivationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreakglassActivationLogAggregateArgs>(args: Subset<T, BreakglassActivationLogAggregateArgs>): Prisma.PrismaPromise<GetBreakglassActivationLogAggregateType<T>>

    /**
     * Group by BreakglassActivationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakglassActivationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreakglassActivationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreakglassActivationLogGroupByArgs['orderBy'] }
        : { orderBy?: BreakglassActivationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreakglassActivationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreakglassActivationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreakglassActivationLog model
   */
  readonly fields: BreakglassActivationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreakglassActivationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreakglassActivationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreakglassActivationLog model
   */
  interface BreakglassActivationLogFieldRefs {
    readonly id: FieldRef<"BreakglassActivationLog", 'String'>
    readonly userId: FieldRef<"BreakglassActivationLog", 'String'>
    readonly orgId: FieldRef<"BreakglassActivationLog", 'String'>
    readonly reason: FieldRef<"BreakglassActivationLog", 'String'>
    readonly method: FieldRef<"BreakglassActivationLog", 'String'>
    readonly riskScore: FieldRef<"BreakglassActivationLog", 'Int'>
    readonly riskFactors: FieldRef<"BreakglassActivationLog", 'String'>
    readonly delayMinutes: FieldRef<"BreakglassActivationLog", 'Int'>
    readonly verificationSteps: FieldRef<"BreakglassActivationLog", 'String'>
    readonly ipAddress: FieldRef<"BreakglassActivationLog", 'String'>
    readonly userAgent: FieldRef<"BreakglassActivationLog", 'String'>
    readonly success: FieldRef<"BreakglassActivationLog", 'Boolean'>
    readonly errorMessage: FieldRef<"BreakglassActivationLog", 'String'>
    readonly notifiedAdmins: FieldRef<"BreakglassActivationLog", 'String'>
    readonly timestamp: FieldRef<"BreakglassActivationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreakglassActivationLog findUnique
   */
  export type BreakglassActivationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * Filter, which BreakglassActivationLog to fetch.
     */
    where: BreakglassActivationLogWhereUniqueInput
  }

  /**
   * BreakglassActivationLog findUniqueOrThrow
   */
  export type BreakglassActivationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * Filter, which BreakglassActivationLog to fetch.
     */
    where: BreakglassActivationLogWhereUniqueInput
  }

  /**
   * BreakglassActivationLog findFirst
   */
  export type BreakglassActivationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * Filter, which BreakglassActivationLog to fetch.
     */
    where?: BreakglassActivationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakglassActivationLogs to fetch.
     */
    orderBy?: BreakglassActivationLogOrderByWithRelationInput | BreakglassActivationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreakglassActivationLogs.
     */
    cursor?: BreakglassActivationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakglassActivationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakglassActivationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreakglassActivationLogs.
     */
    distinct?: BreakglassActivationLogScalarFieldEnum | BreakglassActivationLogScalarFieldEnum[]
  }

  /**
   * BreakglassActivationLog findFirstOrThrow
   */
  export type BreakglassActivationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * Filter, which BreakglassActivationLog to fetch.
     */
    where?: BreakglassActivationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakglassActivationLogs to fetch.
     */
    orderBy?: BreakglassActivationLogOrderByWithRelationInput | BreakglassActivationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreakglassActivationLogs.
     */
    cursor?: BreakglassActivationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakglassActivationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakglassActivationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreakglassActivationLogs.
     */
    distinct?: BreakglassActivationLogScalarFieldEnum | BreakglassActivationLogScalarFieldEnum[]
  }

  /**
   * BreakglassActivationLog findMany
   */
  export type BreakglassActivationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * Filter, which BreakglassActivationLogs to fetch.
     */
    where?: BreakglassActivationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakglassActivationLogs to fetch.
     */
    orderBy?: BreakglassActivationLogOrderByWithRelationInput | BreakglassActivationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreakglassActivationLogs.
     */
    cursor?: BreakglassActivationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakglassActivationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakglassActivationLogs.
     */
    skip?: number
    distinct?: BreakglassActivationLogScalarFieldEnum | BreakglassActivationLogScalarFieldEnum[]
  }

  /**
   * BreakglassActivationLog create
   */
  export type BreakglassActivationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * The data needed to create a BreakglassActivationLog.
     */
    data: XOR<BreakglassActivationLogCreateInput, BreakglassActivationLogUncheckedCreateInput>
  }

  /**
   * BreakglassActivationLog createMany
   */
  export type BreakglassActivationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreakglassActivationLogs.
     */
    data: BreakglassActivationLogCreateManyInput | BreakglassActivationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BreakglassActivationLog createManyAndReturn
   */
  export type BreakglassActivationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * The data used to create many BreakglassActivationLogs.
     */
    data: BreakglassActivationLogCreateManyInput | BreakglassActivationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BreakglassActivationLog update
   */
  export type BreakglassActivationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * The data needed to update a BreakglassActivationLog.
     */
    data: XOR<BreakglassActivationLogUpdateInput, BreakglassActivationLogUncheckedUpdateInput>
    /**
     * Choose, which BreakglassActivationLog to update.
     */
    where: BreakglassActivationLogWhereUniqueInput
  }

  /**
   * BreakglassActivationLog updateMany
   */
  export type BreakglassActivationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreakglassActivationLogs.
     */
    data: XOR<BreakglassActivationLogUpdateManyMutationInput, BreakglassActivationLogUncheckedUpdateManyInput>
    /**
     * Filter which BreakglassActivationLogs to update
     */
    where?: BreakglassActivationLogWhereInput
    /**
     * Limit how many BreakglassActivationLogs to update.
     */
    limit?: number
  }

  /**
   * BreakglassActivationLog updateManyAndReturn
   */
  export type BreakglassActivationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * The data used to update BreakglassActivationLogs.
     */
    data: XOR<BreakglassActivationLogUpdateManyMutationInput, BreakglassActivationLogUncheckedUpdateManyInput>
    /**
     * Filter which BreakglassActivationLogs to update
     */
    where?: BreakglassActivationLogWhereInput
    /**
     * Limit how many BreakglassActivationLogs to update.
     */
    limit?: number
  }

  /**
   * BreakglassActivationLog upsert
   */
  export type BreakglassActivationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * The filter to search for the BreakglassActivationLog to update in case it exists.
     */
    where: BreakglassActivationLogWhereUniqueInput
    /**
     * In case the BreakglassActivationLog found by the `where` argument doesn't exist, create a new BreakglassActivationLog with this data.
     */
    create: XOR<BreakglassActivationLogCreateInput, BreakglassActivationLogUncheckedCreateInput>
    /**
     * In case the BreakglassActivationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreakglassActivationLogUpdateInput, BreakglassActivationLogUncheckedUpdateInput>
  }

  /**
   * BreakglassActivationLog delete
   */
  export type BreakglassActivationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
    /**
     * Filter which BreakglassActivationLog to delete.
     */
    where: BreakglassActivationLogWhereUniqueInput
  }

  /**
   * BreakglassActivationLog deleteMany
   */
  export type BreakglassActivationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreakglassActivationLogs to delete
     */
    where?: BreakglassActivationLogWhereInput
    /**
     * Limit how many BreakglassActivationLogs to delete.
     */
    limit?: number
  }

  /**
   * BreakglassActivationLog without action
   */
  export type BreakglassActivationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakglassActivationLog
     */
    select?: BreakglassActivationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakglassActivationLog
     */
    omit?: BreakglassActivationLogOmit<ExtArgs> | null
  }


  /**
   * Model RecoveryRequest
   */

  export type AggregateRecoveryRequest = {
    _count: RecoveryRequestCountAggregateOutputType | null
    _avg: RecoveryRequestAvgAggregateOutputType | null
    _sum: RecoveryRequestSumAggregateOutputType | null
    _min: RecoveryRequestMinAggregateOutputType | null
    _max: RecoveryRequestMaxAggregateOutputType | null
  }

  export type RecoveryRequestAvgAggregateOutputType = {
    codeAttempts: number | null
    riskScore: number | null
  }

  export type RecoveryRequestSumAggregateOutputType = {
    codeAttempts: number | null
    riskScore: number | null
  }

  export type RecoveryRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    orgId: string | null
    type: string | null
    status: string | null
    verificationToken: string | null
    verificationCode: string | null
    codeExpiresAt: Date | null
    codeAttempts: number | null
    riskScore: number | null
    delayUntil: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    expiresAt: Date | null
    completedAt: Date | null
  }

  export type RecoveryRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    orgId: string | null
    type: string | null
    status: string | null
    verificationToken: string | null
    verificationCode: string | null
    codeExpiresAt: Date | null
    codeAttempts: number | null
    riskScore: number | null
    delayUntil: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    expiresAt: Date | null
    completedAt: Date | null
  }

  export type RecoveryRequestCountAggregateOutputType = {
    id: number
    userId: number
    orgId: number
    type: number
    status: number
    verificationToken: number
    verificationCode: number
    codeExpiresAt: number
    codeAttempts: number
    riskScore: number
    delayUntil: number
    ipAddress: number
    userAgent: number
    createdAt: number
    expiresAt: number
    completedAt: number
    _all: number
  }


  export type RecoveryRequestAvgAggregateInputType = {
    codeAttempts?: true
    riskScore?: true
  }

  export type RecoveryRequestSumAggregateInputType = {
    codeAttempts?: true
    riskScore?: true
  }

  export type RecoveryRequestMinAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    type?: true
    status?: true
    verificationToken?: true
    verificationCode?: true
    codeExpiresAt?: true
    codeAttempts?: true
    riskScore?: true
    delayUntil?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
    completedAt?: true
  }

  export type RecoveryRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    type?: true
    status?: true
    verificationToken?: true
    verificationCode?: true
    codeExpiresAt?: true
    codeAttempts?: true
    riskScore?: true
    delayUntil?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
    completedAt?: true
  }

  export type RecoveryRequestCountAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    type?: true
    status?: true
    verificationToken?: true
    verificationCode?: true
    codeExpiresAt?: true
    codeAttempts?: true
    riskScore?: true
    delayUntil?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
    completedAt?: true
    _all?: true
  }

  export type RecoveryRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryRequest to aggregate.
     */
    where?: RecoveryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryRequests to fetch.
     */
    orderBy?: RecoveryRequestOrderByWithRelationInput | RecoveryRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecoveryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecoveryRequests
    **/
    _count?: true | RecoveryRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecoveryRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecoveryRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecoveryRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecoveryRequestMaxAggregateInputType
  }

  export type GetRecoveryRequestAggregateType<T extends RecoveryRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRecoveryRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecoveryRequest[P]>
      : GetScalarType<T[P], AggregateRecoveryRequest[P]>
  }




  export type RecoveryRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryRequestWhereInput
    orderBy?: RecoveryRequestOrderByWithAggregationInput | RecoveryRequestOrderByWithAggregationInput[]
    by: RecoveryRequestScalarFieldEnum[] | RecoveryRequestScalarFieldEnum
    having?: RecoveryRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecoveryRequestCountAggregateInputType | true
    _avg?: RecoveryRequestAvgAggregateInputType
    _sum?: RecoveryRequestSumAggregateInputType
    _min?: RecoveryRequestMinAggregateInputType
    _max?: RecoveryRequestMaxAggregateInputType
  }

  export type RecoveryRequestGroupByOutputType = {
    id: string
    userId: string
    orgId: string
    type: string
    status: string
    verificationToken: string
    verificationCode: string | null
    codeExpiresAt: Date | null
    codeAttempts: number
    riskScore: number
    delayUntil: Date
    ipAddress: string
    userAgent: string
    createdAt: Date
    expiresAt: Date
    completedAt: Date | null
    _count: RecoveryRequestCountAggregateOutputType | null
    _avg: RecoveryRequestAvgAggregateOutputType | null
    _sum: RecoveryRequestSumAggregateOutputType | null
    _min: RecoveryRequestMinAggregateOutputType | null
    _max: RecoveryRequestMaxAggregateOutputType | null
  }

  type GetRecoveryRequestGroupByPayload<T extends RecoveryRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecoveryRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecoveryRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecoveryRequestGroupByOutputType[P]>
            : GetScalarType<T[P], RecoveryRequestGroupByOutputType[P]>
        }
      >
    >


  export type RecoveryRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    type?: boolean
    status?: boolean
    verificationToken?: boolean
    verificationCode?: boolean
    codeExpiresAt?: boolean
    codeAttempts?: boolean
    riskScore?: boolean
    delayUntil?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["recoveryRequest"]>

  export type RecoveryRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    type?: boolean
    status?: boolean
    verificationToken?: boolean
    verificationCode?: boolean
    codeExpiresAt?: boolean
    codeAttempts?: boolean
    riskScore?: boolean
    delayUntil?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["recoveryRequest"]>

  export type RecoveryRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    type?: boolean
    status?: boolean
    verificationToken?: boolean
    verificationCode?: boolean
    codeExpiresAt?: boolean
    codeAttempts?: boolean
    riskScore?: boolean
    delayUntil?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["recoveryRequest"]>

  export type RecoveryRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    orgId?: boolean
    type?: boolean
    status?: boolean
    verificationToken?: boolean
    verificationCode?: boolean
    codeExpiresAt?: boolean
    codeAttempts?: boolean
    riskScore?: boolean
    delayUntil?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    completedAt?: boolean
  }

  export type RecoveryRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "orgId" | "type" | "status" | "verificationToken" | "verificationCode" | "codeExpiresAt" | "codeAttempts" | "riskScore" | "delayUntil" | "ipAddress" | "userAgent" | "createdAt" | "expiresAt" | "completedAt", ExtArgs["result"]["recoveryRequest"]>

  export type $RecoveryRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecoveryRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      orgId: string
      type: string
      status: string
      verificationToken: string
      verificationCode: string | null
      codeExpiresAt: Date | null
      codeAttempts: number
      riskScore: number
      delayUntil: Date
      ipAddress: string
      userAgent: string
      createdAt: Date
      expiresAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["recoveryRequest"]>
    composites: {}
  }

  type RecoveryRequestGetPayload<S extends boolean | null | undefined | RecoveryRequestDefaultArgs> = $Result.GetResult<Prisma.$RecoveryRequestPayload, S>

  type RecoveryRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecoveryRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecoveryRequestCountAggregateInputType | true
    }

  export interface RecoveryRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecoveryRequest'], meta: { name: 'RecoveryRequest' } }
    /**
     * Find zero or one RecoveryRequest that matches the filter.
     * @param {RecoveryRequestFindUniqueArgs} args - Arguments to find a RecoveryRequest
     * @example
     * // Get one RecoveryRequest
     * const recoveryRequest = await prisma.recoveryRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecoveryRequestFindUniqueArgs>(args: SelectSubset<T, RecoveryRequestFindUniqueArgs<ExtArgs>>): Prisma__RecoveryRequestClient<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecoveryRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecoveryRequestFindUniqueOrThrowArgs} args - Arguments to find a RecoveryRequest
     * @example
     * // Get one RecoveryRequest
     * const recoveryRequest = await prisma.recoveryRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecoveryRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RecoveryRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecoveryRequestClient<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRequestFindFirstArgs} args - Arguments to find a RecoveryRequest
     * @example
     * // Get one RecoveryRequest
     * const recoveryRequest = await prisma.recoveryRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecoveryRequestFindFirstArgs>(args?: SelectSubset<T, RecoveryRequestFindFirstArgs<ExtArgs>>): Prisma__RecoveryRequestClient<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRequestFindFirstOrThrowArgs} args - Arguments to find a RecoveryRequest
     * @example
     * // Get one RecoveryRequest
     * const recoveryRequest = await prisma.recoveryRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecoveryRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RecoveryRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecoveryRequestClient<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecoveryRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecoveryRequests
     * const recoveryRequests = await prisma.recoveryRequest.findMany()
     * 
     * // Get first 10 RecoveryRequests
     * const recoveryRequests = await prisma.recoveryRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recoveryRequestWithIdOnly = await prisma.recoveryRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecoveryRequestFindManyArgs>(args?: SelectSubset<T, RecoveryRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecoveryRequest.
     * @param {RecoveryRequestCreateArgs} args - Arguments to create a RecoveryRequest.
     * @example
     * // Create one RecoveryRequest
     * const RecoveryRequest = await prisma.recoveryRequest.create({
     *   data: {
     *     // ... data to create a RecoveryRequest
     *   }
     * })
     * 
     */
    create<T extends RecoveryRequestCreateArgs>(args: SelectSubset<T, RecoveryRequestCreateArgs<ExtArgs>>): Prisma__RecoveryRequestClient<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecoveryRequests.
     * @param {RecoveryRequestCreateManyArgs} args - Arguments to create many RecoveryRequests.
     * @example
     * // Create many RecoveryRequests
     * const recoveryRequest = await prisma.recoveryRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecoveryRequestCreateManyArgs>(args?: SelectSubset<T, RecoveryRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecoveryRequests and returns the data saved in the database.
     * @param {RecoveryRequestCreateManyAndReturnArgs} args - Arguments to create many RecoveryRequests.
     * @example
     * // Create many RecoveryRequests
     * const recoveryRequest = await prisma.recoveryRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecoveryRequests and only return the `id`
     * const recoveryRequestWithIdOnly = await prisma.recoveryRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecoveryRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RecoveryRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecoveryRequest.
     * @param {RecoveryRequestDeleteArgs} args - Arguments to delete one RecoveryRequest.
     * @example
     * // Delete one RecoveryRequest
     * const RecoveryRequest = await prisma.recoveryRequest.delete({
     *   where: {
     *     // ... filter to delete one RecoveryRequest
     *   }
     * })
     * 
     */
    delete<T extends RecoveryRequestDeleteArgs>(args: SelectSubset<T, RecoveryRequestDeleteArgs<ExtArgs>>): Prisma__RecoveryRequestClient<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecoveryRequest.
     * @param {RecoveryRequestUpdateArgs} args - Arguments to update one RecoveryRequest.
     * @example
     * // Update one RecoveryRequest
     * const recoveryRequest = await prisma.recoveryRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecoveryRequestUpdateArgs>(args: SelectSubset<T, RecoveryRequestUpdateArgs<ExtArgs>>): Prisma__RecoveryRequestClient<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecoveryRequests.
     * @param {RecoveryRequestDeleteManyArgs} args - Arguments to filter RecoveryRequests to delete.
     * @example
     * // Delete a few RecoveryRequests
     * const { count } = await prisma.recoveryRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecoveryRequestDeleteManyArgs>(args?: SelectSubset<T, RecoveryRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecoveryRequests
     * const recoveryRequest = await prisma.recoveryRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecoveryRequestUpdateManyArgs>(args: SelectSubset<T, RecoveryRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryRequests and returns the data updated in the database.
     * @param {RecoveryRequestUpdateManyAndReturnArgs} args - Arguments to update many RecoveryRequests.
     * @example
     * // Update many RecoveryRequests
     * const recoveryRequest = await prisma.recoveryRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecoveryRequests and only return the `id`
     * const recoveryRequestWithIdOnly = await prisma.recoveryRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecoveryRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, RecoveryRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecoveryRequest.
     * @param {RecoveryRequestUpsertArgs} args - Arguments to update or create a RecoveryRequest.
     * @example
     * // Update or create a RecoveryRequest
     * const recoveryRequest = await prisma.recoveryRequest.upsert({
     *   create: {
     *     // ... data to create a RecoveryRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecoveryRequest we want to update
     *   }
     * })
     */
    upsert<T extends RecoveryRequestUpsertArgs>(args: SelectSubset<T, RecoveryRequestUpsertArgs<ExtArgs>>): Prisma__RecoveryRequestClient<$Result.GetResult<Prisma.$RecoveryRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecoveryRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRequestCountArgs} args - Arguments to filter RecoveryRequests to count.
     * @example
     * // Count the number of RecoveryRequests
     * const count = await prisma.recoveryRequest.count({
     *   where: {
     *     // ... the filter for the RecoveryRequests we want to count
     *   }
     * })
    **/
    count<T extends RecoveryRequestCountArgs>(
      args?: Subset<T, RecoveryRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecoveryRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecoveryRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecoveryRequestAggregateArgs>(args: Subset<T, RecoveryRequestAggregateArgs>): Prisma.PrismaPromise<GetRecoveryRequestAggregateType<T>>

    /**
     * Group by RecoveryRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecoveryRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecoveryRequestGroupByArgs['orderBy'] }
        : { orderBy?: RecoveryRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecoveryRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecoveryRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecoveryRequest model
   */
  readonly fields: RecoveryRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecoveryRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecoveryRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecoveryRequest model
   */
  interface RecoveryRequestFieldRefs {
    readonly id: FieldRef<"RecoveryRequest", 'String'>
    readonly userId: FieldRef<"RecoveryRequest", 'String'>
    readonly orgId: FieldRef<"RecoveryRequest", 'String'>
    readonly type: FieldRef<"RecoveryRequest", 'String'>
    readonly status: FieldRef<"RecoveryRequest", 'String'>
    readonly verificationToken: FieldRef<"RecoveryRequest", 'String'>
    readonly verificationCode: FieldRef<"RecoveryRequest", 'String'>
    readonly codeExpiresAt: FieldRef<"RecoveryRequest", 'DateTime'>
    readonly codeAttempts: FieldRef<"RecoveryRequest", 'Int'>
    readonly riskScore: FieldRef<"RecoveryRequest", 'Int'>
    readonly delayUntil: FieldRef<"RecoveryRequest", 'DateTime'>
    readonly ipAddress: FieldRef<"RecoveryRequest", 'String'>
    readonly userAgent: FieldRef<"RecoveryRequest", 'String'>
    readonly createdAt: FieldRef<"RecoveryRequest", 'DateTime'>
    readonly expiresAt: FieldRef<"RecoveryRequest", 'DateTime'>
    readonly completedAt: FieldRef<"RecoveryRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecoveryRequest findUnique
   */
  export type RecoveryRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * Filter, which RecoveryRequest to fetch.
     */
    where: RecoveryRequestWhereUniqueInput
  }

  /**
   * RecoveryRequest findUniqueOrThrow
   */
  export type RecoveryRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * Filter, which RecoveryRequest to fetch.
     */
    where: RecoveryRequestWhereUniqueInput
  }

  /**
   * RecoveryRequest findFirst
   */
  export type RecoveryRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * Filter, which RecoveryRequest to fetch.
     */
    where?: RecoveryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryRequests to fetch.
     */
    orderBy?: RecoveryRequestOrderByWithRelationInput | RecoveryRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryRequests.
     */
    cursor?: RecoveryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryRequests.
     */
    distinct?: RecoveryRequestScalarFieldEnum | RecoveryRequestScalarFieldEnum[]
  }

  /**
   * RecoveryRequest findFirstOrThrow
   */
  export type RecoveryRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * Filter, which RecoveryRequest to fetch.
     */
    where?: RecoveryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryRequests to fetch.
     */
    orderBy?: RecoveryRequestOrderByWithRelationInput | RecoveryRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryRequests.
     */
    cursor?: RecoveryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryRequests.
     */
    distinct?: RecoveryRequestScalarFieldEnum | RecoveryRequestScalarFieldEnum[]
  }

  /**
   * RecoveryRequest findMany
   */
  export type RecoveryRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * Filter, which RecoveryRequests to fetch.
     */
    where?: RecoveryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryRequests to fetch.
     */
    orderBy?: RecoveryRequestOrderByWithRelationInput | RecoveryRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecoveryRequests.
     */
    cursor?: RecoveryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryRequests.
     */
    skip?: number
    distinct?: RecoveryRequestScalarFieldEnum | RecoveryRequestScalarFieldEnum[]
  }

  /**
   * RecoveryRequest create
   */
  export type RecoveryRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * The data needed to create a RecoveryRequest.
     */
    data: XOR<RecoveryRequestCreateInput, RecoveryRequestUncheckedCreateInput>
  }

  /**
   * RecoveryRequest createMany
   */
  export type RecoveryRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecoveryRequests.
     */
    data: RecoveryRequestCreateManyInput | RecoveryRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecoveryRequest createManyAndReturn
   */
  export type RecoveryRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * The data used to create many RecoveryRequests.
     */
    data: RecoveryRequestCreateManyInput | RecoveryRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecoveryRequest update
   */
  export type RecoveryRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * The data needed to update a RecoveryRequest.
     */
    data: XOR<RecoveryRequestUpdateInput, RecoveryRequestUncheckedUpdateInput>
    /**
     * Choose, which RecoveryRequest to update.
     */
    where: RecoveryRequestWhereUniqueInput
  }

  /**
   * RecoveryRequest updateMany
   */
  export type RecoveryRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecoveryRequests.
     */
    data: XOR<RecoveryRequestUpdateManyMutationInput, RecoveryRequestUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryRequests to update
     */
    where?: RecoveryRequestWhereInput
    /**
     * Limit how many RecoveryRequests to update.
     */
    limit?: number
  }

  /**
   * RecoveryRequest updateManyAndReturn
   */
  export type RecoveryRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * The data used to update RecoveryRequests.
     */
    data: XOR<RecoveryRequestUpdateManyMutationInput, RecoveryRequestUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryRequests to update
     */
    where?: RecoveryRequestWhereInput
    /**
     * Limit how many RecoveryRequests to update.
     */
    limit?: number
  }

  /**
   * RecoveryRequest upsert
   */
  export type RecoveryRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * The filter to search for the RecoveryRequest to update in case it exists.
     */
    where: RecoveryRequestWhereUniqueInput
    /**
     * In case the RecoveryRequest found by the `where` argument doesn't exist, create a new RecoveryRequest with this data.
     */
    create: XOR<RecoveryRequestCreateInput, RecoveryRequestUncheckedCreateInput>
    /**
     * In case the RecoveryRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecoveryRequestUpdateInput, RecoveryRequestUncheckedUpdateInput>
  }

  /**
   * RecoveryRequest delete
   */
  export type RecoveryRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
    /**
     * Filter which RecoveryRequest to delete.
     */
    where: RecoveryRequestWhereUniqueInput
  }

  /**
   * RecoveryRequest deleteMany
   */
  export type RecoveryRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryRequests to delete
     */
    where?: RecoveryRequestWhereInput
    /**
     * Limit how many RecoveryRequests to delete.
     */
    limit?: number
  }

  /**
   * RecoveryRequest without action
   */
  export type RecoveryRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryRequest
     */
    select?: RecoveryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryRequest
     */
    omit?: RecoveryRequestOmit<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    aiScore: number | null
  }

  export type LeadSumAggregateOutputType = {
    aiScore: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    publicId: string | null
    sourceType: $Enums.LeadSource | null
    identityHash: string | null
    company: string | null
    contactName: string | null
    email: string | null
    phoneE164: string | null
    website: string | null
    serviceCode: string | null
    zip: string | null
    aiScore: number | null
    systemGenerated: boolean | null
    convertedAt: Date | null
    status: $Enums.LeadStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    city: string | null
    notes: string | null
    sourceDetail: string | null
    state: string | null
    postalCode: string | null
    address: string | null
    addressLine1: string | null
    addressLine2: string | null
    country: string | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    publicId: string | null
    sourceType: $Enums.LeadSource | null
    identityHash: string | null
    company: string | null
    contactName: string | null
    email: string | null
    phoneE164: string | null
    website: string | null
    serviceCode: string | null
    zip: string | null
    aiScore: number | null
    systemGenerated: boolean | null
    convertedAt: Date | null
    status: $Enums.LeadStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    city: string | null
    notes: string | null
    sourceDetail: string | null
    state: string | null
    postalCode: string | null
    address: string | null
    addressLine1: string | null
    addressLine2: string | null
    country: string | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    orgId: number
    publicId: number
    sourceType: number
    identityHash: number
    company: number
    contactName: number
    email: number
    phoneE164: number
    website: number
    serviceCode: number
    zip: number
    enrichmentJson: number
    aiScore: number
    scoreFactors: number
    systemGenerated: number
    convertedAt: number
    rfp: number
    status: number
    createdAt: number
    updatedAt: number
    city: number
    notes: number
    sourceDetail: number
    state: number
    postalCode: number
    address: number
    addressLine1: number
    addressLine2: number
    country: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    aiScore?: true
  }

  export type LeadSumAggregateInputType = {
    aiScore?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    orgId?: true
    publicId?: true
    sourceType?: true
    identityHash?: true
    company?: true
    contactName?: true
    email?: true
    phoneE164?: true
    website?: true
    serviceCode?: true
    zip?: true
    aiScore?: true
    systemGenerated?: true
    convertedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    city?: true
    notes?: true
    sourceDetail?: true
    state?: true
    postalCode?: true
    address?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    orgId?: true
    publicId?: true
    sourceType?: true
    identityHash?: true
    company?: true
    contactName?: true
    email?: true
    phoneE164?: true
    website?: true
    serviceCode?: true
    zip?: true
    aiScore?: true
    systemGenerated?: true
    convertedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    city?: true
    notes?: true
    sourceDetail?: true
    state?: true
    postalCode?: true
    address?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    orgId?: true
    publicId?: true
    sourceType?: true
    identityHash?: true
    company?: true
    contactName?: true
    email?: true
    phoneE164?: true
    website?: true
    serviceCode?: true
    zip?: true
    enrichmentJson?: true
    aiScore?: true
    scoreFactors?: true
    systemGenerated?: true
    convertedAt?: true
    rfp?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    city?: true
    notes?: true
    sourceDetail?: true
    state?: true
    postalCode?: true
    address?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    orgId: string
    publicId: string
    sourceType: $Enums.LeadSource
    identityHash: string
    company: string | null
    contactName: string | null
    email: string | null
    phoneE164: string | null
    website: string | null
    serviceCode: string | null
    zip: string | null
    enrichmentJson: JsonValue
    aiScore: number
    scoreFactors: JsonValue
    systemGenerated: boolean
    convertedAt: Date | null
    rfp: JsonValue | null
    status: $Enums.LeadStatus
    createdAt: Date
    updatedAt: Date
    city: string | null
    notes: string | null
    sourceDetail: string | null
    state: string | null
    postalCode: string | null
    address: string | null
    addressLine1: string | null
    addressLine2: string | null
    country: string | null
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    sourceType?: boolean
    identityHash?: boolean
    company?: boolean
    contactName?: boolean
    email?: boolean
    phoneE164?: boolean
    website?: boolean
    serviceCode?: boolean
    zip?: boolean
    enrichmentJson?: boolean
    aiScore?: boolean
    scoreFactors?: boolean
    systemGenerated?: boolean
    convertedAt?: boolean
    rfp?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean
    notes?: boolean
    sourceDetail?: boolean
    state?: boolean
    postalCode?: boolean
    address?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
    LeadInvoiceLine?: boolean | Lead$LeadInvoiceLineArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    sourceType?: boolean
    identityHash?: boolean
    company?: boolean
    contactName?: boolean
    email?: boolean
    phoneE164?: boolean
    website?: boolean
    serviceCode?: boolean
    zip?: boolean
    enrichmentJson?: boolean
    aiScore?: boolean
    scoreFactors?: boolean
    systemGenerated?: boolean
    convertedAt?: boolean
    rfp?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean
    notes?: boolean
    sourceDetail?: boolean
    state?: boolean
    postalCode?: boolean
    address?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    sourceType?: boolean
    identityHash?: boolean
    company?: boolean
    contactName?: boolean
    email?: boolean
    phoneE164?: boolean
    website?: boolean
    serviceCode?: boolean
    zip?: boolean
    enrichmentJson?: boolean
    aiScore?: boolean
    scoreFactors?: boolean
    systemGenerated?: boolean
    convertedAt?: boolean
    rfp?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean
    notes?: boolean
    sourceDetail?: boolean
    state?: boolean
    postalCode?: boolean
    address?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    sourceType?: boolean
    identityHash?: boolean
    company?: boolean
    contactName?: boolean
    email?: boolean
    phoneE164?: boolean
    website?: boolean
    serviceCode?: boolean
    zip?: boolean
    enrichmentJson?: boolean
    aiScore?: boolean
    scoreFactors?: boolean
    systemGenerated?: boolean
    convertedAt?: boolean
    rfp?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean
    notes?: boolean
    sourceDetail?: boolean
    state?: boolean
    postalCode?: boolean
    address?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "publicId" | "sourceType" | "identityHash" | "company" | "contactName" | "email" | "phoneE164" | "website" | "serviceCode" | "zip" | "enrichmentJson" | "aiScore" | "scoreFactors" | "systemGenerated" | "convertedAt" | "rfp" | "status" | "createdAt" | "updatedAt" | "city" | "notes" | "sourceDetail" | "state" | "postalCode" | "address" | "addressLine1" | "addressLine2" | "country", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
    LeadInvoiceLine?: boolean | Lead$LeadInvoiceLineArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type LeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
      LeadInvoiceLine: Prisma.$LeadInvoiceLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      publicId: string
      sourceType: $Enums.LeadSource
      identityHash: string
      company: string | null
      contactName: string | null
      email: string | null
      phoneE164: string | null
      website: string | null
      serviceCode: string | null
      zip: string | null
      enrichmentJson: Prisma.JsonValue
      aiScore: number
      scoreFactors: Prisma.JsonValue
      /**
       * systemGenerated: true if lead came from SAM/automated import
       */
      systemGenerated: boolean
      /**
       * convertedAt: timestamp when lead was converted (if status changes to converted)
       */
      convertedAt: Date | null
      /**
       * rfp: raw RFP metadata from SAM.gov
       */
      rfp: Prisma.JsonValue | null
      /**
       * Status of the lead. Stored as an enum rather than string for consistency.
       */
      status: $Enums.LeadStatus
      createdAt: Date
      updatedAt: Date
      city: string | null
      notes: string | null
      sourceDetail: string | null
      state: string | null
      postalCode: string | null
      address: string | null
      addressLine1: string | null
      addressLine2: string | null
      country: string | null
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads and returns the data updated in the database.
     * @param {LeadUpdateManyAndReturnArgs} args - Arguments to update many Leads.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    LeadInvoiceLine<T extends Lead$LeadInvoiceLineArgs<ExtArgs> = {}>(args?: Subset<T, Lead$LeadInvoiceLineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly orgId: FieldRef<"Lead", 'String'>
    readonly publicId: FieldRef<"Lead", 'String'>
    readonly sourceType: FieldRef<"Lead", 'LeadSource'>
    readonly identityHash: FieldRef<"Lead", 'String'>
    readonly company: FieldRef<"Lead", 'String'>
    readonly contactName: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly phoneE164: FieldRef<"Lead", 'String'>
    readonly website: FieldRef<"Lead", 'String'>
    readonly serviceCode: FieldRef<"Lead", 'String'>
    readonly zip: FieldRef<"Lead", 'String'>
    readonly enrichmentJson: FieldRef<"Lead", 'Json'>
    readonly aiScore: FieldRef<"Lead", 'Int'>
    readonly scoreFactors: FieldRef<"Lead", 'Json'>
    readonly systemGenerated: FieldRef<"Lead", 'Boolean'>
    readonly convertedAt: FieldRef<"Lead", 'DateTime'>
    readonly rfp: FieldRef<"Lead", 'Json'>
    readonly status: FieldRef<"Lead", 'LeadStatus'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
    readonly city: FieldRef<"Lead", 'String'>
    readonly notes: FieldRef<"Lead", 'String'>
    readonly sourceDetail: FieldRef<"Lead", 'String'>
    readonly state: FieldRef<"Lead", 'String'>
    readonly postalCode: FieldRef<"Lead", 'String'>
    readonly address: FieldRef<"Lead", 'String'>
    readonly addressLine1: FieldRef<"Lead", 'String'>
    readonly addressLine2: FieldRef<"Lead", 'String'>
    readonly country: FieldRef<"Lead", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead updateManyAndReturn
   */
  export type LeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead.LeadInvoiceLine
   */
  export type Lead$LeadInvoiceLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    where?: LeadInvoiceLineWhereInput
    orderBy?: LeadInvoiceLineOrderByWithRelationInput | LeadInvoiceLineOrderByWithRelationInput[]
    cursor?: LeadInvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadInvoiceLineScalarFieldEnum | LeadInvoiceLineScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    publicId: string | null
    company: string | null
    primaryName: string | null
    primaryEmail: string | null
    primaryPhone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    publicId: string | null
    company: string | null
    primaryName: string | null
    primaryEmail: string | null
    primaryPhone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    orgId: number
    publicId: number
    company: number
    primaryName: number
    primaryEmail: number
    primaryPhone: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    orgId?: true
    publicId?: true
    company?: true
    primaryName?: true
    primaryEmail?: true
    primaryPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    orgId?: true
    publicId?: true
    company?: true
    primaryName?: true
    primaryEmail?: true
    primaryPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    orgId?: true
    publicId?: true
    company?: true
    primaryName?: true
    primaryEmail?: true
    primaryPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    orgId: string
    publicId: string
    company: string | null
    primaryName: string | null
    primaryEmail: string | null
    primaryPhone: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    company?: boolean
    primaryName?: boolean
    primaryEmail?: boolean
    primaryPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    jobs?: boolean | Customer$jobsArgs<ExtArgs>
    opportunities?: boolean | Customer$opportunitiesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    company?: boolean
    primaryName?: boolean
    primaryEmail?: boolean
    primaryPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    company?: boolean
    primaryName?: boolean
    primaryEmail?: boolean
    primaryPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    company?: boolean
    primaryName?: boolean
    primaryEmail?: boolean
    primaryPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "publicId" | "company" | "primaryName" | "primaryEmail" | "primaryPhone" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    jobs?: boolean | Customer$jobsArgs<ExtArgs>
    opportunities?: boolean | Customer$opportunitiesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      jobs: Prisma.$JobPayload<ExtArgs>[]
      opportunities: Prisma.$OpportunityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      publicId: string
      company: string | null
      primaryName: string | null
      primaryEmail: string | null
      primaryPhone: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Customer$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends Customer$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    opportunities<T extends Customer$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly orgId: FieldRef<"Customer", 'String'>
    readonly publicId: FieldRef<"Customer", 'String'>
    readonly company: FieldRef<"Customer", 'String'>
    readonly primaryName: FieldRef<"Customer", 'String'>
    readonly primaryEmail: FieldRef<"Customer", 'String'>
    readonly primaryPhone: FieldRef<"Customer", 'String'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.invoices
   */
  export type Customer$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Customer.jobs
   */
  export type Customer$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Customer.opportunities
   */
  export type Customer$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Opportunity
   */

  export type AggregateOpportunity = {
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  export type OpportunityAvgAggregateOutputType = {
    estValue: Decimal | null
  }

  export type OpportunitySumAggregateOutputType = {
    estValue: Decimal | null
  }

  export type OpportunityMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    customerId: string | null
    valueType: $Enums.ValueType | null
    estValue: Decimal | null
    stage: string | null
    ownerId: string | null
    sourceLeadId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpportunityMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    customerId: string | null
    valueType: $Enums.ValueType | null
    estValue: Decimal | null
    stage: string | null
    ownerId: string | null
    sourceLeadId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpportunityCountAggregateOutputType = {
    id: number
    orgId: number
    customerId: number
    valueType: number
    estValue: number
    stage: number
    ownerId: number
    sourceLeadId: number
    classification: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OpportunityAvgAggregateInputType = {
    estValue?: true
  }

  export type OpportunitySumAggregateInputType = {
    estValue?: true
  }

  export type OpportunityMinAggregateInputType = {
    id?: true
    orgId?: true
    customerId?: true
    valueType?: true
    estValue?: true
    stage?: true
    ownerId?: true
    sourceLeadId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpportunityMaxAggregateInputType = {
    id?: true
    orgId?: true
    customerId?: true
    valueType?: true
    estValue?: true
    stage?: true
    ownerId?: true
    sourceLeadId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpportunityCountAggregateInputType = {
    id?: true
    orgId?: true
    customerId?: true
    valueType?: true
    estValue?: true
    stage?: true
    ownerId?: true
    sourceLeadId?: true
    classification?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunity to aggregate.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Opportunities
    **/
    _count?: true | OpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityMaxAggregateInputType
  }

  export type GetOpportunityAggregateType<T extends OpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunity[P]>
      : GetScalarType<T[P], AggregateOpportunity[P]>
  }




  export type OpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithAggregationInput | OpportunityOrderByWithAggregationInput[]
    by: OpportunityScalarFieldEnum[] | OpportunityScalarFieldEnum
    having?: OpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityCountAggregateInputType | true
    _avg?: OpportunityAvgAggregateInputType
    _sum?: OpportunitySumAggregateInputType
    _min?: OpportunityMinAggregateInputType
    _max?: OpportunityMaxAggregateInputType
  }

  export type OpportunityGroupByOutputType = {
    id: string
    orgId: string
    customerId: string
    valueType: $Enums.ValueType
    estValue: Decimal | null
    stage: string
    ownerId: string | null
    sourceLeadId: string | null
    classification: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  type GetOpportunityGroupByPayload<T extends OpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
        }
      >
    >


  export type OpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    valueType?: boolean
    estValue?: boolean
    stage?: boolean
    ownerId?: boolean
    sourceLeadId?: boolean
    classification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    valueType?: boolean
    estValue?: boolean
    stage?: boolean
    ownerId?: boolean
    sourceLeadId?: boolean
    classification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    valueType?: boolean
    estValue?: boolean
    stage?: boolean
    ownerId?: boolean
    sourceLeadId?: boolean
    classification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectScalar = {
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    valueType?: boolean
    estValue?: boolean
    stage?: boolean
    ownerId?: boolean
    sourceLeadId?: boolean
    classification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OpportunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "customerId" | "valueType" | "estValue" | "stage" | "ownerId" | "sourceLeadId" | "classification" | "createdAt" | "updatedAt", ExtArgs["result"]["opportunity"]>
  export type OpportunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $OpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Opportunity"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      customerId: string
      valueType: $Enums.ValueType
      estValue: Prisma.Decimal | null
      stage: string
      ownerId: string | null
      sourceLeadId: string | null
      classification: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["opportunity"]>
    composites: {}
  }

  type OpportunityGetPayload<S extends boolean | null | undefined | OpportunityDefaultArgs> = $Result.GetResult<Prisma.$OpportunityPayload, S>

  type OpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpportunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpportunityCountAggregateInputType | true
    }

  export interface OpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Opportunity'], meta: { name: 'Opportunity' } }
    /**
     * Find zero or one Opportunity that matches the filter.
     * @param {OpportunityFindUniqueArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityFindUniqueArgs>(args: SelectSubset<T, OpportunityFindUniqueArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Opportunity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpportunityFindUniqueOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Opportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityFindFirstArgs>(args?: SelectSubset<T, OpportunityFindFirstArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Opportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Opportunities
     * const opportunities = await prisma.opportunity.findMany()
     * 
     * // Get first 10 Opportunities
     * const opportunities = await prisma.opportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityFindManyArgs>(args?: SelectSubset<T, OpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Opportunity.
     * @param {OpportunityCreateArgs} args - Arguments to create a Opportunity.
     * @example
     * // Create one Opportunity
     * const Opportunity = await prisma.opportunity.create({
     *   data: {
     *     // ... data to create a Opportunity
     *   }
     * })
     * 
     */
    create<T extends OpportunityCreateArgs>(args: SelectSubset<T, OpportunityCreateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Opportunities.
     * @param {OpportunityCreateManyArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityCreateManyArgs>(args?: SelectSubset<T, OpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Opportunities and returns the data saved in the database.
     * @param {OpportunityCreateManyAndReturnArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Opportunity.
     * @param {OpportunityDeleteArgs} args - Arguments to delete one Opportunity.
     * @example
     * // Delete one Opportunity
     * const Opportunity = await prisma.opportunity.delete({
     *   where: {
     *     // ... filter to delete one Opportunity
     *   }
     * })
     * 
     */
    delete<T extends OpportunityDeleteArgs>(args: SelectSubset<T, OpportunityDeleteArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Opportunity.
     * @param {OpportunityUpdateArgs} args - Arguments to update one Opportunity.
     * @example
     * // Update one Opportunity
     * const opportunity = await prisma.opportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityUpdateArgs>(args: SelectSubset<T, OpportunityUpdateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Opportunities.
     * @param {OpportunityDeleteManyArgs} args - Arguments to filter Opportunities to delete.
     * @example
     * // Delete a few Opportunities
     * const { count } = await prisma.opportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityDeleteManyArgs>(args?: SelectSubset<T, OpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityUpdateManyArgs>(args: SelectSubset<T, OpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities and returns the data updated in the database.
     * @param {OpportunityUpdateManyAndReturnArgs} args - Arguments to update many Opportunities.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpportunityUpdateManyAndReturnArgs>(args: SelectSubset<T, OpportunityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Opportunity.
     * @param {OpportunityUpsertArgs} args - Arguments to update or create a Opportunity.
     * @example
     * // Update or create a Opportunity
     * const opportunity = await prisma.opportunity.upsert({
     *   create: {
     *     // ... data to create a Opportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Opportunity we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityUpsertArgs>(args: SelectSubset<T, OpportunityUpsertArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityCountArgs} args - Arguments to filter Opportunities to count.
     * @example
     * // Count the number of Opportunities
     * const count = await prisma.opportunity.count({
     *   where: {
     *     // ... the filter for the Opportunities we want to count
     *   }
     * })
    **/
    count<T extends OpportunityCountArgs>(
      args?: Subset<T, OpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityAggregateArgs>(args: Subset<T, OpportunityAggregateArgs>): Prisma.PrismaPromise<GetOpportunityAggregateType<T>>

    /**
     * Group by Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Opportunity model
   */
  readonly fields: OpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Opportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Opportunity model
   */
  interface OpportunityFieldRefs {
    readonly id: FieldRef<"Opportunity", 'String'>
    readonly orgId: FieldRef<"Opportunity", 'String'>
    readonly customerId: FieldRef<"Opportunity", 'String'>
    readonly valueType: FieldRef<"Opportunity", 'ValueType'>
    readonly estValue: FieldRef<"Opportunity", 'Decimal'>
    readonly stage: FieldRef<"Opportunity", 'String'>
    readonly ownerId: FieldRef<"Opportunity", 'String'>
    readonly sourceLeadId: FieldRef<"Opportunity", 'String'>
    readonly classification: FieldRef<"Opportunity", 'Json'>
    readonly createdAt: FieldRef<"Opportunity", 'DateTime'>
    readonly updatedAt: FieldRef<"Opportunity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Opportunity findUnique
   */
  export type OpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findUniqueOrThrow
   */
  export type OpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findFirst
   */
  export type OpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findFirstOrThrow
   */
  export type OpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findMany
   */
  export type OpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunities to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity create
   */
  export type OpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Opportunity.
     */
    data: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
  }

  /**
   * Opportunity createMany
   */
  export type OpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Opportunity createManyAndReturn
   */
  export type OpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity update
   */
  export type OpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Opportunity.
     */
    data: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
    /**
     * Choose, which Opportunity to update.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity updateMany
   */
  export type OpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to update.
     */
    limit?: number
  }

  /**
   * Opportunity updateManyAndReturn
   */
  export type OpportunityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity upsert
   */
  export type OpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Opportunity to update in case it exists.
     */
    where: OpportunityWhereUniqueInput
    /**
     * In case the Opportunity found by the `where` argument doesn't exist, create a new Opportunity with this data.
     */
    create: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
    /**
     * In case the Opportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
  }

  /**
   * Opportunity delete
   */
  export type OpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter which Opportunity to delete.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity deleteMany
   */
  export type OpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunities to delete
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to delete.
     */
    limit?: number
  }

  /**
   * Opportunity without action
   */
  export type OpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    customerId: string | null
    amount: Decimal | null
    status: string | null
    issuedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    customerId: string | null
    amount: Decimal | null
    status: string | null
    issuedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    orgId: number
    customerId: number
    amount: number
    status: number
    issuedAt: number
    items: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    orgId?: true
    customerId?: true
    amount?: true
    status?: true
    issuedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    orgId?: true
    customerId?: true
    amount?: true
    status?: true
    issuedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    orgId?: true
    customerId?: true
    amount?: true
    status?: true
    issuedAt?: true
    items?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    orgId: string
    customerId: string | null
    amount: Decimal
    status: string
    issuedAt: Date
    items: JsonValue
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    amount?: boolean
    status?: boolean
    issuedAt?: boolean
    items?: boolean
    lineItems?: boolean | Invoice$lineItemsArgs<ExtArgs>
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    amount?: boolean
    status?: boolean
    issuedAt?: boolean
    items?: boolean
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    amount?: boolean
    status?: boolean
    issuedAt?: boolean
    items?: boolean
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    amount?: boolean
    status?: boolean
    issuedAt?: boolean
    items?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "customerId" | "amount" | "status" | "issuedAt" | "items", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | Invoice$lineItemsArgs<ExtArgs>
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      lineItems: Prisma.$InvoiceLinePayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      org: Prisma.$OrgPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      customerId: string | null
      amount: Prisma.Decimal
      status: string
      issuedAt: Date
      items: Prisma.JsonValue
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lineItems<T extends Invoice$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends Invoice$customerArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly orgId: FieldRef<"Invoice", 'String'>
    readonly customerId: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly issuedAt: FieldRef<"Invoice", 'DateTime'>
    readonly items: FieldRef<"Invoice", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.lineItems
   */
  export type Invoice$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * Invoice.customer
   */
  export type Invoice$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
    retryCount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
    retryCount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    invoiceId: string | null
    amount: Decimal | null
    method: string | null
    receivedAt: Date | null
    reference: string | null
    status: string | null
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    failureReason: string | null
    retryCount: number | null
    lastRetryAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    invoiceId: string | null
    amount: Decimal | null
    method: string | null
    receivedAt: Date | null
    reference: string | null
    status: string | null
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    failureReason: string | null
    retryCount: number | null
    lastRetryAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orgId: number
    invoiceId: number
    amount: number
    method: number
    receivedAt: number
    reference: number
    status: number
    stripePaymentIntentId: number
    stripeChargeId: number
    failureReason: number
    retryCount: number
    lastRetryAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    retryCount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    retryCount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orgId?: true
    invoiceId?: true
    amount?: true
    method?: true
    receivedAt?: true
    reference?: true
    status?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    failureReason?: true
    retryCount?: true
    lastRetryAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orgId?: true
    invoiceId?: true
    amount?: true
    method?: true
    receivedAt?: true
    reference?: true
    status?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    failureReason?: true
    retryCount?: true
    lastRetryAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orgId?: true
    invoiceId?: true
    amount?: true
    method?: true
    receivedAt?: true
    reference?: true
    status?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    failureReason?: true
    retryCount?: true
    lastRetryAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    orgId: string
    invoiceId: string | null
    amount: Decimal
    method: string
    receivedAt: Date
    reference: string | null
    status: string
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    failureReason: string | null
    retryCount: number
    lastRetryAt: Date | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    invoiceId?: boolean
    amount?: boolean
    method?: boolean
    receivedAt?: boolean
    reference?: boolean
    status?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    failureReason?: boolean
    retryCount?: boolean
    lastRetryAt?: boolean
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    invoiceId?: boolean
    amount?: boolean
    method?: boolean
    receivedAt?: boolean
    reference?: boolean
    status?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    failureReason?: boolean
    retryCount?: boolean
    lastRetryAt?: boolean
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    invoiceId?: boolean
    amount?: boolean
    method?: boolean
    receivedAt?: boolean
    reference?: boolean
    status?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    failureReason?: boolean
    retryCount?: boolean
    lastRetryAt?: boolean
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    orgId?: boolean
    invoiceId?: boolean
    amount?: boolean
    method?: boolean
    receivedAt?: boolean
    reference?: boolean
    status?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    failureReason?: boolean
    retryCount?: boolean
    lastRetryAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "invoiceId" | "amount" | "method" | "receivedAt" | "reference" | "status" | "stripePaymentIntentId" | "stripeChargeId" | "failureReason" | "retryCount" | "lastRetryAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      invoiceId: string | null
      amount: Prisma.Decimal
      method: string
      receivedAt: Date
      reference: string | null
      status: string
      stripePaymentIntentId: string | null
      stripeChargeId: string | null
      failureReason: string | null
      retryCount: number
      lastRetryAt: Date | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends Payment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly orgId: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly receivedAt: FieldRef<"Payment", 'DateTime'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly stripePaymentIntentId: FieldRef<"Payment", 'String'>
    readonly stripeChargeId: FieldRef<"Payment", 'String'>
    readonly failureReason: FieldRef<"Payment", 'String'>
    readonly retryCount: FieldRef<"Payment", 'Int'>
    readonly lastRetryAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.invoice
   */
  export type Payment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Rfp
   */

  export type AggregateRfp = {
    _count: RfpCountAggregateOutputType | null
    _avg: RfpAvgAggregateOutputType | null
    _sum: RfpSumAggregateOutputType | null
    _min: RfpMinAggregateOutputType | null
    _max: RfpMaxAggregateOutputType | null
  }

  export type RfpAvgAggregateOutputType = {
    aiBidFit: number | null
  }

  export type RfpSumAggregateOutputType = {
    aiBidFit: number | null
  }

  export type RfpMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    publicId: string | null
    sourceSite: string | null
    title: string | null
    dueDate: Date | null
    aiBidFit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RfpMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    publicId: string | null
    sourceSite: string | null
    title: string | null
    dueDate: Date | null
    aiBidFit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RfpCountAggregateOutputType = {
    id: number
    orgId: number
    publicId: number
    sourceSite: number
    title: number
    dueDate: number
    docs: number
    aiBidFit: number
    aiPriceHint: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RfpAvgAggregateInputType = {
    aiBidFit?: true
  }

  export type RfpSumAggregateInputType = {
    aiBidFit?: true
  }

  export type RfpMinAggregateInputType = {
    id?: true
    orgId?: true
    publicId?: true
    sourceSite?: true
    title?: true
    dueDate?: true
    aiBidFit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RfpMaxAggregateInputType = {
    id?: true
    orgId?: true
    publicId?: true
    sourceSite?: true
    title?: true
    dueDate?: true
    aiBidFit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RfpCountAggregateInputType = {
    id?: true
    orgId?: true
    publicId?: true
    sourceSite?: true
    title?: true
    dueDate?: true
    docs?: true
    aiBidFit?: true
    aiPriceHint?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RfpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rfp to aggregate.
     */
    where?: RfpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rfps to fetch.
     */
    orderBy?: RfpOrderByWithRelationInput | RfpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RfpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rfps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rfps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rfps
    **/
    _count?: true | RfpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RfpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RfpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RfpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RfpMaxAggregateInputType
  }

  export type GetRfpAggregateType<T extends RfpAggregateArgs> = {
        [P in keyof T & keyof AggregateRfp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRfp[P]>
      : GetScalarType<T[P], AggregateRfp[P]>
  }




  export type RfpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RfpWhereInput
    orderBy?: RfpOrderByWithAggregationInput | RfpOrderByWithAggregationInput[]
    by: RfpScalarFieldEnum[] | RfpScalarFieldEnum
    having?: RfpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RfpCountAggregateInputType | true
    _avg?: RfpAvgAggregateInputType
    _sum?: RfpSumAggregateInputType
    _min?: RfpMinAggregateInputType
    _max?: RfpMaxAggregateInputType
  }

  export type RfpGroupByOutputType = {
    id: string
    orgId: string
    publicId: string
    sourceSite: string
    title: string
    dueDate: Date | null
    docs: JsonValue
    aiBidFit: number | null
    aiPriceHint: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: RfpCountAggregateOutputType | null
    _avg: RfpAvgAggregateOutputType | null
    _sum: RfpSumAggregateOutputType | null
    _min: RfpMinAggregateOutputType | null
    _max: RfpMaxAggregateOutputType | null
  }

  type GetRfpGroupByPayload<T extends RfpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RfpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RfpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RfpGroupByOutputType[P]>
            : GetScalarType<T[P], RfpGroupByOutputType[P]>
        }
      >
    >


  export type RfpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    sourceSite?: boolean
    title?: boolean
    dueDate?: boolean
    docs?: boolean
    aiBidFit?: boolean
    aiPriceHint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobs?: boolean | Rfp$jobsArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
    _count?: boolean | RfpCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rfp"]>

  export type RfpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    sourceSite?: boolean
    title?: boolean
    dueDate?: boolean
    docs?: boolean
    aiBidFit?: boolean
    aiPriceHint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rfp"]>

  export type RfpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    sourceSite?: boolean
    title?: boolean
    dueDate?: boolean
    docs?: boolean
    aiBidFit?: boolean
    aiPriceHint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rfp"]>

  export type RfpSelectScalar = {
    id?: boolean
    orgId?: boolean
    publicId?: boolean
    sourceSite?: boolean
    title?: boolean
    dueDate?: boolean
    docs?: boolean
    aiBidFit?: boolean
    aiPriceHint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RfpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "publicId" | "sourceSite" | "title" | "dueDate" | "docs" | "aiBidFit" | "aiPriceHint" | "createdAt" | "updatedAt", ExtArgs["result"]["rfp"]>
  export type RfpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | Rfp$jobsArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
    _count?: boolean | RfpCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RfpIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type RfpIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $RfpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rfp"
    objects: {
      jobs: Prisma.$JobPayload<ExtArgs>[]
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      publicId: string
      sourceSite: string
      title: string
      dueDate: Date | null
      docs: Prisma.JsonValue
      aiBidFit: number | null
      aiPriceHint: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rfp"]>
    composites: {}
  }

  type RfpGetPayload<S extends boolean | null | undefined | RfpDefaultArgs> = $Result.GetResult<Prisma.$RfpPayload, S>

  type RfpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RfpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RfpCountAggregateInputType | true
    }

  export interface RfpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rfp'], meta: { name: 'Rfp' } }
    /**
     * Find zero or one Rfp that matches the filter.
     * @param {RfpFindUniqueArgs} args - Arguments to find a Rfp
     * @example
     * // Get one Rfp
     * const rfp = await prisma.rfp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RfpFindUniqueArgs>(args: SelectSubset<T, RfpFindUniqueArgs<ExtArgs>>): Prisma__RfpClient<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rfp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RfpFindUniqueOrThrowArgs} args - Arguments to find a Rfp
     * @example
     * // Get one Rfp
     * const rfp = await prisma.rfp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RfpFindUniqueOrThrowArgs>(args: SelectSubset<T, RfpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RfpClient<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rfp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfpFindFirstArgs} args - Arguments to find a Rfp
     * @example
     * // Get one Rfp
     * const rfp = await prisma.rfp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RfpFindFirstArgs>(args?: SelectSubset<T, RfpFindFirstArgs<ExtArgs>>): Prisma__RfpClient<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rfp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfpFindFirstOrThrowArgs} args - Arguments to find a Rfp
     * @example
     * // Get one Rfp
     * const rfp = await prisma.rfp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RfpFindFirstOrThrowArgs>(args?: SelectSubset<T, RfpFindFirstOrThrowArgs<ExtArgs>>): Prisma__RfpClient<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rfps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rfps
     * const rfps = await prisma.rfp.findMany()
     * 
     * // Get first 10 Rfps
     * const rfps = await prisma.rfp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rfpWithIdOnly = await prisma.rfp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RfpFindManyArgs>(args?: SelectSubset<T, RfpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rfp.
     * @param {RfpCreateArgs} args - Arguments to create a Rfp.
     * @example
     * // Create one Rfp
     * const Rfp = await prisma.rfp.create({
     *   data: {
     *     // ... data to create a Rfp
     *   }
     * })
     * 
     */
    create<T extends RfpCreateArgs>(args: SelectSubset<T, RfpCreateArgs<ExtArgs>>): Prisma__RfpClient<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rfps.
     * @param {RfpCreateManyArgs} args - Arguments to create many Rfps.
     * @example
     * // Create many Rfps
     * const rfp = await prisma.rfp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RfpCreateManyArgs>(args?: SelectSubset<T, RfpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rfps and returns the data saved in the database.
     * @param {RfpCreateManyAndReturnArgs} args - Arguments to create many Rfps.
     * @example
     * // Create many Rfps
     * const rfp = await prisma.rfp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rfps and only return the `id`
     * const rfpWithIdOnly = await prisma.rfp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RfpCreateManyAndReturnArgs>(args?: SelectSubset<T, RfpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rfp.
     * @param {RfpDeleteArgs} args - Arguments to delete one Rfp.
     * @example
     * // Delete one Rfp
     * const Rfp = await prisma.rfp.delete({
     *   where: {
     *     // ... filter to delete one Rfp
     *   }
     * })
     * 
     */
    delete<T extends RfpDeleteArgs>(args: SelectSubset<T, RfpDeleteArgs<ExtArgs>>): Prisma__RfpClient<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rfp.
     * @param {RfpUpdateArgs} args - Arguments to update one Rfp.
     * @example
     * // Update one Rfp
     * const rfp = await prisma.rfp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RfpUpdateArgs>(args: SelectSubset<T, RfpUpdateArgs<ExtArgs>>): Prisma__RfpClient<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rfps.
     * @param {RfpDeleteManyArgs} args - Arguments to filter Rfps to delete.
     * @example
     * // Delete a few Rfps
     * const { count } = await prisma.rfp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RfpDeleteManyArgs>(args?: SelectSubset<T, RfpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rfps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rfps
     * const rfp = await prisma.rfp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RfpUpdateManyArgs>(args: SelectSubset<T, RfpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rfps and returns the data updated in the database.
     * @param {RfpUpdateManyAndReturnArgs} args - Arguments to update many Rfps.
     * @example
     * // Update many Rfps
     * const rfp = await prisma.rfp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rfps and only return the `id`
     * const rfpWithIdOnly = await prisma.rfp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RfpUpdateManyAndReturnArgs>(args: SelectSubset<T, RfpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rfp.
     * @param {RfpUpsertArgs} args - Arguments to update or create a Rfp.
     * @example
     * // Update or create a Rfp
     * const rfp = await prisma.rfp.upsert({
     *   create: {
     *     // ... data to create a Rfp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rfp we want to update
     *   }
     * })
     */
    upsert<T extends RfpUpsertArgs>(args: SelectSubset<T, RfpUpsertArgs<ExtArgs>>): Prisma__RfpClient<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rfps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfpCountArgs} args - Arguments to filter Rfps to count.
     * @example
     * // Count the number of Rfps
     * const count = await prisma.rfp.count({
     *   where: {
     *     // ... the filter for the Rfps we want to count
     *   }
     * })
    **/
    count<T extends RfpCountArgs>(
      args?: Subset<T, RfpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RfpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rfp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RfpAggregateArgs>(args: Subset<T, RfpAggregateArgs>): Prisma.PrismaPromise<GetRfpAggregateType<T>>

    /**
     * Group by Rfp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RfpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RfpGroupByArgs['orderBy'] }
        : { orderBy?: RfpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RfpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRfpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rfp model
   */
  readonly fields: RfpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rfp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RfpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends Rfp$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Rfp$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rfp model
   */
  interface RfpFieldRefs {
    readonly id: FieldRef<"Rfp", 'String'>
    readonly orgId: FieldRef<"Rfp", 'String'>
    readonly publicId: FieldRef<"Rfp", 'String'>
    readonly sourceSite: FieldRef<"Rfp", 'String'>
    readonly title: FieldRef<"Rfp", 'String'>
    readonly dueDate: FieldRef<"Rfp", 'DateTime'>
    readonly docs: FieldRef<"Rfp", 'Json'>
    readonly aiBidFit: FieldRef<"Rfp", 'Int'>
    readonly aiPriceHint: FieldRef<"Rfp", 'Json'>
    readonly createdAt: FieldRef<"Rfp", 'DateTime'>
    readonly updatedAt: FieldRef<"Rfp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rfp findUnique
   */
  export type RfpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    /**
     * Filter, which Rfp to fetch.
     */
    where: RfpWhereUniqueInput
  }

  /**
   * Rfp findUniqueOrThrow
   */
  export type RfpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    /**
     * Filter, which Rfp to fetch.
     */
    where: RfpWhereUniqueInput
  }

  /**
   * Rfp findFirst
   */
  export type RfpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    /**
     * Filter, which Rfp to fetch.
     */
    where?: RfpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rfps to fetch.
     */
    orderBy?: RfpOrderByWithRelationInput | RfpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rfps.
     */
    cursor?: RfpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rfps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rfps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rfps.
     */
    distinct?: RfpScalarFieldEnum | RfpScalarFieldEnum[]
  }

  /**
   * Rfp findFirstOrThrow
   */
  export type RfpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    /**
     * Filter, which Rfp to fetch.
     */
    where?: RfpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rfps to fetch.
     */
    orderBy?: RfpOrderByWithRelationInput | RfpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rfps.
     */
    cursor?: RfpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rfps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rfps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rfps.
     */
    distinct?: RfpScalarFieldEnum | RfpScalarFieldEnum[]
  }

  /**
   * Rfp findMany
   */
  export type RfpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    /**
     * Filter, which Rfps to fetch.
     */
    where?: RfpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rfps to fetch.
     */
    orderBy?: RfpOrderByWithRelationInput | RfpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rfps.
     */
    cursor?: RfpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rfps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rfps.
     */
    skip?: number
    distinct?: RfpScalarFieldEnum | RfpScalarFieldEnum[]
  }

  /**
   * Rfp create
   */
  export type RfpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    /**
     * The data needed to create a Rfp.
     */
    data: XOR<RfpCreateInput, RfpUncheckedCreateInput>
  }

  /**
   * Rfp createMany
   */
  export type RfpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rfps.
     */
    data: RfpCreateManyInput | RfpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rfp createManyAndReturn
   */
  export type RfpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * The data used to create many Rfps.
     */
    data: RfpCreateManyInput | RfpCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rfp update
   */
  export type RfpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    /**
     * The data needed to update a Rfp.
     */
    data: XOR<RfpUpdateInput, RfpUncheckedUpdateInput>
    /**
     * Choose, which Rfp to update.
     */
    where: RfpWhereUniqueInput
  }

  /**
   * Rfp updateMany
   */
  export type RfpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rfps.
     */
    data: XOR<RfpUpdateManyMutationInput, RfpUncheckedUpdateManyInput>
    /**
     * Filter which Rfps to update
     */
    where?: RfpWhereInput
    /**
     * Limit how many Rfps to update.
     */
    limit?: number
  }

  /**
   * Rfp updateManyAndReturn
   */
  export type RfpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * The data used to update Rfps.
     */
    data: XOR<RfpUpdateManyMutationInput, RfpUncheckedUpdateManyInput>
    /**
     * Filter which Rfps to update
     */
    where?: RfpWhereInput
    /**
     * Limit how many Rfps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rfp upsert
   */
  export type RfpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    /**
     * The filter to search for the Rfp to update in case it exists.
     */
    where: RfpWhereUniqueInput
    /**
     * In case the Rfp found by the `where` argument doesn't exist, create a new Rfp with this data.
     */
    create: XOR<RfpCreateInput, RfpUncheckedCreateInput>
    /**
     * In case the Rfp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RfpUpdateInput, RfpUncheckedUpdateInput>
  }

  /**
   * Rfp delete
   */
  export type RfpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    /**
     * Filter which Rfp to delete.
     */
    where: RfpWhereUniqueInput
  }

  /**
   * Rfp deleteMany
   */
  export type RfpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rfps to delete
     */
    where?: RfpWhereInput
    /**
     * Limit how many Rfps to delete.
     */
    limit?: number
  }

  /**
   * Rfp.jobs
   */
  export type Rfp$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Rfp without action
   */
  export type RfpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    customerId: string | null
    rfpId: string | null
    status: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    customerId: string | null
    rfpId: string | null
    status: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    orgId: number
    customerId: number
    rfpId: number
    status: number
    schedule: number
    assignedTo: number
    checklist: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobMinAggregateInputType = {
    id?: true
    orgId?: true
    customerId?: true
    rfpId?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    orgId?: true
    customerId?: true
    rfpId?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    orgId?: true
    customerId?: true
    rfpId?: true
    status?: true
    schedule?: true
    assignedTo?: true
    checklist?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: string
    orgId: string
    customerId: string | null
    rfpId: string | null
    status: string
    schedule: JsonValue
    assignedTo: string | null
    checklist: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: JobCountAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    rfpId?: boolean
    status?: boolean
    schedule?: boolean
    assignedTo?: boolean
    checklist?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Job$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
    rfp?: boolean | Job$rfpArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    rfpId?: boolean
    status?: boolean
    schedule?: boolean
    assignedTo?: boolean
    checklist?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Job$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
    rfp?: boolean | Job$rfpArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    rfpId?: boolean
    status?: boolean
    schedule?: boolean
    assignedTo?: boolean
    checklist?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Job$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
    rfp?: boolean | Job$rfpArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectScalar = {
    id?: boolean
    orgId?: boolean
    customerId?: boolean
    rfpId?: boolean
    status?: boolean
    schedule?: boolean
    assignedTo?: boolean
    checklist?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "customerId" | "rfpId" | "status" | "schedule" | "assignedTo" | "checklist" | "createdAt" | "updatedAt", ExtArgs["result"]["job"]>
  export type JobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Job$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
    rfp?: boolean | Job$rfpArgs<ExtArgs>
  }
  export type JobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Job$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
    rfp?: boolean | Job$rfpArgs<ExtArgs>
  }
  export type JobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Job$customerArgs<ExtArgs>
    org?: boolean | OrgDefaultArgs<ExtArgs>
    rfp?: boolean | Job$rfpArgs<ExtArgs>
  }

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      org: Prisma.$OrgPayload<ExtArgs>
      rfp: Prisma.$RfpPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      customerId: string | null
      rfpId: string | null
      status: string
      schedule: Prisma.JsonValue
      assignedTo: string | null
      checklist: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {JobUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobUpdateManyAndReturnArgs>(args: SelectSubset<T, JobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Job$customerArgs<ExtArgs> = {}>(args?: Subset<T, Job$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rfp<T extends Job$rfpArgs<ExtArgs> = {}>(args?: Subset<T, Job$rfpArgs<ExtArgs>>): Prisma__RfpClient<$Result.GetResult<Prisma.$RfpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'String'>
    readonly orgId: FieldRef<"Job", 'String'>
    readonly customerId: FieldRef<"Job", 'String'>
    readonly rfpId: FieldRef<"Job", 'String'>
    readonly status: FieldRef<"Job", 'String'>
    readonly schedule: FieldRef<"Job", 'Json'>
    readonly assignedTo: FieldRef<"Job", 'String'>
    readonly checklist: FieldRef<"Job", 'Json'>
    readonly createdAt: FieldRef<"Job", 'DateTime'>
    readonly updatedAt: FieldRef<"Job", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job createManyAndReturn
   */
  export type JobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
  }

  /**
   * Job updateManyAndReturn
   */
  export type JobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to delete.
     */
    limit?: number
  }

  /**
   * Job.customer
   */
  export type Job$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Job.rfp
   */
  export type Job$rfpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rfp
     */
    select?: RfpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rfp
     */
    omit?: RfpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfpInclude<ExtArgs> | null
    where?: RfpWhereInput
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    employeeId: string | null
    referredName: string | null
    referredEmail: string | null
    referredPhone: string | null
    status: string | null
    convertedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    employeeId: string | null
    referredName: string | null
    referredEmail: string | null
    referredPhone: string | null
    status: string | null
    convertedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    orgId: number
    employeeId: number
    referredName: number
    referredEmail: number
    referredPhone: number
    status: number
    convertedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralMinAggregateInputType = {
    id?: true
    orgId?: true
    employeeId?: true
    referredName?: true
    referredEmail?: true
    referredPhone?: true
    status?: true
    convertedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    orgId?: true
    employeeId?: true
    referredName?: true
    referredEmail?: true
    referredPhone?: true
    status?: true
    convertedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    orgId?: true
    employeeId?: true
    referredName?: true
    referredEmail?: true
    referredPhone?: true
    status?: true
    convertedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    orgId: string
    employeeId: string | null
    referredName: string
    referredEmail: string | null
    referredPhone: string | null
    status: string
    convertedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    employeeId?: boolean
    referredName?: boolean
    referredEmail?: boolean
    referredPhone?: boolean
    status?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    employeeId?: boolean
    referredName?: boolean
    referredEmail?: boolean
    referredPhone?: boolean
    status?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    employeeId?: boolean
    referredName?: boolean
    referredEmail?: boolean
    referredPhone?: boolean
    status?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    orgId?: boolean
    employeeId?: boolean
    referredName?: boolean
    referredEmail?: boolean
    referredPhone?: boolean
    status?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "employeeId" | "referredName" | "referredEmail" | "referredPhone" | "status" | "convertedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["referral"]>
  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      employeeId: string | null
      referredName: string
      referredEmail: string | null
      referredPhone: string | null
      status: string
      convertedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals and returns the data updated in the database.
     * @param {ReferralUpdateManyAndReturnArgs} args - Arguments to update many Referrals.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly orgId: FieldRef<"Referral", 'String'>
    readonly employeeId: FieldRef<"Referral", 'String'>
    readonly referredName: FieldRef<"Referral", 'String'>
    readonly referredEmail: FieldRef<"Referral", 'String'>
    readonly referredPhone: FieldRef<"Referral", 'String'>
    readonly status: FieldRef<"Referral", 'String'>
    readonly convertedAt: FieldRef<"Referral", 'DateTime'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
    readonly updatedAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral updateManyAndReturn
   */
  export type ReferralUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model BillingLedger
   */

  export type AggregateBillingLedger = {
    _count: BillingLedgerCountAggregateOutputType | null
    _avg: BillingLedgerAvgAggregateOutputType | null
    _sum: BillingLedgerSumAggregateOutputType | null
    _min: BillingLedgerMinAggregateOutputType | null
    _max: BillingLedgerMaxAggregateOutputType | null
  }

  export type BillingLedgerAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type BillingLedgerSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type BillingLedgerMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    type: $Enums.LedgerType | null
    amount: Decimal | null
    createdAt: Date | null
  }

  export type BillingLedgerMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    type: $Enums.LedgerType | null
    amount: Decimal | null
    createdAt: Date | null
  }

  export type BillingLedgerCountAggregateOutputType = {
    id: number
    orgId: number
    type: number
    amount: number
    meta: number
    createdAt: number
    _all: number
  }


  export type BillingLedgerAvgAggregateInputType = {
    amount?: true
  }

  export type BillingLedgerSumAggregateInputType = {
    amount?: true
  }

  export type BillingLedgerMinAggregateInputType = {
    id?: true
    orgId?: true
    type?: true
    amount?: true
    createdAt?: true
  }

  export type BillingLedgerMaxAggregateInputType = {
    id?: true
    orgId?: true
    type?: true
    amount?: true
    createdAt?: true
  }

  export type BillingLedgerCountAggregateInputType = {
    id?: true
    orgId?: true
    type?: true
    amount?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type BillingLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingLedger to aggregate.
     */
    where?: BillingLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingLedgers to fetch.
     */
    orderBy?: BillingLedgerOrderByWithRelationInput | BillingLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingLedgers
    **/
    _count?: true | BillingLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingLedgerMaxAggregateInputType
  }

  export type GetBillingLedgerAggregateType<T extends BillingLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingLedger[P]>
      : GetScalarType<T[P], AggregateBillingLedger[P]>
  }




  export type BillingLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingLedgerWhereInput
    orderBy?: BillingLedgerOrderByWithAggregationInput | BillingLedgerOrderByWithAggregationInput[]
    by: BillingLedgerScalarFieldEnum[] | BillingLedgerScalarFieldEnum
    having?: BillingLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingLedgerCountAggregateInputType | true
    _avg?: BillingLedgerAvgAggregateInputType
    _sum?: BillingLedgerSumAggregateInputType
    _min?: BillingLedgerMinAggregateInputType
    _max?: BillingLedgerMaxAggregateInputType
  }

  export type BillingLedgerGroupByOutputType = {
    id: string
    orgId: string
    type: $Enums.LedgerType
    amount: Decimal
    meta: JsonValue
    createdAt: Date
    _count: BillingLedgerCountAggregateOutputType | null
    _avg: BillingLedgerAvgAggregateOutputType | null
    _sum: BillingLedgerSumAggregateOutputType | null
    _min: BillingLedgerMinAggregateOutputType | null
    _max: BillingLedgerMaxAggregateOutputType | null
  }

  type GetBillingLedgerGroupByPayload<T extends BillingLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], BillingLedgerGroupByOutputType[P]>
        }
      >
    >


  export type BillingLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    type?: boolean
    amount?: boolean
    meta?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingLedger"]>

  export type BillingLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    type?: boolean
    amount?: boolean
    meta?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingLedger"]>

  export type BillingLedgerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    type?: boolean
    amount?: boolean
    meta?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingLedger"]>

  export type BillingLedgerSelectScalar = {
    id?: boolean
    orgId?: boolean
    type?: boolean
    amount?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type BillingLedgerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "type" | "amount" | "meta" | "createdAt", ExtArgs["result"]["billingLedger"]>
  export type BillingLedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type BillingLedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type BillingLedgerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $BillingLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingLedger"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      type: $Enums.LedgerType
      amount: Prisma.Decimal
      meta: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["billingLedger"]>
    composites: {}
  }

  type BillingLedgerGetPayload<S extends boolean | null | undefined | BillingLedgerDefaultArgs> = $Result.GetResult<Prisma.$BillingLedgerPayload, S>

  type BillingLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingLedgerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingLedgerCountAggregateInputType | true
    }

  export interface BillingLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingLedger'], meta: { name: 'BillingLedger' } }
    /**
     * Find zero or one BillingLedger that matches the filter.
     * @param {BillingLedgerFindUniqueArgs} args - Arguments to find a BillingLedger
     * @example
     * // Get one BillingLedger
     * const billingLedger = await prisma.billingLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingLedgerFindUniqueArgs>(args: SelectSubset<T, BillingLedgerFindUniqueArgs<ExtArgs>>): Prisma__BillingLedgerClient<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingLedger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingLedgerFindUniqueOrThrowArgs} args - Arguments to find a BillingLedger
     * @example
     * // Get one BillingLedger
     * const billingLedger = await prisma.billingLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingLedgerClient<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingLedgerFindFirstArgs} args - Arguments to find a BillingLedger
     * @example
     * // Get one BillingLedger
     * const billingLedger = await prisma.billingLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingLedgerFindFirstArgs>(args?: SelectSubset<T, BillingLedgerFindFirstArgs<ExtArgs>>): Prisma__BillingLedgerClient<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingLedgerFindFirstOrThrowArgs} args - Arguments to find a BillingLedger
     * @example
     * // Get one BillingLedger
     * const billingLedger = await prisma.billingLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingLedgerClient<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingLedgers
     * const billingLedgers = await prisma.billingLedger.findMany()
     * 
     * // Get first 10 BillingLedgers
     * const billingLedgers = await prisma.billingLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingLedgerWithIdOnly = await prisma.billingLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingLedgerFindManyArgs>(args?: SelectSubset<T, BillingLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingLedger.
     * @param {BillingLedgerCreateArgs} args - Arguments to create a BillingLedger.
     * @example
     * // Create one BillingLedger
     * const BillingLedger = await prisma.billingLedger.create({
     *   data: {
     *     // ... data to create a BillingLedger
     *   }
     * })
     * 
     */
    create<T extends BillingLedgerCreateArgs>(args: SelectSubset<T, BillingLedgerCreateArgs<ExtArgs>>): Prisma__BillingLedgerClient<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingLedgers.
     * @param {BillingLedgerCreateManyArgs} args - Arguments to create many BillingLedgers.
     * @example
     * // Create many BillingLedgers
     * const billingLedger = await prisma.billingLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingLedgerCreateManyArgs>(args?: SelectSubset<T, BillingLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingLedgers and returns the data saved in the database.
     * @param {BillingLedgerCreateManyAndReturnArgs} args - Arguments to create many BillingLedgers.
     * @example
     * // Create many BillingLedgers
     * const billingLedger = await prisma.billingLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingLedgers and only return the `id`
     * const billingLedgerWithIdOnly = await prisma.billingLedger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingLedger.
     * @param {BillingLedgerDeleteArgs} args - Arguments to delete one BillingLedger.
     * @example
     * // Delete one BillingLedger
     * const BillingLedger = await prisma.billingLedger.delete({
     *   where: {
     *     // ... filter to delete one BillingLedger
     *   }
     * })
     * 
     */
    delete<T extends BillingLedgerDeleteArgs>(args: SelectSubset<T, BillingLedgerDeleteArgs<ExtArgs>>): Prisma__BillingLedgerClient<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingLedger.
     * @param {BillingLedgerUpdateArgs} args - Arguments to update one BillingLedger.
     * @example
     * // Update one BillingLedger
     * const billingLedger = await prisma.billingLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingLedgerUpdateArgs>(args: SelectSubset<T, BillingLedgerUpdateArgs<ExtArgs>>): Prisma__BillingLedgerClient<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingLedgers.
     * @param {BillingLedgerDeleteManyArgs} args - Arguments to filter BillingLedgers to delete.
     * @example
     * // Delete a few BillingLedgers
     * const { count } = await prisma.billingLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingLedgerDeleteManyArgs>(args?: SelectSubset<T, BillingLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingLedgers
     * const billingLedger = await prisma.billingLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingLedgerUpdateManyArgs>(args: SelectSubset<T, BillingLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingLedgers and returns the data updated in the database.
     * @param {BillingLedgerUpdateManyAndReturnArgs} args - Arguments to update many BillingLedgers.
     * @example
     * // Update many BillingLedgers
     * const billingLedger = await prisma.billingLedger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingLedgers and only return the `id`
     * const billingLedgerWithIdOnly = await prisma.billingLedger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingLedgerUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingLedgerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingLedger.
     * @param {BillingLedgerUpsertArgs} args - Arguments to update or create a BillingLedger.
     * @example
     * // Update or create a BillingLedger
     * const billingLedger = await prisma.billingLedger.upsert({
     *   create: {
     *     // ... data to create a BillingLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingLedger we want to update
     *   }
     * })
     */
    upsert<T extends BillingLedgerUpsertArgs>(args: SelectSubset<T, BillingLedgerUpsertArgs<ExtArgs>>): Prisma__BillingLedgerClient<$Result.GetResult<Prisma.$BillingLedgerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingLedgerCountArgs} args - Arguments to filter BillingLedgers to count.
     * @example
     * // Count the number of BillingLedgers
     * const count = await prisma.billingLedger.count({
     *   where: {
     *     // ... the filter for the BillingLedgers we want to count
     *   }
     * })
    **/
    count<T extends BillingLedgerCountArgs>(
      args?: Subset<T, BillingLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingLedgerAggregateArgs>(args: Subset<T, BillingLedgerAggregateArgs>): Prisma.PrismaPromise<GetBillingLedgerAggregateType<T>>

    /**
     * Group by BillingLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingLedgerGroupByArgs['orderBy'] }
        : { orderBy?: BillingLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingLedger model
   */
  readonly fields: BillingLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingLedger model
   */
  interface BillingLedgerFieldRefs {
    readonly id: FieldRef<"BillingLedger", 'String'>
    readonly orgId: FieldRef<"BillingLedger", 'String'>
    readonly type: FieldRef<"BillingLedger", 'LedgerType'>
    readonly amount: FieldRef<"BillingLedger", 'Decimal'>
    readonly meta: FieldRef<"BillingLedger", 'Json'>
    readonly createdAt: FieldRef<"BillingLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingLedger findUnique
   */
  export type BillingLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
    /**
     * Filter, which BillingLedger to fetch.
     */
    where: BillingLedgerWhereUniqueInput
  }

  /**
   * BillingLedger findUniqueOrThrow
   */
  export type BillingLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
    /**
     * Filter, which BillingLedger to fetch.
     */
    where: BillingLedgerWhereUniqueInput
  }

  /**
   * BillingLedger findFirst
   */
  export type BillingLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
    /**
     * Filter, which BillingLedger to fetch.
     */
    where?: BillingLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingLedgers to fetch.
     */
    orderBy?: BillingLedgerOrderByWithRelationInput | BillingLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingLedgers.
     */
    cursor?: BillingLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingLedgers.
     */
    distinct?: BillingLedgerScalarFieldEnum | BillingLedgerScalarFieldEnum[]
  }

  /**
   * BillingLedger findFirstOrThrow
   */
  export type BillingLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
    /**
     * Filter, which BillingLedger to fetch.
     */
    where?: BillingLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingLedgers to fetch.
     */
    orderBy?: BillingLedgerOrderByWithRelationInput | BillingLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingLedgers.
     */
    cursor?: BillingLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingLedgers.
     */
    distinct?: BillingLedgerScalarFieldEnum | BillingLedgerScalarFieldEnum[]
  }

  /**
   * BillingLedger findMany
   */
  export type BillingLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
    /**
     * Filter, which BillingLedgers to fetch.
     */
    where?: BillingLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingLedgers to fetch.
     */
    orderBy?: BillingLedgerOrderByWithRelationInput | BillingLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingLedgers.
     */
    cursor?: BillingLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingLedgers.
     */
    skip?: number
    distinct?: BillingLedgerScalarFieldEnum | BillingLedgerScalarFieldEnum[]
  }

  /**
   * BillingLedger create
   */
  export type BillingLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingLedger.
     */
    data: XOR<BillingLedgerCreateInput, BillingLedgerUncheckedCreateInput>
  }

  /**
   * BillingLedger createMany
   */
  export type BillingLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingLedgers.
     */
    data: BillingLedgerCreateManyInput | BillingLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingLedger createManyAndReturn
   */
  export type BillingLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * The data used to create many BillingLedgers.
     */
    data: BillingLedgerCreateManyInput | BillingLedgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingLedger update
   */
  export type BillingLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingLedger.
     */
    data: XOR<BillingLedgerUpdateInput, BillingLedgerUncheckedUpdateInput>
    /**
     * Choose, which BillingLedger to update.
     */
    where: BillingLedgerWhereUniqueInput
  }

  /**
   * BillingLedger updateMany
   */
  export type BillingLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingLedgers.
     */
    data: XOR<BillingLedgerUpdateManyMutationInput, BillingLedgerUncheckedUpdateManyInput>
    /**
     * Filter which BillingLedgers to update
     */
    where?: BillingLedgerWhereInput
    /**
     * Limit how many BillingLedgers to update.
     */
    limit?: number
  }

  /**
   * BillingLedger updateManyAndReturn
   */
  export type BillingLedgerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * The data used to update BillingLedgers.
     */
    data: XOR<BillingLedgerUpdateManyMutationInput, BillingLedgerUncheckedUpdateManyInput>
    /**
     * Filter which BillingLedgers to update
     */
    where?: BillingLedgerWhereInput
    /**
     * Limit how many BillingLedgers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingLedger upsert
   */
  export type BillingLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingLedger to update in case it exists.
     */
    where: BillingLedgerWhereUniqueInput
    /**
     * In case the BillingLedger found by the `where` argument doesn't exist, create a new BillingLedger with this data.
     */
    create: XOR<BillingLedgerCreateInput, BillingLedgerUncheckedCreateInput>
    /**
     * In case the BillingLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingLedgerUpdateInput, BillingLedgerUncheckedUpdateInput>
  }

  /**
   * BillingLedger delete
   */
  export type BillingLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
    /**
     * Filter which BillingLedger to delete.
     */
    where: BillingLedgerWhereUniqueInput
  }

  /**
   * BillingLedger deleteMany
   */
  export type BillingLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingLedgers to delete
     */
    where?: BillingLedgerWhereInput
    /**
     * Limit how many BillingLedgers to delete.
     */
    limit?: number
  }

  /**
   * BillingLedger without action
   */
  export type BillingLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingLedger
     */
    select?: BillingLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingLedger
     */
    omit?: BillingLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingLedgerInclude<ExtArgs> | null
  }


  /**
   * Model LeadInvoice
   */

  export type AggregateLeadInvoice = {
    _count: LeadInvoiceCountAggregateOutputType | null
    _avg: LeadInvoiceAvgAggregateOutputType | null
    _sum: LeadInvoiceSumAggregateOutputType | null
    _min: LeadInvoiceMinAggregateOutputType | null
    _max: LeadInvoiceMaxAggregateOutputType | null
  }

  export type LeadInvoiceAvgAggregateOutputType = {
    subtotalCents: number | null
    taxCents: number | null
    totalCents: number | null
    leadCount: number | null
  }

  export type LeadInvoiceSumAggregateOutputType = {
    subtotalCents: number | null
    taxCents: number | null
    totalCents: number | null
    leadCount: number | null
  }

  export type LeadInvoiceMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    number: string | null
    periodFrom: Date | null
    periodTo: Date | null
    status: string | null
    subtotalCents: number | null
    taxCents: number | null
    totalCents: number | null
    currency: string | null
    stripeInvoiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    leadCount: number | null
  }

  export type LeadInvoiceMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    number: string | null
    periodFrom: Date | null
    periodTo: Date | null
    status: string | null
    subtotalCents: number | null
    taxCents: number | null
    totalCents: number | null
    currency: string | null
    stripeInvoiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    leadCount: number | null
  }

  export type LeadInvoiceCountAggregateOutputType = {
    id: number
    orgId: number
    number: number
    periodFrom: number
    periodTo: number
    status: number
    subtotalCents: number
    taxCents: number
    totalCents: number
    currency: number
    stripeInvoiceId: number
    createdAt: number
    updatedAt: number
    leadCount: number
    _all: number
  }


  export type LeadInvoiceAvgAggregateInputType = {
    subtotalCents?: true
    taxCents?: true
    totalCents?: true
    leadCount?: true
  }

  export type LeadInvoiceSumAggregateInputType = {
    subtotalCents?: true
    taxCents?: true
    totalCents?: true
    leadCount?: true
  }

  export type LeadInvoiceMinAggregateInputType = {
    id?: true
    orgId?: true
    number?: true
    periodFrom?: true
    periodTo?: true
    status?: true
    subtotalCents?: true
    taxCents?: true
    totalCents?: true
    currency?: true
    stripeInvoiceId?: true
    createdAt?: true
    updatedAt?: true
    leadCount?: true
  }

  export type LeadInvoiceMaxAggregateInputType = {
    id?: true
    orgId?: true
    number?: true
    periodFrom?: true
    periodTo?: true
    status?: true
    subtotalCents?: true
    taxCents?: true
    totalCents?: true
    currency?: true
    stripeInvoiceId?: true
    createdAt?: true
    updatedAt?: true
    leadCount?: true
  }

  export type LeadInvoiceCountAggregateInputType = {
    id?: true
    orgId?: true
    number?: true
    periodFrom?: true
    periodTo?: true
    status?: true
    subtotalCents?: true
    taxCents?: true
    totalCents?: true
    currency?: true
    stripeInvoiceId?: true
    createdAt?: true
    updatedAt?: true
    leadCount?: true
    _all?: true
  }

  export type LeadInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadInvoice to aggregate.
     */
    where?: LeadInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadInvoices to fetch.
     */
    orderBy?: LeadInvoiceOrderByWithRelationInput | LeadInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadInvoices
    **/
    _count?: true | LeadInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadInvoiceMaxAggregateInputType
  }

  export type GetLeadInvoiceAggregateType<T extends LeadInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadInvoice[P]>
      : GetScalarType<T[P], AggregateLeadInvoice[P]>
  }




  export type LeadInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadInvoiceWhereInput
    orderBy?: LeadInvoiceOrderByWithAggregationInput | LeadInvoiceOrderByWithAggregationInput[]
    by: LeadInvoiceScalarFieldEnum[] | LeadInvoiceScalarFieldEnum
    having?: LeadInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadInvoiceCountAggregateInputType | true
    _avg?: LeadInvoiceAvgAggregateInputType
    _sum?: LeadInvoiceSumAggregateInputType
    _min?: LeadInvoiceMinAggregateInputType
    _max?: LeadInvoiceMaxAggregateInputType
  }

  export type LeadInvoiceGroupByOutputType = {
    id: string
    orgId: string | null
    number: string
    periodFrom: Date
    periodTo: Date
    status: string
    subtotalCents: number
    taxCents: number
    totalCents: number
    currency: string
    stripeInvoiceId: string | null
    createdAt: Date
    updatedAt: Date
    leadCount: number
    _count: LeadInvoiceCountAggregateOutputType | null
    _avg: LeadInvoiceAvgAggregateOutputType | null
    _sum: LeadInvoiceSumAggregateOutputType | null
    _min: LeadInvoiceMinAggregateOutputType | null
    _max: LeadInvoiceMaxAggregateOutputType | null
  }

  type GetLeadInvoiceGroupByPayload<T extends LeadInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], LeadInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type LeadInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    number?: boolean
    periodFrom?: boolean
    periodTo?: boolean
    status?: boolean
    subtotalCents?: boolean
    taxCents?: boolean
    totalCents?: boolean
    currency?: boolean
    stripeInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leadCount?: boolean
    org?: boolean | LeadInvoice$orgArgs<ExtArgs>
    lines?: boolean | LeadInvoice$linesArgs<ExtArgs>
    _count?: boolean | LeadInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadInvoice"]>

  export type LeadInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    number?: boolean
    periodFrom?: boolean
    periodTo?: boolean
    status?: boolean
    subtotalCents?: boolean
    taxCents?: boolean
    totalCents?: boolean
    currency?: boolean
    stripeInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leadCount?: boolean
    org?: boolean | LeadInvoice$orgArgs<ExtArgs>
  }, ExtArgs["result"]["leadInvoice"]>

  export type LeadInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    number?: boolean
    periodFrom?: boolean
    periodTo?: boolean
    status?: boolean
    subtotalCents?: boolean
    taxCents?: boolean
    totalCents?: boolean
    currency?: boolean
    stripeInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leadCount?: boolean
    org?: boolean | LeadInvoice$orgArgs<ExtArgs>
  }, ExtArgs["result"]["leadInvoice"]>

  export type LeadInvoiceSelectScalar = {
    id?: boolean
    orgId?: boolean
    number?: boolean
    periodFrom?: boolean
    periodTo?: boolean
    status?: boolean
    subtotalCents?: boolean
    taxCents?: boolean
    totalCents?: boolean
    currency?: boolean
    stripeInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leadCount?: boolean
  }

  export type LeadInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "number" | "periodFrom" | "periodTo" | "status" | "subtotalCents" | "taxCents" | "totalCents" | "currency" | "stripeInvoiceId" | "createdAt" | "updatedAt" | "leadCount", ExtArgs["result"]["leadInvoice"]>
  export type LeadInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | LeadInvoice$orgArgs<ExtArgs>
    lines?: boolean | LeadInvoice$linesArgs<ExtArgs>
    _count?: boolean | LeadInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | LeadInvoice$orgArgs<ExtArgs>
  }
  export type LeadInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | LeadInvoice$orgArgs<ExtArgs>
  }

  export type $LeadInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadInvoice"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs> | null
      lines: Prisma.$LeadInvoiceLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string | null
      number: string
      periodFrom: Date
      periodTo: Date
      status: string
      subtotalCents: number
      taxCents: number
      totalCents: number
      currency: string
      stripeInvoiceId: string | null
      createdAt: Date
      updatedAt: Date
      /**
       * Number of leads billed on this invoice (to support flat-per-lead billing)
       */
      leadCount: number
    }, ExtArgs["result"]["leadInvoice"]>
    composites: {}
  }

  type LeadInvoiceGetPayload<S extends boolean | null | undefined | LeadInvoiceDefaultArgs> = $Result.GetResult<Prisma.$LeadInvoicePayload, S>

  type LeadInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadInvoiceCountAggregateInputType | true
    }

  export interface LeadInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadInvoice'], meta: { name: 'LeadInvoice' } }
    /**
     * Find zero or one LeadInvoice that matches the filter.
     * @param {LeadInvoiceFindUniqueArgs} args - Arguments to find a LeadInvoice
     * @example
     * // Get one LeadInvoice
     * const leadInvoice = await prisma.leadInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadInvoiceFindUniqueArgs>(args: SelectSubset<T, LeadInvoiceFindUniqueArgs<ExtArgs>>): Prisma__LeadInvoiceClient<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadInvoiceFindUniqueOrThrowArgs} args - Arguments to find a LeadInvoice
     * @example
     * // Get one LeadInvoice
     * const leadInvoice = await prisma.leadInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadInvoiceClient<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceFindFirstArgs} args - Arguments to find a LeadInvoice
     * @example
     * // Get one LeadInvoice
     * const leadInvoice = await prisma.leadInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadInvoiceFindFirstArgs>(args?: SelectSubset<T, LeadInvoiceFindFirstArgs<ExtArgs>>): Prisma__LeadInvoiceClient<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceFindFirstOrThrowArgs} args - Arguments to find a LeadInvoice
     * @example
     * // Get one LeadInvoice
     * const leadInvoice = await prisma.leadInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadInvoiceClient<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadInvoices
     * const leadInvoices = await prisma.leadInvoice.findMany()
     * 
     * // Get first 10 LeadInvoices
     * const leadInvoices = await prisma.leadInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadInvoiceWithIdOnly = await prisma.leadInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadInvoiceFindManyArgs>(args?: SelectSubset<T, LeadInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadInvoice.
     * @param {LeadInvoiceCreateArgs} args - Arguments to create a LeadInvoice.
     * @example
     * // Create one LeadInvoice
     * const LeadInvoice = await prisma.leadInvoice.create({
     *   data: {
     *     // ... data to create a LeadInvoice
     *   }
     * })
     * 
     */
    create<T extends LeadInvoiceCreateArgs>(args: SelectSubset<T, LeadInvoiceCreateArgs<ExtArgs>>): Prisma__LeadInvoiceClient<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadInvoices.
     * @param {LeadInvoiceCreateManyArgs} args - Arguments to create many LeadInvoices.
     * @example
     * // Create many LeadInvoices
     * const leadInvoice = await prisma.leadInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadInvoiceCreateManyArgs>(args?: SelectSubset<T, LeadInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadInvoices and returns the data saved in the database.
     * @param {LeadInvoiceCreateManyAndReturnArgs} args - Arguments to create many LeadInvoices.
     * @example
     * // Create many LeadInvoices
     * const leadInvoice = await prisma.leadInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadInvoices and only return the `id`
     * const leadInvoiceWithIdOnly = await prisma.leadInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadInvoice.
     * @param {LeadInvoiceDeleteArgs} args - Arguments to delete one LeadInvoice.
     * @example
     * // Delete one LeadInvoice
     * const LeadInvoice = await prisma.leadInvoice.delete({
     *   where: {
     *     // ... filter to delete one LeadInvoice
     *   }
     * })
     * 
     */
    delete<T extends LeadInvoiceDeleteArgs>(args: SelectSubset<T, LeadInvoiceDeleteArgs<ExtArgs>>): Prisma__LeadInvoiceClient<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadInvoice.
     * @param {LeadInvoiceUpdateArgs} args - Arguments to update one LeadInvoice.
     * @example
     * // Update one LeadInvoice
     * const leadInvoice = await prisma.leadInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadInvoiceUpdateArgs>(args: SelectSubset<T, LeadInvoiceUpdateArgs<ExtArgs>>): Prisma__LeadInvoiceClient<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadInvoices.
     * @param {LeadInvoiceDeleteManyArgs} args - Arguments to filter LeadInvoices to delete.
     * @example
     * // Delete a few LeadInvoices
     * const { count } = await prisma.leadInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadInvoiceDeleteManyArgs>(args?: SelectSubset<T, LeadInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadInvoices
     * const leadInvoice = await prisma.leadInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadInvoiceUpdateManyArgs>(args: SelectSubset<T, LeadInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadInvoices and returns the data updated in the database.
     * @param {LeadInvoiceUpdateManyAndReturnArgs} args - Arguments to update many LeadInvoices.
     * @example
     * // Update many LeadInvoices
     * const leadInvoice = await prisma.leadInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadInvoices and only return the `id`
     * const leadInvoiceWithIdOnly = await prisma.leadInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadInvoice.
     * @param {LeadInvoiceUpsertArgs} args - Arguments to update or create a LeadInvoice.
     * @example
     * // Update or create a LeadInvoice
     * const leadInvoice = await prisma.leadInvoice.upsert({
     *   create: {
     *     // ... data to create a LeadInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadInvoice we want to update
     *   }
     * })
     */
    upsert<T extends LeadInvoiceUpsertArgs>(args: SelectSubset<T, LeadInvoiceUpsertArgs<ExtArgs>>): Prisma__LeadInvoiceClient<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceCountArgs} args - Arguments to filter LeadInvoices to count.
     * @example
     * // Count the number of LeadInvoices
     * const count = await prisma.leadInvoice.count({
     *   where: {
     *     // ... the filter for the LeadInvoices we want to count
     *   }
     * })
    **/
    count<T extends LeadInvoiceCountArgs>(
      args?: Subset<T, LeadInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadInvoiceAggregateArgs>(args: Subset<T, LeadInvoiceAggregateArgs>): Prisma.PrismaPromise<GetLeadInvoiceAggregateType<T>>

    /**
     * Group by LeadInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: LeadInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadInvoice model
   */
  readonly fields: LeadInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends LeadInvoice$orgArgs<ExtArgs> = {}>(args?: Subset<T, LeadInvoice$orgArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends LeadInvoice$linesArgs<ExtArgs> = {}>(args?: Subset<T, LeadInvoice$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadInvoice model
   */
  interface LeadInvoiceFieldRefs {
    readonly id: FieldRef<"LeadInvoice", 'String'>
    readonly orgId: FieldRef<"LeadInvoice", 'String'>
    readonly number: FieldRef<"LeadInvoice", 'String'>
    readonly periodFrom: FieldRef<"LeadInvoice", 'DateTime'>
    readonly periodTo: FieldRef<"LeadInvoice", 'DateTime'>
    readonly status: FieldRef<"LeadInvoice", 'String'>
    readonly subtotalCents: FieldRef<"LeadInvoice", 'Int'>
    readonly taxCents: FieldRef<"LeadInvoice", 'Int'>
    readonly totalCents: FieldRef<"LeadInvoice", 'Int'>
    readonly currency: FieldRef<"LeadInvoice", 'String'>
    readonly stripeInvoiceId: FieldRef<"LeadInvoice", 'String'>
    readonly createdAt: FieldRef<"LeadInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"LeadInvoice", 'DateTime'>
    readonly leadCount: FieldRef<"LeadInvoice", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LeadInvoice findUnique
   */
  export type LeadInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which LeadInvoice to fetch.
     */
    where: LeadInvoiceWhereUniqueInput
  }

  /**
   * LeadInvoice findUniqueOrThrow
   */
  export type LeadInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which LeadInvoice to fetch.
     */
    where: LeadInvoiceWhereUniqueInput
  }

  /**
   * LeadInvoice findFirst
   */
  export type LeadInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which LeadInvoice to fetch.
     */
    where?: LeadInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadInvoices to fetch.
     */
    orderBy?: LeadInvoiceOrderByWithRelationInput | LeadInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadInvoices.
     */
    cursor?: LeadInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadInvoices.
     */
    distinct?: LeadInvoiceScalarFieldEnum | LeadInvoiceScalarFieldEnum[]
  }

  /**
   * LeadInvoice findFirstOrThrow
   */
  export type LeadInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which LeadInvoice to fetch.
     */
    where?: LeadInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadInvoices to fetch.
     */
    orderBy?: LeadInvoiceOrderByWithRelationInput | LeadInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadInvoices.
     */
    cursor?: LeadInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadInvoices.
     */
    distinct?: LeadInvoiceScalarFieldEnum | LeadInvoiceScalarFieldEnum[]
  }

  /**
   * LeadInvoice findMany
   */
  export type LeadInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which LeadInvoices to fetch.
     */
    where?: LeadInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadInvoices to fetch.
     */
    orderBy?: LeadInvoiceOrderByWithRelationInput | LeadInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadInvoices.
     */
    cursor?: LeadInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadInvoices.
     */
    skip?: number
    distinct?: LeadInvoiceScalarFieldEnum | LeadInvoiceScalarFieldEnum[]
  }

  /**
   * LeadInvoice create
   */
  export type LeadInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadInvoice.
     */
    data: XOR<LeadInvoiceCreateInput, LeadInvoiceUncheckedCreateInput>
  }

  /**
   * LeadInvoice createMany
   */
  export type LeadInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadInvoices.
     */
    data: LeadInvoiceCreateManyInput | LeadInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadInvoice createManyAndReturn
   */
  export type LeadInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many LeadInvoices.
     */
    data: LeadInvoiceCreateManyInput | LeadInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadInvoice update
   */
  export type LeadInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadInvoice.
     */
    data: XOR<LeadInvoiceUpdateInput, LeadInvoiceUncheckedUpdateInput>
    /**
     * Choose, which LeadInvoice to update.
     */
    where: LeadInvoiceWhereUniqueInput
  }

  /**
   * LeadInvoice updateMany
   */
  export type LeadInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadInvoices.
     */
    data: XOR<LeadInvoiceUpdateManyMutationInput, LeadInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which LeadInvoices to update
     */
    where?: LeadInvoiceWhereInput
    /**
     * Limit how many LeadInvoices to update.
     */
    limit?: number
  }

  /**
   * LeadInvoice updateManyAndReturn
   */
  export type LeadInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update LeadInvoices.
     */
    data: XOR<LeadInvoiceUpdateManyMutationInput, LeadInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which LeadInvoices to update
     */
    where?: LeadInvoiceWhereInput
    /**
     * Limit how many LeadInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadInvoice upsert
   */
  export type LeadInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadInvoice to update in case it exists.
     */
    where: LeadInvoiceWhereUniqueInput
    /**
     * In case the LeadInvoice found by the `where` argument doesn't exist, create a new LeadInvoice with this data.
     */
    create: XOR<LeadInvoiceCreateInput, LeadInvoiceUncheckedCreateInput>
    /**
     * In case the LeadInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadInvoiceUpdateInput, LeadInvoiceUncheckedUpdateInput>
  }

  /**
   * LeadInvoice delete
   */
  export type LeadInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
    /**
     * Filter which LeadInvoice to delete.
     */
    where: LeadInvoiceWhereUniqueInput
  }

  /**
   * LeadInvoice deleteMany
   */
  export type LeadInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadInvoices to delete
     */
    where?: LeadInvoiceWhereInput
    /**
     * Limit how many LeadInvoices to delete.
     */
    limit?: number
  }

  /**
   * LeadInvoice.org
   */
  export type LeadInvoice$orgArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    where?: OrgWhereInput
  }

  /**
   * LeadInvoice.lines
   */
  export type LeadInvoice$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    where?: LeadInvoiceLineWhereInput
    orderBy?: LeadInvoiceLineOrderByWithRelationInput | LeadInvoiceLineOrderByWithRelationInput[]
    cursor?: LeadInvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadInvoiceLineScalarFieldEnum | LeadInvoiceLineScalarFieldEnum[]
  }

  /**
   * LeadInvoice without action
   */
  export type LeadInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoice
     */
    select?: LeadInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoice
     */
    omit?: LeadInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model LeadInvoiceLine
   */

  export type AggregateLeadInvoiceLine = {
    _count: LeadInvoiceLineCountAggregateOutputType | null
    _avg: LeadInvoiceLineAvgAggregateOutputType | null
    _sum: LeadInvoiceLineSumAggregateOutputType | null
    _min: LeadInvoiceLineMinAggregateOutputType | null
    _max: LeadInvoiceLineMaxAggregateOutputType | null
  }

  export type LeadInvoiceLineAvgAggregateOutputType = {
    quantity: number | null
    unitPriceCents: number | null
    amountCents: number | null
  }

  export type LeadInvoiceLineSumAggregateOutputType = {
    quantity: number | null
    unitPriceCents: number | null
    amountCents: number | null
  }

  export type LeadInvoiceLineMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    leadId: string | null
    description: string | null
    quantity: number | null
    unitPriceCents: number | null
    amountCents: number | null
    source: string | null
    createdAt: Date | null
  }

  export type LeadInvoiceLineMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    leadId: string | null
    description: string | null
    quantity: number | null
    unitPriceCents: number | null
    amountCents: number | null
    source: string | null
    createdAt: Date | null
  }

  export type LeadInvoiceLineCountAggregateOutputType = {
    id: number
    invoiceId: number
    leadId: number
    description: number
    quantity: number
    unitPriceCents: number
    amountCents: number
    source: number
    createdAt: number
    _all: number
  }


  export type LeadInvoiceLineAvgAggregateInputType = {
    quantity?: true
    unitPriceCents?: true
    amountCents?: true
  }

  export type LeadInvoiceLineSumAggregateInputType = {
    quantity?: true
    unitPriceCents?: true
    amountCents?: true
  }

  export type LeadInvoiceLineMinAggregateInputType = {
    id?: true
    invoiceId?: true
    leadId?: true
    description?: true
    quantity?: true
    unitPriceCents?: true
    amountCents?: true
    source?: true
    createdAt?: true
  }

  export type LeadInvoiceLineMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    leadId?: true
    description?: true
    quantity?: true
    unitPriceCents?: true
    amountCents?: true
    source?: true
    createdAt?: true
  }

  export type LeadInvoiceLineCountAggregateInputType = {
    id?: true
    invoiceId?: true
    leadId?: true
    description?: true
    quantity?: true
    unitPriceCents?: true
    amountCents?: true
    source?: true
    createdAt?: true
    _all?: true
  }

  export type LeadInvoiceLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadInvoiceLine to aggregate.
     */
    where?: LeadInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadInvoiceLines to fetch.
     */
    orderBy?: LeadInvoiceLineOrderByWithRelationInput | LeadInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadInvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadInvoiceLines
    **/
    _count?: true | LeadInvoiceLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadInvoiceLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadInvoiceLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadInvoiceLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadInvoiceLineMaxAggregateInputType
  }

  export type GetLeadInvoiceLineAggregateType<T extends LeadInvoiceLineAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadInvoiceLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadInvoiceLine[P]>
      : GetScalarType<T[P], AggregateLeadInvoiceLine[P]>
  }




  export type LeadInvoiceLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadInvoiceLineWhereInput
    orderBy?: LeadInvoiceLineOrderByWithAggregationInput | LeadInvoiceLineOrderByWithAggregationInput[]
    by: LeadInvoiceLineScalarFieldEnum[] | LeadInvoiceLineScalarFieldEnum
    having?: LeadInvoiceLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadInvoiceLineCountAggregateInputType | true
    _avg?: LeadInvoiceLineAvgAggregateInputType
    _sum?: LeadInvoiceLineSumAggregateInputType
    _min?: LeadInvoiceLineMinAggregateInputType
    _max?: LeadInvoiceLineMaxAggregateInputType
  }

  export type LeadInvoiceLineGroupByOutputType = {
    id: string
    invoiceId: string
    leadId: string | null
    description: string
    quantity: number
    unitPriceCents: number
    amountCents: number
    source: string | null
    createdAt: Date
    _count: LeadInvoiceLineCountAggregateOutputType | null
    _avg: LeadInvoiceLineAvgAggregateOutputType | null
    _sum: LeadInvoiceLineSumAggregateOutputType | null
    _min: LeadInvoiceLineMinAggregateOutputType | null
    _max: LeadInvoiceLineMaxAggregateOutputType | null
  }

  type GetLeadInvoiceLineGroupByPayload<T extends LeadInvoiceLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadInvoiceLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadInvoiceLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadInvoiceLineGroupByOutputType[P]>
            : GetScalarType<T[P], LeadInvoiceLineGroupByOutputType[P]>
        }
      >
    >


  export type LeadInvoiceLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    leadId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    amountCents?: boolean
    source?: boolean
    createdAt?: boolean
    invoice?: boolean | LeadInvoiceDefaultArgs<ExtArgs>
    lead?: boolean | LeadInvoiceLine$leadArgs<ExtArgs>
  }, ExtArgs["result"]["leadInvoiceLine"]>

  export type LeadInvoiceLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    leadId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    amountCents?: boolean
    source?: boolean
    createdAt?: boolean
    invoice?: boolean | LeadInvoiceDefaultArgs<ExtArgs>
    lead?: boolean | LeadInvoiceLine$leadArgs<ExtArgs>
  }, ExtArgs["result"]["leadInvoiceLine"]>

  export type LeadInvoiceLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    leadId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    amountCents?: boolean
    source?: boolean
    createdAt?: boolean
    invoice?: boolean | LeadInvoiceDefaultArgs<ExtArgs>
    lead?: boolean | LeadInvoiceLine$leadArgs<ExtArgs>
  }, ExtArgs["result"]["leadInvoiceLine"]>

  export type LeadInvoiceLineSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    leadId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    amountCents?: boolean
    source?: boolean
    createdAt?: boolean
  }

  export type LeadInvoiceLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "leadId" | "description" | "quantity" | "unitPriceCents" | "amountCents" | "source" | "createdAt", ExtArgs["result"]["leadInvoiceLine"]>
  export type LeadInvoiceLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | LeadInvoiceDefaultArgs<ExtArgs>
    lead?: boolean | LeadInvoiceLine$leadArgs<ExtArgs>
  }
  export type LeadInvoiceLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | LeadInvoiceDefaultArgs<ExtArgs>
    lead?: boolean | LeadInvoiceLine$leadArgs<ExtArgs>
  }
  export type LeadInvoiceLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | LeadInvoiceDefaultArgs<ExtArgs>
    lead?: boolean | LeadInvoiceLine$leadArgs<ExtArgs>
  }

  export type $LeadInvoiceLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadInvoiceLine"
    objects: {
      invoice: Prisma.$LeadInvoicePayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      leadId: string | null
      description: string
      quantity: number
      unitPriceCents: number
      amountCents: number
      source: string | null
      createdAt: Date
    }, ExtArgs["result"]["leadInvoiceLine"]>
    composites: {}
  }

  type LeadInvoiceLineGetPayload<S extends boolean | null | undefined | LeadInvoiceLineDefaultArgs> = $Result.GetResult<Prisma.$LeadInvoiceLinePayload, S>

  type LeadInvoiceLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadInvoiceLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadInvoiceLineCountAggregateInputType | true
    }

  export interface LeadInvoiceLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadInvoiceLine'], meta: { name: 'LeadInvoiceLine' } }
    /**
     * Find zero or one LeadInvoiceLine that matches the filter.
     * @param {LeadInvoiceLineFindUniqueArgs} args - Arguments to find a LeadInvoiceLine
     * @example
     * // Get one LeadInvoiceLine
     * const leadInvoiceLine = await prisma.leadInvoiceLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadInvoiceLineFindUniqueArgs>(args: SelectSubset<T, LeadInvoiceLineFindUniqueArgs<ExtArgs>>): Prisma__LeadInvoiceLineClient<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadInvoiceLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadInvoiceLineFindUniqueOrThrowArgs} args - Arguments to find a LeadInvoiceLine
     * @example
     * // Get one LeadInvoiceLine
     * const leadInvoiceLine = await prisma.leadInvoiceLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadInvoiceLineFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadInvoiceLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadInvoiceLineClient<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadInvoiceLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceLineFindFirstArgs} args - Arguments to find a LeadInvoiceLine
     * @example
     * // Get one LeadInvoiceLine
     * const leadInvoiceLine = await prisma.leadInvoiceLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadInvoiceLineFindFirstArgs>(args?: SelectSubset<T, LeadInvoiceLineFindFirstArgs<ExtArgs>>): Prisma__LeadInvoiceLineClient<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadInvoiceLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceLineFindFirstOrThrowArgs} args - Arguments to find a LeadInvoiceLine
     * @example
     * // Get one LeadInvoiceLine
     * const leadInvoiceLine = await prisma.leadInvoiceLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadInvoiceLineFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadInvoiceLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadInvoiceLineClient<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadInvoiceLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadInvoiceLines
     * const leadInvoiceLines = await prisma.leadInvoiceLine.findMany()
     * 
     * // Get first 10 LeadInvoiceLines
     * const leadInvoiceLines = await prisma.leadInvoiceLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadInvoiceLineWithIdOnly = await prisma.leadInvoiceLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadInvoiceLineFindManyArgs>(args?: SelectSubset<T, LeadInvoiceLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadInvoiceLine.
     * @param {LeadInvoiceLineCreateArgs} args - Arguments to create a LeadInvoiceLine.
     * @example
     * // Create one LeadInvoiceLine
     * const LeadInvoiceLine = await prisma.leadInvoiceLine.create({
     *   data: {
     *     // ... data to create a LeadInvoiceLine
     *   }
     * })
     * 
     */
    create<T extends LeadInvoiceLineCreateArgs>(args: SelectSubset<T, LeadInvoiceLineCreateArgs<ExtArgs>>): Prisma__LeadInvoiceLineClient<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadInvoiceLines.
     * @param {LeadInvoiceLineCreateManyArgs} args - Arguments to create many LeadInvoiceLines.
     * @example
     * // Create many LeadInvoiceLines
     * const leadInvoiceLine = await prisma.leadInvoiceLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadInvoiceLineCreateManyArgs>(args?: SelectSubset<T, LeadInvoiceLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadInvoiceLines and returns the data saved in the database.
     * @param {LeadInvoiceLineCreateManyAndReturnArgs} args - Arguments to create many LeadInvoiceLines.
     * @example
     * // Create many LeadInvoiceLines
     * const leadInvoiceLine = await prisma.leadInvoiceLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadInvoiceLines and only return the `id`
     * const leadInvoiceLineWithIdOnly = await prisma.leadInvoiceLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadInvoiceLineCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadInvoiceLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadInvoiceLine.
     * @param {LeadInvoiceLineDeleteArgs} args - Arguments to delete one LeadInvoiceLine.
     * @example
     * // Delete one LeadInvoiceLine
     * const LeadInvoiceLine = await prisma.leadInvoiceLine.delete({
     *   where: {
     *     // ... filter to delete one LeadInvoiceLine
     *   }
     * })
     * 
     */
    delete<T extends LeadInvoiceLineDeleteArgs>(args: SelectSubset<T, LeadInvoiceLineDeleteArgs<ExtArgs>>): Prisma__LeadInvoiceLineClient<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadInvoiceLine.
     * @param {LeadInvoiceLineUpdateArgs} args - Arguments to update one LeadInvoiceLine.
     * @example
     * // Update one LeadInvoiceLine
     * const leadInvoiceLine = await prisma.leadInvoiceLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadInvoiceLineUpdateArgs>(args: SelectSubset<T, LeadInvoiceLineUpdateArgs<ExtArgs>>): Prisma__LeadInvoiceLineClient<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadInvoiceLines.
     * @param {LeadInvoiceLineDeleteManyArgs} args - Arguments to filter LeadInvoiceLines to delete.
     * @example
     * // Delete a few LeadInvoiceLines
     * const { count } = await prisma.leadInvoiceLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadInvoiceLineDeleteManyArgs>(args?: SelectSubset<T, LeadInvoiceLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadInvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadInvoiceLines
     * const leadInvoiceLine = await prisma.leadInvoiceLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadInvoiceLineUpdateManyArgs>(args: SelectSubset<T, LeadInvoiceLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadInvoiceLines and returns the data updated in the database.
     * @param {LeadInvoiceLineUpdateManyAndReturnArgs} args - Arguments to update many LeadInvoiceLines.
     * @example
     * // Update many LeadInvoiceLines
     * const leadInvoiceLine = await prisma.leadInvoiceLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadInvoiceLines and only return the `id`
     * const leadInvoiceLineWithIdOnly = await prisma.leadInvoiceLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadInvoiceLineUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadInvoiceLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadInvoiceLine.
     * @param {LeadInvoiceLineUpsertArgs} args - Arguments to update or create a LeadInvoiceLine.
     * @example
     * // Update or create a LeadInvoiceLine
     * const leadInvoiceLine = await prisma.leadInvoiceLine.upsert({
     *   create: {
     *     // ... data to create a LeadInvoiceLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadInvoiceLine we want to update
     *   }
     * })
     */
    upsert<T extends LeadInvoiceLineUpsertArgs>(args: SelectSubset<T, LeadInvoiceLineUpsertArgs<ExtArgs>>): Prisma__LeadInvoiceLineClient<$Result.GetResult<Prisma.$LeadInvoiceLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadInvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceLineCountArgs} args - Arguments to filter LeadInvoiceLines to count.
     * @example
     * // Count the number of LeadInvoiceLines
     * const count = await prisma.leadInvoiceLine.count({
     *   where: {
     *     // ... the filter for the LeadInvoiceLines we want to count
     *   }
     * })
    **/
    count<T extends LeadInvoiceLineCountArgs>(
      args?: Subset<T, LeadInvoiceLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadInvoiceLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadInvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadInvoiceLineAggregateArgs>(args: Subset<T, LeadInvoiceLineAggregateArgs>): Prisma.PrismaPromise<GetLeadInvoiceLineAggregateType<T>>

    /**
     * Group by LeadInvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadInvoiceLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadInvoiceLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadInvoiceLineGroupByArgs['orderBy'] }
        : { orderBy?: LeadInvoiceLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadInvoiceLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadInvoiceLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadInvoiceLine model
   */
  readonly fields: LeadInvoiceLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadInvoiceLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadInvoiceLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends LeadInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadInvoiceDefaultArgs<ExtArgs>>): Prisma__LeadInvoiceClient<$Result.GetResult<Prisma.$LeadInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lead<T extends LeadInvoiceLine$leadArgs<ExtArgs> = {}>(args?: Subset<T, LeadInvoiceLine$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadInvoiceLine model
   */
  interface LeadInvoiceLineFieldRefs {
    readonly id: FieldRef<"LeadInvoiceLine", 'String'>
    readonly invoiceId: FieldRef<"LeadInvoiceLine", 'String'>
    readonly leadId: FieldRef<"LeadInvoiceLine", 'String'>
    readonly description: FieldRef<"LeadInvoiceLine", 'String'>
    readonly quantity: FieldRef<"LeadInvoiceLine", 'Int'>
    readonly unitPriceCents: FieldRef<"LeadInvoiceLine", 'Int'>
    readonly amountCents: FieldRef<"LeadInvoiceLine", 'Int'>
    readonly source: FieldRef<"LeadInvoiceLine", 'String'>
    readonly createdAt: FieldRef<"LeadInvoiceLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeadInvoiceLine findUnique
   */
  export type LeadInvoiceLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which LeadInvoiceLine to fetch.
     */
    where: LeadInvoiceLineWhereUniqueInput
  }

  /**
   * LeadInvoiceLine findUniqueOrThrow
   */
  export type LeadInvoiceLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which LeadInvoiceLine to fetch.
     */
    where: LeadInvoiceLineWhereUniqueInput
  }

  /**
   * LeadInvoiceLine findFirst
   */
  export type LeadInvoiceLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which LeadInvoiceLine to fetch.
     */
    where?: LeadInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadInvoiceLines to fetch.
     */
    orderBy?: LeadInvoiceLineOrderByWithRelationInput | LeadInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadInvoiceLines.
     */
    cursor?: LeadInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadInvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadInvoiceLines.
     */
    distinct?: LeadInvoiceLineScalarFieldEnum | LeadInvoiceLineScalarFieldEnum[]
  }

  /**
   * LeadInvoiceLine findFirstOrThrow
   */
  export type LeadInvoiceLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which LeadInvoiceLine to fetch.
     */
    where?: LeadInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadInvoiceLines to fetch.
     */
    orderBy?: LeadInvoiceLineOrderByWithRelationInput | LeadInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadInvoiceLines.
     */
    cursor?: LeadInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadInvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadInvoiceLines.
     */
    distinct?: LeadInvoiceLineScalarFieldEnum | LeadInvoiceLineScalarFieldEnum[]
  }

  /**
   * LeadInvoiceLine findMany
   */
  export type LeadInvoiceLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which LeadInvoiceLines to fetch.
     */
    where?: LeadInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadInvoiceLines to fetch.
     */
    orderBy?: LeadInvoiceLineOrderByWithRelationInput | LeadInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadInvoiceLines.
     */
    cursor?: LeadInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadInvoiceLines.
     */
    skip?: number
    distinct?: LeadInvoiceLineScalarFieldEnum | LeadInvoiceLineScalarFieldEnum[]
  }

  /**
   * LeadInvoiceLine create
   */
  export type LeadInvoiceLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadInvoiceLine.
     */
    data: XOR<LeadInvoiceLineCreateInput, LeadInvoiceLineUncheckedCreateInput>
  }

  /**
   * LeadInvoiceLine createMany
   */
  export type LeadInvoiceLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadInvoiceLines.
     */
    data: LeadInvoiceLineCreateManyInput | LeadInvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadInvoiceLine createManyAndReturn
   */
  export type LeadInvoiceLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to create many LeadInvoiceLines.
     */
    data: LeadInvoiceLineCreateManyInput | LeadInvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadInvoiceLine update
   */
  export type LeadInvoiceLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadInvoiceLine.
     */
    data: XOR<LeadInvoiceLineUpdateInput, LeadInvoiceLineUncheckedUpdateInput>
    /**
     * Choose, which LeadInvoiceLine to update.
     */
    where: LeadInvoiceLineWhereUniqueInput
  }

  /**
   * LeadInvoiceLine updateMany
   */
  export type LeadInvoiceLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadInvoiceLines.
     */
    data: XOR<LeadInvoiceLineUpdateManyMutationInput, LeadInvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which LeadInvoiceLines to update
     */
    where?: LeadInvoiceLineWhereInput
    /**
     * Limit how many LeadInvoiceLines to update.
     */
    limit?: number
  }

  /**
   * LeadInvoiceLine updateManyAndReturn
   */
  export type LeadInvoiceLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to update LeadInvoiceLines.
     */
    data: XOR<LeadInvoiceLineUpdateManyMutationInput, LeadInvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which LeadInvoiceLines to update
     */
    where?: LeadInvoiceLineWhereInput
    /**
     * Limit how many LeadInvoiceLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadInvoiceLine upsert
   */
  export type LeadInvoiceLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadInvoiceLine to update in case it exists.
     */
    where: LeadInvoiceLineWhereUniqueInput
    /**
     * In case the LeadInvoiceLine found by the `where` argument doesn't exist, create a new LeadInvoiceLine with this data.
     */
    create: XOR<LeadInvoiceLineCreateInput, LeadInvoiceLineUncheckedCreateInput>
    /**
     * In case the LeadInvoiceLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadInvoiceLineUpdateInput, LeadInvoiceLineUncheckedUpdateInput>
  }

  /**
   * LeadInvoiceLine delete
   */
  export type LeadInvoiceLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter which LeadInvoiceLine to delete.
     */
    where: LeadInvoiceLineWhereUniqueInput
  }

  /**
   * LeadInvoiceLine deleteMany
   */
  export type LeadInvoiceLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadInvoiceLines to delete
     */
    where?: LeadInvoiceLineWhereInput
    /**
     * Limit how many LeadInvoiceLines to delete.
     */
    limit?: number
  }

  /**
   * LeadInvoiceLine.lead
   */
  export type LeadInvoiceLine$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * LeadInvoiceLine without action
   */
  export type LeadInvoiceLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadInvoiceLine
     */
    select?: LeadInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadInvoiceLine
     */
    omit?: LeadInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInvoiceLineInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    actorUserId: string | null
    entity: string | null
    entityId: string | null
    field: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    actorUserId: string | null
    entity: string | null
    entityId: string | null
    field: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    orgId: number
    actorUserId: number
    entity: number
    entityId: number
    field: number
    oldValue: number
    newValue: number
    reason: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    orgId?: true
    actorUserId?: true
    entity?: true
    entityId?: true
    field?: true
    reason?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    orgId?: true
    actorUserId?: true
    entity?: true
    entityId?: true
    field?: true
    reason?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    orgId?: true
    actorUserId?: true
    entity?: true
    entityId?: true
    field?: true
    oldValue?: true
    newValue?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    orgId: string
    actorUserId: string | null
    entity: string
    entityId: string | null
    field: string | null
    oldValue: JsonValue | null
    newValue: JsonValue | null
    reason: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    actorUserId?: boolean
    entity?: boolean
    entityId?: boolean
    field?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    actorUserId?: boolean
    entity?: boolean
    entityId?: boolean
    field?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    actorUserId?: boolean
    entity?: boolean
    entityId?: boolean
    field?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    orgId?: boolean
    actorUserId?: boolean
    entity?: boolean
    entityId?: boolean
    field?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "actorUserId" | "entity" | "entityId" | "field" | "oldValue" | "newValue" | "reason" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      actorUserId: string | null
      /**
       * The entity type affected (e.g. 'lead', 'invoice', 'pricing', etc.)
       */
      entity: string
      /**
       * Identifier of the record affected
       */
      entityId: string | null
      /**
       * Name of the field that was changed (nullable for record-level actions)
       */
      field: string | null
      /**
       * Previous value (JSON) before the change, if applicable
       */
      oldValue: Prisma.JsonValue | null
      /**
       * New value (JSON) after the change, if applicable
       */
      newValue: Prisma.JsonValue | null
      /**
       * Free-form reason or comment describing why the change was made
       */
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly orgId: FieldRef<"AuditLog", 'String'>
    readonly actorUserId: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly field: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'Json'>
    readonly newValue: FieldRef<"AuditLog", 'Json'>
    readonly reason: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model RbacPermission
   */

  export type AggregateRbacPermission = {
    _count: RbacPermissionCountAggregateOutputType | null
    _min: RbacPermissionMinAggregateOutputType | null
    _max: RbacPermissionMaxAggregateOutputType | null
  }

  export type RbacPermissionMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RbacPermissionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RbacPermissionCountAggregateOutputType = {
    id: number
    code: number
    description: number
    createdAt: number
    _all: number
  }


  export type RbacPermissionMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
  }

  export type RbacPermissionMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
  }

  export type RbacPermissionCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type RbacPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RbacPermission to aggregate.
     */
    where?: RbacPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacPermissions to fetch.
     */
    orderBy?: RbacPermissionOrderByWithRelationInput | RbacPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RbacPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RbacPermissions
    **/
    _count?: true | RbacPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RbacPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RbacPermissionMaxAggregateInputType
  }

  export type GetRbacPermissionAggregateType<T extends RbacPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRbacPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRbacPermission[P]>
      : GetScalarType<T[P], AggregateRbacPermission[P]>
  }




  export type RbacPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RbacPermissionWhereInput
    orderBy?: RbacPermissionOrderByWithAggregationInput | RbacPermissionOrderByWithAggregationInput[]
    by: RbacPermissionScalarFieldEnum[] | RbacPermissionScalarFieldEnum
    having?: RbacPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RbacPermissionCountAggregateInputType | true
    _min?: RbacPermissionMinAggregateInputType
    _max?: RbacPermissionMaxAggregateInputType
  }

  export type RbacPermissionGroupByOutputType = {
    id: string
    code: string
    description: string | null
    createdAt: Date
    _count: RbacPermissionCountAggregateOutputType | null
    _min: RbacPermissionMinAggregateOutputType | null
    _max: RbacPermissionMaxAggregateOutputType | null
  }

  type GetRbacPermissionGroupByPayload<T extends RbacPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RbacPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RbacPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RbacPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RbacPermissionGroupByOutputType[P]>
        }
      >
    >


  export type RbacPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    rolePerms?: boolean | RbacPermission$rolePermsArgs<ExtArgs>
    _count?: boolean | RbacPermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rbacPermission"]>

  export type RbacPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rbacPermission"]>

  export type RbacPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rbacPermission"]>

  export type RbacPermissionSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type RbacPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "createdAt", ExtArgs["result"]["rbacPermission"]>
  export type RbacPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePerms?: boolean | RbacPermission$rolePermsArgs<ExtArgs>
    _count?: boolean | RbacPermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RbacPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RbacPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RbacPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RbacPermission"
    objects: {
      rolePerms: Prisma.$RbacRolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["rbacPermission"]>
    composites: {}
  }

  type RbacPermissionGetPayload<S extends boolean | null | undefined | RbacPermissionDefaultArgs> = $Result.GetResult<Prisma.$RbacPermissionPayload, S>

  type RbacPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RbacPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RbacPermissionCountAggregateInputType | true
    }

  export interface RbacPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RbacPermission'], meta: { name: 'RbacPermission' } }
    /**
     * Find zero or one RbacPermission that matches the filter.
     * @param {RbacPermissionFindUniqueArgs} args - Arguments to find a RbacPermission
     * @example
     * // Get one RbacPermission
     * const rbacPermission = await prisma.rbacPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RbacPermissionFindUniqueArgs>(args: SelectSubset<T, RbacPermissionFindUniqueArgs<ExtArgs>>): Prisma__RbacPermissionClient<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RbacPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RbacPermissionFindUniqueOrThrowArgs} args - Arguments to find a RbacPermission
     * @example
     * // Get one RbacPermission
     * const rbacPermission = await prisma.rbacPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RbacPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RbacPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RbacPermissionClient<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RbacPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacPermissionFindFirstArgs} args - Arguments to find a RbacPermission
     * @example
     * // Get one RbacPermission
     * const rbacPermission = await prisma.rbacPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RbacPermissionFindFirstArgs>(args?: SelectSubset<T, RbacPermissionFindFirstArgs<ExtArgs>>): Prisma__RbacPermissionClient<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RbacPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacPermissionFindFirstOrThrowArgs} args - Arguments to find a RbacPermission
     * @example
     * // Get one RbacPermission
     * const rbacPermission = await prisma.rbacPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RbacPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RbacPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RbacPermissionClient<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RbacPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RbacPermissions
     * const rbacPermissions = await prisma.rbacPermission.findMany()
     * 
     * // Get first 10 RbacPermissions
     * const rbacPermissions = await prisma.rbacPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rbacPermissionWithIdOnly = await prisma.rbacPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RbacPermissionFindManyArgs>(args?: SelectSubset<T, RbacPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RbacPermission.
     * @param {RbacPermissionCreateArgs} args - Arguments to create a RbacPermission.
     * @example
     * // Create one RbacPermission
     * const RbacPermission = await prisma.rbacPermission.create({
     *   data: {
     *     // ... data to create a RbacPermission
     *   }
     * })
     * 
     */
    create<T extends RbacPermissionCreateArgs>(args: SelectSubset<T, RbacPermissionCreateArgs<ExtArgs>>): Prisma__RbacPermissionClient<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RbacPermissions.
     * @param {RbacPermissionCreateManyArgs} args - Arguments to create many RbacPermissions.
     * @example
     * // Create many RbacPermissions
     * const rbacPermission = await prisma.rbacPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RbacPermissionCreateManyArgs>(args?: SelectSubset<T, RbacPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RbacPermissions and returns the data saved in the database.
     * @param {RbacPermissionCreateManyAndReturnArgs} args - Arguments to create many RbacPermissions.
     * @example
     * // Create many RbacPermissions
     * const rbacPermission = await prisma.rbacPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RbacPermissions and only return the `id`
     * const rbacPermissionWithIdOnly = await prisma.rbacPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RbacPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RbacPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RbacPermission.
     * @param {RbacPermissionDeleteArgs} args - Arguments to delete one RbacPermission.
     * @example
     * // Delete one RbacPermission
     * const RbacPermission = await prisma.rbacPermission.delete({
     *   where: {
     *     // ... filter to delete one RbacPermission
     *   }
     * })
     * 
     */
    delete<T extends RbacPermissionDeleteArgs>(args: SelectSubset<T, RbacPermissionDeleteArgs<ExtArgs>>): Prisma__RbacPermissionClient<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RbacPermission.
     * @param {RbacPermissionUpdateArgs} args - Arguments to update one RbacPermission.
     * @example
     * // Update one RbacPermission
     * const rbacPermission = await prisma.rbacPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RbacPermissionUpdateArgs>(args: SelectSubset<T, RbacPermissionUpdateArgs<ExtArgs>>): Prisma__RbacPermissionClient<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RbacPermissions.
     * @param {RbacPermissionDeleteManyArgs} args - Arguments to filter RbacPermissions to delete.
     * @example
     * // Delete a few RbacPermissions
     * const { count } = await prisma.rbacPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RbacPermissionDeleteManyArgs>(args?: SelectSubset<T, RbacPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RbacPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RbacPermissions
     * const rbacPermission = await prisma.rbacPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RbacPermissionUpdateManyArgs>(args: SelectSubset<T, RbacPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RbacPermissions and returns the data updated in the database.
     * @param {RbacPermissionUpdateManyAndReturnArgs} args - Arguments to update many RbacPermissions.
     * @example
     * // Update many RbacPermissions
     * const rbacPermission = await prisma.rbacPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RbacPermissions and only return the `id`
     * const rbacPermissionWithIdOnly = await prisma.rbacPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RbacPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RbacPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RbacPermission.
     * @param {RbacPermissionUpsertArgs} args - Arguments to update or create a RbacPermission.
     * @example
     * // Update or create a RbacPermission
     * const rbacPermission = await prisma.rbacPermission.upsert({
     *   create: {
     *     // ... data to create a RbacPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RbacPermission we want to update
     *   }
     * })
     */
    upsert<T extends RbacPermissionUpsertArgs>(args: SelectSubset<T, RbacPermissionUpsertArgs<ExtArgs>>): Prisma__RbacPermissionClient<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RbacPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacPermissionCountArgs} args - Arguments to filter RbacPermissions to count.
     * @example
     * // Count the number of RbacPermissions
     * const count = await prisma.rbacPermission.count({
     *   where: {
     *     // ... the filter for the RbacPermissions we want to count
     *   }
     * })
    **/
    count<T extends RbacPermissionCountArgs>(
      args?: Subset<T, RbacPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RbacPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RbacPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RbacPermissionAggregateArgs>(args: Subset<T, RbacPermissionAggregateArgs>): Prisma.PrismaPromise<GetRbacPermissionAggregateType<T>>

    /**
     * Group by RbacPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RbacPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RbacPermissionGroupByArgs['orderBy'] }
        : { orderBy?: RbacPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RbacPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRbacPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RbacPermission model
   */
  readonly fields: RbacPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RbacPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RbacPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePerms<T extends RbacPermission$rolePermsArgs<ExtArgs> = {}>(args?: Subset<T, RbacPermission$rolePermsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RbacPermission model
   */
  interface RbacPermissionFieldRefs {
    readonly id: FieldRef<"RbacPermission", 'String'>
    readonly code: FieldRef<"RbacPermission", 'String'>
    readonly description: FieldRef<"RbacPermission", 'String'>
    readonly createdAt: FieldRef<"RbacPermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RbacPermission findUnique
   */
  export type RbacPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacPermissionInclude<ExtArgs> | null
    /**
     * Filter, which RbacPermission to fetch.
     */
    where: RbacPermissionWhereUniqueInput
  }

  /**
   * RbacPermission findUniqueOrThrow
   */
  export type RbacPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacPermissionInclude<ExtArgs> | null
    /**
     * Filter, which RbacPermission to fetch.
     */
    where: RbacPermissionWhereUniqueInput
  }

  /**
   * RbacPermission findFirst
   */
  export type RbacPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacPermissionInclude<ExtArgs> | null
    /**
     * Filter, which RbacPermission to fetch.
     */
    where?: RbacPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacPermissions to fetch.
     */
    orderBy?: RbacPermissionOrderByWithRelationInput | RbacPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RbacPermissions.
     */
    cursor?: RbacPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RbacPermissions.
     */
    distinct?: RbacPermissionScalarFieldEnum | RbacPermissionScalarFieldEnum[]
  }

  /**
   * RbacPermission findFirstOrThrow
   */
  export type RbacPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacPermissionInclude<ExtArgs> | null
    /**
     * Filter, which RbacPermission to fetch.
     */
    where?: RbacPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacPermissions to fetch.
     */
    orderBy?: RbacPermissionOrderByWithRelationInput | RbacPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RbacPermissions.
     */
    cursor?: RbacPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RbacPermissions.
     */
    distinct?: RbacPermissionScalarFieldEnum | RbacPermissionScalarFieldEnum[]
  }

  /**
   * RbacPermission findMany
   */
  export type RbacPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacPermissionInclude<ExtArgs> | null
    /**
     * Filter, which RbacPermissions to fetch.
     */
    where?: RbacPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacPermissions to fetch.
     */
    orderBy?: RbacPermissionOrderByWithRelationInput | RbacPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RbacPermissions.
     */
    cursor?: RbacPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacPermissions.
     */
    skip?: number
    distinct?: RbacPermissionScalarFieldEnum | RbacPermissionScalarFieldEnum[]
  }

  /**
   * RbacPermission create
   */
  export type RbacPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RbacPermission.
     */
    data: XOR<RbacPermissionCreateInput, RbacPermissionUncheckedCreateInput>
  }

  /**
   * RbacPermission createMany
   */
  export type RbacPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RbacPermissions.
     */
    data: RbacPermissionCreateManyInput | RbacPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RbacPermission createManyAndReturn
   */
  export type RbacPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RbacPermissions.
     */
    data: RbacPermissionCreateManyInput | RbacPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RbacPermission update
   */
  export type RbacPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RbacPermission.
     */
    data: XOR<RbacPermissionUpdateInput, RbacPermissionUncheckedUpdateInput>
    /**
     * Choose, which RbacPermission to update.
     */
    where: RbacPermissionWhereUniqueInput
  }

  /**
   * RbacPermission updateMany
   */
  export type RbacPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RbacPermissions.
     */
    data: XOR<RbacPermissionUpdateManyMutationInput, RbacPermissionUncheckedUpdateManyInput>
    /**
     * Filter which RbacPermissions to update
     */
    where?: RbacPermissionWhereInput
    /**
     * Limit how many RbacPermissions to update.
     */
    limit?: number
  }

  /**
   * RbacPermission updateManyAndReturn
   */
  export type RbacPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * The data used to update RbacPermissions.
     */
    data: XOR<RbacPermissionUpdateManyMutationInput, RbacPermissionUncheckedUpdateManyInput>
    /**
     * Filter which RbacPermissions to update
     */
    where?: RbacPermissionWhereInput
    /**
     * Limit how many RbacPermissions to update.
     */
    limit?: number
  }

  /**
   * RbacPermission upsert
   */
  export type RbacPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RbacPermission to update in case it exists.
     */
    where: RbacPermissionWhereUniqueInput
    /**
     * In case the RbacPermission found by the `where` argument doesn't exist, create a new RbacPermission with this data.
     */
    create: XOR<RbacPermissionCreateInput, RbacPermissionUncheckedCreateInput>
    /**
     * In case the RbacPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RbacPermissionUpdateInput, RbacPermissionUncheckedUpdateInput>
  }

  /**
   * RbacPermission delete
   */
  export type RbacPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacPermissionInclude<ExtArgs> | null
    /**
     * Filter which RbacPermission to delete.
     */
    where: RbacPermissionWhereUniqueInput
  }

  /**
   * RbacPermission deleteMany
   */
  export type RbacPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RbacPermissions to delete
     */
    where?: RbacPermissionWhereInput
    /**
     * Limit how many RbacPermissions to delete.
     */
    limit?: number
  }

  /**
   * RbacPermission.rolePerms
   */
  export type RbacPermission$rolePermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    where?: RbacRolePermissionWhereInput
    orderBy?: RbacRolePermissionOrderByWithRelationInput | RbacRolePermissionOrderByWithRelationInput[]
    cursor?: RbacRolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RbacRolePermissionScalarFieldEnum | RbacRolePermissionScalarFieldEnum[]
  }

  /**
   * RbacPermission without action
   */
  export type RbacPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacPermission
     */
    select?: RbacPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacPermission
     */
    omit?: RbacPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacPermissionInclude<ExtArgs> | null
  }


  /**
   * Model RbacRole
   */

  export type AggregateRbacRole = {
    _count: RbacRoleCountAggregateOutputType | null
    _min: RbacRoleMinAggregateOutputType | null
    _max: RbacRoleMaxAggregateOutputType | null
  }

  export type RbacRoleMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    slug: string | null
    isSystem: boolean | null
    createdAt: Date | null
  }

  export type RbacRoleMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    slug: string | null
    isSystem: boolean | null
    createdAt: Date | null
  }

  export type RbacRoleCountAggregateOutputType = {
    id: number
    orgId: number
    name: number
    slug: number
    isSystem: number
    createdAt: number
    _all: number
  }


  export type RbacRoleMinAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    slug?: true
    isSystem?: true
    createdAt?: true
  }

  export type RbacRoleMaxAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    slug?: true
    isSystem?: true
    createdAt?: true
  }

  export type RbacRoleCountAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    slug?: true
    isSystem?: true
    createdAt?: true
    _all?: true
  }

  export type RbacRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RbacRole to aggregate.
     */
    where?: RbacRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacRoles to fetch.
     */
    orderBy?: RbacRoleOrderByWithRelationInput | RbacRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RbacRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RbacRoles
    **/
    _count?: true | RbacRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RbacRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RbacRoleMaxAggregateInputType
  }

  export type GetRbacRoleAggregateType<T extends RbacRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRbacRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRbacRole[P]>
      : GetScalarType<T[P], AggregateRbacRole[P]>
  }




  export type RbacRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RbacRoleWhereInput
    orderBy?: RbacRoleOrderByWithAggregationInput | RbacRoleOrderByWithAggregationInput[]
    by: RbacRoleScalarFieldEnum[] | RbacRoleScalarFieldEnum
    having?: RbacRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RbacRoleCountAggregateInputType | true
    _min?: RbacRoleMinAggregateInputType
    _max?: RbacRoleMaxAggregateInputType
  }

  export type RbacRoleGroupByOutputType = {
    id: string
    orgId: string | null
    name: string
    slug: string
    isSystem: boolean
    createdAt: Date
    _count: RbacRoleCountAggregateOutputType | null
    _min: RbacRoleMinAggregateOutputType | null
    _max: RbacRoleMaxAggregateOutputType | null
  }

  type GetRbacRoleGroupByPayload<T extends RbacRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RbacRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RbacRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RbacRoleGroupByOutputType[P]>
            : GetScalarType<T[P], RbacRoleGroupByOutputType[P]>
        }
      >
    >


  export type RbacRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    slug?: boolean
    isSystem?: boolean
    createdAt?: boolean
    org?: boolean | RbacRole$orgArgs<ExtArgs>
    rolePerms?: boolean | RbacRole$rolePermsArgs<ExtArgs>
    userRoles?: boolean | RbacRole$userRolesArgs<ExtArgs>
    _count?: boolean | RbacRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rbacRole"]>

  export type RbacRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    slug?: boolean
    isSystem?: boolean
    createdAt?: boolean
    org?: boolean | RbacRole$orgArgs<ExtArgs>
  }, ExtArgs["result"]["rbacRole"]>

  export type RbacRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    slug?: boolean
    isSystem?: boolean
    createdAt?: boolean
    org?: boolean | RbacRole$orgArgs<ExtArgs>
  }, ExtArgs["result"]["rbacRole"]>

  export type RbacRoleSelectScalar = {
    id?: boolean
    orgId?: boolean
    name?: boolean
    slug?: boolean
    isSystem?: boolean
    createdAt?: boolean
  }

  export type RbacRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "name" | "slug" | "isSystem" | "createdAt", ExtArgs["result"]["rbacRole"]>
  export type RbacRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | RbacRole$orgArgs<ExtArgs>
    rolePerms?: boolean | RbacRole$rolePermsArgs<ExtArgs>
    userRoles?: boolean | RbacRole$userRolesArgs<ExtArgs>
    _count?: boolean | RbacRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RbacRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | RbacRole$orgArgs<ExtArgs>
  }
  export type RbacRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | RbacRole$orgArgs<ExtArgs>
  }

  export type $RbacRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RbacRole"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs> | null
      rolePerms: Prisma.$RbacRolePermissionPayload<ExtArgs>[]
      userRoles: Prisma.$RbacUserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string | null
      name: string
      slug: string
      isSystem: boolean
      createdAt: Date
    }, ExtArgs["result"]["rbacRole"]>
    composites: {}
  }

  type RbacRoleGetPayload<S extends boolean | null | undefined | RbacRoleDefaultArgs> = $Result.GetResult<Prisma.$RbacRolePayload, S>

  type RbacRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RbacRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RbacRoleCountAggregateInputType | true
    }

  export interface RbacRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RbacRole'], meta: { name: 'RbacRole' } }
    /**
     * Find zero or one RbacRole that matches the filter.
     * @param {RbacRoleFindUniqueArgs} args - Arguments to find a RbacRole
     * @example
     * // Get one RbacRole
     * const rbacRole = await prisma.rbacRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RbacRoleFindUniqueArgs>(args: SelectSubset<T, RbacRoleFindUniqueArgs<ExtArgs>>): Prisma__RbacRoleClient<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RbacRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RbacRoleFindUniqueOrThrowArgs} args - Arguments to find a RbacRole
     * @example
     * // Get one RbacRole
     * const rbacRole = await prisma.rbacRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RbacRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RbacRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RbacRoleClient<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RbacRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRoleFindFirstArgs} args - Arguments to find a RbacRole
     * @example
     * // Get one RbacRole
     * const rbacRole = await prisma.rbacRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RbacRoleFindFirstArgs>(args?: SelectSubset<T, RbacRoleFindFirstArgs<ExtArgs>>): Prisma__RbacRoleClient<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RbacRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRoleFindFirstOrThrowArgs} args - Arguments to find a RbacRole
     * @example
     * // Get one RbacRole
     * const rbacRole = await prisma.rbacRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RbacRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RbacRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RbacRoleClient<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RbacRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RbacRoles
     * const rbacRoles = await prisma.rbacRole.findMany()
     * 
     * // Get first 10 RbacRoles
     * const rbacRoles = await prisma.rbacRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rbacRoleWithIdOnly = await prisma.rbacRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RbacRoleFindManyArgs>(args?: SelectSubset<T, RbacRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RbacRole.
     * @param {RbacRoleCreateArgs} args - Arguments to create a RbacRole.
     * @example
     * // Create one RbacRole
     * const RbacRole = await prisma.rbacRole.create({
     *   data: {
     *     // ... data to create a RbacRole
     *   }
     * })
     * 
     */
    create<T extends RbacRoleCreateArgs>(args: SelectSubset<T, RbacRoleCreateArgs<ExtArgs>>): Prisma__RbacRoleClient<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RbacRoles.
     * @param {RbacRoleCreateManyArgs} args - Arguments to create many RbacRoles.
     * @example
     * // Create many RbacRoles
     * const rbacRole = await prisma.rbacRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RbacRoleCreateManyArgs>(args?: SelectSubset<T, RbacRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RbacRoles and returns the data saved in the database.
     * @param {RbacRoleCreateManyAndReturnArgs} args - Arguments to create many RbacRoles.
     * @example
     * // Create many RbacRoles
     * const rbacRole = await prisma.rbacRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RbacRoles and only return the `id`
     * const rbacRoleWithIdOnly = await prisma.rbacRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RbacRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RbacRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RbacRole.
     * @param {RbacRoleDeleteArgs} args - Arguments to delete one RbacRole.
     * @example
     * // Delete one RbacRole
     * const RbacRole = await prisma.rbacRole.delete({
     *   where: {
     *     // ... filter to delete one RbacRole
     *   }
     * })
     * 
     */
    delete<T extends RbacRoleDeleteArgs>(args: SelectSubset<T, RbacRoleDeleteArgs<ExtArgs>>): Prisma__RbacRoleClient<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RbacRole.
     * @param {RbacRoleUpdateArgs} args - Arguments to update one RbacRole.
     * @example
     * // Update one RbacRole
     * const rbacRole = await prisma.rbacRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RbacRoleUpdateArgs>(args: SelectSubset<T, RbacRoleUpdateArgs<ExtArgs>>): Prisma__RbacRoleClient<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RbacRoles.
     * @param {RbacRoleDeleteManyArgs} args - Arguments to filter RbacRoles to delete.
     * @example
     * // Delete a few RbacRoles
     * const { count } = await prisma.rbacRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RbacRoleDeleteManyArgs>(args?: SelectSubset<T, RbacRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RbacRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RbacRoles
     * const rbacRole = await prisma.rbacRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RbacRoleUpdateManyArgs>(args: SelectSubset<T, RbacRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RbacRoles and returns the data updated in the database.
     * @param {RbacRoleUpdateManyAndReturnArgs} args - Arguments to update many RbacRoles.
     * @example
     * // Update many RbacRoles
     * const rbacRole = await prisma.rbacRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RbacRoles and only return the `id`
     * const rbacRoleWithIdOnly = await prisma.rbacRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RbacRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RbacRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RbacRole.
     * @param {RbacRoleUpsertArgs} args - Arguments to update or create a RbacRole.
     * @example
     * // Update or create a RbacRole
     * const rbacRole = await prisma.rbacRole.upsert({
     *   create: {
     *     // ... data to create a RbacRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RbacRole we want to update
     *   }
     * })
     */
    upsert<T extends RbacRoleUpsertArgs>(args: SelectSubset<T, RbacRoleUpsertArgs<ExtArgs>>): Prisma__RbacRoleClient<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RbacRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRoleCountArgs} args - Arguments to filter RbacRoles to count.
     * @example
     * // Count the number of RbacRoles
     * const count = await prisma.rbacRole.count({
     *   where: {
     *     // ... the filter for the RbacRoles we want to count
     *   }
     * })
    **/
    count<T extends RbacRoleCountArgs>(
      args?: Subset<T, RbacRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RbacRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RbacRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RbacRoleAggregateArgs>(args: Subset<T, RbacRoleAggregateArgs>): Prisma.PrismaPromise<GetRbacRoleAggregateType<T>>

    /**
     * Group by RbacRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RbacRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RbacRoleGroupByArgs['orderBy'] }
        : { orderBy?: RbacRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RbacRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRbacRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RbacRole model
   */
  readonly fields: RbacRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RbacRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RbacRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends RbacRole$orgArgs<ExtArgs> = {}>(args?: Subset<T, RbacRole$orgArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rolePerms<T extends RbacRole$rolePermsArgs<ExtArgs> = {}>(args?: Subset<T, RbacRole$rolePermsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userRoles<T extends RbacRole$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, RbacRole$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RbacRole model
   */
  interface RbacRoleFieldRefs {
    readonly id: FieldRef<"RbacRole", 'String'>
    readonly orgId: FieldRef<"RbacRole", 'String'>
    readonly name: FieldRef<"RbacRole", 'String'>
    readonly slug: FieldRef<"RbacRole", 'String'>
    readonly isSystem: FieldRef<"RbacRole", 'Boolean'>
    readonly createdAt: FieldRef<"RbacRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RbacRole findUnique
   */
  export type RbacRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
    /**
     * Filter, which RbacRole to fetch.
     */
    where: RbacRoleWhereUniqueInput
  }

  /**
   * RbacRole findUniqueOrThrow
   */
  export type RbacRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
    /**
     * Filter, which RbacRole to fetch.
     */
    where: RbacRoleWhereUniqueInput
  }

  /**
   * RbacRole findFirst
   */
  export type RbacRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
    /**
     * Filter, which RbacRole to fetch.
     */
    where?: RbacRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacRoles to fetch.
     */
    orderBy?: RbacRoleOrderByWithRelationInput | RbacRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RbacRoles.
     */
    cursor?: RbacRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RbacRoles.
     */
    distinct?: RbacRoleScalarFieldEnum | RbacRoleScalarFieldEnum[]
  }

  /**
   * RbacRole findFirstOrThrow
   */
  export type RbacRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
    /**
     * Filter, which RbacRole to fetch.
     */
    where?: RbacRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacRoles to fetch.
     */
    orderBy?: RbacRoleOrderByWithRelationInput | RbacRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RbacRoles.
     */
    cursor?: RbacRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RbacRoles.
     */
    distinct?: RbacRoleScalarFieldEnum | RbacRoleScalarFieldEnum[]
  }

  /**
   * RbacRole findMany
   */
  export type RbacRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
    /**
     * Filter, which RbacRoles to fetch.
     */
    where?: RbacRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacRoles to fetch.
     */
    orderBy?: RbacRoleOrderByWithRelationInput | RbacRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RbacRoles.
     */
    cursor?: RbacRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacRoles.
     */
    skip?: number
    distinct?: RbacRoleScalarFieldEnum | RbacRoleScalarFieldEnum[]
  }

  /**
   * RbacRole create
   */
  export type RbacRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a RbacRole.
     */
    data: XOR<RbacRoleCreateInput, RbacRoleUncheckedCreateInput>
  }

  /**
   * RbacRole createMany
   */
  export type RbacRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RbacRoles.
     */
    data: RbacRoleCreateManyInput | RbacRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RbacRole createManyAndReturn
   */
  export type RbacRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * The data used to create many RbacRoles.
     */
    data: RbacRoleCreateManyInput | RbacRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RbacRole update
   */
  export type RbacRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a RbacRole.
     */
    data: XOR<RbacRoleUpdateInput, RbacRoleUncheckedUpdateInput>
    /**
     * Choose, which RbacRole to update.
     */
    where: RbacRoleWhereUniqueInput
  }

  /**
   * RbacRole updateMany
   */
  export type RbacRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RbacRoles.
     */
    data: XOR<RbacRoleUpdateManyMutationInput, RbacRoleUncheckedUpdateManyInput>
    /**
     * Filter which RbacRoles to update
     */
    where?: RbacRoleWhereInput
    /**
     * Limit how many RbacRoles to update.
     */
    limit?: number
  }

  /**
   * RbacRole updateManyAndReturn
   */
  export type RbacRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * The data used to update RbacRoles.
     */
    data: XOR<RbacRoleUpdateManyMutationInput, RbacRoleUncheckedUpdateManyInput>
    /**
     * Filter which RbacRoles to update
     */
    where?: RbacRoleWhereInput
    /**
     * Limit how many RbacRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RbacRole upsert
   */
  export type RbacRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the RbacRole to update in case it exists.
     */
    where: RbacRoleWhereUniqueInput
    /**
     * In case the RbacRole found by the `where` argument doesn't exist, create a new RbacRole with this data.
     */
    create: XOR<RbacRoleCreateInput, RbacRoleUncheckedCreateInput>
    /**
     * In case the RbacRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RbacRoleUpdateInput, RbacRoleUncheckedUpdateInput>
  }

  /**
   * RbacRole delete
   */
  export type RbacRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
    /**
     * Filter which RbacRole to delete.
     */
    where: RbacRoleWhereUniqueInput
  }

  /**
   * RbacRole deleteMany
   */
  export type RbacRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RbacRoles to delete
     */
    where?: RbacRoleWhereInput
    /**
     * Limit how many RbacRoles to delete.
     */
    limit?: number
  }

  /**
   * RbacRole.org
   */
  export type RbacRole$orgArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    where?: OrgWhereInput
  }

  /**
   * RbacRole.rolePerms
   */
  export type RbacRole$rolePermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    where?: RbacRolePermissionWhereInput
    orderBy?: RbacRolePermissionOrderByWithRelationInput | RbacRolePermissionOrderByWithRelationInput[]
    cursor?: RbacRolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RbacRolePermissionScalarFieldEnum | RbacRolePermissionScalarFieldEnum[]
  }

  /**
   * RbacRole.userRoles
   */
  export type RbacRole$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    where?: RbacUserRoleWhereInput
    orderBy?: RbacUserRoleOrderByWithRelationInput | RbacUserRoleOrderByWithRelationInput[]
    cursor?: RbacUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RbacUserRoleScalarFieldEnum | RbacUserRoleScalarFieldEnum[]
  }

  /**
   * RbacRole without action
   */
  export type RbacRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRole
     */
    select?: RbacRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRole
     */
    omit?: RbacRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRoleInclude<ExtArgs> | null
  }


  /**
   * Model RbacRolePermission
   */

  export type AggregateRbacRolePermission = {
    _count: RbacRolePermissionCountAggregateOutputType | null
    _min: RbacRolePermissionMinAggregateOutputType | null
    _max: RbacRolePermissionMaxAggregateOutputType | null
  }

  export type RbacRolePermissionMinAggregateOutputType = {
    roleId: string | null
    permissionId: string | null
  }

  export type RbacRolePermissionMaxAggregateOutputType = {
    roleId: string | null
    permissionId: string | null
  }

  export type RbacRolePermissionCountAggregateOutputType = {
    roleId: number
    permissionId: number
    _all: number
  }


  export type RbacRolePermissionMinAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RbacRolePermissionMaxAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RbacRolePermissionCountAggregateInputType = {
    roleId?: true
    permissionId?: true
    _all?: true
  }

  export type RbacRolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RbacRolePermission to aggregate.
     */
    where?: RbacRolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacRolePermissions to fetch.
     */
    orderBy?: RbacRolePermissionOrderByWithRelationInput | RbacRolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RbacRolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacRolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacRolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RbacRolePermissions
    **/
    _count?: true | RbacRolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RbacRolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RbacRolePermissionMaxAggregateInputType
  }

  export type GetRbacRolePermissionAggregateType<T extends RbacRolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRbacRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRbacRolePermission[P]>
      : GetScalarType<T[P], AggregateRbacRolePermission[P]>
  }




  export type RbacRolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RbacRolePermissionWhereInput
    orderBy?: RbacRolePermissionOrderByWithAggregationInput | RbacRolePermissionOrderByWithAggregationInput[]
    by: RbacRolePermissionScalarFieldEnum[] | RbacRolePermissionScalarFieldEnum
    having?: RbacRolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RbacRolePermissionCountAggregateInputType | true
    _min?: RbacRolePermissionMinAggregateInputType
    _max?: RbacRolePermissionMaxAggregateInputType
  }

  export type RbacRolePermissionGroupByOutputType = {
    roleId: string
    permissionId: string
    _count: RbacRolePermissionCountAggregateOutputType | null
    _min: RbacRolePermissionMinAggregateOutputType | null
    _max: RbacRolePermissionMaxAggregateOutputType | null
  }

  type GetRbacRolePermissionGroupByPayload<T extends RbacRolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RbacRolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RbacRolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RbacRolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RbacRolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RbacRolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
    permission?: boolean | RbacPermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rbacRolePermission"]>

  export type RbacRolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
    permission?: boolean | RbacPermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rbacRolePermission"]>

  export type RbacRolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
    permission?: boolean | RbacPermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rbacRolePermission"]>

  export type RbacRolePermissionSelectScalar = {
    roleId?: boolean
    permissionId?: boolean
  }

  export type RbacRolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roleId" | "permissionId", ExtArgs["result"]["rbacRolePermission"]>
  export type RbacRolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
    permission?: boolean | RbacPermissionDefaultArgs<ExtArgs>
  }
  export type RbacRolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
    permission?: boolean | RbacPermissionDefaultArgs<ExtArgs>
  }
  export type RbacRolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
    permission?: boolean | RbacPermissionDefaultArgs<ExtArgs>
  }

  export type $RbacRolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RbacRolePermission"
    objects: {
      role: Prisma.$RbacRolePayload<ExtArgs>
      permission: Prisma.$RbacPermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: string
      permissionId: string
    }, ExtArgs["result"]["rbacRolePermission"]>
    composites: {}
  }

  type RbacRolePermissionGetPayload<S extends boolean | null | undefined | RbacRolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RbacRolePermissionPayload, S>

  type RbacRolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RbacRolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RbacRolePermissionCountAggregateInputType | true
    }

  export interface RbacRolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RbacRolePermission'], meta: { name: 'RbacRolePermission' } }
    /**
     * Find zero or one RbacRolePermission that matches the filter.
     * @param {RbacRolePermissionFindUniqueArgs} args - Arguments to find a RbacRolePermission
     * @example
     * // Get one RbacRolePermission
     * const rbacRolePermission = await prisma.rbacRolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RbacRolePermissionFindUniqueArgs>(args: SelectSubset<T, RbacRolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RbacRolePermissionClient<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RbacRolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RbacRolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RbacRolePermission
     * @example
     * // Get one RbacRolePermission
     * const rbacRolePermission = await prisma.rbacRolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RbacRolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RbacRolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RbacRolePermissionClient<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RbacRolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRolePermissionFindFirstArgs} args - Arguments to find a RbacRolePermission
     * @example
     * // Get one RbacRolePermission
     * const rbacRolePermission = await prisma.rbacRolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RbacRolePermissionFindFirstArgs>(args?: SelectSubset<T, RbacRolePermissionFindFirstArgs<ExtArgs>>): Prisma__RbacRolePermissionClient<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RbacRolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRolePermissionFindFirstOrThrowArgs} args - Arguments to find a RbacRolePermission
     * @example
     * // Get one RbacRolePermission
     * const rbacRolePermission = await prisma.rbacRolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RbacRolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RbacRolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RbacRolePermissionClient<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RbacRolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RbacRolePermissions
     * const rbacRolePermissions = await prisma.rbacRolePermission.findMany()
     * 
     * // Get first 10 RbacRolePermissions
     * const rbacRolePermissions = await prisma.rbacRolePermission.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rbacRolePermissionWithRoleIdOnly = await prisma.rbacRolePermission.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RbacRolePermissionFindManyArgs>(args?: SelectSubset<T, RbacRolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RbacRolePermission.
     * @param {RbacRolePermissionCreateArgs} args - Arguments to create a RbacRolePermission.
     * @example
     * // Create one RbacRolePermission
     * const RbacRolePermission = await prisma.rbacRolePermission.create({
     *   data: {
     *     // ... data to create a RbacRolePermission
     *   }
     * })
     * 
     */
    create<T extends RbacRolePermissionCreateArgs>(args: SelectSubset<T, RbacRolePermissionCreateArgs<ExtArgs>>): Prisma__RbacRolePermissionClient<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RbacRolePermissions.
     * @param {RbacRolePermissionCreateManyArgs} args - Arguments to create many RbacRolePermissions.
     * @example
     * // Create many RbacRolePermissions
     * const rbacRolePermission = await prisma.rbacRolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RbacRolePermissionCreateManyArgs>(args?: SelectSubset<T, RbacRolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RbacRolePermissions and returns the data saved in the database.
     * @param {RbacRolePermissionCreateManyAndReturnArgs} args - Arguments to create many RbacRolePermissions.
     * @example
     * // Create many RbacRolePermissions
     * const rbacRolePermission = await prisma.rbacRolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RbacRolePermissions and only return the `roleId`
     * const rbacRolePermissionWithRoleIdOnly = await prisma.rbacRolePermission.createManyAndReturn({
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RbacRolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RbacRolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RbacRolePermission.
     * @param {RbacRolePermissionDeleteArgs} args - Arguments to delete one RbacRolePermission.
     * @example
     * // Delete one RbacRolePermission
     * const RbacRolePermission = await prisma.rbacRolePermission.delete({
     *   where: {
     *     // ... filter to delete one RbacRolePermission
     *   }
     * })
     * 
     */
    delete<T extends RbacRolePermissionDeleteArgs>(args: SelectSubset<T, RbacRolePermissionDeleteArgs<ExtArgs>>): Prisma__RbacRolePermissionClient<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RbacRolePermission.
     * @param {RbacRolePermissionUpdateArgs} args - Arguments to update one RbacRolePermission.
     * @example
     * // Update one RbacRolePermission
     * const rbacRolePermission = await prisma.rbacRolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RbacRolePermissionUpdateArgs>(args: SelectSubset<T, RbacRolePermissionUpdateArgs<ExtArgs>>): Prisma__RbacRolePermissionClient<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RbacRolePermissions.
     * @param {RbacRolePermissionDeleteManyArgs} args - Arguments to filter RbacRolePermissions to delete.
     * @example
     * // Delete a few RbacRolePermissions
     * const { count } = await prisma.rbacRolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RbacRolePermissionDeleteManyArgs>(args?: SelectSubset<T, RbacRolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RbacRolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RbacRolePermissions
     * const rbacRolePermission = await prisma.rbacRolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RbacRolePermissionUpdateManyArgs>(args: SelectSubset<T, RbacRolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RbacRolePermissions and returns the data updated in the database.
     * @param {RbacRolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RbacRolePermissions.
     * @example
     * // Update many RbacRolePermissions
     * const rbacRolePermission = await prisma.rbacRolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RbacRolePermissions and only return the `roleId`
     * const rbacRolePermissionWithRoleIdOnly = await prisma.rbacRolePermission.updateManyAndReturn({
     *   select: { roleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RbacRolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RbacRolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RbacRolePermission.
     * @param {RbacRolePermissionUpsertArgs} args - Arguments to update or create a RbacRolePermission.
     * @example
     * // Update or create a RbacRolePermission
     * const rbacRolePermission = await prisma.rbacRolePermission.upsert({
     *   create: {
     *     // ... data to create a RbacRolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RbacRolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RbacRolePermissionUpsertArgs>(args: SelectSubset<T, RbacRolePermissionUpsertArgs<ExtArgs>>): Prisma__RbacRolePermissionClient<$Result.GetResult<Prisma.$RbacRolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RbacRolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRolePermissionCountArgs} args - Arguments to filter RbacRolePermissions to count.
     * @example
     * // Count the number of RbacRolePermissions
     * const count = await prisma.rbacRolePermission.count({
     *   where: {
     *     // ... the filter for the RbacRolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RbacRolePermissionCountArgs>(
      args?: Subset<T, RbacRolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RbacRolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RbacRolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RbacRolePermissionAggregateArgs>(args: Subset<T, RbacRolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRbacRolePermissionAggregateType<T>>

    /**
     * Group by RbacRolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacRolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RbacRolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RbacRolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RbacRolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RbacRolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRbacRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RbacRolePermission model
   */
  readonly fields: RbacRolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RbacRolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RbacRolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RbacRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RbacRoleDefaultArgs<ExtArgs>>): Prisma__RbacRoleClient<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends RbacPermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RbacPermissionDefaultArgs<ExtArgs>>): Prisma__RbacPermissionClient<$Result.GetResult<Prisma.$RbacPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RbacRolePermission model
   */
  interface RbacRolePermissionFieldRefs {
    readonly roleId: FieldRef<"RbacRolePermission", 'String'>
    readonly permissionId: FieldRef<"RbacRolePermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RbacRolePermission findUnique
   */
  export type RbacRolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RbacRolePermission to fetch.
     */
    where: RbacRolePermissionWhereUniqueInput
  }

  /**
   * RbacRolePermission findUniqueOrThrow
   */
  export type RbacRolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RbacRolePermission to fetch.
     */
    where: RbacRolePermissionWhereUniqueInput
  }

  /**
   * RbacRolePermission findFirst
   */
  export type RbacRolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RbacRolePermission to fetch.
     */
    where?: RbacRolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacRolePermissions to fetch.
     */
    orderBy?: RbacRolePermissionOrderByWithRelationInput | RbacRolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RbacRolePermissions.
     */
    cursor?: RbacRolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacRolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacRolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RbacRolePermissions.
     */
    distinct?: RbacRolePermissionScalarFieldEnum | RbacRolePermissionScalarFieldEnum[]
  }

  /**
   * RbacRolePermission findFirstOrThrow
   */
  export type RbacRolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RbacRolePermission to fetch.
     */
    where?: RbacRolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacRolePermissions to fetch.
     */
    orderBy?: RbacRolePermissionOrderByWithRelationInput | RbacRolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RbacRolePermissions.
     */
    cursor?: RbacRolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacRolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacRolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RbacRolePermissions.
     */
    distinct?: RbacRolePermissionScalarFieldEnum | RbacRolePermissionScalarFieldEnum[]
  }

  /**
   * RbacRolePermission findMany
   */
  export type RbacRolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RbacRolePermissions to fetch.
     */
    where?: RbacRolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacRolePermissions to fetch.
     */
    orderBy?: RbacRolePermissionOrderByWithRelationInput | RbacRolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RbacRolePermissions.
     */
    cursor?: RbacRolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacRolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacRolePermissions.
     */
    skip?: number
    distinct?: RbacRolePermissionScalarFieldEnum | RbacRolePermissionScalarFieldEnum[]
  }

  /**
   * RbacRolePermission create
   */
  export type RbacRolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RbacRolePermission.
     */
    data: XOR<RbacRolePermissionCreateInput, RbacRolePermissionUncheckedCreateInput>
  }

  /**
   * RbacRolePermission createMany
   */
  export type RbacRolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RbacRolePermissions.
     */
    data: RbacRolePermissionCreateManyInput | RbacRolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RbacRolePermission createManyAndReturn
   */
  export type RbacRolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RbacRolePermissions.
     */
    data: RbacRolePermissionCreateManyInput | RbacRolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RbacRolePermission update
   */
  export type RbacRolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RbacRolePermission.
     */
    data: XOR<RbacRolePermissionUpdateInput, RbacRolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RbacRolePermission to update.
     */
    where: RbacRolePermissionWhereUniqueInput
  }

  /**
   * RbacRolePermission updateMany
   */
  export type RbacRolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RbacRolePermissions.
     */
    data: XOR<RbacRolePermissionUpdateManyMutationInput, RbacRolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RbacRolePermissions to update
     */
    where?: RbacRolePermissionWhereInput
    /**
     * Limit how many RbacRolePermissions to update.
     */
    limit?: number
  }

  /**
   * RbacRolePermission updateManyAndReturn
   */
  export type RbacRolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RbacRolePermissions.
     */
    data: XOR<RbacRolePermissionUpdateManyMutationInput, RbacRolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RbacRolePermissions to update
     */
    where?: RbacRolePermissionWhereInput
    /**
     * Limit how many RbacRolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RbacRolePermission upsert
   */
  export type RbacRolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RbacRolePermission to update in case it exists.
     */
    where: RbacRolePermissionWhereUniqueInput
    /**
     * In case the RbacRolePermission found by the `where` argument doesn't exist, create a new RbacRolePermission with this data.
     */
    create: XOR<RbacRolePermissionCreateInput, RbacRolePermissionUncheckedCreateInput>
    /**
     * In case the RbacRolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RbacRolePermissionUpdateInput, RbacRolePermissionUncheckedUpdateInput>
  }

  /**
   * RbacRolePermission delete
   */
  export type RbacRolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RbacRolePermission to delete.
     */
    where: RbacRolePermissionWhereUniqueInput
  }

  /**
   * RbacRolePermission deleteMany
   */
  export type RbacRolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RbacRolePermissions to delete
     */
    where?: RbacRolePermissionWhereInput
    /**
     * Limit how many RbacRolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RbacRolePermission without action
   */
  export type RbacRolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacRolePermission
     */
    select?: RbacRolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacRolePermission
     */
    omit?: RbacRolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacRolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model RbacUserRole
   */

  export type AggregateRbacUserRole = {
    _count: RbacUserRoleCountAggregateOutputType | null
    _min: RbacUserRoleMinAggregateOutputType | null
    _max: RbacUserRoleMaxAggregateOutputType | null
  }

  export type RbacUserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    orgId: string | null
    roleId: string | null
  }

  export type RbacUserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    orgId: string | null
    roleId: string | null
  }

  export type RbacUserRoleCountAggregateOutputType = {
    id: number
    userId: number
    orgId: number
    roleId: number
    _all: number
  }


  export type RbacUserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    roleId?: true
  }

  export type RbacUserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    roleId?: true
  }

  export type RbacUserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    roleId?: true
    _all?: true
  }

  export type RbacUserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RbacUserRole to aggregate.
     */
    where?: RbacUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacUserRoles to fetch.
     */
    orderBy?: RbacUserRoleOrderByWithRelationInput | RbacUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RbacUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RbacUserRoles
    **/
    _count?: true | RbacUserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RbacUserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RbacUserRoleMaxAggregateInputType
  }

  export type GetRbacUserRoleAggregateType<T extends RbacUserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRbacUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRbacUserRole[P]>
      : GetScalarType<T[P], AggregateRbacUserRole[P]>
  }




  export type RbacUserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RbacUserRoleWhereInput
    orderBy?: RbacUserRoleOrderByWithAggregationInput | RbacUserRoleOrderByWithAggregationInput[]
    by: RbacUserRoleScalarFieldEnum[] | RbacUserRoleScalarFieldEnum
    having?: RbacUserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RbacUserRoleCountAggregateInputType | true
    _min?: RbacUserRoleMinAggregateInputType
    _max?: RbacUserRoleMaxAggregateInputType
  }

  export type RbacUserRoleGroupByOutputType = {
    id: string
    userId: string
    orgId: string | null
    roleId: string
    _count: RbacUserRoleCountAggregateOutputType | null
    _min: RbacUserRoleMinAggregateOutputType | null
    _max: RbacUserRoleMaxAggregateOutputType | null
  }

  type GetRbacUserRoleGroupByPayload<T extends RbacUserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RbacUserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RbacUserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RbacUserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], RbacUserRoleGroupByOutputType[P]>
        }
      >
    >


  export type RbacUserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    org?: boolean | RbacUserRole$orgArgs<ExtArgs>
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rbacUserRole"]>

  export type RbacUserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    org?: boolean | RbacUserRole$orgArgs<ExtArgs>
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rbacUserRole"]>

  export type RbacUserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    org?: boolean | RbacUserRole$orgArgs<ExtArgs>
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rbacUserRole"]>

  export type RbacUserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    orgId?: boolean
    roleId?: boolean
  }

  export type RbacUserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "orgId" | "roleId", ExtArgs["result"]["rbacUserRole"]>
  export type RbacUserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    org?: boolean | RbacUserRole$orgArgs<ExtArgs>
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
  }
  export type RbacUserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    org?: boolean | RbacUserRole$orgArgs<ExtArgs>
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
  }
  export type RbacUserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    org?: boolean | RbacUserRole$orgArgs<ExtArgs>
    role?: boolean | RbacRoleDefaultArgs<ExtArgs>
  }

  export type $RbacUserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RbacUserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      org: Prisma.$OrgPayload<ExtArgs> | null
      role: Prisma.$RbacRolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      orgId: string | null
      roleId: string
    }, ExtArgs["result"]["rbacUserRole"]>
    composites: {}
  }

  type RbacUserRoleGetPayload<S extends boolean | null | undefined | RbacUserRoleDefaultArgs> = $Result.GetResult<Prisma.$RbacUserRolePayload, S>

  type RbacUserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RbacUserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RbacUserRoleCountAggregateInputType | true
    }

  export interface RbacUserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RbacUserRole'], meta: { name: 'RbacUserRole' } }
    /**
     * Find zero or one RbacUserRole that matches the filter.
     * @param {RbacUserRoleFindUniqueArgs} args - Arguments to find a RbacUserRole
     * @example
     * // Get one RbacUserRole
     * const rbacUserRole = await prisma.rbacUserRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RbacUserRoleFindUniqueArgs>(args: SelectSubset<T, RbacUserRoleFindUniqueArgs<ExtArgs>>): Prisma__RbacUserRoleClient<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RbacUserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RbacUserRoleFindUniqueOrThrowArgs} args - Arguments to find a RbacUserRole
     * @example
     * // Get one RbacUserRole
     * const rbacUserRole = await prisma.rbacUserRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RbacUserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RbacUserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RbacUserRoleClient<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RbacUserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacUserRoleFindFirstArgs} args - Arguments to find a RbacUserRole
     * @example
     * // Get one RbacUserRole
     * const rbacUserRole = await prisma.rbacUserRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RbacUserRoleFindFirstArgs>(args?: SelectSubset<T, RbacUserRoleFindFirstArgs<ExtArgs>>): Prisma__RbacUserRoleClient<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RbacUserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacUserRoleFindFirstOrThrowArgs} args - Arguments to find a RbacUserRole
     * @example
     * // Get one RbacUserRole
     * const rbacUserRole = await prisma.rbacUserRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RbacUserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RbacUserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RbacUserRoleClient<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RbacUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacUserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RbacUserRoles
     * const rbacUserRoles = await prisma.rbacUserRole.findMany()
     * 
     * // Get first 10 RbacUserRoles
     * const rbacUserRoles = await prisma.rbacUserRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rbacUserRoleWithIdOnly = await prisma.rbacUserRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RbacUserRoleFindManyArgs>(args?: SelectSubset<T, RbacUserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RbacUserRole.
     * @param {RbacUserRoleCreateArgs} args - Arguments to create a RbacUserRole.
     * @example
     * // Create one RbacUserRole
     * const RbacUserRole = await prisma.rbacUserRole.create({
     *   data: {
     *     // ... data to create a RbacUserRole
     *   }
     * })
     * 
     */
    create<T extends RbacUserRoleCreateArgs>(args: SelectSubset<T, RbacUserRoleCreateArgs<ExtArgs>>): Prisma__RbacUserRoleClient<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RbacUserRoles.
     * @param {RbacUserRoleCreateManyArgs} args - Arguments to create many RbacUserRoles.
     * @example
     * // Create many RbacUserRoles
     * const rbacUserRole = await prisma.rbacUserRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RbacUserRoleCreateManyArgs>(args?: SelectSubset<T, RbacUserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RbacUserRoles and returns the data saved in the database.
     * @param {RbacUserRoleCreateManyAndReturnArgs} args - Arguments to create many RbacUserRoles.
     * @example
     * // Create many RbacUserRoles
     * const rbacUserRole = await prisma.rbacUserRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RbacUserRoles and only return the `id`
     * const rbacUserRoleWithIdOnly = await prisma.rbacUserRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RbacUserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RbacUserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RbacUserRole.
     * @param {RbacUserRoleDeleteArgs} args - Arguments to delete one RbacUserRole.
     * @example
     * // Delete one RbacUserRole
     * const RbacUserRole = await prisma.rbacUserRole.delete({
     *   where: {
     *     // ... filter to delete one RbacUserRole
     *   }
     * })
     * 
     */
    delete<T extends RbacUserRoleDeleteArgs>(args: SelectSubset<T, RbacUserRoleDeleteArgs<ExtArgs>>): Prisma__RbacUserRoleClient<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RbacUserRole.
     * @param {RbacUserRoleUpdateArgs} args - Arguments to update one RbacUserRole.
     * @example
     * // Update one RbacUserRole
     * const rbacUserRole = await prisma.rbacUserRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RbacUserRoleUpdateArgs>(args: SelectSubset<T, RbacUserRoleUpdateArgs<ExtArgs>>): Prisma__RbacUserRoleClient<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RbacUserRoles.
     * @param {RbacUserRoleDeleteManyArgs} args - Arguments to filter RbacUserRoles to delete.
     * @example
     * // Delete a few RbacUserRoles
     * const { count } = await prisma.rbacUserRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RbacUserRoleDeleteManyArgs>(args?: SelectSubset<T, RbacUserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RbacUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacUserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RbacUserRoles
     * const rbacUserRole = await prisma.rbacUserRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RbacUserRoleUpdateManyArgs>(args: SelectSubset<T, RbacUserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RbacUserRoles and returns the data updated in the database.
     * @param {RbacUserRoleUpdateManyAndReturnArgs} args - Arguments to update many RbacUserRoles.
     * @example
     * // Update many RbacUserRoles
     * const rbacUserRole = await prisma.rbacUserRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RbacUserRoles and only return the `id`
     * const rbacUserRoleWithIdOnly = await prisma.rbacUserRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RbacUserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RbacUserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RbacUserRole.
     * @param {RbacUserRoleUpsertArgs} args - Arguments to update or create a RbacUserRole.
     * @example
     * // Update or create a RbacUserRole
     * const rbacUserRole = await prisma.rbacUserRole.upsert({
     *   create: {
     *     // ... data to create a RbacUserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RbacUserRole we want to update
     *   }
     * })
     */
    upsert<T extends RbacUserRoleUpsertArgs>(args: SelectSubset<T, RbacUserRoleUpsertArgs<ExtArgs>>): Prisma__RbacUserRoleClient<$Result.GetResult<Prisma.$RbacUserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RbacUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacUserRoleCountArgs} args - Arguments to filter RbacUserRoles to count.
     * @example
     * // Count the number of RbacUserRoles
     * const count = await prisma.rbacUserRole.count({
     *   where: {
     *     // ... the filter for the RbacUserRoles we want to count
     *   }
     * })
    **/
    count<T extends RbacUserRoleCountArgs>(
      args?: Subset<T, RbacUserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RbacUserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RbacUserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacUserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RbacUserRoleAggregateArgs>(args: Subset<T, RbacUserRoleAggregateArgs>): Prisma.PrismaPromise<GetRbacUserRoleAggregateType<T>>

    /**
     * Group by RbacUserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RbacUserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RbacUserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RbacUserRoleGroupByArgs['orderBy'] }
        : { orderBy?: RbacUserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RbacUserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRbacUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RbacUserRole model
   */
  readonly fields: RbacUserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RbacUserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RbacUserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    org<T extends RbacUserRole$orgArgs<ExtArgs> = {}>(args?: Subset<T, RbacUserRole$orgArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    role<T extends RbacRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RbacRoleDefaultArgs<ExtArgs>>): Prisma__RbacRoleClient<$Result.GetResult<Prisma.$RbacRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RbacUserRole model
   */
  interface RbacUserRoleFieldRefs {
    readonly id: FieldRef<"RbacUserRole", 'String'>
    readonly userId: FieldRef<"RbacUserRole", 'String'>
    readonly orgId: FieldRef<"RbacUserRole", 'String'>
    readonly roleId: FieldRef<"RbacUserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RbacUserRole findUnique
   */
  export type RbacUserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which RbacUserRole to fetch.
     */
    where: RbacUserRoleWhereUniqueInput
  }

  /**
   * RbacUserRole findUniqueOrThrow
   */
  export type RbacUserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which RbacUserRole to fetch.
     */
    where: RbacUserRoleWhereUniqueInput
  }

  /**
   * RbacUserRole findFirst
   */
  export type RbacUserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which RbacUserRole to fetch.
     */
    where?: RbacUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacUserRoles to fetch.
     */
    orderBy?: RbacUserRoleOrderByWithRelationInput | RbacUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RbacUserRoles.
     */
    cursor?: RbacUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RbacUserRoles.
     */
    distinct?: RbacUserRoleScalarFieldEnum | RbacUserRoleScalarFieldEnum[]
  }

  /**
   * RbacUserRole findFirstOrThrow
   */
  export type RbacUserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which RbacUserRole to fetch.
     */
    where?: RbacUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacUserRoles to fetch.
     */
    orderBy?: RbacUserRoleOrderByWithRelationInput | RbacUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RbacUserRoles.
     */
    cursor?: RbacUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RbacUserRoles.
     */
    distinct?: RbacUserRoleScalarFieldEnum | RbacUserRoleScalarFieldEnum[]
  }

  /**
   * RbacUserRole findMany
   */
  export type RbacUserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which RbacUserRoles to fetch.
     */
    where?: RbacUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RbacUserRoles to fetch.
     */
    orderBy?: RbacUserRoleOrderByWithRelationInput | RbacUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RbacUserRoles.
     */
    cursor?: RbacUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RbacUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RbacUserRoles.
     */
    skip?: number
    distinct?: RbacUserRoleScalarFieldEnum | RbacUserRoleScalarFieldEnum[]
  }

  /**
   * RbacUserRole create
   */
  export type RbacUserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a RbacUserRole.
     */
    data: XOR<RbacUserRoleCreateInput, RbacUserRoleUncheckedCreateInput>
  }

  /**
   * RbacUserRole createMany
   */
  export type RbacUserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RbacUserRoles.
     */
    data: RbacUserRoleCreateManyInput | RbacUserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RbacUserRole createManyAndReturn
   */
  export type RbacUserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many RbacUserRoles.
     */
    data: RbacUserRoleCreateManyInput | RbacUserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RbacUserRole update
   */
  export type RbacUserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a RbacUserRole.
     */
    data: XOR<RbacUserRoleUpdateInput, RbacUserRoleUncheckedUpdateInput>
    /**
     * Choose, which RbacUserRole to update.
     */
    where: RbacUserRoleWhereUniqueInput
  }

  /**
   * RbacUserRole updateMany
   */
  export type RbacUserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RbacUserRoles.
     */
    data: XOR<RbacUserRoleUpdateManyMutationInput, RbacUserRoleUncheckedUpdateManyInput>
    /**
     * Filter which RbacUserRoles to update
     */
    where?: RbacUserRoleWhereInput
    /**
     * Limit how many RbacUserRoles to update.
     */
    limit?: number
  }

  /**
   * RbacUserRole updateManyAndReturn
   */
  export type RbacUserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * The data used to update RbacUserRoles.
     */
    data: XOR<RbacUserRoleUpdateManyMutationInput, RbacUserRoleUncheckedUpdateManyInput>
    /**
     * Filter which RbacUserRoles to update
     */
    where?: RbacUserRoleWhereInput
    /**
     * Limit how many RbacUserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RbacUserRole upsert
   */
  export type RbacUserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the RbacUserRole to update in case it exists.
     */
    where: RbacUserRoleWhereUniqueInput
    /**
     * In case the RbacUserRole found by the `where` argument doesn't exist, create a new RbacUserRole with this data.
     */
    create: XOR<RbacUserRoleCreateInput, RbacUserRoleUncheckedCreateInput>
    /**
     * In case the RbacUserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RbacUserRoleUpdateInput, RbacUserRoleUncheckedUpdateInput>
  }

  /**
   * RbacUserRole delete
   */
  export type RbacUserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
    /**
     * Filter which RbacUserRole to delete.
     */
    where: RbacUserRoleWhereUniqueInput
  }

  /**
   * RbacUserRole deleteMany
   */
  export type RbacUserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RbacUserRoles to delete
     */
    where?: RbacUserRoleWhereInput
    /**
     * Limit how many RbacUserRoles to delete.
     */
    limit?: number
  }

  /**
   * RbacUserRole.org
   */
  export type RbacUserRole$orgArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    where?: OrgWhereInput
  }

  /**
   * RbacUserRole without action
   */
  export type RbacUserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RbacUserRole
     */
    select?: RbacUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RbacUserRole
     */
    omit?: RbacUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RbacUserRoleInclude<ExtArgs> | null
  }


  /**
   * Model ProviderConfig
   */

  export type AggregateProviderConfig = {
    _count: ProviderConfigCountAggregateOutputType | null
    _min: ProviderConfigMinAggregateOutputType | null
    _max: ProviderConfigMaxAggregateOutputType | null
  }

  export type ProviderConfigMinAggregateOutputType = {
    id: string | null
    samApiKey: string | null
    stripeSecretKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderConfigMaxAggregateOutputType = {
    id: string | null
    samApiKey: string | null
    stripeSecretKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderConfigCountAggregateOutputType = {
    id: number
    samApiKey: number
    stripeSecretKey: number
    otherConfig: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProviderConfigMinAggregateInputType = {
    id?: true
    samApiKey?: true
    stripeSecretKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderConfigMaxAggregateInputType = {
    id?: true
    samApiKey?: true
    stripeSecretKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderConfigCountAggregateInputType = {
    id?: true
    samApiKey?: true
    stripeSecretKey?: true
    otherConfig?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProviderConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderConfig to aggregate.
     */
    where?: ProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderConfigs to fetch.
     */
    orderBy?: ProviderConfigOrderByWithRelationInput | ProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderConfigs
    **/
    _count?: true | ProviderConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderConfigMaxAggregateInputType
  }

  export type GetProviderConfigAggregateType<T extends ProviderConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderConfig[P]>
      : GetScalarType<T[P], AggregateProviderConfig[P]>
  }




  export type ProviderConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderConfigWhereInput
    orderBy?: ProviderConfigOrderByWithAggregationInput | ProviderConfigOrderByWithAggregationInput[]
    by: ProviderConfigScalarFieldEnum[] | ProviderConfigScalarFieldEnum
    having?: ProviderConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderConfigCountAggregateInputType | true
    _min?: ProviderConfigMinAggregateInputType
    _max?: ProviderConfigMaxAggregateInputType
  }

  export type ProviderConfigGroupByOutputType = {
    id: string
    samApiKey: string | null
    stripeSecretKey: string | null
    otherConfig: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProviderConfigCountAggregateOutputType | null
    _min: ProviderConfigMinAggregateOutputType | null
    _max: ProviderConfigMaxAggregateOutputType | null
  }

  type GetProviderConfigGroupByPayload<T extends ProviderConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderConfigGroupByOutputType[P]>
        }
      >
    >


  export type ProviderConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    samApiKey?: boolean
    stripeSecretKey?: boolean
    otherConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["providerConfig"]>

  export type ProviderConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    samApiKey?: boolean
    stripeSecretKey?: boolean
    otherConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["providerConfig"]>

  export type ProviderConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    samApiKey?: boolean
    stripeSecretKey?: boolean
    otherConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["providerConfig"]>

  export type ProviderConfigSelectScalar = {
    id?: boolean
    samApiKey?: boolean
    stripeSecretKey?: boolean
    otherConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProviderConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "samApiKey" | "stripeSecretKey" | "otherConfig" | "createdAt" | "updatedAt", ExtArgs["result"]["providerConfig"]>

  export type $ProviderConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      samApiKey: string | null
      stripeSecretKey: string | null
      otherConfig: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["providerConfig"]>
    composites: {}
  }

  type ProviderConfigGetPayload<S extends boolean | null | undefined | ProviderConfigDefaultArgs> = $Result.GetResult<Prisma.$ProviderConfigPayload, S>

  type ProviderConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderConfigCountAggregateInputType | true
    }

  export interface ProviderConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderConfig'], meta: { name: 'ProviderConfig' } }
    /**
     * Find zero or one ProviderConfig that matches the filter.
     * @param {ProviderConfigFindUniqueArgs} args - Arguments to find a ProviderConfig
     * @example
     * // Get one ProviderConfig
     * const providerConfig = await prisma.providerConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderConfigFindUniqueArgs>(args: SelectSubset<T, ProviderConfigFindUniqueArgs<ExtArgs>>): Prisma__ProviderConfigClient<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProviderConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderConfigFindUniqueOrThrowArgs} args - Arguments to find a ProviderConfig
     * @example
     * // Get one ProviderConfig
     * const providerConfig = await prisma.providerConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderConfigClient<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderConfigFindFirstArgs} args - Arguments to find a ProviderConfig
     * @example
     * // Get one ProviderConfig
     * const providerConfig = await prisma.providerConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderConfigFindFirstArgs>(args?: SelectSubset<T, ProviderConfigFindFirstArgs<ExtArgs>>): Prisma__ProviderConfigClient<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderConfigFindFirstOrThrowArgs} args - Arguments to find a ProviderConfig
     * @example
     * // Get one ProviderConfig
     * const providerConfig = await prisma.providerConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderConfigClient<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProviderConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderConfigs
     * const providerConfigs = await prisma.providerConfig.findMany()
     * 
     * // Get first 10 ProviderConfigs
     * const providerConfigs = await prisma.providerConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerConfigWithIdOnly = await prisma.providerConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderConfigFindManyArgs>(args?: SelectSubset<T, ProviderConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProviderConfig.
     * @param {ProviderConfigCreateArgs} args - Arguments to create a ProviderConfig.
     * @example
     * // Create one ProviderConfig
     * const ProviderConfig = await prisma.providerConfig.create({
     *   data: {
     *     // ... data to create a ProviderConfig
     *   }
     * })
     * 
     */
    create<T extends ProviderConfigCreateArgs>(args: SelectSubset<T, ProviderConfigCreateArgs<ExtArgs>>): Prisma__ProviderConfigClient<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProviderConfigs.
     * @param {ProviderConfigCreateManyArgs} args - Arguments to create many ProviderConfigs.
     * @example
     * // Create many ProviderConfigs
     * const providerConfig = await prisma.providerConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderConfigCreateManyArgs>(args?: SelectSubset<T, ProviderConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProviderConfigs and returns the data saved in the database.
     * @param {ProviderConfigCreateManyAndReturnArgs} args - Arguments to create many ProviderConfigs.
     * @example
     * // Create many ProviderConfigs
     * const providerConfig = await prisma.providerConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProviderConfigs and only return the `id`
     * const providerConfigWithIdOnly = await prisma.providerConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProviderConfig.
     * @param {ProviderConfigDeleteArgs} args - Arguments to delete one ProviderConfig.
     * @example
     * // Delete one ProviderConfig
     * const ProviderConfig = await prisma.providerConfig.delete({
     *   where: {
     *     // ... filter to delete one ProviderConfig
     *   }
     * })
     * 
     */
    delete<T extends ProviderConfigDeleteArgs>(args: SelectSubset<T, ProviderConfigDeleteArgs<ExtArgs>>): Prisma__ProviderConfigClient<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProviderConfig.
     * @param {ProviderConfigUpdateArgs} args - Arguments to update one ProviderConfig.
     * @example
     * // Update one ProviderConfig
     * const providerConfig = await prisma.providerConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderConfigUpdateArgs>(args: SelectSubset<T, ProviderConfigUpdateArgs<ExtArgs>>): Prisma__ProviderConfigClient<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProviderConfigs.
     * @param {ProviderConfigDeleteManyArgs} args - Arguments to filter ProviderConfigs to delete.
     * @example
     * // Delete a few ProviderConfigs
     * const { count } = await prisma.providerConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderConfigDeleteManyArgs>(args?: SelectSubset<T, ProviderConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderConfigs
     * const providerConfig = await prisma.providerConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderConfigUpdateManyArgs>(args: SelectSubset<T, ProviderConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderConfigs and returns the data updated in the database.
     * @param {ProviderConfigUpdateManyAndReturnArgs} args - Arguments to update many ProviderConfigs.
     * @example
     * // Update many ProviderConfigs
     * const providerConfig = await prisma.providerConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProviderConfigs and only return the `id`
     * const providerConfigWithIdOnly = await prisma.providerConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProviderConfig.
     * @param {ProviderConfigUpsertArgs} args - Arguments to update or create a ProviderConfig.
     * @example
     * // Update or create a ProviderConfig
     * const providerConfig = await prisma.providerConfig.upsert({
     *   create: {
     *     // ... data to create a ProviderConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderConfig we want to update
     *   }
     * })
     */
    upsert<T extends ProviderConfigUpsertArgs>(args: SelectSubset<T, ProviderConfigUpsertArgs<ExtArgs>>): Prisma__ProviderConfigClient<$Result.GetResult<Prisma.$ProviderConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProviderConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderConfigCountArgs} args - Arguments to filter ProviderConfigs to count.
     * @example
     * // Count the number of ProviderConfigs
     * const count = await prisma.providerConfig.count({
     *   where: {
     *     // ... the filter for the ProviderConfigs we want to count
     *   }
     * })
    **/
    count<T extends ProviderConfigCountArgs>(
      args?: Subset<T, ProviderConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderConfigAggregateArgs>(args: Subset<T, ProviderConfigAggregateArgs>): Prisma.PrismaPromise<GetProviderConfigAggregateType<T>>

    /**
     * Group by ProviderConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderConfigGroupByArgs['orderBy'] }
        : { orderBy?: ProviderConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderConfig model
   */
  readonly fields: ProviderConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProviderConfig model
   */
  interface ProviderConfigFieldRefs {
    readonly id: FieldRef<"ProviderConfig", 'String'>
    readonly samApiKey: FieldRef<"ProviderConfig", 'String'>
    readonly stripeSecretKey: FieldRef<"ProviderConfig", 'String'>
    readonly otherConfig: FieldRef<"ProviderConfig", 'Json'>
    readonly createdAt: FieldRef<"ProviderConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"ProviderConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProviderConfig findUnique
   */
  export type ProviderConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * Filter, which ProviderConfig to fetch.
     */
    where: ProviderConfigWhereUniqueInput
  }

  /**
   * ProviderConfig findUniqueOrThrow
   */
  export type ProviderConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * Filter, which ProviderConfig to fetch.
     */
    where: ProviderConfigWhereUniqueInput
  }

  /**
   * ProviderConfig findFirst
   */
  export type ProviderConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * Filter, which ProviderConfig to fetch.
     */
    where?: ProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderConfigs to fetch.
     */
    orderBy?: ProviderConfigOrderByWithRelationInput | ProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderConfigs.
     */
    cursor?: ProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderConfigs.
     */
    distinct?: ProviderConfigScalarFieldEnum | ProviderConfigScalarFieldEnum[]
  }

  /**
   * ProviderConfig findFirstOrThrow
   */
  export type ProviderConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * Filter, which ProviderConfig to fetch.
     */
    where?: ProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderConfigs to fetch.
     */
    orderBy?: ProviderConfigOrderByWithRelationInput | ProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderConfigs.
     */
    cursor?: ProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderConfigs.
     */
    distinct?: ProviderConfigScalarFieldEnum | ProviderConfigScalarFieldEnum[]
  }

  /**
   * ProviderConfig findMany
   */
  export type ProviderConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * Filter, which ProviderConfigs to fetch.
     */
    where?: ProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderConfigs to fetch.
     */
    orderBy?: ProviderConfigOrderByWithRelationInput | ProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderConfigs.
     */
    cursor?: ProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderConfigs.
     */
    skip?: number
    distinct?: ProviderConfigScalarFieldEnum | ProviderConfigScalarFieldEnum[]
  }

  /**
   * ProviderConfig create
   */
  export type ProviderConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a ProviderConfig.
     */
    data: XOR<ProviderConfigCreateInput, ProviderConfigUncheckedCreateInput>
  }

  /**
   * ProviderConfig createMany
   */
  export type ProviderConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderConfigs.
     */
    data: ProviderConfigCreateManyInput | ProviderConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProviderConfig createManyAndReturn
   */
  export type ProviderConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * The data used to create many ProviderConfigs.
     */
    data: ProviderConfigCreateManyInput | ProviderConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProviderConfig update
   */
  export type ProviderConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a ProviderConfig.
     */
    data: XOR<ProviderConfigUpdateInput, ProviderConfigUncheckedUpdateInput>
    /**
     * Choose, which ProviderConfig to update.
     */
    where: ProviderConfigWhereUniqueInput
  }

  /**
   * ProviderConfig updateMany
   */
  export type ProviderConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderConfigs.
     */
    data: XOR<ProviderConfigUpdateManyMutationInput, ProviderConfigUncheckedUpdateManyInput>
    /**
     * Filter which ProviderConfigs to update
     */
    where?: ProviderConfigWhereInput
    /**
     * Limit how many ProviderConfigs to update.
     */
    limit?: number
  }

  /**
   * ProviderConfig updateManyAndReturn
   */
  export type ProviderConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * The data used to update ProviderConfigs.
     */
    data: XOR<ProviderConfigUpdateManyMutationInput, ProviderConfigUncheckedUpdateManyInput>
    /**
     * Filter which ProviderConfigs to update
     */
    where?: ProviderConfigWhereInput
    /**
     * Limit how many ProviderConfigs to update.
     */
    limit?: number
  }

  /**
   * ProviderConfig upsert
   */
  export type ProviderConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the ProviderConfig to update in case it exists.
     */
    where: ProviderConfigWhereUniqueInput
    /**
     * In case the ProviderConfig found by the `where` argument doesn't exist, create a new ProviderConfig with this data.
     */
    create: XOR<ProviderConfigCreateInput, ProviderConfigUncheckedCreateInput>
    /**
     * In case the ProviderConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderConfigUpdateInput, ProviderConfigUncheckedUpdateInput>
  }

  /**
   * ProviderConfig delete
   */
  export type ProviderConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
    /**
     * Filter which ProviderConfig to delete.
     */
    where: ProviderConfigWhereUniqueInput
  }

  /**
   * ProviderConfig deleteMany
   */
  export type ProviderConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderConfigs to delete
     */
    where?: ProviderConfigWhereInput
    /**
     * Limit how many ProviderConfigs to delete.
     */
    limit?: number
  }

  /**
   * ProviderConfig without action
   */
  export type ProviderConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderConfig
     */
    select?: ProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderConfig
     */
    omit?: ProviderConfigOmit<ExtArgs> | null
  }


  /**
   * Model PricingPlan
   */

  export type AggregatePricingPlan = {
    _count: PricingPlanCountAggregateOutputType | null
    _avg: PricingPlanAvgAggregateOutputType | null
    _sum: PricingPlanSumAggregateOutputType | null
    _min: PricingPlanMinAggregateOutputType | null
    _max: PricingPlanMaxAggregateOutputType | null
  }

  export type PricingPlanAvgAggregateOutputType = {
    unitAmount: number | null
    includedUnits: number | null
  }

  export type PricingPlanSumAggregateOutputType = {
    unitAmount: number | null
    includedUnits: number | null
  }

  export type PricingPlanMinAggregateOutputType = {
    orgId: string | null
    model: $Enums.PricingModel | null
    currency: string | null
    unitAmount: number | null
    includedUnits: number | null
  }

  export type PricingPlanMaxAggregateOutputType = {
    orgId: string | null
    model: $Enums.PricingModel | null
    currency: string | null
    unitAmount: number | null
    includedUnits: number | null
  }

  export type PricingPlanCountAggregateOutputType = {
    orgId: number
    model: number
    currency: number
    unitAmount: number
    tiersJson: number
    includedUnits: number
    _all: number
  }


  export type PricingPlanAvgAggregateInputType = {
    unitAmount?: true
    includedUnits?: true
  }

  export type PricingPlanSumAggregateInputType = {
    unitAmount?: true
    includedUnits?: true
  }

  export type PricingPlanMinAggregateInputType = {
    orgId?: true
    model?: true
    currency?: true
    unitAmount?: true
    includedUnits?: true
  }

  export type PricingPlanMaxAggregateInputType = {
    orgId?: true
    model?: true
    currency?: true
    unitAmount?: true
    includedUnits?: true
  }

  export type PricingPlanCountAggregateInputType = {
    orgId?: true
    model?: true
    currency?: true
    unitAmount?: true
    tiersJson?: true
    includedUnits?: true
    _all?: true
  }

  export type PricingPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingPlan to aggregate.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PricingPlans
    **/
    _count?: true | PricingPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingPlanMaxAggregateInputType
  }

  export type GetPricingPlanAggregateType<T extends PricingPlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingPlan[P]>
      : GetScalarType<T[P], AggregatePricingPlan[P]>
  }




  export type PricingPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingPlanWhereInput
    orderBy?: PricingPlanOrderByWithAggregationInput | PricingPlanOrderByWithAggregationInput[]
    by: PricingPlanScalarFieldEnum[] | PricingPlanScalarFieldEnum
    having?: PricingPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingPlanCountAggregateInputType | true
    _avg?: PricingPlanAvgAggregateInputType
    _sum?: PricingPlanSumAggregateInputType
    _min?: PricingPlanMinAggregateInputType
    _max?: PricingPlanMaxAggregateInputType
  }

  export type PricingPlanGroupByOutputType = {
    orgId: string
    model: $Enums.PricingModel
    currency: string
    unitAmount: number
    tiersJson: JsonValue | null
    includedUnits: number
    _count: PricingPlanCountAggregateOutputType | null
    _avg: PricingPlanAvgAggregateOutputType | null
    _sum: PricingPlanSumAggregateOutputType | null
    _min: PricingPlanMinAggregateOutputType | null
    _max: PricingPlanMaxAggregateOutputType | null
  }

  type GetPricingPlanGroupByPayload<T extends PricingPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricingPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingPlanGroupByOutputType[P]>
            : GetScalarType<T[P], PricingPlanGroupByOutputType[P]>
        }
      >
    >


  export type PricingPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orgId?: boolean
    model?: boolean
    currency?: boolean
    unitAmount?: boolean
    tiersJson?: boolean
    includedUnits?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingPlan"]>

  export type PricingPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orgId?: boolean
    model?: boolean
    currency?: boolean
    unitAmount?: boolean
    tiersJson?: boolean
    includedUnits?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingPlan"]>

  export type PricingPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orgId?: boolean
    model?: boolean
    currency?: boolean
    unitAmount?: boolean
    tiersJson?: boolean
    includedUnits?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingPlan"]>

  export type PricingPlanSelectScalar = {
    orgId?: boolean
    model?: boolean
    currency?: boolean
    unitAmount?: boolean
    tiersJson?: boolean
    includedUnits?: boolean
  }

  export type PricingPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"orgId" | "model" | "currency" | "unitAmount" | "tiersJson" | "includedUnits", ExtArgs["result"]["pricingPlan"]>
  export type PricingPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type PricingPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type PricingPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $PricingPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PricingPlan"
    objects: {
      /**
       * Relation to organization (named to match Org.pricingPlan)
       */
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      orgId: string
      /**
       * Billing model used for this organization (per-lead, tiered, subscription, or hybrid)
       */
      model: $Enums.PricingModel
      /**
       * ISO currency code (e.g. "usd")
       */
      currency: string
      /**
       * Fixed unit price in cents for per-lead billing
       */
      unitAmount: number
      /**
       * JSON-encoded pricing tiers (used when model is TIERED or HYBRID)
       */
      tiersJson: Prisma.JsonValue | null
      /**
       * Number of prepaid leads included before billing starts
       */
      includedUnits: number
    }, ExtArgs["result"]["pricingPlan"]>
    composites: {}
  }

  type PricingPlanGetPayload<S extends boolean | null | undefined | PricingPlanDefaultArgs> = $Result.GetResult<Prisma.$PricingPlanPayload, S>

  type PricingPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PricingPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PricingPlanCountAggregateInputType | true
    }

  export interface PricingPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PricingPlan'], meta: { name: 'PricingPlan' } }
    /**
     * Find zero or one PricingPlan that matches the filter.
     * @param {PricingPlanFindUniqueArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PricingPlanFindUniqueArgs>(args: SelectSubset<T, PricingPlanFindUniqueArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PricingPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PricingPlanFindUniqueOrThrowArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PricingPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PricingPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricingPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanFindFirstArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PricingPlanFindFirstArgs>(args?: SelectSubset<T, PricingPlanFindFirstArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricingPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanFindFirstOrThrowArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PricingPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PricingPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PricingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingPlans
     * const pricingPlans = await prisma.pricingPlan.findMany()
     * 
     * // Get first 10 PricingPlans
     * const pricingPlans = await prisma.pricingPlan.findMany({ take: 10 })
     * 
     * // Only select the `orgId`
     * const pricingPlanWithOrgIdOnly = await prisma.pricingPlan.findMany({ select: { orgId: true } })
     * 
     */
    findMany<T extends PricingPlanFindManyArgs>(args?: SelectSubset<T, PricingPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PricingPlan.
     * @param {PricingPlanCreateArgs} args - Arguments to create a PricingPlan.
     * @example
     * // Create one PricingPlan
     * const PricingPlan = await prisma.pricingPlan.create({
     *   data: {
     *     // ... data to create a PricingPlan
     *   }
     * })
     * 
     */
    create<T extends PricingPlanCreateArgs>(args: SelectSubset<T, PricingPlanCreateArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PricingPlans.
     * @param {PricingPlanCreateManyArgs} args - Arguments to create many PricingPlans.
     * @example
     * // Create many PricingPlans
     * const pricingPlan = await prisma.pricingPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PricingPlanCreateManyArgs>(args?: SelectSubset<T, PricingPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PricingPlans and returns the data saved in the database.
     * @param {PricingPlanCreateManyAndReturnArgs} args - Arguments to create many PricingPlans.
     * @example
     * // Create many PricingPlans
     * const pricingPlan = await prisma.pricingPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PricingPlans and only return the `orgId`
     * const pricingPlanWithOrgIdOnly = await prisma.pricingPlan.createManyAndReturn({
     *   select: { orgId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PricingPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PricingPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PricingPlan.
     * @param {PricingPlanDeleteArgs} args - Arguments to delete one PricingPlan.
     * @example
     * // Delete one PricingPlan
     * const PricingPlan = await prisma.pricingPlan.delete({
     *   where: {
     *     // ... filter to delete one PricingPlan
     *   }
     * })
     * 
     */
    delete<T extends PricingPlanDeleteArgs>(args: SelectSubset<T, PricingPlanDeleteArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PricingPlan.
     * @param {PricingPlanUpdateArgs} args - Arguments to update one PricingPlan.
     * @example
     * // Update one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PricingPlanUpdateArgs>(args: SelectSubset<T, PricingPlanUpdateArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PricingPlans.
     * @param {PricingPlanDeleteManyArgs} args - Arguments to filter PricingPlans to delete.
     * @example
     * // Delete a few PricingPlans
     * const { count } = await prisma.pricingPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PricingPlanDeleteManyArgs>(args?: SelectSubset<T, PricingPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingPlans
     * const pricingPlan = await prisma.pricingPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PricingPlanUpdateManyArgs>(args: SelectSubset<T, PricingPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingPlans and returns the data updated in the database.
     * @param {PricingPlanUpdateManyAndReturnArgs} args - Arguments to update many PricingPlans.
     * @example
     * // Update many PricingPlans
     * const pricingPlan = await prisma.pricingPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PricingPlans and only return the `orgId`
     * const pricingPlanWithOrgIdOnly = await prisma.pricingPlan.updateManyAndReturn({
     *   select: { orgId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PricingPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PricingPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PricingPlan.
     * @param {PricingPlanUpsertArgs} args - Arguments to update or create a PricingPlan.
     * @example
     * // Update or create a PricingPlan
     * const pricingPlan = await prisma.pricingPlan.upsert({
     *   create: {
     *     // ... data to create a PricingPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingPlan we want to update
     *   }
     * })
     */
    upsert<T extends PricingPlanUpsertArgs>(args: SelectSubset<T, PricingPlanUpsertArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PricingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanCountArgs} args - Arguments to filter PricingPlans to count.
     * @example
     * // Count the number of PricingPlans
     * const count = await prisma.pricingPlan.count({
     *   where: {
     *     // ... the filter for the PricingPlans we want to count
     *   }
     * })
    **/
    count<T extends PricingPlanCountArgs>(
      args?: Subset<T, PricingPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingPlanAggregateArgs>(args: Subset<T, PricingPlanAggregateArgs>): Prisma.PrismaPromise<GetPricingPlanAggregateType<T>>

    /**
     * Group by PricingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingPlanGroupByArgs['orderBy'] }
        : { orderBy?: PricingPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PricingPlan model
   */
  readonly fields: PricingPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PricingPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PricingPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PricingPlan model
   */
  interface PricingPlanFieldRefs {
    readonly orgId: FieldRef<"PricingPlan", 'String'>
    readonly model: FieldRef<"PricingPlan", 'PricingModel'>
    readonly currency: FieldRef<"PricingPlan", 'String'>
    readonly unitAmount: FieldRef<"PricingPlan", 'Int'>
    readonly tiersJson: FieldRef<"PricingPlan", 'Json'>
    readonly includedUnits: FieldRef<"PricingPlan", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PricingPlan findUnique
   */
  export type PricingPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan findUniqueOrThrow
   */
  export type PricingPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan findFirst
   */
  export type PricingPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingPlans.
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingPlans.
     */
    distinct?: PricingPlanScalarFieldEnum | PricingPlanScalarFieldEnum[]
  }

  /**
   * PricingPlan findFirstOrThrow
   */
  export type PricingPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingPlans.
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingPlans.
     */
    distinct?: PricingPlanScalarFieldEnum | PricingPlanScalarFieldEnum[]
  }

  /**
   * PricingPlan findMany
   */
  export type PricingPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter, which PricingPlans to fetch.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PricingPlans.
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    distinct?: PricingPlanScalarFieldEnum | PricingPlanScalarFieldEnum[]
  }

  /**
   * PricingPlan create
   */
  export type PricingPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a PricingPlan.
     */
    data: XOR<PricingPlanCreateInput, PricingPlanUncheckedCreateInput>
  }

  /**
   * PricingPlan createMany
   */
  export type PricingPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PricingPlans.
     */
    data: PricingPlanCreateManyInput | PricingPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PricingPlan createManyAndReturn
   */
  export type PricingPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * The data used to create many PricingPlans.
     */
    data: PricingPlanCreateManyInput | PricingPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PricingPlan update
   */
  export type PricingPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a PricingPlan.
     */
    data: XOR<PricingPlanUpdateInput, PricingPlanUncheckedUpdateInput>
    /**
     * Choose, which PricingPlan to update.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan updateMany
   */
  export type PricingPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PricingPlans.
     */
    data: XOR<PricingPlanUpdateManyMutationInput, PricingPlanUncheckedUpdateManyInput>
    /**
     * Filter which PricingPlans to update
     */
    where?: PricingPlanWhereInput
    /**
     * Limit how many PricingPlans to update.
     */
    limit?: number
  }

  /**
   * PricingPlan updateManyAndReturn
   */
  export type PricingPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * The data used to update PricingPlans.
     */
    data: XOR<PricingPlanUpdateManyMutationInput, PricingPlanUncheckedUpdateManyInput>
    /**
     * Filter which PricingPlans to update
     */
    where?: PricingPlanWhereInput
    /**
     * Limit how many PricingPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PricingPlan upsert
   */
  export type PricingPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the PricingPlan to update in case it exists.
     */
    where: PricingPlanWhereUniqueInput
    /**
     * In case the PricingPlan found by the `where` argument doesn't exist, create a new PricingPlan with this data.
     */
    create: XOR<PricingPlanCreateInput, PricingPlanUncheckedCreateInput>
    /**
     * In case the PricingPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricingPlanUpdateInput, PricingPlanUncheckedUpdateInput>
  }

  /**
   * PricingPlan delete
   */
  export type PricingPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter which PricingPlan to delete.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan deleteMany
   */
  export type PricingPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingPlans to delete
     */
    where?: PricingPlanWhereInput
    /**
     * Limit how many PricingPlans to delete.
     */
    limit?: number
  }

  /**
   * PricingPlan without action
   */
  export type PricingPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
  }


  /**
   * Model AiUsageEvent
   */

  export type AggregateAiUsageEvent = {
    _count: AiUsageEventCountAggregateOutputType | null
    _avg: AiUsageEventAvgAggregateOutputType | null
    _sum: AiUsageEventSumAggregateOutputType | null
    _min: AiUsageEventMinAggregateOutputType | null
    _max: AiUsageEventMaxAggregateOutputType | null
  }

  export type AiUsageEventAvgAggregateOutputType = {
    tokensIn: number | null
    tokensOut: number | null
    costUsd: Decimal | null
    creditsUsed: number | null
  }

  export type AiUsageEventSumAggregateOutputType = {
    tokensIn: number | null
    tokensOut: number | null
    costUsd: Decimal | null
    creditsUsed: number | null
  }

  export type AiUsageEventMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    userId: string | null
    feature: string | null
    model: string | null
    tokensIn: number | null
    tokensOut: number | null
    costUsd: Decimal | null
    creditsUsed: number | null
    requestId: string | null
    createdAt: Date | null
  }

  export type AiUsageEventMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    userId: string | null
    feature: string | null
    model: string | null
    tokensIn: number | null
    tokensOut: number | null
    costUsd: Decimal | null
    creditsUsed: number | null
    requestId: string | null
    createdAt: Date | null
  }

  export type AiUsageEventCountAggregateOutputType = {
    id: number
    orgId: number
    userId: number
    feature: number
    model: number
    tokensIn: number
    tokensOut: number
    costUsd: number
    creditsUsed: number
    requestId: number
    createdAt: number
    _all: number
  }


  export type AiUsageEventAvgAggregateInputType = {
    tokensIn?: true
    tokensOut?: true
    costUsd?: true
    creditsUsed?: true
  }

  export type AiUsageEventSumAggregateInputType = {
    tokensIn?: true
    tokensOut?: true
    costUsd?: true
    creditsUsed?: true
  }

  export type AiUsageEventMinAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    feature?: true
    model?: true
    tokensIn?: true
    tokensOut?: true
    costUsd?: true
    creditsUsed?: true
    requestId?: true
    createdAt?: true
  }

  export type AiUsageEventMaxAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    feature?: true
    model?: true
    tokensIn?: true
    tokensOut?: true
    costUsd?: true
    creditsUsed?: true
    requestId?: true
    createdAt?: true
  }

  export type AiUsageEventCountAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    feature?: true
    model?: true
    tokensIn?: true
    tokensOut?: true
    costUsd?: true
    creditsUsed?: true
    requestId?: true
    createdAt?: true
    _all?: true
  }

  export type AiUsageEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiUsageEvent to aggregate.
     */
    where?: AiUsageEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiUsageEvents to fetch.
     */
    orderBy?: AiUsageEventOrderByWithRelationInput | AiUsageEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiUsageEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiUsageEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiUsageEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiUsageEvents
    **/
    _count?: true | AiUsageEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiUsageEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiUsageEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiUsageEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiUsageEventMaxAggregateInputType
  }

  export type GetAiUsageEventAggregateType<T extends AiUsageEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAiUsageEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiUsageEvent[P]>
      : GetScalarType<T[P], AggregateAiUsageEvent[P]>
  }




  export type AiUsageEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiUsageEventWhereInput
    orderBy?: AiUsageEventOrderByWithAggregationInput | AiUsageEventOrderByWithAggregationInput[]
    by: AiUsageEventScalarFieldEnum[] | AiUsageEventScalarFieldEnum
    having?: AiUsageEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiUsageEventCountAggregateInputType | true
    _avg?: AiUsageEventAvgAggregateInputType
    _sum?: AiUsageEventSumAggregateInputType
    _min?: AiUsageEventMinAggregateInputType
    _max?: AiUsageEventMaxAggregateInputType
  }

  export type AiUsageEventGroupByOutputType = {
    id: string
    orgId: string
    userId: string | null
    feature: string
    model: string
    tokensIn: number
    tokensOut: number
    costUsd: Decimal
    creditsUsed: number
    requestId: string | null
    createdAt: Date
    _count: AiUsageEventCountAggregateOutputType | null
    _avg: AiUsageEventAvgAggregateOutputType | null
    _sum: AiUsageEventSumAggregateOutputType | null
    _min: AiUsageEventMinAggregateOutputType | null
    _max: AiUsageEventMaxAggregateOutputType | null
  }

  type GetAiUsageEventGroupByPayload<T extends AiUsageEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiUsageEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiUsageEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiUsageEventGroupByOutputType[P]>
            : GetScalarType<T[P], AiUsageEventGroupByOutputType[P]>
        }
      >
    >


  export type AiUsageEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    feature?: boolean
    model?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    costUsd?: boolean
    creditsUsed?: boolean
    requestId?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiUsageEvent"]>

  export type AiUsageEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    feature?: boolean
    model?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    costUsd?: boolean
    creditsUsed?: boolean
    requestId?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiUsageEvent"]>

  export type AiUsageEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    feature?: boolean
    model?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    costUsd?: boolean
    creditsUsed?: boolean
    requestId?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiUsageEvent"]>

  export type AiUsageEventSelectScalar = {
    id?: boolean
    orgId?: boolean
    userId?: boolean
    feature?: boolean
    model?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    costUsd?: boolean
    creditsUsed?: boolean
    requestId?: boolean
    createdAt?: boolean
  }

  export type AiUsageEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "userId" | "feature" | "model" | "tokensIn" | "tokensOut" | "costUsd" | "creditsUsed" | "requestId" | "createdAt", ExtArgs["result"]["aiUsageEvent"]>
  export type AiUsageEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type AiUsageEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type AiUsageEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $AiUsageEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiUsageEvent"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      userId: string | null
      feature: string
      model: string
      tokensIn: number
      tokensOut: number
      costUsd: Prisma.Decimal
      creditsUsed: number
      requestId: string | null
      createdAt: Date
    }, ExtArgs["result"]["aiUsageEvent"]>
    composites: {}
  }

  type AiUsageEventGetPayload<S extends boolean | null | undefined | AiUsageEventDefaultArgs> = $Result.GetResult<Prisma.$AiUsageEventPayload, S>

  type AiUsageEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiUsageEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiUsageEventCountAggregateInputType | true
    }

  export interface AiUsageEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiUsageEvent'], meta: { name: 'AiUsageEvent' } }
    /**
     * Find zero or one AiUsageEvent that matches the filter.
     * @param {AiUsageEventFindUniqueArgs} args - Arguments to find a AiUsageEvent
     * @example
     * // Get one AiUsageEvent
     * const aiUsageEvent = await prisma.aiUsageEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiUsageEventFindUniqueArgs>(args: SelectSubset<T, AiUsageEventFindUniqueArgs<ExtArgs>>): Prisma__AiUsageEventClient<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiUsageEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiUsageEventFindUniqueOrThrowArgs} args - Arguments to find a AiUsageEvent
     * @example
     * // Get one AiUsageEvent
     * const aiUsageEvent = await prisma.aiUsageEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiUsageEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AiUsageEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiUsageEventClient<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiUsageEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageEventFindFirstArgs} args - Arguments to find a AiUsageEvent
     * @example
     * // Get one AiUsageEvent
     * const aiUsageEvent = await prisma.aiUsageEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiUsageEventFindFirstArgs>(args?: SelectSubset<T, AiUsageEventFindFirstArgs<ExtArgs>>): Prisma__AiUsageEventClient<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiUsageEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageEventFindFirstOrThrowArgs} args - Arguments to find a AiUsageEvent
     * @example
     * // Get one AiUsageEvent
     * const aiUsageEvent = await prisma.aiUsageEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiUsageEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AiUsageEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiUsageEventClient<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiUsageEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiUsageEvents
     * const aiUsageEvents = await prisma.aiUsageEvent.findMany()
     * 
     * // Get first 10 AiUsageEvents
     * const aiUsageEvents = await prisma.aiUsageEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiUsageEventWithIdOnly = await prisma.aiUsageEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiUsageEventFindManyArgs>(args?: SelectSubset<T, AiUsageEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiUsageEvent.
     * @param {AiUsageEventCreateArgs} args - Arguments to create a AiUsageEvent.
     * @example
     * // Create one AiUsageEvent
     * const AiUsageEvent = await prisma.aiUsageEvent.create({
     *   data: {
     *     // ... data to create a AiUsageEvent
     *   }
     * })
     * 
     */
    create<T extends AiUsageEventCreateArgs>(args: SelectSubset<T, AiUsageEventCreateArgs<ExtArgs>>): Prisma__AiUsageEventClient<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiUsageEvents.
     * @param {AiUsageEventCreateManyArgs} args - Arguments to create many AiUsageEvents.
     * @example
     * // Create many AiUsageEvents
     * const aiUsageEvent = await prisma.aiUsageEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiUsageEventCreateManyArgs>(args?: SelectSubset<T, AiUsageEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiUsageEvents and returns the data saved in the database.
     * @param {AiUsageEventCreateManyAndReturnArgs} args - Arguments to create many AiUsageEvents.
     * @example
     * // Create many AiUsageEvents
     * const aiUsageEvent = await prisma.aiUsageEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiUsageEvents and only return the `id`
     * const aiUsageEventWithIdOnly = await prisma.aiUsageEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiUsageEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AiUsageEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiUsageEvent.
     * @param {AiUsageEventDeleteArgs} args - Arguments to delete one AiUsageEvent.
     * @example
     * // Delete one AiUsageEvent
     * const AiUsageEvent = await prisma.aiUsageEvent.delete({
     *   where: {
     *     // ... filter to delete one AiUsageEvent
     *   }
     * })
     * 
     */
    delete<T extends AiUsageEventDeleteArgs>(args: SelectSubset<T, AiUsageEventDeleteArgs<ExtArgs>>): Prisma__AiUsageEventClient<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiUsageEvent.
     * @param {AiUsageEventUpdateArgs} args - Arguments to update one AiUsageEvent.
     * @example
     * // Update one AiUsageEvent
     * const aiUsageEvent = await prisma.aiUsageEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiUsageEventUpdateArgs>(args: SelectSubset<T, AiUsageEventUpdateArgs<ExtArgs>>): Prisma__AiUsageEventClient<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiUsageEvents.
     * @param {AiUsageEventDeleteManyArgs} args - Arguments to filter AiUsageEvents to delete.
     * @example
     * // Delete a few AiUsageEvents
     * const { count } = await prisma.aiUsageEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiUsageEventDeleteManyArgs>(args?: SelectSubset<T, AiUsageEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiUsageEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiUsageEvents
     * const aiUsageEvent = await prisma.aiUsageEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiUsageEventUpdateManyArgs>(args: SelectSubset<T, AiUsageEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiUsageEvents and returns the data updated in the database.
     * @param {AiUsageEventUpdateManyAndReturnArgs} args - Arguments to update many AiUsageEvents.
     * @example
     * // Update many AiUsageEvents
     * const aiUsageEvent = await prisma.aiUsageEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiUsageEvents and only return the `id`
     * const aiUsageEventWithIdOnly = await prisma.aiUsageEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiUsageEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AiUsageEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiUsageEvent.
     * @param {AiUsageEventUpsertArgs} args - Arguments to update or create a AiUsageEvent.
     * @example
     * // Update or create a AiUsageEvent
     * const aiUsageEvent = await prisma.aiUsageEvent.upsert({
     *   create: {
     *     // ... data to create a AiUsageEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiUsageEvent we want to update
     *   }
     * })
     */
    upsert<T extends AiUsageEventUpsertArgs>(args: SelectSubset<T, AiUsageEventUpsertArgs<ExtArgs>>): Prisma__AiUsageEventClient<$Result.GetResult<Prisma.$AiUsageEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiUsageEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageEventCountArgs} args - Arguments to filter AiUsageEvents to count.
     * @example
     * // Count the number of AiUsageEvents
     * const count = await prisma.aiUsageEvent.count({
     *   where: {
     *     // ... the filter for the AiUsageEvents we want to count
     *   }
     * })
    **/
    count<T extends AiUsageEventCountArgs>(
      args?: Subset<T, AiUsageEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiUsageEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiUsageEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiUsageEventAggregateArgs>(args: Subset<T, AiUsageEventAggregateArgs>): Prisma.PrismaPromise<GetAiUsageEventAggregateType<T>>

    /**
     * Group by AiUsageEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiUsageEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiUsageEventGroupByArgs['orderBy'] }
        : { orderBy?: AiUsageEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiUsageEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiUsageEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiUsageEvent model
   */
  readonly fields: AiUsageEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiUsageEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiUsageEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiUsageEvent model
   */
  interface AiUsageEventFieldRefs {
    readonly id: FieldRef<"AiUsageEvent", 'String'>
    readonly orgId: FieldRef<"AiUsageEvent", 'String'>
    readonly userId: FieldRef<"AiUsageEvent", 'String'>
    readonly feature: FieldRef<"AiUsageEvent", 'String'>
    readonly model: FieldRef<"AiUsageEvent", 'String'>
    readonly tokensIn: FieldRef<"AiUsageEvent", 'Int'>
    readonly tokensOut: FieldRef<"AiUsageEvent", 'Int'>
    readonly costUsd: FieldRef<"AiUsageEvent", 'Decimal'>
    readonly creditsUsed: FieldRef<"AiUsageEvent", 'Int'>
    readonly requestId: FieldRef<"AiUsageEvent", 'String'>
    readonly createdAt: FieldRef<"AiUsageEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiUsageEvent findUnique
   */
  export type AiUsageEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
    /**
     * Filter, which AiUsageEvent to fetch.
     */
    where: AiUsageEventWhereUniqueInput
  }

  /**
   * AiUsageEvent findUniqueOrThrow
   */
  export type AiUsageEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
    /**
     * Filter, which AiUsageEvent to fetch.
     */
    where: AiUsageEventWhereUniqueInput
  }

  /**
   * AiUsageEvent findFirst
   */
  export type AiUsageEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
    /**
     * Filter, which AiUsageEvent to fetch.
     */
    where?: AiUsageEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiUsageEvents to fetch.
     */
    orderBy?: AiUsageEventOrderByWithRelationInput | AiUsageEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiUsageEvents.
     */
    cursor?: AiUsageEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiUsageEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiUsageEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiUsageEvents.
     */
    distinct?: AiUsageEventScalarFieldEnum | AiUsageEventScalarFieldEnum[]
  }

  /**
   * AiUsageEvent findFirstOrThrow
   */
  export type AiUsageEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
    /**
     * Filter, which AiUsageEvent to fetch.
     */
    where?: AiUsageEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiUsageEvents to fetch.
     */
    orderBy?: AiUsageEventOrderByWithRelationInput | AiUsageEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiUsageEvents.
     */
    cursor?: AiUsageEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiUsageEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiUsageEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiUsageEvents.
     */
    distinct?: AiUsageEventScalarFieldEnum | AiUsageEventScalarFieldEnum[]
  }

  /**
   * AiUsageEvent findMany
   */
  export type AiUsageEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
    /**
     * Filter, which AiUsageEvents to fetch.
     */
    where?: AiUsageEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiUsageEvents to fetch.
     */
    orderBy?: AiUsageEventOrderByWithRelationInput | AiUsageEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiUsageEvents.
     */
    cursor?: AiUsageEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiUsageEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiUsageEvents.
     */
    skip?: number
    distinct?: AiUsageEventScalarFieldEnum | AiUsageEventScalarFieldEnum[]
  }

  /**
   * AiUsageEvent create
   */
  export type AiUsageEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AiUsageEvent.
     */
    data: XOR<AiUsageEventCreateInput, AiUsageEventUncheckedCreateInput>
  }

  /**
   * AiUsageEvent createMany
   */
  export type AiUsageEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiUsageEvents.
     */
    data: AiUsageEventCreateManyInput | AiUsageEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiUsageEvent createManyAndReturn
   */
  export type AiUsageEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * The data used to create many AiUsageEvents.
     */
    data: AiUsageEventCreateManyInput | AiUsageEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiUsageEvent update
   */
  export type AiUsageEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AiUsageEvent.
     */
    data: XOR<AiUsageEventUpdateInput, AiUsageEventUncheckedUpdateInput>
    /**
     * Choose, which AiUsageEvent to update.
     */
    where: AiUsageEventWhereUniqueInput
  }

  /**
   * AiUsageEvent updateMany
   */
  export type AiUsageEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiUsageEvents.
     */
    data: XOR<AiUsageEventUpdateManyMutationInput, AiUsageEventUncheckedUpdateManyInput>
    /**
     * Filter which AiUsageEvents to update
     */
    where?: AiUsageEventWhereInput
    /**
     * Limit how many AiUsageEvents to update.
     */
    limit?: number
  }

  /**
   * AiUsageEvent updateManyAndReturn
   */
  export type AiUsageEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * The data used to update AiUsageEvents.
     */
    data: XOR<AiUsageEventUpdateManyMutationInput, AiUsageEventUncheckedUpdateManyInput>
    /**
     * Filter which AiUsageEvents to update
     */
    where?: AiUsageEventWhereInput
    /**
     * Limit how many AiUsageEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiUsageEvent upsert
   */
  export type AiUsageEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AiUsageEvent to update in case it exists.
     */
    where: AiUsageEventWhereUniqueInput
    /**
     * In case the AiUsageEvent found by the `where` argument doesn't exist, create a new AiUsageEvent with this data.
     */
    create: XOR<AiUsageEventCreateInput, AiUsageEventUncheckedCreateInput>
    /**
     * In case the AiUsageEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiUsageEventUpdateInput, AiUsageEventUncheckedUpdateInput>
  }

  /**
   * AiUsageEvent delete
   */
  export type AiUsageEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
    /**
     * Filter which AiUsageEvent to delete.
     */
    where: AiUsageEventWhereUniqueInput
  }

  /**
   * AiUsageEvent deleteMany
   */
  export type AiUsageEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiUsageEvents to delete
     */
    where?: AiUsageEventWhereInput
    /**
     * Limit how many AiUsageEvents to delete.
     */
    limit?: number
  }

  /**
   * AiUsageEvent without action
   */
  export type AiUsageEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiUsageEvent
     */
    select?: AiUsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiUsageEvent
     */
    omit?: AiUsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageEventInclude<ExtArgs> | null
  }


  /**
   * Model AiMonthlySummary
   */

  export type AggregateAiMonthlySummary = {
    _count: AiMonthlySummaryCountAggregateOutputType | null
    _avg: AiMonthlySummaryAvgAggregateOutputType | null
    _sum: AiMonthlySummarySumAggregateOutputType | null
    _min: AiMonthlySummaryMinAggregateOutputType | null
    _max: AiMonthlySummaryMaxAggregateOutputType | null
  }

  export type AiMonthlySummaryAvgAggregateOutputType = {
    tokensIn: number | null
    tokensOut: number | null
    costUsd: Decimal | null
    creditsUsed: number | null
    callCount: number | null
  }

  export type AiMonthlySummarySumAggregateOutputType = {
    tokensIn: number | null
    tokensOut: number | null
    costUsd: Decimal | null
    creditsUsed: number | null
    callCount: number | null
  }

  export type AiMonthlySummaryMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    monthKey: string | null
    tokensIn: number | null
    tokensOut: number | null
    costUsd: Decimal | null
    creditsUsed: number | null
    callCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiMonthlySummaryMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    monthKey: string | null
    tokensIn: number | null
    tokensOut: number | null
    costUsd: Decimal | null
    creditsUsed: number | null
    callCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiMonthlySummaryCountAggregateOutputType = {
    id: number
    orgId: number
    monthKey: number
    tokensIn: number
    tokensOut: number
    costUsd: number
    creditsUsed: number
    callCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiMonthlySummaryAvgAggregateInputType = {
    tokensIn?: true
    tokensOut?: true
    costUsd?: true
    creditsUsed?: true
    callCount?: true
  }

  export type AiMonthlySummarySumAggregateInputType = {
    tokensIn?: true
    tokensOut?: true
    costUsd?: true
    creditsUsed?: true
    callCount?: true
  }

  export type AiMonthlySummaryMinAggregateInputType = {
    id?: true
    orgId?: true
    monthKey?: true
    tokensIn?: true
    tokensOut?: true
    costUsd?: true
    creditsUsed?: true
    callCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiMonthlySummaryMaxAggregateInputType = {
    id?: true
    orgId?: true
    monthKey?: true
    tokensIn?: true
    tokensOut?: true
    costUsd?: true
    creditsUsed?: true
    callCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiMonthlySummaryCountAggregateInputType = {
    id?: true
    orgId?: true
    monthKey?: true
    tokensIn?: true
    tokensOut?: true
    costUsd?: true
    creditsUsed?: true
    callCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiMonthlySummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiMonthlySummary to aggregate.
     */
    where?: AiMonthlySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMonthlySummaries to fetch.
     */
    orderBy?: AiMonthlySummaryOrderByWithRelationInput | AiMonthlySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiMonthlySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMonthlySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMonthlySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiMonthlySummaries
    **/
    _count?: true | AiMonthlySummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiMonthlySummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiMonthlySummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiMonthlySummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiMonthlySummaryMaxAggregateInputType
  }

  export type GetAiMonthlySummaryAggregateType<T extends AiMonthlySummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateAiMonthlySummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiMonthlySummary[P]>
      : GetScalarType<T[P], AggregateAiMonthlySummary[P]>
  }




  export type AiMonthlySummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiMonthlySummaryWhereInput
    orderBy?: AiMonthlySummaryOrderByWithAggregationInput | AiMonthlySummaryOrderByWithAggregationInput[]
    by: AiMonthlySummaryScalarFieldEnum[] | AiMonthlySummaryScalarFieldEnum
    having?: AiMonthlySummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiMonthlySummaryCountAggregateInputType | true
    _avg?: AiMonthlySummaryAvgAggregateInputType
    _sum?: AiMonthlySummarySumAggregateInputType
    _min?: AiMonthlySummaryMinAggregateInputType
    _max?: AiMonthlySummaryMaxAggregateInputType
  }

  export type AiMonthlySummaryGroupByOutputType = {
    id: string
    orgId: string
    monthKey: string
    tokensIn: number
    tokensOut: number
    costUsd: Decimal
    creditsUsed: number
    callCount: number
    createdAt: Date
    updatedAt: Date
    _count: AiMonthlySummaryCountAggregateOutputType | null
    _avg: AiMonthlySummaryAvgAggregateOutputType | null
    _sum: AiMonthlySummarySumAggregateOutputType | null
    _min: AiMonthlySummaryMinAggregateOutputType | null
    _max: AiMonthlySummaryMaxAggregateOutputType | null
  }

  type GetAiMonthlySummaryGroupByPayload<T extends AiMonthlySummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiMonthlySummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiMonthlySummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiMonthlySummaryGroupByOutputType[P]>
            : GetScalarType<T[P], AiMonthlySummaryGroupByOutputType[P]>
        }
      >
    >


  export type AiMonthlySummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    monthKey?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    costUsd?: boolean
    creditsUsed?: boolean
    callCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiMonthlySummary"]>

  export type AiMonthlySummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    monthKey?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    costUsd?: boolean
    creditsUsed?: boolean
    callCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiMonthlySummary"]>

  export type AiMonthlySummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    monthKey?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    costUsd?: boolean
    creditsUsed?: boolean
    callCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiMonthlySummary"]>

  export type AiMonthlySummarySelectScalar = {
    id?: boolean
    orgId?: boolean
    monthKey?: boolean
    tokensIn?: boolean
    tokensOut?: boolean
    costUsd?: boolean
    creditsUsed?: boolean
    callCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiMonthlySummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "monthKey" | "tokensIn" | "tokensOut" | "costUsd" | "creditsUsed" | "callCount" | "createdAt" | "updatedAt", ExtArgs["result"]["aiMonthlySummary"]>
  export type AiMonthlySummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type AiMonthlySummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type AiMonthlySummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $AiMonthlySummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiMonthlySummary"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      monthKey: string
      tokensIn: number
      tokensOut: number
      costUsd: Prisma.Decimal
      creditsUsed: number
      callCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiMonthlySummary"]>
    composites: {}
  }

  type AiMonthlySummaryGetPayload<S extends boolean | null | undefined | AiMonthlySummaryDefaultArgs> = $Result.GetResult<Prisma.$AiMonthlySummaryPayload, S>

  type AiMonthlySummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiMonthlySummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiMonthlySummaryCountAggregateInputType | true
    }

  export interface AiMonthlySummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiMonthlySummary'], meta: { name: 'AiMonthlySummary' } }
    /**
     * Find zero or one AiMonthlySummary that matches the filter.
     * @param {AiMonthlySummaryFindUniqueArgs} args - Arguments to find a AiMonthlySummary
     * @example
     * // Get one AiMonthlySummary
     * const aiMonthlySummary = await prisma.aiMonthlySummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiMonthlySummaryFindUniqueArgs>(args: SelectSubset<T, AiMonthlySummaryFindUniqueArgs<ExtArgs>>): Prisma__AiMonthlySummaryClient<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiMonthlySummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiMonthlySummaryFindUniqueOrThrowArgs} args - Arguments to find a AiMonthlySummary
     * @example
     * // Get one AiMonthlySummary
     * const aiMonthlySummary = await prisma.aiMonthlySummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiMonthlySummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, AiMonthlySummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiMonthlySummaryClient<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiMonthlySummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMonthlySummaryFindFirstArgs} args - Arguments to find a AiMonthlySummary
     * @example
     * // Get one AiMonthlySummary
     * const aiMonthlySummary = await prisma.aiMonthlySummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiMonthlySummaryFindFirstArgs>(args?: SelectSubset<T, AiMonthlySummaryFindFirstArgs<ExtArgs>>): Prisma__AiMonthlySummaryClient<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiMonthlySummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMonthlySummaryFindFirstOrThrowArgs} args - Arguments to find a AiMonthlySummary
     * @example
     * // Get one AiMonthlySummary
     * const aiMonthlySummary = await prisma.aiMonthlySummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiMonthlySummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, AiMonthlySummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiMonthlySummaryClient<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiMonthlySummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMonthlySummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiMonthlySummaries
     * const aiMonthlySummaries = await prisma.aiMonthlySummary.findMany()
     * 
     * // Get first 10 AiMonthlySummaries
     * const aiMonthlySummaries = await prisma.aiMonthlySummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiMonthlySummaryWithIdOnly = await prisma.aiMonthlySummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiMonthlySummaryFindManyArgs>(args?: SelectSubset<T, AiMonthlySummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiMonthlySummary.
     * @param {AiMonthlySummaryCreateArgs} args - Arguments to create a AiMonthlySummary.
     * @example
     * // Create one AiMonthlySummary
     * const AiMonthlySummary = await prisma.aiMonthlySummary.create({
     *   data: {
     *     // ... data to create a AiMonthlySummary
     *   }
     * })
     * 
     */
    create<T extends AiMonthlySummaryCreateArgs>(args: SelectSubset<T, AiMonthlySummaryCreateArgs<ExtArgs>>): Prisma__AiMonthlySummaryClient<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiMonthlySummaries.
     * @param {AiMonthlySummaryCreateManyArgs} args - Arguments to create many AiMonthlySummaries.
     * @example
     * // Create many AiMonthlySummaries
     * const aiMonthlySummary = await prisma.aiMonthlySummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiMonthlySummaryCreateManyArgs>(args?: SelectSubset<T, AiMonthlySummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiMonthlySummaries and returns the data saved in the database.
     * @param {AiMonthlySummaryCreateManyAndReturnArgs} args - Arguments to create many AiMonthlySummaries.
     * @example
     * // Create many AiMonthlySummaries
     * const aiMonthlySummary = await prisma.aiMonthlySummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiMonthlySummaries and only return the `id`
     * const aiMonthlySummaryWithIdOnly = await prisma.aiMonthlySummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiMonthlySummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, AiMonthlySummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiMonthlySummary.
     * @param {AiMonthlySummaryDeleteArgs} args - Arguments to delete one AiMonthlySummary.
     * @example
     * // Delete one AiMonthlySummary
     * const AiMonthlySummary = await prisma.aiMonthlySummary.delete({
     *   where: {
     *     // ... filter to delete one AiMonthlySummary
     *   }
     * })
     * 
     */
    delete<T extends AiMonthlySummaryDeleteArgs>(args: SelectSubset<T, AiMonthlySummaryDeleteArgs<ExtArgs>>): Prisma__AiMonthlySummaryClient<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiMonthlySummary.
     * @param {AiMonthlySummaryUpdateArgs} args - Arguments to update one AiMonthlySummary.
     * @example
     * // Update one AiMonthlySummary
     * const aiMonthlySummary = await prisma.aiMonthlySummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiMonthlySummaryUpdateArgs>(args: SelectSubset<T, AiMonthlySummaryUpdateArgs<ExtArgs>>): Prisma__AiMonthlySummaryClient<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiMonthlySummaries.
     * @param {AiMonthlySummaryDeleteManyArgs} args - Arguments to filter AiMonthlySummaries to delete.
     * @example
     * // Delete a few AiMonthlySummaries
     * const { count } = await prisma.aiMonthlySummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiMonthlySummaryDeleteManyArgs>(args?: SelectSubset<T, AiMonthlySummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiMonthlySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMonthlySummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiMonthlySummaries
     * const aiMonthlySummary = await prisma.aiMonthlySummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiMonthlySummaryUpdateManyArgs>(args: SelectSubset<T, AiMonthlySummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiMonthlySummaries and returns the data updated in the database.
     * @param {AiMonthlySummaryUpdateManyAndReturnArgs} args - Arguments to update many AiMonthlySummaries.
     * @example
     * // Update many AiMonthlySummaries
     * const aiMonthlySummary = await prisma.aiMonthlySummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiMonthlySummaries and only return the `id`
     * const aiMonthlySummaryWithIdOnly = await prisma.aiMonthlySummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiMonthlySummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, AiMonthlySummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiMonthlySummary.
     * @param {AiMonthlySummaryUpsertArgs} args - Arguments to update or create a AiMonthlySummary.
     * @example
     * // Update or create a AiMonthlySummary
     * const aiMonthlySummary = await prisma.aiMonthlySummary.upsert({
     *   create: {
     *     // ... data to create a AiMonthlySummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiMonthlySummary we want to update
     *   }
     * })
     */
    upsert<T extends AiMonthlySummaryUpsertArgs>(args: SelectSubset<T, AiMonthlySummaryUpsertArgs<ExtArgs>>): Prisma__AiMonthlySummaryClient<$Result.GetResult<Prisma.$AiMonthlySummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiMonthlySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMonthlySummaryCountArgs} args - Arguments to filter AiMonthlySummaries to count.
     * @example
     * // Count the number of AiMonthlySummaries
     * const count = await prisma.aiMonthlySummary.count({
     *   where: {
     *     // ... the filter for the AiMonthlySummaries we want to count
     *   }
     * })
    **/
    count<T extends AiMonthlySummaryCountArgs>(
      args?: Subset<T, AiMonthlySummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiMonthlySummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiMonthlySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMonthlySummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiMonthlySummaryAggregateArgs>(args: Subset<T, AiMonthlySummaryAggregateArgs>): Prisma.PrismaPromise<GetAiMonthlySummaryAggregateType<T>>

    /**
     * Group by AiMonthlySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMonthlySummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiMonthlySummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiMonthlySummaryGroupByArgs['orderBy'] }
        : { orderBy?: AiMonthlySummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiMonthlySummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiMonthlySummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiMonthlySummary model
   */
  readonly fields: AiMonthlySummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiMonthlySummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiMonthlySummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiMonthlySummary model
   */
  interface AiMonthlySummaryFieldRefs {
    readonly id: FieldRef<"AiMonthlySummary", 'String'>
    readonly orgId: FieldRef<"AiMonthlySummary", 'String'>
    readonly monthKey: FieldRef<"AiMonthlySummary", 'String'>
    readonly tokensIn: FieldRef<"AiMonthlySummary", 'Int'>
    readonly tokensOut: FieldRef<"AiMonthlySummary", 'Int'>
    readonly costUsd: FieldRef<"AiMonthlySummary", 'Decimal'>
    readonly creditsUsed: FieldRef<"AiMonthlySummary", 'Int'>
    readonly callCount: FieldRef<"AiMonthlySummary", 'Int'>
    readonly createdAt: FieldRef<"AiMonthlySummary", 'DateTime'>
    readonly updatedAt: FieldRef<"AiMonthlySummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiMonthlySummary findUnique
   */
  export type AiMonthlySummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
    /**
     * Filter, which AiMonthlySummary to fetch.
     */
    where: AiMonthlySummaryWhereUniqueInput
  }

  /**
   * AiMonthlySummary findUniqueOrThrow
   */
  export type AiMonthlySummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
    /**
     * Filter, which AiMonthlySummary to fetch.
     */
    where: AiMonthlySummaryWhereUniqueInput
  }

  /**
   * AiMonthlySummary findFirst
   */
  export type AiMonthlySummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
    /**
     * Filter, which AiMonthlySummary to fetch.
     */
    where?: AiMonthlySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMonthlySummaries to fetch.
     */
    orderBy?: AiMonthlySummaryOrderByWithRelationInput | AiMonthlySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiMonthlySummaries.
     */
    cursor?: AiMonthlySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMonthlySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMonthlySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiMonthlySummaries.
     */
    distinct?: AiMonthlySummaryScalarFieldEnum | AiMonthlySummaryScalarFieldEnum[]
  }

  /**
   * AiMonthlySummary findFirstOrThrow
   */
  export type AiMonthlySummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
    /**
     * Filter, which AiMonthlySummary to fetch.
     */
    where?: AiMonthlySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMonthlySummaries to fetch.
     */
    orderBy?: AiMonthlySummaryOrderByWithRelationInput | AiMonthlySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiMonthlySummaries.
     */
    cursor?: AiMonthlySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMonthlySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMonthlySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiMonthlySummaries.
     */
    distinct?: AiMonthlySummaryScalarFieldEnum | AiMonthlySummaryScalarFieldEnum[]
  }

  /**
   * AiMonthlySummary findMany
   */
  export type AiMonthlySummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
    /**
     * Filter, which AiMonthlySummaries to fetch.
     */
    where?: AiMonthlySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMonthlySummaries to fetch.
     */
    orderBy?: AiMonthlySummaryOrderByWithRelationInput | AiMonthlySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiMonthlySummaries.
     */
    cursor?: AiMonthlySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMonthlySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMonthlySummaries.
     */
    skip?: number
    distinct?: AiMonthlySummaryScalarFieldEnum | AiMonthlySummaryScalarFieldEnum[]
  }

  /**
   * AiMonthlySummary create
   */
  export type AiMonthlySummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a AiMonthlySummary.
     */
    data: XOR<AiMonthlySummaryCreateInput, AiMonthlySummaryUncheckedCreateInput>
  }

  /**
   * AiMonthlySummary createMany
   */
  export type AiMonthlySummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiMonthlySummaries.
     */
    data: AiMonthlySummaryCreateManyInput | AiMonthlySummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiMonthlySummary createManyAndReturn
   */
  export type AiMonthlySummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * The data used to create many AiMonthlySummaries.
     */
    data: AiMonthlySummaryCreateManyInput | AiMonthlySummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiMonthlySummary update
   */
  export type AiMonthlySummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a AiMonthlySummary.
     */
    data: XOR<AiMonthlySummaryUpdateInput, AiMonthlySummaryUncheckedUpdateInput>
    /**
     * Choose, which AiMonthlySummary to update.
     */
    where: AiMonthlySummaryWhereUniqueInput
  }

  /**
   * AiMonthlySummary updateMany
   */
  export type AiMonthlySummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiMonthlySummaries.
     */
    data: XOR<AiMonthlySummaryUpdateManyMutationInput, AiMonthlySummaryUncheckedUpdateManyInput>
    /**
     * Filter which AiMonthlySummaries to update
     */
    where?: AiMonthlySummaryWhereInput
    /**
     * Limit how many AiMonthlySummaries to update.
     */
    limit?: number
  }

  /**
   * AiMonthlySummary updateManyAndReturn
   */
  export type AiMonthlySummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * The data used to update AiMonthlySummaries.
     */
    data: XOR<AiMonthlySummaryUpdateManyMutationInput, AiMonthlySummaryUncheckedUpdateManyInput>
    /**
     * Filter which AiMonthlySummaries to update
     */
    where?: AiMonthlySummaryWhereInput
    /**
     * Limit how many AiMonthlySummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiMonthlySummary upsert
   */
  export type AiMonthlySummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the AiMonthlySummary to update in case it exists.
     */
    where: AiMonthlySummaryWhereUniqueInput
    /**
     * In case the AiMonthlySummary found by the `where` argument doesn't exist, create a new AiMonthlySummary with this data.
     */
    create: XOR<AiMonthlySummaryCreateInput, AiMonthlySummaryUncheckedCreateInput>
    /**
     * In case the AiMonthlySummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiMonthlySummaryUpdateInput, AiMonthlySummaryUncheckedUpdateInput>
  }

  /**
   * AiMonthlySummary delete
   */
  export type AiMonthlySummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
    /**
     * Filter which AiMonthlySummary to delete.
     */
    where: AiMonthlySummaryWhereUniqueInput
  }

  /**
   * AiMonthlySummary deleteMany
   */
  export type AiMonthlySummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiMonthlySummaries to delete
     */
    where?: AiMonthlySummaryWhereInput
    /**
     * Limit how many AiMonthlySummaries to delete.
     */
    limit?: number
  }

  /**
   * AiMonthlySummary without action
   */
  export type AiMonthlySummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMonthlySummary
     */
    select?: AiMonthlySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiMonthlySummary
     */
    omit?: AiMonthlySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMonthlySummaryInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    actorType: string | null
    actorId: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    actorType: string | null
    actorId: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    orgId: number
    actorType: number
    actorId: number
    entityType: number
    entityId: number
    action: number
    meta: number
    createdAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    orgId?: true
    actorType?: true
    actorId?: true
    entityType?: true
    entityId?: true
    action?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    orgId?: true
    actorType?: true
    actorId?: true
    entityType?: true
    entityId?: true
    action?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    orgId?: true
    actorType?: true
    actorId?: true
    entityType?: true
    entityId?: true
    action?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    orgId: string
    actorType: string
    actorId: string | null
    entityType: string
    entityId: string
    action: string
    meta: JsonValue
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    actorType?: boolean
    actorId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    meta?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    actorType?: boolean
    actorId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    meta?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    actorType?: boolean
    actorId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    meta?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    orgId?: boolean
    actorType?: boolean
    actorId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "actorType" | "actorId" | "entityType" | "entityId" | "action" | "meta" | "createdAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      actorType: string
      actorId: string | null
      entityType: string
      entityId: string
      action: string
      meta: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly orgId: FieldRef<"Activity", 'String'>
    readonly actorType: FieldRef<"Activity", 'String'>
    readonly actorId: FieldRef<"Activity", 'String'>
    readonly entityType: FieldRef<"Activity", 'String'>
    readonly entityId: FieldRef<"Activity", 'String'>
    readonly action: FieldRef<"Activity", 'String'>
    readonly meta: FieldRef<"Activity", 'Json'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    priceCents: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    priceCents: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    plan: string | null
    status: string | null
    startedAt: Date | null
    canceledAt: Date | null
    renewsAt: Date | null
    priceCents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    plan: string | null
    status: string | null
    startedAt: Date | null
    canceledAt: Date | null
    renewsAt: Date | null
    priceCents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    orgId: number
    plan: number
    status: number
    startedAt: number
    canceledAt: number
    renewsAt: number
    priceCents: number
    meta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    priceCents?: true
  }

  export type SubscriptionSumAggregateInputType = {
    priceCents?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    orgId?: true
    plan?: true
    status?: true
    startedAt?: true
    canceledAt?: true
    renewsAt?: true
    priceCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    orgId?: true
    plan?: true
    status?: true
    startedAt?: true
    canceledAt?: true
    renewsAt?: true
    priceCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    orgId?: true
    plan?: true
    status?: true
    startedAt?: true
    canceledAt?: true
    renewsAt?: true
    priceCents?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    orgId: string
    plan: string
    status: string
    startedAt: Date
    canceledAt: Date | null
    renewsAt: Date | null
    priceCents: number
    meta: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    plan?: boolean
    status?: boolean
    startedAt?: boolean
    canceledAt?: boolean
    renewsAt?: boolean
    priceCents?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    plan?: boolean
    status?: boolean
    startedAt?: boolean
    canceledAt?: boolean
    renewsAt?: boolean
    priceCents?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    plan?: boolean
    status?: boolean
    startedAt?: boolean
    canceledAt?: boolean
    renewsAt?: boolean
    priceCents?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    orgId?: boolean
    plan?: boolean
    status?: boolean
    startedAt?: boolean
    canceledAt?: boolean
    renewsAt?: boolean
    priceCents?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "plan" | "status" | "startedAt" | "canceledAt" | "renewsAt" | "priceCents" | "meta" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      plan: string
      status: string
      startedAt: Date
      canceledAt: Date | null
      renewsAt: Date | null
      priceCents: number
      meta: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly orgId: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly startedAt: FieldRef<"Subscription", 'DateTime'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly renewsAt: FieldRef<"Subscription", 'DateTime'>
    readonly priceCents: FieldRef<"Subscription", 'Int'>
    readonly meta: FieldRef<"Subscription", 'Json'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model UsageMeter
   */

  export type AggregateUsageMeter = {
    _count: UsageMeterCountAggregateOutputType | null
    _avg: UsageMeterAvgAggregateOutputType | null
    _sum: UsageMeterSumAggregateOutputType | null
    _min: UsageMeterMinAggregateOutputType | null
    _max: UsageMeterMaxAggregateOutputType | null
  }

  export type UsageMeterAvgAggregateOutputType = {
    quantity: number | null
  }

  export type UsageMeterSumAggregateOutputType = {
    quantity: number | null
  }

  export type UsageMeterMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    meter: string | null
    quantity: number | null
    windowStart: Date | null
    windowEnd: Date | null
    createdAt: Date | null
  }

  export type UsageMeterMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    meter: string | null
    quantity: number | null
    windowStart: Date | null
    windowEnd: Date | null
    createdAt: Date | null
  }

  export type UsageMeterCountAggregateOutputType = {
    id: number
    orgId: number
    meter: number
    quantity: number
    windowStart: number
    windowEnd: number
    createdAt: number
    _all: number
  }


  export type UsageMeterAvgAggregateInputType = {
    quantity?: true
  }

  export type UsageMeterSumAggregateInputType = {
    quantity?: true
  }

  export type UsageMeterMinAggregateInputType = {
    id?: true
    orgId?: true
    meter?: true
    quantity?: true
    windowStart?: true
    windowEnd?: true
    createdAt?: true
  }

  export type UsageMeterMaxAggregateInputType = {
    id?: true
    orgId?: true
    meter?: true
    quantity?: true
    windowStart?: true
    windowEnd?: true
    createdAt?: true
  }

  export type UsageMeterCountAggregateInputType = {
    id?: true
    orgId?: true
    meter?: true
    quantity?: true
    windowStart?: true
    windowEnd?: true
    createdAt?: true
    _all?: true
  }

  export type UsageMeterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageMeter to aggregate.
     */
    where?: UsageMeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMeters to fetch.
     */
    orderBy?: UsageMeterOrderByWithRelationInput | UsageMeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageMeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageMeters
    **/
    _count?: true | UsageMeterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageMeterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageMeterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageMeterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageMeterMaxAggregateInputType
  }

  export type GetUsageMeterAggregateType<T extends UsageMeterAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageMeter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageMeter[P]>
      : GetScalarType<T[P], AggregateUsageMeter[P]>
  }




  export type UsageMeterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageMeterWhereInput
    orderBy?: UsageMeterOrderByWithAggregationInput | UsageMeterOrderByWithAggregationInput[]
    by: UsageMeterScalarFieldEnum[] | UsageMeterScalarFieldEnum
    having?: UsageMeterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageMeterCountAggregateInputType | true
    _avg?: UsageMeterAvgAggregateInputType
    _sum?: UsageMeterSumAggregateInputType
    _min?: UsageMeterMinAggregateInputType
    _max?: UsageMeterMaxAggregateInputType
  }

  export type UsageMeterGroupByOutputType = {
    id: string
    orgId: string
    meter: string
    quantity: number
    windowStart: Date
    windowEnd: Date
    createdAt: Date
    _count: UsageMeterCountAggregateOutputType | null
    _avg: UsageMeterAvgAggregateOutputType | null
    _sum: UsageMeterSumAggregateOutputType | null
    _min: UsageMeterMinAggregateOutputType | null
    _max: UsageMeterMaxAggregateOutputType | null
  }

  type GetUsageMeterGroupByPayload<T extends UsageMeterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageMeterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageMeterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageMeterGroupByOutputType[P]>
            : GetScalarType<T[P], UsageMeterGroupByOutputType[P]>
        }
      >
    >


  export type UsageMeterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    meter?: boolean
    quantity?: boolean
    windowStart?: boolean
    windowEnd?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageMeter"]>

  export type UsageMeterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    meter?: boolean
    quantity?: boolean
    windowStart?: boolean
    windowEnd?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageMeter"]>

  export type UsageMeterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    meter?: boolean
    quantity?: boolean
    windowStart?: boolean
    windowEnd?: boolean
    createdAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageMeter"]>

  export type UsageMeterSelectScalar = {
    id?: boolean
    orgId?: boolean
    meter?: boolean
    quantity?: boolean
    windowStart?: boolean
    windowEnd?: boolean
    createdAt?: boolean
  }

  export type UsageMeterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "meter" | "quantity" | "windowStart" | "windowEnd" | "createdAt", ExtArgs["result"]["usageMeter"]>
  export type UsageMeterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type UsageMeterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type UsageMeterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $UsageMeterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageMeter"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      meter: string
      quantity: number
      windowStart: Date
      windowEnd: Date
      createdAt: Date
    }, ExtArgs["result"]["usageMeter"]>
    composites: {}
  }

  type UsageMeterGetPayload<S extends boolean | null | undefined | UsageMeterDefaultArgs> = $Result.GetResult<Prisma.$UsageMeterPayload, S>

  type UsageMeterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageMeterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageMeterCountAggregateInputType | true
    }

  export interface UsageMeterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageMeter'], meta: { name: 'UsageMeter' } }
    /**
     * Find zero or one UsageMeter that matches the filter.
     * @param {UsageMeterFindUniqueArgs} args - Arguments to find a UsageMeter
     * @example
     * // Get one UsageMeter
     * const usageMeter = await prisma.usageMeter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageMeterFindUniqueArgs>(args: SelectSubset<T, UsageMeterFindUniqueArgs<ExtArgs>>): Prisma__UsageMeterClient<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsageMeter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageMeterFindUniqueOrThrowArgs} args - Arguments to find a UsageMeter
     * @example
     * // Get one UsageMeter
     * const usageMeter = await prisma.usageMeter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageMeterFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageMeterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageMeterClient<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageMeter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMeterFindFirstArgs} args - Arguments to find a UsageMeter
     * @example
     * // Get one UsageMeter
     * const usageMeter = await prisma.usageMeter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageMeterFindFirstArgs>(args?: SelectSubset<T, UsageMeterFindFirstArgs<ExtArgs>>): Prisma__UsageMeterClient<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageMeter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMeterFindFirstOrThrowArgs} args - Arguments to find a UsageMeter
     * @example
     * // Get one UsageMeter
     * const usageMeter = await prisma.usageMeter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageMeterFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageMeterFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageMeterClient<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsageMeters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMeterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageMeters
     * const usageMeters = await prisma.usageMeter.findMany()
     * 
     * // Get first 10 UsageMeters
     * const usageMeters = await prisma.usageMeter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageMeterWithIdOnly = await prisma.usageMeter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageMeterFindManyArgs>(args?: SelectSubset<T, UsageMeterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsageMeter.
     * @param {UsageMeterCreateArgs} args - Arguments to create a UsageMeter.
     * @example
     * // Create one UsageMeter
     * const UsageMeter = await prisma.usageMeter.create({
     *   data: {
     *     // ... data to create a UsageMeter
     *   }
     * })
     * 
     */
    create<T extends UsageMeterCreateArgs>(args: SelectSubset<T, UsageMeterCreateArgs<ExtArgs>>): Prisma__UsageMeterClient<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsageMeters.
     * @param {UsageMeterCreateManyArgs} args - Arguments to create many UsageMeters.
     * @example
     * // Create many UsageMeters
     * const usageMeter = await prisma.usageMeter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageMeterCreateManyArgs>(args?: SelectSubset<T, UsageMeterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageMeters and returns the data saved in the database.
     * @param {UsageMeterCreateManyAndReturnArgs} args - Arguments to create many UsageMeters.
     * @example
     * // Create many UsageMeters
     * const usageMeter = await prisma.usageMeter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageMeters and only return the `id`
     * const usageMeterWithIdOnly = await prisma.usageMeter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageMeterCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageMeterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsageMeter.
     * @param {UsageMeterDeleteArgs} args - Arguments to delete one UsageMeter.
     * @example
     * // Delete one UsageMeter
     * const UsageMeter = await prisma.usageMeter.delete({
     *   where: {
     *     // ... filter to delete one UsageMeter
     *   }
     * })
     * 
     */
    delete<T extends UsageMeterDeleteArgs>(args: SelectSubset<T, UsageMeterDeleteArgs<ExtArgs>>): Prisma__UsageMeterClient<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsageMeter.
     * @param {UsageMeterUpdateArgs} args - Arguments to update one UsageMeter.
     * @example
     * // Update one UsageMeter
     * const usageMeter = await prisma.usageMeter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageMeterUpdateArgs>(args: SelectSubset<T, UsageMeterUpdateArgs<ExtArgs>>): Prisma__UsageMeterClient<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsageMeters.
     * @param {UsageMeterDeleteManyArgs} args - Arguments to filter UsageMeters to delete.
     * @example
     * // Delete a few UsageMeters
     * const { count } = await prisma.usageMeter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageMeterDeleteManyArgs>(args?: SelectSubset<T, UsageMeterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageMeters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMeterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageMeters
     * const usageMeter = await prisma.usageMeter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageMeterUpdateManyArgs>(args: SelectSubset<T, UsageMeterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageMeters and returns the data updated in the database.
     * @param {UsageMeterUpdateManyAndReturnArgs} args - Arguments to update many UsageMeters.
     * @example
     * // Update many UsageMeters
     * const usageMeter = await prisma.usageMeter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsageMeters and only return the `id`
     * const usageMeterWithIdOnly = await prisma.usageMeter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageMeterUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageMeterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsageMeter.
     * @param {UsageMeterUpsertArgs} args - Arguments to update or create a UsageMeter.
     * @example
     * // Update or create a UsageMeter
     * const usageMeter = await prisma.usageMeter.upsert({
     *   create: {
     *     // ... data to create a UsageMeter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageMeter we want to update
     *   }
     * })
     */
    upsert<T extends UsageMeterUpsertArgs>(args: SelectSubset<T, UsageMeterUpsertArgs<ExtArgs>>): Prisma__UsageMeterClient<$Result.GetResult<Prisma.$UsageMeterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsageMeters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMeterCountArgs} args - Arguments to filter UsageMeters to count.
     * @example
     * // Count the number of UsageMeters
     * const count = await prisma.usageMeter.count({
     *   where: {
     *     // ... the filter for the UsageMeters we want to count
     *   }
     * })
    **/
    count<T extends UsageMeterCountArgs>(
      args?: Subset<T, UsageMeterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageMeterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageMeter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMeterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageMeterAggregateArgs>(args: Subset<T, UsageMeterAggregateArgs>): Prisma.PrismaPromise<GetUsageMeterAggregateType<T>>

    /**
     * Group by UsageMeter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMeterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageMeterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageMeterGroupByArgs['orderBy'] }
        : { orderBy?: UsageMeterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageMeterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageMeterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageMeter model
   */
  readonly fields: UsageMeterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageMeter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageMeterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageMeter model
   */
  interface UsageMeterFieldRefs {
    readonly id: FieldRef<"UsageMeter", 'String'>
    readonly orgId: FieldRef<"UsageMeter", 'String'>
    readonly meter: FieldRef<"UsageMeter", 'String'>
    readonly quantity: FieldRef<"UsageMeter", 'Int'>
    readonly windowStart: FieldRef<"UsageMeter", 'DateTime'>
    readonly windowEnd: FieldRef<"UsageMeter", 'DateTime'>
    readonly createdAt: FieldRef<"UsageMeter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageMeter findUnique
   */
  export type UsageMeterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
    /**
     * Filter, which UsageMeter to fetch.
     */
    where: UsageMeterWhereUniqueInput
  }

  /**
   * UsageMeter findUniqueOrThrow
   */
  export type UsageMeterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
    /**
     * Filter, which UsageMeter to fetch.
     */
    where: UsageMeterWhereUniqueInput
  }

  /**
   * UsageMeter findFirst
   */
  export type UsageMeterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
    /**
     * Filter, which UsageMeter to fetch.
     */
    where?: UsageMeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMeters to fetch.
     */
    orderBy?: UsageMeterOrderByWithRelationInput | UsageMeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageMeters.
     */
    cursor?: UsageMeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageMeters.
     */
    distinct?: UsageMeterScalarFieldEnum | UsageMeterScalarFieldEnum[]
  }

  /**
   * UsageMeter findFirstOrThrow
   */
  export type UsageMeterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
    /**
     * Filter, which UsageMeter to fetch.
     */
    where?: UsageMeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMeters to fetch.
     */
    orderBy?: UsageMeterOrderByWithRelationInput | UsageMeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageMeters.
     */
    cursor?: UsageMeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMeters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageMeters.
     */
    distinct?: UsageMeterScalarFieldEnum | UsageMeterScalarFieldEnum[]
  }

  /**
   * UsageMeter findMany
   */
  export type UsageMeterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
    /**
     * Filter, which UsageMeters to fetch.
     */
    where?: UsageMeterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMeters to fetch.
     */
    orderBy?: UsageMeterOrderByWithRelationInput | UsageMeterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageMeters.
     */
    cursor?: UsageMeterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMeters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMeters.
     */
    skip?: number
    distinct?: UsageMeterScalarFieldEnum | UsageMeterScalarFieldEnum[]
  }

  /**
   * UsageMeter create
   */
  export type UsageMeterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageMeter.
     */
    data: XOR<UsageMeterCreateInput, UsageMeterUncheckedCreateInput>
  }

  /**
   * UsageMeter createMany
   */
  export type UsageMeterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageMeters.
     */
    data: UsageMeterCreateManyInput | UsageMeterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageMeter createManyAndReturn
   */
  export type UsageMeterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * The data used to create many UsageMeters.
     */
    data: UsageMeterCreateManyInput | UsageMeterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageMeter update
   */
  export type UsageMeterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageMeter.
     */
    data: XOR<UsageMeterUpdateInput, UsageMeterUncheckedUpdateInput>
    /**
     * Choose, which UsageMeter to update.
     */
    where: UsageMeterWhereUniqueInput
  }

  /**
   * UsageMeter updateMany
   */
  export type UsageMeterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageMeters.
     */
    data: XOR<UsageMeterUpdateManyMutationInput, UsageMeterUncheckedUpdateManyInput>
    /**
     * Filter which UsageMeters to update
     */
    where?: UsageMeterWhereInput
    /**
     * Limit how many UsageMeters to update.
     */
    limit?: number
  }

  /**
   * UsageMeter updateManyAndReturn
   */
  export type UsageMeterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * The data used to update UsageMeters.
     */
    data: XOR<UsageMeterUpdateManyMutationInput, UsageMeterUncheckedUpdateManyInput>
    /**
     * Filter which UsageMeters to update
     */
    where?: UsageMeterWhereInput
    /**
     * Limit how many UsageMeters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageMeter upsert
   */
  export type UsageMeterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageMeter to update in case it exists.
     */
    where: UsageMeterWhereUniqueInput
    /**
     * In case the UsageMeter found by the `where` argument doesn't exist, create a new UsageMeter with this data.
     */
    create: XOR<UsageMeterCreateInput, UsageMeterUncheckedCreateInput>
    /**
     * In case the UsageMeter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageMeterUpdateInput, UsageMeterUncheckedUpdateInput>
  }

  /**
   * UsageMeter delete
   */
  export type UsageMeterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
    /**
     * Filter which UsageMeter to delete.
     */
    where: UsageMeterWhereUniqueInput
  }

  /**
   * UsageMeter deleteMany
   */
  export type UsageMeterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageMeters to delete
     */
    where?: UsageMeterWhereInput
    /**
     * Limit how many UsageMeters to delete.
     */
    limit?: number
  }

  /**
   * UsageMeter without action
   */
  export type UsageMeterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMeter
     */
    select?: UsageMeterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMeter
     */
    omit?: UsageMeterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMeterInclude<ExtArgs> | null
  }


  /**
   * Model AddonPurchase
   */

  export type AggregateAddonPurchase = {
    _count: AddonPurchaseCountAggregateOutputType | null
    _avg: AddonPurchaseAvgAggregateOutputType | null
    _sum: AddonPurchaseSumAggregateOutputType | null
    _min: AddonPurchaseMinAggregateOutputType | null
    _max: AddonPurchaseMaxAggregateOutputType | null
  }

  export type AddonPurchaseAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type AddonPurchaseSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type AddonPurchaseMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    sku: string | null
    amount: Decimal | null
    status: string | null
    purchasedAt: Date | null
    refundedAt: Date | null
  }

  export type AddonPurchaseMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    sku: string | null
    amount: Decimal | null
    status: string | null
    purchasedAt: Date | null
    refundedAt: Date | null
  }

  export type AddonPurchaseCountAggregateOutputType = {
    id: number
    orgId: number
    sku: number
    amount: number
    status: number
    purchasedAt: number
    refundedAt: number
    meta: number
    _all: number
  }


  export type AddonPurchaseAvgAggregateInputType = {
    amount?: true
  }

  export type AddonPurchaseSumAggregateInputType = {
    amount?: true
  }

  export type AddonPurchaseMinAggregateInputType = {
    id?: true
    orgId?: true
    sku?: true
    amount?: true
    status?: true
    purchasedAt?: true
    refundedAt?: true
  }

  export type AddonPurchaseMaxAggregateInputType = {
    id?: true
    orgId?: true
    sku?: true
    amount?: true
    status?: true
    purchasedAt?: true
    refundedAt?: true
  }

  export type AddonPurchaseCountAggregateInputType = {
    id?: true
    orgId?: true
    sku?: true
    amount?: true
    status?: true
    purchasedAt?: true
    refundedAt?: true
    meta?: true
    _all?: true
  }

  export type AddonPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddonPurchase to aggregate.
     */
    where?: AddonPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddonPurchases to fetch.
     */
    orderBy?: AddonPurchaseOrderByWithRelationInput | AddonPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddonPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddonPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddonPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddonPurchases
    **/
    _count?: true | AddonPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddonPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddonPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddonPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddonPurchaseMaxAggregateInputType
  }

  export type GetAddonPurchaseAggregateType<T extends AddonPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregateAddonPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddonPurchase[P]>
      : GetScalarType<T[P], AggregateAddonPurchase[P]>
  }




  export type AddonPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddonPurchaseWhereInput
    orderBy?: AddonPurchaseOrderByWithAggregationInput | AddonPurchaseOrderByWithAggregationInput[]
    by: AddonPurchaseScalarFieldEnum[] | AddonPurchaseScalarFieldEnum
    having?: AddonPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddonPurchaseCountAggregateInputType | true
    _avg?: AddonPurchaseAvgAggregateInputType
    _sum?: AddonPurchaseSumAggregateInputType
    _min?: AddonPurchaseMinAggregateInputType
    _max?: AddonPurchaseMaxAggregateInputType
  }

  export type AddonPurchaseGroupByOutputType = {
    id: string
    orgId: string
    sku: string
    amount: Decimal
    status: string
    purchasedAt: Date
    refundedAt: Date | null
    meta: JsonValue
    _count: AddonPurchaseCountAggregateOutputType | null
    _avg: AddonPurchaseAvgAggregateOutputType | null
    _sum: AddonPurchaseSumAggregateOutputType | null
    _min: AddonPurchaseMinAggregateOutputType | null
    _max: AddonPurchaseMaxAggregateOutputType | null
  }

  type GetAddonPurchaseGroupByPayload<T extends AddonPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddonPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddonPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddonPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], AddonPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type AddonPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    sku?: boolean
    amount?: boolean
    status?: boolean
    purchasedAt?: boolean
    refundedAt?: boolean
    meta?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addonPurchase"]>

  export type AddonPurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    sku?: boolean
    amount?: boolean
    status?: boolean
    purchasedAt?: boolean
    refundedAt?: boolean
    meta?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addonPurchase"]>

  export type AddonPurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    sku?: boolean
    amount?: boolean
    status?: boolean
    purchasedAt?: boolean
    refundedAt?: boolean
    meta?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addonPurchase"]>

  export type AddonPurchaseSelectScalar = {
    id?: boolean
    orgId?: boolean
    sku?: boolean
    amount?: boolean
    status?: boolean
    purchasedAt?: boolean
    refundedAt?: boolean
    meta?: boolean
  }

  export type AddonPurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "sku" | "amount" | "status" | "purchasedAt" | "refundedAt" | "meta", ExtArgs["result"]["addonPurchase"]>
  export type AddonPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type AddonPurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type AddonPurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $AddonPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddonPurchase"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      sku: string
      amount: Prisma.Decimal
      status: string
      purchasedAt: Date
      refundedAt: Date | null
      meta: Prisma.JsonValue
    }, ExtArgs["result"]["addonPurchase"]>
    composites: {}
  }

  type AddonPurchaseGetPayload<S extends boolean | null | undefined | AddonPurchaseDefaultArgs> = $Result.GetResult<Prisma.$AddonPurchasePayload, S>

  type AddonPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddonPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddonPurchaseCountAggregateInputType | true
    }

  export interface AddonPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddonPurchase'], meta: { name: 'AddonPurchase' } }
    /**
     * Find zero or one AddonPurchase that matches the filter.
     * @param {AddonPurchaseFindUniqueArgs} args - Arguments to find a AddonPurchase
     * @example
     * // Get one AddonPurchase
     * const addonPurchase = await prisma.addonPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddonPurchaseFindUniqueArgs>(args: SelectSubset<T, AddonPurchaseFindUniqueArgs<ExtArgs>>): Prisma__AddonPurchaseClient<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddonPurchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddonPurchaseFindUniqueOrThrowArgs} args - Arguments to find a AddonPurchase
     * @example
     * // Get one AddonPurchase
     * const addonPurchase = await prisma.addonPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddonPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, AddonPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddonPurchaseClient<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddonPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonPurchaseFindFirstArgs} args - Arguments to find a AddonPurchase
     * @example
     * // Get one AddonPurchase
     * const addonPurchase = await prisma.addonPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddonPurchaseFindFirstArgs>(args?: SelectSubset<T, AddonPurchaseFindFirstArgs<ExtArgs>>): Prisma__AddonPurchaseClient<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddonPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonPurchaseFindFirstOrThrowArgs} args - Arguments to find a AddonPurchase
     * @example
     * // Get one AddonPurchase
     * const addonPurchase = await prisma.addonPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddonPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, AddonPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddonPurchaseClient<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddonPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddonPurchases
     * const addonPurchases = await prisma.addonPurchase.findMany()
     * 
     * // Get first 10 AddonPurchases
     * const addonPurchases = await prisma.addonPurchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addonPurchaseWithIdOnly = await prisma.addonPurchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddonPurchaseFindManyArgs>(args?: SelectSubset<T, AddonPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddonPurchase.
     * @param {AddonPurchaseCreateArgs} args - Arguments to create a AddonPurchase.
     * @example
     * // Create one AddonPurchase
     * const AddonPurchase = await prisma.addonPurchase.create({
     *   data: {
     *     // ... data to create a AddonPurchase
     *   }
     * })
     * 
     */
    create<T extends AddonPurchaseCreateArgs>(args: SelectSubset<T, AddonPurchaseCreateArgs<ExtArgs>>): Prisma__AddonPurchaseClient<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddonPurchases.
     * @param {AddonPurchaseCreateManyArgs} args - Arguments to create many AddonPurchases.
     * @example
     * // Create many AddonPurchases
     * const addonPurchase = await prisma.addonPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddonPurchaseCreateManyArgs>(args?: SelectSubset<T, AddonPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddonPurchases and returns the data saved in the database.
     * @param {AddonPurchaseCreateManyAndReturnArgs} args - Arguments to create many AddonPurchases.
     * @example
     * // Create many AddonPurchases
     * const addonPurchase = await prisma.addonPurchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddonPurchases and only return the `id`
     * const addonPurchaseWithIdOnly = await prisma.addonPurchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddonPurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, AddonPurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AddonPurchase.
     * @param {AddonPurchaseDeleteArgs} args - Arguments to delete one AddonPurchase.
     * @example
     * // Delete one AddonPurchase
     * const AddonPurchase = await prisma.addonPurchase.delete({
     *   where: {
     *     // ... filter to delete one AddonPurchase
     *   }
     * })
     * 
     */
    delete<T extends AddonPurchaseDeleteArgs>(args: SelectSubset<T, AddonPurchaseDeleteArgs<ExtArgs>>): Prisma__AddonPurchaseClient<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddonPurchase.
     * @param {AddonPurchaseUpdateArgs} args - Arguments to update one AddonPurchase.
     * @example
     * // Update one AddonPurchase
     * const addonPurchase = await prisma.addonPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddonPurchaseUpdateArgs>(args: SelectSubset<T, AddonPurchaseUpdateArgs<ExtArgs>>): Prisma__AddonPurchaseClient<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddonPurchases.
     * @param {AddonPurchaseDeleteManyArgs} args - Arguments to filter AddonPurchases to delete.
     * @example
     * // Delete a few AddonPurchases
     * const { count } = await prisma.addonPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddonPurchaseDeleteManyArgs>(args?: SelectSubset<T, AddonPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddonPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddonPurchases
     * const addonPurchase = await prisma.addonPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddonPurchaseUpdateManyArgs>(args: SelectSubset<T, AddonPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddonPurchases and returns the data updated in the database.
     * @param {AddonPurchaseUpdateManyAndReturnArgs} args - Arguments to update many AddonPurchases.
     * @example
     * // Update many AddonPurchases
     * const addonPurchase = await prisma.addonPurchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AddonPurchases and only return the `id`
     * const addonPurchaseWithIdOnly = await prisma.addonPurchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddonPurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, AddonPurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AddonPurchase.
     * @param {AddonPurchaseUpsertArgs} args - Arguments to update or create a AddonPurchase.
     * @example
     * // Update or create a AddonPurchase
     * const addonPurchase = await prisma.addonPurchase.upsert({
     *   create: {
     *     // ... data to create a AddonPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddonPurchase we want to update
     *   }
     * })
     */
    upsert<T extends AddonPurchaseUpsertArgs>(args: SelectSubset<T, AddonPurchaseUpsertArgs<ExtArgs>>): Prisma__AddonPurchaseClient<$Result.GetResult<Prisma.$AddonPurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddonPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonPurchaseCountArgs} args - Arguments to filter AddonPurchases to count.
     * @example
     * // Count the number of AddonPurchases
     * const count = await prisma.addonPurchase.count({
     *   where: {
     *     // ... the filter for the AddonPurchases we want to count
     *   }
     * })
    **/
    count<T extends AddonPurchaseCountArgs>(
      args?: Subset<T, AddonPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddonPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddonPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddonPurchaseAggregateArgs>(args: Subset<T, AddonPurchaseAggregateArgs>): Prisma.PrismaPromise<GetAddonPurchaseAggregateType<T>>

    /**
     * Group by AddonPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddonPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddonPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: AddonPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddonPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddonPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddonPurchase model
   */
  readonly fields: AddonPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddonPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddonPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddonPurchase model
   */
  interface AddonPurchaseFieldRefs {
    readonly id: FieldRef<"AddonPurchase", 'String'>
    readonly orgId: FieldRef<"AddonPurchase", 'String'>
    readonly sku: FieldRef<"AddonPurchase", 'String'>
    readonly amount: FieldRef<"AddonPurchase", 'Decimal'>
    readonly status: FieldRef<"AddonPurchase", 'String'>
    readonly purchasedAt: FieldRef<"AddonPurchase", 'DateTime'>
    readonly refundedAt: FieldRef<"AddonPurchase", 'DateTime'>
    readonly meta: FieldRef<"AddonPurchase", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AddonPurchase findUnique
   */
  export type AddonPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which AddonPurchase to fetch.
     */
    where: AddonPurchaseWhereUniqueInput
  }

  /**
   * AddonPurchase findUniqueOrThrow
   */
  export type AddonPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which AddonPurchase to fetch.
     */
    where: AddonPurchaseWhereUniqueInput
  }

  /**
   * AddonPurchase findFirst
   */
  export type AddonPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which AddonPurchase to fetch.
     */
    where?: AddonPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddonPurchases to fetch.
     */
    orderBy?: AddonPurchaseOrderByWithRelationInput | AddonPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddonPurchases.
     */
    cursor?: AddonPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddonPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddonPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddonPurchases.
     */
    distinct?: AddonPurchaseScalarFieldEnum | AddonPurchaseScalarFieldEnum[]
  }

  /**
   * AddonPurchase findFirstOrThrow
   */
  export type AddonPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which AddonPurchase to fetch.
     */
    where?: AddonPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddonPurchases to fetch.
     */
    orderBy?: AddonPurchaseOrderByWithRelationInput | AddonPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddonPurchases.
     */
    cursor?: AddonPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddonPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddonPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddonPurchases.
     */
    distinct?: AddonPurchaseScalarFieldEnum | AddonPurchaseScalarFieldEnum[]
  }

  /**
   * AddonPurchase findMany
   */
  export type AddonPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which AddonPurchases to fetch.
     */
    where?: AddonPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddonPurchases to fetch.
     */
    orderBy?: AddonPurchaseOrderByWithRelationInput | AddonPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddonPurchases.
     */
    cursor?: AddonPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddonPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddonPurchases.
     */
    skip?: number
    distinct?: AddonPurchaseScalarFieldEnum | AddonPurchaseScalarFieldEnum[]
  }

  /**
   * AddonPurchase create
   */
  export type AddonPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a AddonPurchase.
     */
    data: XOR<AddonPurchaseCreateInput, AddonPurchaseUncheckedCreateInput>
  }

  /**
   * AddonPurchase createMany
   */
  export type AddonPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddonPurchases.
     */
    data: AddonPurchaseCreateManyInput | AddonPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddonPurchase createManyAndReturn
   */
  export type AddonPurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many AddonPurchases.
     */
    data: AddonPurchaseCreateManyInput | AddonPurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddonPurchase update
   */
  export type AddonPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a AddonPurchase.
     */
    data: XOR<AddonPurchaseUpdateInput, AddonPurchaseUncheckedUpdateInput>
    /**
     * Choose, which AddonPurchase to update.
     */
    where: AddonPurchaseWhereUniqueInput
  }

  /**
   * AddonPurchase updateMany
   */
  export type AddonPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddonPurchases.
     */
    data: XOR<AddonPurchaseUpdateManyMutationInput, AddonPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which AddonPurchases to update
     */
    where?: AddonPurchaseWhereInput
    /**
     * Limit how many AddonPurchases to update.
     */
    limit?: number
  }

  /**
   * AddonPurchase updateManyAndReturn
   */
  export type AddonPurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * The data used to update AddonPurchases.
     */
    data: XOR<AddonPurchaseUpdateManyMutationInput, AddonPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which AddonPurchases to update
     */
    where?: AddonPurchaseWhereInput
    /**
     * Limit how many AddonPurchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddonPurchase upsert
   */
  export type AddonPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the AddonPurchase to update in case it exists.
     */
    where: AddonPurchaseWhereUniqueInput
    /**
     * In case the AddonPurchase found by the `where` argument doesn't exist, create a new AddonPurchase with this data.
     */
    create: XOR<AddonPurchaseCreateInput, AddonPurchaseUncheckedCreateInput>
    /**
     * In case the AddonPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddonPurchaseUpdateInput, AddonPurchaseUncheckedUpdateInput>
  }

  /**
   * AddonPurchase delete
   */
  export type AddonPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
    /**
     * Filter which AddonPurchase to delete.
     */
    where: AddonPurchaseWhereUniqueInput
  }

  /**
   * AddonPurchase deleteMany
   */
  export type AddonPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddonPurchases to delete
     */
    where?: AddonPurchaseWhereInput
    /**
     * Limit how many AddonPurchases to delete.
     */
    limit?: number
  }

  /**
   * AddonPurchase without action
   */
  export type AddonPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonPurchase
     */
    select?: AddonPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddonPurchase
     */
    omit?: AddonPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model FederationKey
   */

  export type AggregateFederationKey = {
    _count: FederationKeyCountAggregateOutputType | null
    _min: FederationKeyMinAggregateOutputType | null
    _max: FederationKeyMaxAggregateOutputType | null
  }

  export type FederationKeyMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    keyId: string | null
    secretHash: string | null
    scope: string | null
    createdAt: Date | null
    disabledAt: Date | null
    rotatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type FederationKeyMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    keyId: string | null
    secretHash: string | null
    scope: string | null
    createdAt: Date | null
    disabledAt: Date | null
    rotatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type FederationKeyCountAggregateOutputType = {
    id: number
    tenantId: number
    keyId: number
    secretHash: number
    scope: number
    createdAt: number
    disabledAt: number
    rotatedAt: number
    lastUsedAt: number
    _all: number
  }


  export type FederationKeyMinAggregateInputType = {
    id?: true
    tenantId?: true
    keyId?: true
    secretHash?: true
    scope?: true
    createdAt?: true
    disabledAt?: true
    rotatedAt?: true
    lastUsedAt?: true
  }

  export type FederationKeyMaxAggregateInputType = {
    id?: true
    tenantId?: true
    keyId?: true
    secretHash?: true
    scope?: true
    createdAt?: true
    disabledAt?: true
    rotatedAt?: true
    lastUsedAt?: true
  }

  export type FederationKeyCountAggregateInputType = {
    id?: true
    tenantId?: true
    keyId?: true
    secretHash?: true
    scope?: true
    createdAt?: true
    disabledAt?: true
    rotatedAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type FederationKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FederationKey to aggregate.
     */
    where?: FederationKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FederationKeys to fetch.
     */
    orderBy?: FederationKeyOrderByWithRelationInput | FederationKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FederationKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FederationKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FederationKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FederationKeys
    **/
    _count?: true | FederationKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FederationKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FederationKeyMaxAggregateInputType
  }

  export type GetFederationKeyAggregateType<T extends FederationKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateFederationKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFederationKey[P]>
      : GetScalarType<T[P], AggregateFederationKey[P]>
  }




  export type FederationKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FederationKeyWhereInput
    orderBy?: FederationKeyOrderByWithAggregationInput | FederationKeyOrderByWithAggregationInput[]
    by: FederationKeyScalarFieldEnum[] | FederationKeyScalarFieldEnum
    having?: FederationKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FederationKeyCountAggregateInputType | true
    _min?: FederationKeyMinAggregateInputType
    _max?: FederationKeyMaxAggregateInputType
  }

  export type FederationKeyGroupByOutputType = {
    id: string
    tenantId: string
    keyId: string
    secretHash: string
    scope: string
    createdAt: Date
    disabledAt: Date | null
    rotatedAt: Date | null
    lastUsedAt: Date | null
    _count: FederationKeyCountAggregateOutputType | null
    _min: FederationKeyMinAggregateOutputType | null
    _max: FederationKeyMaxAggregateOutputType | null
  }

  type GetFederationKeyGroupByPayload<T extends FederationKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FederationKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FederationKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FederationKeyGroupByOutputType[P]>
            : GetScalarType<T[P], FederationKeyGroupByOutputType[P]>
        }
      >
    >


  export type FederationKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    keyId?: boolean
    secretHash?: boolean
    scope?: boolean
    createdAt?: boolean
    disabledAt?: boolean
    rotatedAt?: boolean
    lastUsedAt?: boolean
  }, ExtArgs["result"]["federationKey"]>

  export type FederationKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    keyId?: boolean
    secretHash?: boolean
    scope?: boolean
    createdAt?: boolean
    disabledAt?: boolean
    rotatedAt?: boolean
    lastUsedAt?: boolean
  }, ExtArgs["result"]["federationKey"]>

  export type FederationKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    keyId?: boolean
    secretHash?: boolean
    scope?: boolean
    createdAt?: boolean
    disabledAt?: boolean
    rotatedAt?: boolean
    lastUsedAt?: boolean
  }, ExtArgs["result"]["federationKey"]>

  export type FederationKeySelectScalar = {
    id?: boolean
    tenantId?: boolean
    keyId?: boolean
    secretHash?: boolean
    scope?: boolean
    createdAt?: boolean
    disabledAt?: boolean
    rotatedAt?: boolean
    lastUsedAt?: boolean
  }

  export type FederationKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "keyId" | "secretHash" | "scope" | "createdAt" | "disabledAt" | "rotatedAt" | "lastUsedAt", ExtArgs["result"]["federationKey"]>

  export type $FederationKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FederationKey"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      keyId: string
      secretHash: string
      scope: string
      createdAt: Date
      disabledAt: Date | null
      rotatedAt: Date | null
      lastUsedAt: Date | null
    }, ExtArgs["result"]["federationKey"]>
    composites: {}
  }

  type FederationKeyGetPayload<S extends boolean | null | undefined | FederationKeyDefaultArgs> = $Result.GetResult<Prisma.$FederationKeyPayload, S>

  type FederationKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FederationKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FederationKeyCountAggregateInputType | true
    }

  export interface FederationKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FederationKey'], meta: { name: 'FederationKey' } }
    /**
     * Find zero or one FederationKey that matches the filter.
     * @param {FederationKeyFindUniqueArgs} args - Arguments to find a FederationKey
     * @example
     * // Get one FederationKey
     * const federationKey = await prisma.federationKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FederationKeyFindUniqueArgs>(args: SelectSubset<T, FederationKeyFindUniqueArgs<ExtArgs>>): Prisma__FederationKeyClient<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FederationKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FederationKeyFindUniqueOrThrowArgs} args - Arguments to find a FederationKey
     * @example
     * // Get one FederationKey
     * const federationKey = await prisma.federationKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FederationKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, FederationKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FederationKeyClient<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FederationKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FederationKeyFindFirstArgs} args - Arguments to find a FederationKey
     * @example
     * // Get one FederationKey
     * const federationKey = await prisma.federationKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FederationKeyFindFirstArgs>(args?: SelectSubset<T, FederationKeyFindFirstArgs<ExtArgs>>): Prisma__FederationKeyClient<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FederationKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FederationKeyFindFirstOrThrowArgs} args - Arguments to find a FederationKey
     * @example
     * // Get one FederationKey
     * const federationKey = await prisma.federationKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FederationKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, FederationKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__FederationKeyClient<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FederationKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FederationKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FederationKeys
     * const federationKeys = await prisma.federationKey.findMany()
     * 
     * // Get first 10 FederationKeys
     * const federationKeys = await prisma.federationKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const federationKeyWithIdOnly = await prisma.federationKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FederationKeyFindManyArgs>(args?: SelectSubset<T, FederationKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FederationKey.
     * @param {FederationKeyCreateArgs} args - Arguments to create a FederationKey.
     * @example
     * // Create one FederationKey
     * const FederationKey = await prisma.federationKey.create({
     *   data: {
     *     // ... data to create a FederationKey
     *   }
     * })
     * 
     */
    create<T extends FederationKeyCreateArgs>(args: SelectSubset<T, FederationKeyCreateArgs<ExtArgs>>): Prisma__FederationKeyClient<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FederationKeys.
     * @param {FederationKeyCreateManyArgs} args - Arguments to create many FederationKeys.
     * @example
     * // Create many FederationKeys
     * const federationKey = await prisma.federationKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FederationKeyCreateManyArgs>(args?: SelectSubset<T, FederationKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FederationKeys and returns the data saved in the database.
     * @param {FederationKeyCreateManyAndReturnArgs} args - Arguments to create many FederationKeys.
     * @example
     * // Create many FederationKeys
     * const federationKey = await prisma.federationKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FederationKeys and only return the `id`
     * const federationKeyWithIdOnly = await prisma.federationKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FederationKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, FederationKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FederationKey.
     * @param {FederationKeyDeleteArgs} args - Arguments to delete one FederationKey.
     * @example
     * // Delete one FederationKey
     * const FederationKey = await prisma.federationKey.delete({
     *   where: {
     *     // ... filter to delete one FederationKey
     *   }
     * })
     * 
     */
    delete<T extends FederationKeyDeleteArgs>(args: SelectSubset<T, FederationKeyDeleteArgs<ExtArgs>>): Prisma__FederationKeyClient<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FederationKey.
     * @param {FederationKeyUpdateArgs} args - Arguments to update one FederationKey.
     * @example
     * // Update one FederationKey
     * const federationKey = await prisma.federationKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FederationKeyUpdateArgs>(args: SelectSubset<T, FederationKeyUpdateArgs<ExtArgs>>): Prisma__FederationKeyClient<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FederationKeys.
     * @param {FederationKeyDeleteManyArgs} args - Arguments to filter FederationKeys to delete.
     * @example
     * // Delete a few FederationKeys
     * const { count } = await prisma.federationKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FederationKeyDeleteManyArgs>(args?: SelectSubset<T, FederationKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FederationKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FederationKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FederationKeys
     * const federationKey = await prisma.federationKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FederationKeyUpdateManyArgs>(args: SelectSubset<T, FederationKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FederationKeys and returns the data updated in the database.
     * @param {FederationKeyUpdateManyAndReturnArgs} args - Arguments to update many FederationKeys.
     * @example
     * // Update many FederationKeys
     * const federationKey = await prisma.federationKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FederationKeys and only return the `id`
     * const federationKeyWithIdOnly = await prisma.federationKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FederationKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, FederationKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FederationKey.
     * @param {FederationKeyUpsertArgs} args - Arguments to update or create a FederationKey.
     * @example
     * // Update or create a FederationKey
     * const federationKey = await prisma.federationKey.upsert({
     *   create: {
     *     // ... data to create a FederationKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FederationKey we want to update
     *   }
     * })
     */
    upsert<T extends FederationKeyUpsertArgs>(args: SelectSubset<T, FederationKeyUpsertArgs<ExtArgs>>): Prisma__FederationKeyClient<$Result.GetResult<Prisma.$FederationKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FederationKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FederationKeyCountArgs} args - Arguments to filter FederationKeys to count.
     * @example
     * // Count the number of FederationKeys
     * const count = await prisma.federationKey.count({
     *   where: {
     *     // ... the filter for the FederationKeys we want to count
     *   }
     * })
    **/
    count<T extends FederationKeyCountArgs>(
      args?: Subset<T, FederationKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FederationKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FederationKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FederationKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FederationKeyAggregateArgs>(args: Subset<T, FederationKeyAggregateArgs>): Prisma.PrismaPromise<GetFederationKeyAggregateType<T>>

    /**
     * Group by FederationKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FederationKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FederationKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FederationKeyGroupByArgs['orderBy'] }
        : { orderBy?: FederationKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FederationKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFederationKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FederationKey model
   */
  readonly fields: FederationKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FederationKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FederationKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FederationKey model
   */
  interface FederationKeyFieldRefs {
    readonly id: FieldRef<"FederationKey", 'String'>
    readonly tenantId: FieldRef<"FederationKey", 'String'>
    readonly keyId: FieldRef<"FederationKey", 'String'>
    readonly secretHash: FieldRef<"FederationKey", 'String'>
    readonly scope: FieldRef<"FederationKey", 'String'>
    readonly createdAt: FieldRef<"FederationKey", 'DateTime'>
    readonly disabledAt: FieldRef<"FederationKey", 'DateTime'>
    readonly rotatedAt: FieldRef<"FederationKey", 'DateTime'>
    readonly lastUsedAt: FieldRef<"FederationKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FederationKey findUnique
   */
  export type FederationKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * Filter, which FederationKey to fetch.
     */
    where: FederationKeyWhereUniqueInput
  }

  /**
   * FederationKey findUniqueOrThrow
   */
  export type FederationKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * Filter, which FederationKey to fetch.
     */
    where: FederationKeyWhereUniqueInput
  }

  /**
   * FederationKey findFirst
   */
  export type FederationKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * Filter, which FederationKey to fetch.
     */
    where?: FederationKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FederationKeys to fetch.
     */
    orderBy?: FederationKeyOrderByWithRelationInput | FederationKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FederationKeys.
     */
    cursor?: FederationKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FederationKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FederationKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FederationKeys.
     */
    distinct?: FederationKeyScalarFieldEnum | FederationKeyScalarFieldEnum[]
  }

  /**
   * FederationKey findFirstOrThrow
   */
  export type FederationKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * Filter, which FederationKey to fetch.
     */
    where?: FederationKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FederationKeys to fetch.
     */
    orderBy?: FederationKeyOrderByWithRelationInput | FederationKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FederationKeys.
     */
    cursor?: FederationKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FederationKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FederationKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FederationKeys.
     */
    distinct?: FederationKeyScalarFieldEnum | FederationKeyScalarFieldEnum[]
  }

  /**
   * FederationKey findMany
   */
  export type FederationKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * Filter, which FederationKeys to fetch.
     */
    where?: FederationKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FederationKeys to fetch.
     */
    orderBy?: FederationKeyOrderByWithRelationInput | FederationKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FederationKeys.
     */
    cursor?: FederationKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FederationKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FederationKeys.
     */
    skip?: number
    distinct?: FederationKeyScalarFieldEnum | FederationKeyScalarFieldEnum[]
  }

  /**
   * FederationKey create
   */
  export type FederationKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * The data needed to create a FederationKey.
     */
    data: XOR<FederationKeyCreateInput, FederationKeyUncheckedCreateInput>
  }

  /**
   * FederationKey createMany
   */
  export type FederationKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FederationKeys.
     */
    data: FederationKeyCreateManyInput | FederationKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FederationKey createManyAndReturn
   */
  export type FederationKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * The data used to create many FederationKeys.
     */
    data: FederationKeyCreateManyInput | FederationKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FederationKey update
   */
  export type FederationKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * The data needed to update a FederationKey.
     */
    data: XOR<FederationKeyUpdateInput, FederationKeyUncheckedUpdateInput>
    /**
     * Choose, which FederationKey to update.
     */
    where: FederationKeyWhereUniqueInput
  }

  /**
   * FederationKey updateMany
   */
  export type FederationKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FederationKeys.
     */
    data: XOR<FederationKeyUpdateManyMutationInput, FederationKeyUncheckedUpdateManyInput>
    /**
     * Filter which FederationKeys to update
     */
    where?: FederationKeyWhereInput
    /**
     * Limit how many FederationKeys to update.
     */
    limit?: number
  }

  /**
   * FederationKey updateManyAndReturn
   */
  export type FederationKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * The data used to update FederationKeys.
     */
    data: XOR<FederationKeyUpdateManyMutationInput, FederationKeyUncheckedUpdateManyInput>
    /**
     * Filter which FederationKeys to update
     */
    where?: FederationKeyWhereInput
    /**
     * Limit how many FederationKeys to update.
     */
    limit?: number
  }

  /**
   * FederationKey upsert
   */
  export type FederationKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * The filter to search for the FederationKey to update in case it exists.
     */
    where: FederationKeyWhereUniqueInput
    /**
     * In case the FederationKey found by the `where` argument doesn't exist, create a new FederationKey with this data.
     */
    create: XOR<FederationKeyCreateInput, FederationKeyUncheckedCreateInput>
    /**
     * In case the FederationKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FederationKeyUpdateInput, FederationKeyUncheckedUpdateInput>
  }

  /**
   * FederationKey delete
   */
  export type FederationKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
    /**
     * Filter which FederationKey to delete.
     */
    where: FederationKeyWhereUniqueInput
  }

  /**
   * FederationKey deleteMany
   */
  export type FederationKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FederationKeys to delete
     */
    where?: FederationKeyWhereInput
    /**
     * Limit how many FederationKeys to delete.
     */
    limit?: number
  }

  /**
   * FederationKey without action
   */
  export type FederationKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FederationKey
     */
    select?: FederationKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FederationKey
     */
    omit?: FederationKeyOmit<ExtArgs> | null
  }


  /**
   * Model OIDCConfig
   */

  export type AggregateOIDCConfig = {
    _count: OIDCConfigCountAggregateOutputType | null
    _min: OIDCConfigMinAggregateOutputType | null
    _max: OIDCConfigMaxAggregateOutputType | null
  }

  export type OIDCConfigMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    issuerUrl: string | null
    clientId: string | null
    clientSecret: string | null
    scopes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastTestedAt: Date | null
  }

  export type OIDCConfigMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    issuerUrl: string | null
    clientId: string | null
    clientSecret: string | null
    scopes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastTestedAt: Date | null
  }

  export type OIDCConfigCountAggregateOutputType = {
    id: number
    enabled: number
    issuerUrl: number
    clientId: number
    clientSecret: number
    scopes: number
    createdAt: number
    updatedAt: number
    lastTestedAt: number
    _all: number
  }


  export type OIDCConfigMinAggregateInputType = {
    id?: true
    enabled?: true
    issuerUrl?: true
    clientId?: true
    clientSecret?: true
    scopes?: true
    createdAt?: true
    updatedAt?: true
    lastTestedAt?: true
  }

  export type OIDCConfigMaxAggregateInputType = {
    id?: true
    enabled?: true
    issuerUrl?: true
    clientId?: true
    clientSecret?: true
    scopes?: true
    createdAt?: true
    updatedAt?: true
    lastTestedAt?: true
  }

  export type OIDCConfigCountAggregateInputType = {
    id?: true
    enabled?: true
    issuerUrl?: true
    clientId?: true
    clientSecret?: true
    scopes?: true
    createdAt?: true
    updatedAt?: true
    lastTestedAt?: true
    _all?: true
  }

  export type OIDCConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OIDCConfig to aggregate.
     */
    where?: OIDCConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCConfigs to fetch.
     */
    orderBy?: OIDCConfigOrderByWithRelationInput | OIDCConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OIDCConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OIDCConfigs
    **/
    _count?: true | OIDCConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OIDCConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OIDCConfigMaxAggregateInputType
  }

  export type GetOIDCConfigAggregateType<T extends OIDCConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateOIDCConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOIDCConfig[P]>
      : GetScalarType<T[P], AggregateOIDCConfig[P]>
  }




  export type OIDCConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OIDCConfigWhereInput
    orderBy?: OIDCConfigOrderByWithAggregationInput | OIDCConfigOrderByWithAggregationInput[]
    by: OIDCConfigScalarFieldEnum[] | OIDCConfigScalarFieldEnum
    having?: OIDCConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OIDCConfigCountAggregateInputType | true
    _min?: OIDCConfigMinAggregateInputType
    _max?: OIDCConfigMaxAggregateInputType
  }

  export type OIDCConfigGroupByOutputType = {
    id: string
    enabled: boolean
    issuerUrl: string
    clientId: string
    clientSecret: string
    scopes: string
    createdAt: Date
    updatedAt: Date
    lastTestedAt: Date | null
    _count: OIDCConfigCountAggregateOutputType | null
    _min: OIDCConfigMinAggregateOutputType | null
    _max: OIDCConfigMaxAggregateOutputType | null
  }

  type GetOIDCConfigGroupByPayload<T extends OIDCConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OIDCConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OIDCConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OIDCConfigGroupByOutputType[P]>
            : GetScalarType<T[P], OIDCConfigGroupByOutputType[P]>
        }
      >
    >


  export type OIDCConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    issuerUrl?: boolean
    clientId?: boolean
    clientSecret?: boolean
    scopes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastTestedAt?: boolean
  }, ExtArgs["result"]["oIDCConfig"]>

  export type OIDCConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    issuerUrl?: boolean
    clientId?: boolean
    clientSecret?: boolean
    scopes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastTestedAt?: boolean
  }, ExtArgs["result"]["oIDCConfig"]>

  export type OIDCConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    issuerUrl?: boolean
    clientId?: boolean
    clientSecret?: boolean
    scopes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastTestedAt?: boolean
  }, ExtArgs["result"]["oIDCConfig"]>

  export type OIDCConfigSelectScalar = {
    id?: boolean
    enabled?: boolean
    issuerUrl?: boolean
    clientId?: boolean
    clientSecret?: boolean
    scopes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastTestedAt?: boolean
  }

  export type OIDCConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "issuerUrl" | "clientId" | "clientSecret" | "scopes" | "createdAt" | "updatedAt" | "lastTestedAt", ExtArgs["result"]["oIDCConfig"]>

  export type $OIDCConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OIDCConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      issuerUrl: string
      clientId: string
      clientSecret: string
      scopes: string
      createdAt: Date
      updatedAt: Date
      lastTestedAt: Date | null
    }, ExtArgs["result"]["oIDCConfig"]>
    composites: {}
  }

  type OIDCConfigGetPayload<S extends boolean | null | undefined | OIDCConfigDefaultArgs> = $Result.GetResult<Prisma.$OIDCConfigPayload, S>

  type OIDCConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OIDCConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OIDCConfigCountAggregateInputType | true
    }

  export interface OIDCConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OIDCConfig'], meta: { name: 'OIDCConfig' } }
    /**
     * Find zero or one OIDCConfig that matches the filter.
     * @param {OIDCConfigFindUniqueArgs} args - Arguments to find a OIDCConfig
     * @example
     * // Get one OIDCConfig
     * const oIDCConfig = await prisma.oIDCConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OIDCConfigFindUniqueArgs>(args: SelectSubset<T, OIDCConfigFindUniqueArgs<ExtArgs>>): Prisma__OIDCConfigClient<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OIDCConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OIDCConfigFindUniqueOrThrowArgs} args - Arguments to find a OIDCConfig
     * @example
     * // Get one OIDCConfig
     * const oIDCConfig = await prisma.oIDCConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OIDCConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, OIDCConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OIDCConfigClient<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OIDCConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCConfigFindFirstArgs} args - Arguments to find a OIDCConfig
     * @example
     * // Get one OIDCConfig
     * const oIDCConfig = await prisma.oIDCConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OIDCConfigFindFirstArgs>(args?: SelectSubset<T, OIDCConfigFindFirstArgs<ExtArgs>>): Prisma__OIDCConfigClient<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OIDCConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCConfigFindFirstOrThrowArgs} args - Arguments to find a OIDCConfig
     * @example
     * // Get one OIDCConfig
     * const oIDCConfig = await prisma.oIDCConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OIDCConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, OIDCConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__OIDCConfigClient<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OIDCConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OIDCConfigs
     * const oIDCConfigs = await prisma.oIDCConfig.findMany()
     * 
     * // Get first 10 OIDCConfigs
     * const oIDCConfigs = await prisma.oIDCConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oIDCConfigWithIdOnly = await prisma.oIDCConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OIDCConfigFindManyArgs>(args?: SelectSubset<T, OIDCConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OIDCConfig.
     * @param {OIDCConfigCreateArgs} args - Arguments to create a OIDCConfig.
     * @example
     * // Create one OIDCConfig
     * const OIDCConfig = await prisma.oIDCConfig.create({
     *   data: {
     *     // ... data to create a OIDCConfig
     *   }
     * })
     * 
     */
    create<T extends OIDCConfigCreateArgs>(args: SelectSubset<T, OIDCConfigCreateArgs<ExtArgs>>): Prisma__OIDCConfigClient<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OIDCConfigs.
     * @param {OIDCConfigCreateManyArgs} args - Arguments to create many OIDCConfigs.
     * @example
     * // Create many OIDCConfigs
     * const oIDCConfig = await prisma.oIDCConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OIDCConfigCreateManyArgs>(args?: SelectSubset<T, OIDCConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OIDCConfigs and returns the data saved in the database.
     * @param {OIDCConfigCreateManyAndReturnArgs} args - Arguments to create many OIDCConfigs.
     * @example
     * // Create many OIDCConfigs
     * const oIDCConfig = await prisma.oIDCConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OIDCConfigs and only return the `id`
     * const oIDCConfigWithIdOnly = await prisma.oIDCConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OIDCConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, OIDCConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OIDCConfig.
     * @param {OIDCConfigDeleteArgs} args - Arguments to delete one OIDCConfig.
     * @example
     * // Delete one OIDCConfig
     * const OIDCConfig = await prisma.oIDCConfig.delete({
     *   where: {
     *     // ... filter to delete one OIDCConfig
     *   }
     * })
     * 
     */
    delete<T extends OIDCConfigDeleteArgs>(args: SelectSubset<T, OIDCConfigDeleteArgs<ExtArgs>>): Prisma__OIDCConfigClient<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OIDCConfig.
     * @param {OIDCConfigUpdateArgs} args - Arguments to update one OIDCConfig.
     * @example
     * // Update one OIDCConfig
     * const oIDCConfig = await prisma.oIDCConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OIDCConfigUpdateArgs>(args: SelectSubset<T, OIDCConfigUpdateArgs<ExtArgs>>): Prisma__OIDCConfigClient<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OIDCConfigs.
     * @param {OIDCConfigDeleteManyArgs} args - Arguments to filter OIDCConfigs to delete.
     * @example
     * // Delete a few OIDCConfigs
     * const { count } = await prisma.oIDCConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OIDCConfigDeleteManyArgs>(args?: SelectSubset<T, OIDCConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OIDCConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OIDCConfigs
     * const oIDCConfig = await prisma.oIDCConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OIDCConfigUpdateManyArgs>(args: SelectSubset<T, OIDCConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OIDCConfigs and returns the data updated in the database.
     * @param {OIDCConfigUpdateManyAndReturnArgs} args - Arguments to update many OIDCConfigs.
     * @example
     * // Update many OIDCConfigs
     * const oIDCConfig = await prisma.oIDCConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OIDCConfigs and only return the `id`
     * const oIDCConfigWithIdOnly = await prisma.oIDCConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OIDCConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, OIDCConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OIDCConfig.
     * @param {OIDCConfigUpsertArgs} args - Arguments to update or create a OIDCConfig.
     * @example
     * // Update or create a OIDCConfig
     * const oIDCConfig = await prisma.oIDCConfig.upsert({
     *   create: {
     *     // ... data to create a OIDCConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OIDCConfig we want to update
     *   }
     * })
     */
    upsert<T extends OIDCConfigUpsertArgs>(args: SelectSubset<T, OIDCConfigUpsertArgs<ExtArgs>>): Prisma__OIDCConfigClient<$Result.GetResult<Prisma.$OIDCConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OIDCConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCConfigCountArgs} args - Arguments to filter OIDCConfigs to count.
     * @example
     * // Count the number of OIDCConfigs
     * const count = await prisma.oIDCConfig.count({
     *   where: {
     *     // ... the filter for the OIDCConfigs we want to count
     *   }
     * })
    **/
    count<T extends OIDCConfigCountArgs>(
      args?: Subset<T, OIDCConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OIDCConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OIDCConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OIDCConfigAggregateArgs>(args: Subset<T, OIDCConfigAggregateArgs>): Prisma.PrismaPromise<GetOIDCConfigAggregateType<T>>

    /**
     * Group by OIDCConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OIDCConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OIDCConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OIDCConfigGroupByArgs['orderBy'] }
        : { orderBy?: OIDCConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OIDCConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOIDCConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OIDCConfig model
   */
  readonly fields: OIDCConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OIDCConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OIDCConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OIDCConfig model
   */
  interface OIDCConfigFieldRefs {
    readonly id: FieldRef<"OIDCConfig", 'String'>
    readonly enabled: FieldRef<"OIDCConfig", 'Boolean'>
    readonly issuerUrl: FieldRef<"OIDCConfig", 'String'>
    readonly clientId: FieldRef<"OIDCConfig", 'String'>
    readonly clientSecret: FieldRef<"OIDCConfig", 'String'>
    readonly scopes: FieldRef<"OIDCConfig", 'String'>
    readonly createdAt: FieldRef<"OIDCConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"OIDCConfig", 'DateTime'>
    readonly lastTestedAt: FieldRef<"OIDCConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OIDCConfig findUnique
   */
  export type OIDCConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * Filter, which OIDCConfig to fetch.
     */
    where: OIDCConfigWhereUniqueInput
  }

  /**
   * OIDCConfig findUniqueOrThrow
   */
  export type OIDCConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * Filter, which OIDCConfig to fetch.
     */
    where: OIDCConfigWhereUniqueInput
  }

  /**
   * OIDCConfig findFirst
   */
  export type OIDCConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * Filter, which OIDCConfig to fetch.
     */
    where?: OIDCConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCConfigs to fetch.
     */
    orderBy?: OIDCConfigOrderByWithRelationInput | OIDCConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OIDCConfigs.
     */
    cursor?: OIDCConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OIDCConfigs.
     */
    distinct?: OIDCConfigScalarFieldEnum | OIDCConfigScalarFieldEnum[]
  }

  /**
   * OIDCConfig findFirstOrThrow
   */
  export type OIDCConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * Filter, which OIDCConfig to fetch.
     */
    where?: OIDCConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCConfigs to fetch.
     */
    orderBy?: OIDCConfigOrderByWithRelationInput | OIDCConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OIDCConfigs.
     */
    cursor?: OIDCConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OIDCConfigs.
     */
    distinct?: OIDCConfigScalarFieldEnum | OIDCConfigScalarFieldEnum[]
  }

  /**
   * OIDCConfig findMany
   */
  export type OIDCConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * Filter, which OIDCConfigs to fetch.
     */
    where?: OIDCConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OIDCConfigs to fetch.
     */
    orderBy?: OIDCConfigOrderByWithRelationInput | OIDCConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OIDCConfigs.
     */
    cursor?: OIDCConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OIDCConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OIDCConfigs.
     */
    skip?: number
    distinct?: OIDCConfigScalarFieldEnum | OIDCConfigScalarFieldEnum[]
  }

  /**
   * OIDCConfig create
   */
  export type OIDCConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a OIDCConfig.
     */
    data: XOR<OIDCConfigCreateInput, OIDCConfigUncheckedCreateInput>
  }

  /**
   * OIDCConfig createMany
   */
  export type OIDCConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OIDCConfigs.
     */
    data: OIDCConfigCreateManyInput | OIDCConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OIDCConfig createManyAndReturn
   */
  export type OIDCConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * The data used to create many OIDCConfigs.
     */
    data: OIDCConfigCreateManyInput | OIDCConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OIDCConfig update
   */
  export type OIDCConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a OIDCConfig.
     */
    data: XOR<OIDCConfigUpdateInput, OIDCConfigUncheckedUpdateInput>
    /**
     * Choose, which OIDCConfig to update.
     */
    where: OIDCConfigWhereUniqueInput
  }

  /**
   * OIDCConfig updateMany
   */
  export type OIDCConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OIDCConfigs.
     */
    data: XOR<OIDCConfigUpdateManyMutationInput, OIDCConfigUncheckedUpdateManyInput>
    /**
     * Filter which OIDCConfigs to update
     */
    where?: OIDCConfigWhereInput
    /**
     * Limit how many OIDCConfigs to update.
     */
    limit?: number
  }

  /**
   * OIDCConfig updateManyAndReturn
   */
  export type OIDCConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * The data used to update OIDCConfigs.
     */
    data: XOR<OIDCConfigUpdateManyMutationInput, OIDCConfigUncheckedUpdateManyInput>
    /**
     * Filter which OIDCConfigs to update
     */
    where?: OIDCConfigWhereInput
    /**
     * Limit how many OIDCConfigs to update.
     */
    limit?: number
  }

  /**
   * OIDCConfig upsert
   */
  export type OIDCConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the OIDCConfig to update in case it exists.
     */
    where: OIDCConfigWhereUniqueInput
    /**
     * In case the OIDCConfig found by the `where` argument doesn't exist, create a new OIDCConfig with this data.
     */
    create: XOR<OIDCConfigCreateInput, OIDCConfigUncheckedCreateInput>
    /**
     * In case the OIDCConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OIDCConfigUpdateInput, OIDCConfigUncheckedUpdateInput>
  }

  /**
   * OIDCConfig delete
   */
  export type OIDCConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
    /**
     * Filter which OIDCConfig to delete.
     */
    where: OIDCConfigWhereUniqueInput
  }

  /**
   * OIDCConfig deleteMany
   */
  export type OIDCConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OIDCConfigs to delete
     */
    where?: OIDCConfigWhereInput
    /**
     * Limit how many OIDCConfigs to delete.
     */
    limit?: number
  }

  /**
   * OIDCConfig without action
   */
  export type OIDCConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OIDCConfig
     */
    select?: OIDCConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OIDCConfig
     */
    omit?: OIDCConfigOmit<ExtArgs> | null
  }


  /**
   * Model ProviderIntegration
   */

  export type AggregateProviderIntegration = {
    _count: ProviderIntegrationCountAggregateOutputType | null
    _min: ProviderIntegrationMinAggregateOutputType | null
    _max: ProviderIntegrationMaxAggregateOutputType | null
  }

  export type ProviderIntegrationMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSyncAt: Date | null
  }

  export type ProviderIntegrationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSyncAt: Date | null
  }

  export type ProviderIntegrationCountAggregateOutputType = {
    id: number
    name: number
    type: number
    config: number
    enabled: number
    createdAt: number
    updatedAt: number
    lastSyncAt: number
    _all: number
  }


  export type ProviderIntegrationMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    lastSyncAt?: true
  }

  export type ProviderIntegrationMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    lastSyncAt?: true
  }

  export type ProviderIntegrationCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    config?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    lastSyncAt?: true
    _all?: true
  }

  export type ProviderIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderIntegration to aggregate.
     */
    where?: ProviderIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderIntegrations to fetch.
     */
    orderBy?: ProviderIntegrationOrderByWithRelationInput | ProviderIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderIntegrations
    **/
    _count?: true | ProviderIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderIntegrationMaxAggregateInputType
  }

  export type GetProviderIntegrationAggregateType<T extends ProviderIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderIntegration[P]>
      : GetScalarType<T[P], AggregateProviderIntegration[P]>
  }




  export type ProviderIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderIntegrationWhereInput
    orderBy?: ProviderIntegrationOrderByWithAggregationInput | ProviderIntegrationOrderByWithAggregationInput[]
    by: ProviderIntegrationScalarFieldEnum[] | ProviderIntegrationScalarFieldEnum
    having?: ProviderIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderIntegrationCountAggregateInputType | true
    _min?: ProviderIntegrationMinAggregateInputType
    _max?: ProviderIntegrationMaxAggregateInputType
  }

  export type ProviderIntegrationGroupByOutputType = {
    id: string
    name: string
    type: string
    config: JsonValue
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    lastSyncAt: Date | null
    _count: ProviderIntegrationCountAggregateOutputType | null
    _min: ProviderIntegrationMinAggregateOutputType | null
    _max: ProviderIntegrationMaxAggregateOutputType | null
  }

  type GetProviderIntegrationGroupByPayload<T extends ProviderIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type ProviderIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncAt?: boolean
  }, ExtArgs["result"]["providerIntegration"]>

  export type ProviderIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncAt?: boolean
  }, ExtArgs["result"]["providerIntegration"]>

  export type ProviderIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncAt?: boolean
  }, ExtArgs["result"]["providerIntegration"]>

  export type ProviderIntegrationSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncAt?: boolean
  }

  export type ProviderIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "config" | "enabled" | "createdAt" | "updatedAt" | "lastSyncAt", ExtArgs["result"]["providerIntegration"]>

  export type $ProviderIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderIntegration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      config: Prisma.JsonValue
      enabled: boolean
      createdAt: Date
      updatedAt: Date
      lastSyncAt: Date | null
    }, ExtArgs["result"]["providerIntegration"]>
    composites: {}
  }

  type ProviderIntegrationGetPayload<S extends boolean | null | undefined | ProviderIntegrationDefaultArgs> = $Result.GetResult<Prisma.$ProviderIntegrationPayload, S>

  type ProviderIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderIntegrationCountAggregateInputType | true
    }

  export interface ProviderIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderIntegration'], meta: { name: 'ProviderIntegration' } }
    /**
     * Find zero or one ProviderIntegration that matches the filter.
     * @param {ProviderIntegrationFindUniqueArgs} args - Arguments to find a ProviderIntegration
     * @example
     * // Get one ProviderIntegration
     * const providerIntegration = await prisma.providerIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderIntegrationFindUniqueArgs>(args: SelectSubset<T, ProviderIntegrationFindUniqueArgs<ExtArgs>>): Prisma__ProviderIntegrationClient<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProviderIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderIntegrationFindUniqueOrThrowArgs} args - Arguments to find a ProviderIntegration
     * @example
     * // Get one ProviderIntegration
     * const providerIntegration = await prisma.providerIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderIntegrationClient<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderIntegrationFindFirstArgs} args - Arguments to find a ProviderIntegration
     * @example
     * // Get one ProviderIntegration
     * const providerIntegration = await prisma.providerIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderIntegrationFindFirstArgs>(args?: SelectSubset<T, ProviderIntegrationFindFirstArgs<ExtArgs>>): Prisma__ProviderIntegrationClient<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderIntegrationFindFirstOrThrowArgs} args - Arguments to find a ProviderIntegration
     * @example
     * // Get one ProviderIntegration
     * const providerIntegration = await prisma.providerIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderIntegrationClient<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProviderIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderIntegrations
     * const providerIntegrations = await prisma.providerIntegration.findMany()
     * 
     * // Get first 10 ProviderIntegrations
     * const providerIntegrations = await prisma.providerIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerIntegrationWithIdOnly = await prisma.providerIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderIntegrationFindManyArgs>(args?: SelectSubset<T, ProviderIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProviderIntegration.
     * @param {ProviderIntegrationCreateArgs} args - Arguments to create a ProviderIntegration.
     * @example
     * // Create one ProviderIntegration
     * const ProviderIntegration = await prisma.providerIntegration.create({
     *   data: {
     *     // ... data to create a ProviderIntegration
     *   }
     * })
     * 
     */
    create<T extends ProviderIntegrationCreateArgs>(args: SelectSubset<T, ProviderIntegrationCreateArgs<ExtArgs>>): Prisma__ProviderIntegrationClient<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProviderIntegrations.
     * @param {ProviderIntegrationCreateManyArgs} args - Arguments to create many ProviderIntegrations.
     * @example
     * // Create many ProviderIntegrations
     * const providerIntegration = await prisma.providerIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderIntegrationCreateManyArgs>(args?: SelectSubset<T, ProviderIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProviderIntegrations and returns the data saved in the database.
     * @param {ProviderIntegrationCreateManyAndReturnArgs} args - Arguments to create many ProviderIntegrations.
     * @example
     * // Create many ProviderIntegrations
     * const providerIntegration = await prisma.providerIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProviderIntegrations and only return the `id`
     * const providerIntegrationWithIdOnly = await prisma.providerIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProviderIntegration.
     * @param {ProviderIntegrationDeleteArgs} args - Arguments to delete one ProviderIntegration.
     * @example
     * // Delete one ProviderIntegration
     * const ProviderIntegration = await prisma.providerIntegration.delete({
     *   where: {
     *     // ... filter to delete one ProviderIntegration
     *   }
     * })
     * 
     */
    delete<T extends ProviderIntegrationDeleteArgs>(args: SelectSubset<T, ProviderIntegrationDeleteArgs<ExtArgs>>): Prisma__ProviderIntegrationClient<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProviderIntegration.
     * @param {ProviderIntegrationUpdateArgs} args - Arguments to update one ProviderIntegration.
     * @example
     * // Update one ProviderIntegration
     * const providerIntegration = await prisma.providerIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderIntegrationUpdateArgs>(args: SelectSubset<T, ProviderIntegrationUpdateArgs<ExtArgs>>): Prisma__ProviderIntegrationClient<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProviderIntegrations.
     * @param {ProviderIntegrationDeleteManyArgs} args - Arguments to filter ProviderIntegrations to delete.
     * @example
     * // Delete a few ProviderIntegrations
     * const { count } = await prisma.providerIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderIntegrationDeleteManyArgs>(args?: SelectSubset<T, ProviderIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderIntegrations
     * const providerIntegration = await prisma.providerIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderIntegrationUpdateManyArgs>(args: SelectSubset<T, ProviderIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderIntegrations and returns the data updated in the database.
     * @param {ProviderIntegrationUpdateManyAndReturnArgs} args - Arguments to update many ProviderIntegrations.
     * @example
     * // Update many ProviderIntegrations
     * const providerIntegration = await prisma.providerIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProviderIntegrations and only return the `id`
     * const providerIntegrationWithIdOnly = await prisma.providerIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProviderIntegration.
     * @param {ProviderIntegrationUpsertArgs} args - Arguments to update or create a ProviderIntegration.
     * @example
     * // Update or create a ProviderIntegration
     * const providerIntegration = await prisma.providerIntegration.upsert({
     *   create: {
     *     // ... data to create a ProviderIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderIntegration we want to update
     *   }
     * })
     */
    upsert<T extends ProviderIntegrationUpsertArgs>(args: SelectSubset<T, ProviderIntegrationUpsertArgs<ExtArgs>>): Prisma__ProviderIntegrationClient<$Result.GetResult<Prisma.$ProviderIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProviderIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderIntegrationCountArgs} args - Arguments to filter ProviderIntegrations to count.
     * @example
     * // Count the number of ProviderIntegrations
     * const count = await prisma.providerIntegration.count({
     *   where: {
     *     // ... the filter for the ProviderIntegrations we want to count
     *   }
     * })
    **/
    count<T extends ProviderIntegrationCountArgs>(
      args?: Subset<T, ProviderIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderIntegrationAggregateArgs>(args: Subset<T, ProviderIntegrationAggregateArgs>): Prisma.PrismaPromise<GetProviderIntegrationAggregateType<T>>

    /**
     * Group by ProviderIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: ProviderIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderIntegration model
   */
  readonly fields: ProviderIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProviderIntegration model
   */
  interface ProviderIntegrationFieldRefs {
    readonly id: FieldRef<"ProviderIntegration", 'String'>
    readonly name: FieldRef<"ProviderIntegration", 'String'>
    readonly type: FieldRef<"ProviderIntegration", 'String'>
    readonly config: FieldRef<"ProviderIntegration", 'Json'>
    readonly enabled: FieldRef<"ProviderIntegration", 'Boolean'>
    readonly createdAt: FieldRef<"ProviderIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"ProviderIntegration", 'DateTime'>
    readonly lastSyncAt: FieldRef<"ProviderIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProviderIntegration findUnique
   */
  export type ProviderIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which ProviderIntegration to fetch.
     */
    where: ProviderIntegrationWhereUniqueInput
  }

  /**
   * ProviderIntegration findUniqueOrThrow
   */
  export type ProviderIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which ProviderIntegration to fetch.
     */
    where: ProviderIntegrationWhereUniqueInput
  }

  /**
   * ProviderIntegration findFirst
   */
  export type ProviderIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which ProviderIntegration to fetch.
     */
    where?: ProviderIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderIntegrations to fetch.
     */
    orderBy?: ProviderIntegrationOrderByWithRelationInput | ProviderIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderIntegrations.
     */
    cursor?: ProviderIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderIntegrations.
     */
    distinct?: ProviderIntegrationScalarFieldEnum | ProviderIntegrationScalarFieldEnum[]
  }

  /**
   * ProviderIntegration findFirstOrThrow
   */
  export type ProviderIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which ProviderIntegration to fetch.
     */
    where?: ProviderIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderIntegrations to fetch.
     */
    orderBy?: ProviderIntegrationOrderByWithRelationInput | ProviderIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderIntegrations.
     */
    cursor?: ProviderIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderIntegrations.
     */
    distinct?: ProviderIntegrationScalarFieldEnum | ProviderIntegrationScalarFieldEnum[]
  }

  /**
   * ProviderIntegration findMany
   */
  export type ProviderIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which ProviderIntegrations to fetch.
     */
    where?: ProviderIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderIntegrations to fetch.
     */
    orderBy?: ProviderIntegrationOrderByWithRelationInput | ProviderIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderIntegrations.
     */
    cursor?: ProviderIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderIntegrations.
     */
    skip?: number
    distinct?: ProviderIntegrationScalarFieldEnum | ProviderIntegrationScalarFieldEnum[]
  }

  /**
   * ProviderIntegration create
   */
  export type ProviderIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to create a ProviderIntegration.
     */
    data: XOR<ProviderIntegrationCreateInput, ProviderIntegrationUncheckedCreateInput>
  }

  /**
   * ProviderIntegration createMany
   */
  export type ProviderIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderIntegrations.
     */
    data: ProviderIntegrationCreateManyInput | ProviderIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProviderIntegration createManyAndReturn
   */
  export type ProviderIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many ProviderIntegrations.
     */
    data: ProviderIntegrationCreateManyInput | ProviderIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProviderIntegration update
   */
  export type ProviderIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to update a ProviderIntegration.
     */
    data: XOR<ProviderIntegrationUpdateInput, ProviderIntegrationUncheckedUpdateInput>
    /**
     * Choose, which ProviderIntegration to update.
     */
    where: ProviderIntegrationWhereUniqueInput
  }

  /**
   * ProviderIntegration updateMany
   */
  export type ProviderIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderIntegrations.
     */
    data: XOR<ProviderIntegrationUpdateManyMutationInput, ProviderIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which ProviderIntegrations to update
     */
    where?: ProviderIntegrationWhereInput
    /**
     * Limit how many ProviderIntegrations to update.
     */
    limit?: number
  }

  /**
   * ProviderIntegration updateManyAndReturn
   */
  export type ProviderIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update ProviderIntegrations.
     */
    data: XOR<ProviderIntegrationUpdateManyMutationInput, ProviderIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which ProviderIntegrations to update
     */
    where?: ProviderIntegrationWhereInput
    /**
     * Limit how many ProviderIntegrations to update.
     */
    limit?: number
  }

  /**
   * ProviderIntegration upsert
   */
  export type ProviderIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * The filter to search for the ProviderIntegration to update in case it exists.
     */
    where: ProviderIntegrationWhereUniqueInput
    /**
     * In case the ProviderIntegration found by the `where` argument doesn't exist, create a new ProviderIntegration with this data.
     */
    create: XOR<ProviderIntegrationCreateInput, ProviderIntegrationUncheckedCreateInput>
    /**
     * In case the ProviderIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderIntegrationUpdateInput, ProviderIntegrationUncheckedUpdateInput>
  }

  /**
   * ProviderIntegration delete
   */
  export type ProviderIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
    /**
     * Filter which ProviderIntegration to delete.
     */
    where: ProviderIntegrationWhereUniqueInput
  }

  /**
   * ProviderIntegration deleteMany
   */
  export type ProviderIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderIntegrations to delete
     */
    where?: ProviderIntegrationWhereInput
    /**
     * Limit how many ProviderIntegrations to delete.
     */
    limit?: number
  }

  /**
   * ProviderIntegration without action
   */
  export type ProviderIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderIntegration
     */
    select?: ProviderIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderIntegration
     */
    omit?: ProviderIntegrationOmit<ExtArgs> | null
  }


  /**
   * Model AuditEvent
   */

  export type AggregateAuditEvent = {
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  export type AuditEventMinAggregateOutputType = {
    id: string | null
    actorType: string | null
    actorId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditEventMaxAggregateOutputType = {
    id: string | null
    actorType: string | null
    actorId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditEventCountAggregateOutputType = {
    id: number
    actorType: number
    actorId: number
    action: number
    entityType: number
    entityId: number
    metadata: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditEventMinAggregateInputType = {
    id?: true
    actorType?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditEventMaxAggregateInputType = {
    id?: true
    actorType?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditEventCountAggregateInputType = {
    id?: true
    actorType?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvent to aggregate.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditEvents
    **/
    _count?: true | AuditEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditEventMaxAggregateInputType
  }

  export type GetAuditEventAggregateType<T extends AuditEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditEvent[P]>
      : GetScalarType<T[P], AggregateAuditEvent[P]>
  }




  export type AuditEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithAggregationInput | AuditEventOrderByWithAggregationInput[]
    by: AuditEventScalarFieldEnum[] | AuditEventScalarFieldEnum
    having?: AuditEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditEventCountAggregateInputType | true
    _min?: AuditEventMinAggregateInputType
    _max?: AuditEventMaxAggregateInputType
  }

  export type AuditEventGroupByOutputType = {
    id: string
    actorType: string
    actorId: string | null
    action: string
    entityType: string
    entityId: string | null
    metadata: JsonValue
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  type GetAuditEventGroupByPayload<T extends AuditEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
            : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
        }
      >
    >


  export type AuditEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorType?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorType?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorType?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectScalar = {
    id?: boolean
    actorType?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorType" | "actorId" | "action" | "entityType" | "entityId" | "metadata" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditEvent"]>

  export type $AuditEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorType: string
      actorId: string | null
      action: string
      entityType: string
      entityId: string | null
      metadata: Prisma.JsonValue
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditEvent"]>
    composites: {}
  }

  type AuditEventGetPayload<S extends boolean | null | undefined | AuditEventDefaultArgs> = $Result.GetResult<Prisma.$AuditEventPayload, S>

  type AuditEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditEventCountAggregateInputType | true
    }

  export interface AuditEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditEvent'], meta: { name: 'AuditEvent' } }
    /**
     * Find zero or one AuditEvent that matches the filter.
     * @param {AuditEventFindUniqueArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditEventFindUniqueArgs>(args: SelectSubset<T, AuditEventFindUniqueArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditEventFindUniqueOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditEventFindFirstArgs>(args?: SelectSubset<T, AuditEventFindFirstArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany()
     * 
     * // Get first 10 AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditEventFindManyArgs>(args?: SelectSubset<T, AuditEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditEvent.
     * @param {AuditEventCreateArgs} args - Arguments to create a AuditEvent.
     * @example
     * // Create one AuditEvent
     * const AuditEvent = await prisma.auditEvent.create({
     *   data: {
     *     // ... data to create a AuditEvent
     *   }
     * })
     * 
     */
    create<T extends AuditEventCreateArgs>(args: SelectSubset<T, AuditEventCreateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditEvents.
     * @param {AuditEventCreateManyArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditEventCreateManyArgs>(args?: SelectSubset<T, AuditEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditEvents and returns the data saved in the database.
     * @param {AuditEventCreateManyAndReturnArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditEvents and only return the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditEvent.
     * @param {AuditEventDeleteArgs} args - Arguments to delete one AuditEvent.
     * @example
     * // Delete one AuditEvent
     * const AuditEvent = await prisma.auditEvent.delete({
     *   where: {
     *     // ... filter to delete one AuditEvent
     *   }
     * })
     * 
     */
    delete<T extends AuditEventDeleteArgs>(args: SelectSubset<T, AuditEventDeleteArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditEvent.
     * @param {AuditEventUpdateArgs} args - Arguments to update one AuditEvent.
     * @example
     * // Update one AuditEvent
     * const auditEvent = await prisma.auditEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditEventUpdateArgs>(args: SelectSubset<T, AuditEventUpdateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditEvents.
     * @param {AuditEventDeleteManyArgs} args - Arguments to filter AuditEvents to delete.
     * @example
     * // Delete a few AuditEvents
     * const { count } = await prisma.auditEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditEventDeleteManyArgs>(args?: SelectSubset<T, AuditEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditEvents
     * const auditEvent = await prisma.auditEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditEventUpdateManyArgs>(args: SelectSubset<T, AuditEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEvents and returns the data updated in the database.
     * @param {AuditEventUpdateManyAndReturnArgs} args - Arguments to update many AuditEvents.
     * @example
     * // Update many AuditEvents
     * const auditEvent = await prisma.auditEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditEvents and only return the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditEvent.
     * @param {AuditEventUpsertArgs} args - Arguments to update or create a AuditEvent.
     * @example
     * // Update or create a AuditEvent
     * const auditEvent = await prisma.auditEvent.upsert({
     *   create: {
     *     // ... data to create a AuditEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditEvent we want to update
     *   }
     * })
     */
    upsert<T extends AuditEventUpsertArgs>(args: SelectSubset<T, AuditEventUpsertArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventCountArgs} args - Arguments to filter AuditEvents to count.
     * @example
     * // Count the number of AuditEvents
     * const count = await prisma.auditEvent.count({
     *   where: {
     *     // ... the filter for the AuditEvents we want to count
     *   }
     * })
    **/
    count<T extends AuditEventCountArgs>(
      args?: Subset<T, AuditEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditEventAggregateArgs>(args: Subset<T, AuditEventAggregateArgs>): Prisma.PrismaPromise<GetAuditEventAggregateType<T>>

    /**
     * Group by AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditEventGroupByArgs['orderBy'] }
        : { orderBy?: AuditEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditEvent model
   */
  readonly fields: AuditEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditEvent model
   */
  interface AuditEventFieldRefs {
    readonly id: FieldRef<"AuditEvent", 'String'>
    readonly actorType: FieldRef<"AuditEvent", 'String'>
    readonly actorId: FieldRef<"AuditEvent", 'String'>
    readonly action: FieldRef<"AuditEvent", 'String'>
    readonly entityType: FieldRef<"AuditEvent", 'String'>
    readonly entityId: FieldRef<"AuditEvent", 'String'>
    readonly metadata: FieldRef<"AuditEvent", 'Json'>
    readonly ipAddress: FieldRef<"AuditEvent", 'String'>
    readonly userAgent: FieldRef<"AuditEvent", 'String'>
    readonly createdAt: FieldRef<"AuditEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditEvent findUnique
   */
  export type AuditEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findUniqueOrThrow
   */
  export type AuditEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findFirst
   */
  export type AuditEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findFirstOrThrow
   */
  export type AuditEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findMany
   */
  export type AuditEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Filter, which AuditEvents to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent create
   */
  export type AuditEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditEvent.
     */
    data: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
  }

  /**
   * AuditEvent createMany
   */
  export type AuditEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditEvent createManyAndReturn
   */
  export type AuditEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditEvent update
   */
  export type AuditEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditEvent.
     */
    data: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
    /**
     * Choose, which AuditEvent to update.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent updateMany
   */
  export type AuditEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditEvents.
     */
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AuditEvents to update
     */
    where?: AuditEventWhereInput
    /**
     * Limit how many AuditEvents to update.
     */
    limit?: number
  }

  /**
   * AuditEvent updateManyAndReturn
   */
  export type AuditEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * The data used to update AuditEvents.
     */
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AuditEvents to update
     */
    where?: AuditEventWhereInput
    /**
     * Limit how many AuditEvents to update.
     */
    limit?: number
  }

  /**
   * AuditEvent upsert
   */
  export type AuditEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditEvent to update in case it exists.
     */
    where: AuditEventWhereUniqueInput
    /**
     * In case the AuditEvent found by the `where` argument doesn't exist, create a new AuditEvent with this data.
     */
    create: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
    /**
     * In case the AuditEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
  }

  /**
   * AuditEvent delete
   */
  export type AuditEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Filter which AuditEvent to delete.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent deleteMany
   */
  export type AuditEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvents to delete
     */
    where?: AuditEventWhereInput
    /**
     * Limit how many AuditEvents to delete.
     */
    limit?: number
  }

  /**
   * AuditEvent without action
   */
  export type AuditEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsSnapshot
   */

  export type AggregateAnalyticsSnapshot = {
    _count: AnalyticsSnapshotCountAggregateOutputType | null
    _avg: AnalyticsSnapshotAvgAggregateOutputType | null
    _sum: AnalyticsSnapshotSumAggregateOutputType | null
    _min: AnalyticsSnapshotMinAggregateOutputType | null
    _max: AnalyticsSnapshotMaxAggregateOutputType | null
  }

  export type AnalyticsSnapshotAvgAggregateOutputType = {
    mrrCents: number | null
    arrCents: number | null
    activeClients: number | null
    newClients: number | null
    churnedClients: number | null
    totalRevenue: number | null
  }

  export type AnalyticsSnapshotSumAggregateOutputType = {
    mrrCents: number | null
    arrCents: number | null
    activeClients: number | null
    newClients: number | null
    churnedClients: number | null
    totalRevenue: number | null
  }

  export type AnalyticsSnapshotMinAggregateOutputType = {
    id: string | null
    snapshotDate: Date | null
    mrrCents: number | null
    arrCents: number | null
    activeClients: number | null
    newClients: number | null
    churnedClients: number | null
    totalRevenue: number | null
    createdAt: Date | null
  }

  export type AnalyticsSnapshotMaxAggregateOutputType = {
    id: string | null
    snapshotDate: Date | null
    mrrCents: number | null
    arrCents: number | null
    activeClients: number | null
    newClients: number | null
    churnedClients: number | null
    totalRevenue: number | null
    createdAt: Date | null
  }

  export type AnalyticsSnapshotCountAggregateOutputType = {
    id: number
    snapshotDate: number
    mrrCents: number
    arrCents: number
    activeClients: number
    newClients: number
    churnedClients: number
    totalRevenue: number
    metricsJson: number
    createdAt: number
    _all: number
  }


  export type AnalyticsSnapshotAvgAggregateInputType = {
    mrrCents?: true
    arrCents?: true
    activeClients?: true
    newClients?: true
    churnedClients?: true
    totalRevenue?: true
  }

  export type AnalyticsSnapshotSumAggregateInputType = {
    mrrCents?: true
    arrCents?: true
    activeClients?: true
    newClients?: true
    churnedClients?: true
    totalRevenue?: true
  }

  export type AnalyticsSnapshotMinAggregateInputType = {
    id?: true
    snapshotDate?: true
    mrrCents?: true
    arrCents?: true
    activeClients?: true
    newClients?: true
    churnedClients?: true
    totalRevenue?: true
    createdAt?: true
  }

  export type AnalyticsSnapshotMaxAggregateInputType = {
    id?: true
    snapshotDate?: true
    mrrCents?: true
    arrCents?: true
    activeClients?: true
    newClients?: true
    churnedClients?: true
    totalRevenue?: true
    createdAt?: true
  }

  export type AnalyticsSnapshotCountAggregateInputType = {
    id?: true
    snapshotDate?: true
    mrrCents?: true
    arrCents?: true
    activeClients?: true
    newClients?: true
    churnedClients?: true
    totalRevenue?: true
    metricsJson?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsSnapshot to aggregate.
     */
    where?: AnalyticsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSnapshots to fetch.
     */
    orderBy?: AnalyticsSnapshotOrderByWithRelationInput | AnalyticsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsSnapshots
    **/
    _count?: true | AnalyticsSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsSnapshotMaxAggregateInputType
  }

  export type GetAnalyticsSnapshotAggregateType<T extends AnalyticsSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsSnapshot[P]>
      : GetScalarType<T[P], AggregateAnalyticsSnapshot[P]>
  }




  export type AnalyticsSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsSnapshotWhereInput
    orderBy?: AnalyticsSnapshotOrderByWithAggregationInput | AnalyticsSnapshotOrderByWithAggregationInput[]
    by: AnalyticsSnapshotScalarFieldEnum[] | AnalyticsSnapshotScalarFieldEnum
    having?: AnalyticsSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsSnapshotCountAggregateInputType | true
    _avg?: AnalyticsSnapshotAvgAggregateInputType
    _sum?: AnalyticsSnapshotSumAggregateInputType
    _min?: AnalyticsSnapshotMinAggregateInputType
    _max?: AnalyticsSnapshotMaxAggregateInputType
  }

  export type AnalyticsSnapshotGroupByOutputType = {
    id: string
    snapshotDate: Date
    mrrCents: number
    arrCents: number
    activeClients: number
    newClients: number
    churnedClients: number
    totalRevenue: number
    metricsJson: JsonValue
    createdAt: Date
    _count: AnalyticsSnapshotCountAggregateOutputType | null
    _avg: AnalyticsSnapshotAvgAggregateOutputType | null
    _sum: AnalyticsSnapshotSumAggregateOutputType | null
    _min: AnalyticsSnapshotMinAggregateOutputType | null
    _max: AnalyticsSnapshotMaxAggregateOutputType | null
  }

  type GetAnalyticsSnapshotGroupByPayload<T extends AnalyticsSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotDate?: boolean
    mrrCents?: boolean
    arrCents?: boolean
    activeClients?: boolean
    newClients?: boolean
    churnedClients?: boolean
    totalRevenue?: boolean
    metricsJson?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsSnapshot"]>

  export type AnalyticsSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotDate?: boolean
    mrrCents?: boolean
    arrCents?: boolean
    activeClients?: boolean
    newClients?: boolean
    churnedClients?: boolean
    totalRevenue?: boolean
    metricsJson?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsSnapshot"]>

  export type AnalyticsSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotDate?: boolean
    mrrCents?: boolean
    arrCents?: boolean
    activeClients?: boolean
    newClients?: boolean
    churnedClients?: boolean
    totalRevenue?: boolean
    metricsJson?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsSnapshot"]>

  export type AnalyticsSnapshotSelectScalar = {
    id?: boolean
    snapshotDate?: boolean
    mrrCents?: boolean
    arrCents?: boolean
    activeClients?: boolean
    newClients?: boolean
    churnedClients?: boolean
    totalRevenue?: boolean
    metricsJson?: boolean
    createdAt?: boolean
  }

  export type AnalyticsSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "snapshotDate" | "mrrCents" | "arrCents" | "activeClients" | "newClients" | "churnedClients" | "totalRevenue" | "metricsJson" | "createdAt", ExtArgs["result"]["analyticsSnapshot"]>

  export type $AnalyticsSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsSnapshot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      snapshotDate: Date
      mrrCents: number
      arrCents: number
      activeClients: number
      newClients: number
      churnedClients: number
      totalRevenue: number
      metricsJson: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["analyticsSnapshot"]>
    composites: {}
  }

  type AnalyticsSnapshotGetPayload<S extends boolean | null | undefined | AnalyticsSnapshotDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsSnapshotPayload, S>

  type AnalyticsSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsSnapshotCountAggregateInputType | true
    }

  export interface AnalyticsSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsSnapshot'], meta: { name: 'AnalyticsSnapshot' } }
    /**
     * Find zero or one AnalyticsSnapshot that matches the filter.
     * @param {AnalyticsSnapshotFindUniqueArgs} args - Arguments to find a AnalyticsSnapshot
     * @example
     * // Get one AnalyticsSnapshot
     * const analyticsSnapshot = await prisma.analyticsSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsSnapshotFindUniqueArgs>(args: SelectSubset<T, AnalyticsSnapshotFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsSnapshotClient<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsSnapshotFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsSnapshot
     * @example
     * // Get one AnalyticsSnapshot
     * const analyticsSnapshot = await prisma.analyticsSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsSnapshotClient<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSnapshotFindFirstArgs} args - Arguments to find a AnalyticsSnapshot
     * @example
     * // Get one AnalyticsSnapshot
     * const analyticsSnapshot = await prisma.analyticsSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsSnapshotFindFirstArgs>(args?: SelectSubset<T, AnalyticsSnapshotFindFirstArgs<ExtArgs>>): Prisma__AnalyticsSnapshotClient<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSnapshotFindFirstOrThrowArgs} args - Arguments to find a AnalyticsSnapshot
     * @example
     * // Get one AnalyticsSnapshot
     * const analyticsSnapshot = await prisma.analyticsSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsSnapshotClient<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsSnapshots
     * const analyticsSnapshots = await prisma.analyticsSnapshot.findMany()
     * 
     * // Get first 10 AnalyticsSnapshots
     * const analyticsSnapshots = await prisma.analyticsSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsSnapshotWithIdOnly = await prisma.analyticsSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsSnapshotFindManyArgs>(args?: SelectSubset<T, AnalyticsSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsSnapshot.
     * @param {AnalyticsSnapshotCreateArgs} args - Arguments to create a AnalyticsSnapshot.
     * @example
     * // Create one AnalyticsSnapshot
     * const AnalyticsSnapshot = await prisma.analyticsSnapshot.create({
     *   data: {
     *     // ... data to create a AnalyticsSnapshot
     *   }
     * })
     * 
     */
    create<T extends AnalyticsSnapshotCreateArgs>(args: SelectSubset<T, AnalyticsSnapshotCreateArgs<ExtArgs>>): Prisma__AnalyticsSnapshotClient<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsSnapshots.
     * @param {AnalyticsSnapshotCreateManyArgs} args - Arguments to create many AnalyticsSnapshots.
     * @example
     * // Create many AnalyticsSnapshots
     * const analyticsSnapshot = await prisma.analyticsSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsSnapshotCreateManyArgs>(args?: SelectSubset<T, AnalyticsSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsSnapshots and returns the data saved in the database.
     * @param {AnalyticsSnapshotCreateManyAndReturnArgs} args - Arguments to create many AnalyticsSnapshots.
     * @example
     * // Create many AnalyticsSnapshots
     * const analyticsSnapshot = await prisma.analyticsSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsSnapshots and only return the `id`
     * const analyticsSnapshotWithIdOnly = await prisma.analyticsSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsSnapshot.
     * @param {AnalyticsSnapshotDeleteArgs} args - Arguments to delete one AnalyticsSnapshot.
     * @example
     * // Delete one AnalyticsSnapshot
     * const AnalyticsSnapshot = await prisma.analyticsSnapshot.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsSnapshot
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsSnapshotDeleteArgs>(args: SelectSubset<T, AnalyticsSnapshotDeleteArgs<ExtArgs>>): Prisma__AnalyticsSnapshotClient<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsSnapshot.
     * @param {AnalyticsSnapshotUpdateArgs} args - Arguments to update one AnalyticsSnapshot.
     * @example
     * // Update one AnalyticsSnapshot
     * const analyticsSnapshot = await prisma.analyticsSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsSnapshotUpdateArgs>(args: SelectSubset<T, AnalyticsSnapshotUpdateArgs<ExtArgs>>): Prisma__AnalyticsSnapshotClient<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsSnapshots.
     * @param {AnalyticsSnapshotDeleteManyArgs} args - Arguments to filter AnalyticsSnapshots to delete.
     * @example
     * // Delete a few AnalyticsSnapshots
     * const { count } = await prisma.analyticsSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsSnapshotDeleteManyArgs>(args?: SelectSubset<T, AnalyticsSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsSnapshots
     * const analyticsSnapshot = await prisma.analyticsSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsSnapshotUpdateManyArgs>(args: SelectSubset<T, AnalyticsSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsSnapshots and returns the data updated in the database.
     * @param {AnalyticsSnapshotUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsSnapshots.
     * @example
     * // Update many AnalyticsSnapshots
     * const analyticsSnapshot = await prisma.analyticsSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsSnapshots and only return the `id`
     * const analyticsSnapshotWithIdOnly = await prisma.analyticsSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsSnapshot.
     * @param {AnalyticsSnapshotUpsertArgs} args - Arguments to update or create a AnalyticsSnapshot.
     * @example
     * // Update or create a AnalyticsSnapshot
     * const analyticsSnapshot = await prisma.analyticsSnapshot.upsert({
     *   create: {
     *     // ... data to create a AnalyticsSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsSnapshotUpsertArgs>(args: SelectSubset<T, AnalyticsSnapshotUpsertArgs<ExtArgs>>): Prisma__AnalyticsSnapshotClient<$Result.GetResult<Prisma.$AnalyticsSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSnapshotCountArgs} args - Arguments to filter AnalyticsSnapshots to count.
     * @example
     * // Count the number of AnalyticsSnapshots
     * const count = await prisma.analyticsSnapshot.count({
     *   where: {
     *     // ... the filter for the AnalyticsSnapshots we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsSnapshotCountArgs>(
      args?: Subset<T, AnalyticsSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsSnapshotAggregateArgs>(args: Subset<T, AnalyticsSnapshotAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsSnapshotAggregateType<T>>

    /**
     * Group by AnalyticsSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsSnapshot model
   */
  readonly fields: AnalyticsSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsSnapshot model
   */
  interface AnalyticsSnapshotFieldRefs {
    readonly id: FieldRef<"AnalyticsSnapshot", 'String'>
    readonly snapshotDate: FieldRef<"AnalyticsSnapshot", 'DateTime'>
    readonly mrrCents: FieldRef<"AnalyticsSnapshot", 'Int'>
    readonly arrCents: FieldRef<"AnalyticsSnapshot", 'Int'>
    readonly activeClients: FieldRef<"AnalyticsSnapshot", 'Int'>
    readonly newClients: FieldRef<"AnalyticsSnapshot", 'Int'>
    readonly churnedClients: FieldRef<"AnalyticsSnapshot", 'Int'>
    readonly totalRevenue: FieldRef<"AnalyticsSnapshot", 'Int'>
    readonly metricsJson: FieldRef<"AnalyticsSnapshot", 'Json'>
    readonly createdAt: FieldRef<"AnalyticsSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsSnapshot findUnique
   */
  export type AnalyticsSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSnapshot to fetch.
     */
    where: AnalyticsSnapshotWhereUniqueInput
  }

  /**
   * AnalyticsSnapshot findUniqueOrThrow
   */
  export type AnalyticsSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSnapshot to fetch.
     */
    where: AnalyticsSnapshotWhereUniqueInput
  }

  /**
   * AnalyticsSnapshot findFirst
   */
  export type AnalyticsSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSnapshot to fetch.
     */
    where?: AnalyticsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSnapshots to fetch.
     */
    orderBy?: AnalyticsSnapshotOrderByWithRelationInput | AnalyticsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsSnapshots.
     */
    cursor?: AnalyticsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsSnapshots.
     */
    distinct?: AnalyticsSnapshotScalarFieldEnum | AnalyticsSnapshotScalarFieldEnum[]
  }

  /**
   * AnalyticsSnapshot findFirstOrThrow
   */
  export type AnalyticsSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSnapshot to fetch.
     */
    where?: AnalyticsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSnapshots to fetch.
     */
    orderBy?: AnalyticsSnapshotOrderByWithRelationInput | AnalyticsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsSnapshots.
     */
    cursor?: AnalyticsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsSnapshots.
     */
    distinct?: AnalyticsSnapshotScalarFieldEnum | AnalyticsSnapshotScalarFieldEnum[]
  }

  /**
   * AnalyticsSnapshot findMany
   */
  export type AnalyticsSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSnapshots to fetch.
     */
    where?: AnalyticsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSnapshots to fetch.
     */
    orderBy?: AnalyticsSnapshotOrderByWithRelationInput | AnalyticsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsSnapshots.
     */
    cursor?: AnalyticsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSnapshots.
     */
    skip?: number
    distinct?: AnalyticsSnapshotScalarFieldEnum | AnalyticsSnapshotScalarFieldEnum[]
  }

  /**
   * AnalyticsSnapshot create
   */
  export type AnalyticsSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsSnapshot.
     */
    data: XOR<AnalyticsSnapshotCreateInput, AnalyticsSnapshotUncheckedCreateInput>
  }

  /**
   * AnalyticsSnapshot createMany
   */
  export type AnalyticsSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsSnapshots.
     */
    data: AnalyticsSnapshotCreateManyInput | AnalyticsSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsSnapshot createManyAndReturn
   */
  export type AnalyticsSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsSnapshots.
     */
    data: AnalyticsSnapshotCreateManyInput | AnalyticsSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsSnapshot update
   */
  export type AnalyticsSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsSnapshot.
     */
    data: XOR<AnalyticsSnapshotUpdateInput, AnalyticsSnapshotUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsSnapshot to update.
     */
    where: AnalyticsSnapshotWhereUniqueInput
  }

  /**
   * AnalyticsSnapshot updateMany
   */
  export type AnalyticsSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsSnapshots.
     */
    data: XOR<AnalyticsSnapshotUpdateManyMutationInput, AnalyticsSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsSnapshots to update
     */
    where?: AnalyticsSnapshotWhereInput
    /**
     * Limit how many AnalyticsSnapshots to update.
     */
    limit?: number
  }

  /**
   * AnalyticsSnapshot updateManyAndReturn
   */
  export type AnalyticsSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsSnapshots.
     */
    data: XOR<AnalyticsSnapshotUpdateManyMutationInput, AnalyticsSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsSnapshots to update
     */
    where?: AnalyticsSnapshotWhereInput
    /**
     * Limit how many AnalyticsSnapshots to update.
     */
    limit?: number
  }

  /**
   * AnalyticsSnapshot upsert
   */
  export type AnalyticsSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsSnapshot to update in case it exists.
     */
    where: AnalyticsSnapshotWhereUniqueInput
    /**
     * In case the AnalyticsSnapshot found by the `where` argument doesn't exist, create a new AnalyticsSnapshot with this data.
     */
    create: XOR<AnalyticsSnapshotCreateInput, AnalyticsSnapshotUncheckedCreateInput>
    /**
     * In case the AnalyticsSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsSnapshotUpdateInput, AnalyticsSnapshotUncheckedUpdateInput>
  }

  /**
   * AnalyticsSnapshot delete
   */
  export type AnalyticsSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsSnapshot to delete.
     */
    where: AnalyticsSnapshotWhereUniqueInput
  }

  /**
   * AnalyticsSnapshot deleteMany
   */
  export type AnalyticsSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsSnapshots to delete
     */
    where?: AnalyticsSnapshotWhereInput
    /**
     * Limit how many AnalyticsSnapshots to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsSnapshot without action
   */
  export type AnalyticsSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSnapshot
     */
    select?: AnalyticsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSnapshot
     */
    omit?: AnalyticsSnapshotOmit<ExtArgs> | null
  }


  /**
   * Model Incident
   */

  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    severity: $Enums.IncidentSeverity | null
    status: $Enums.IncidentStatus | null
    title: string | null
    description: string | null
    assigneeUserId: string | null
    slaResponseDeadline: Date | null
    slaResolveDeadline: Date | null
    acknowledgedAt: Date | null
    resolvedAt: Date | null
    closedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    severity: $Enums.IncidentSeverity | null
    status: $Enums.IncidentStatus | null
    title: string | null
    description: string | null
    assigneeUserId: string | null
    slaResponseDeadline: Date | null
    slaResolveDeadline: Date | null
    acknowledgedAt: Date | null
    resolvedAt: Date | null
    closedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    orgId: number
    severity: number
    status: number
    title: number
    description: number
    assigneeUserId: number
    slaResponseDeadline: number
    slaResolveDeadline: number
    acknowledgedAt: number
    resolvedAt: number
    closedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncidentMinAggregateInputType = {
    id?: true
    orgId?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    assigneeUserId?: true
    slaResponseDeadline?: true
    slaResolveDeadline?: true
    acknowledgedAt?: true
    resolvedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    orgId?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    assigneeUserId?: true
    slaResponseDeadline?: true
    slaResolveDeadline?: true
    acknowledgedAt?: true
    resolvedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    orgId?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    assigneeUserId?: true
    slaResponseDeadline?: true
    slaResolveDeadline?: true
    acknowledgedAt?: true
    resolvedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incident to aggregate.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithAggregationInput | IncidentOrderByWithAggregationInput[]
    by: IncidentScalarFieldEnum[] | IncidentScalarFieldEnum
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }

  export type IncidentGroupByOutputType = {
    id: string
    orgId: string
    severity: $Enums.IncidentSeverity
    status: $Enums.IncidentStatus
    title: string
    description: string
    assigneeUserId: string | null
    slaResponseDeadline: Date | null
    slaResolveDeadline: Date | null
    acknowledgedAt: Date | null
    resolvedAt: Date | null
    closedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    assigneeUserId?: boolean
    slaResponseDeadline?: boolean
    slaResolveDeadline?: boolean
    acknowledgedAt?: boolean
    resolvedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    assigneeUserId?: boolean
    slaResponseDeadline?: boolean
    slaResolveDeadline?: boolean
    acknowledgedAt?: boolean
    resolvedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    assigneeUserId?: boolean
    slaResponseDeadline?: boolean
    slaResolveDeadline?: boolean
    acknowledgedAt?: boolean
    resolvedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectScalar = {
    id?: boolean
    orgId?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    assigneeUserId?: boolean
    slaResponseDeadline?: boolean
    slaResolveDeadline?: boolean
    acknowledgedAt?: boolean
    resolvedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncidentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "severity" | "status" | "title" | "description" | "assigneeUserId" | "slaResponseDeadline" | "slaResolveDeadline" | "acknowledgedAt" | "resolvedAt" | "closedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["incident"]>
  export type IncidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type IncidentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type IncidentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $IncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incident"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      severity: $Enums.IncidentSeverity
      status: $Enums.IncidentStatus
      title: string
      description: string
      assigneeUserId: string | null
      slaResponseDeadline: Date | null
      slaResolveDeadline: Date | null
      acknowledgedAt: Date | null
      resolvedAt: Date | null
      closedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incident"]>
    composites: {}
  }

  type IncidentGetPayload<S extends boolean | null | undefined | IncidentDefaultArgs> = $Result.GetResult<Prisma.$IncidentPayload, S>

  type IncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncidentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncidentCountAggregateInputType | true
    }

  export interface IncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incident'], meta: { name: 'Incident' } }
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentFindUniqueArgs>(args: SelectSubset<T, IncidentFindUniqueArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Incident that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentFindFirstArgs>(args?: SelectSubset<T, IncidentFindFirstArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Incident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentFindManyArgs>(args?: SelectSubset<T, IncidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
     */
    create<T extends IncidentCreateArgs>(args: SelectSubset<T, IncidentCreateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Incidents.
     * @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCreateManyArgs>(args?: SelectSubset<T, IncidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incidents and returns the data saved in the database.
     * @param {IncidentCreateManyAndReturnArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
     */
    delete<T extends IncidentDeleteArgs>(args: SelectSubset<T, IncidentDeleteArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateArgs>(args: SelectSubset<T, IncidentUpdateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentDeleteManyArgs>(args?: SelectSubset<T, IncidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents and returns the data updated in the database.
     * @param {IncidentUpdateManyAndReturnArgs} args - Arguments to update many Incidents.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncidentUpdateManyAndReturnArgs>(args: SelectSubset<T, IncidentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpsertArgs>(args: SelectSubset<T, IncidentUpsertArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): Prisma.PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incident model
   */
  readonly fields: IncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incident model
   */
  interface IncidentFieldRefs {
    readonly id: FieldRef<"Incident", 'String'>
    readonly orgId: FieldRef<"Incident", 'String'>
    readonly severity: FieldRef<"Incident", 'IncidentSeverity'>
    readonly status: FieldRef<"Incident", 'IncidentStatus'>
    readonly title: FieldRef<"Incident", 'String'>
    readonly description: FieldRef<"Incident", 'String'>
    readonly assigneeUserId: FieldRef<"Incident", 'String'>
    readonly slaResponseDeadline: FieldRef<"Incident", 'DateTime'>
    readonly slaResolveDeadline: FieldRef<"Incident", 'DateTime'>
    readonly acknowledgedAt: FieldRef<"Incident", 'DateTime'>
    readonly resolvedAt: FieldRef<"Incident", 'DateTime'>
    readonly closedAt: FieldRef<"Incident", 'DateTime'>
    readonly createdAt: FieldRef<"Incident", 'DateTime'>
    readonly updatedAt: FieldRef<"Incident", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Incident findUnique
   */
  export type IncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findFirst
   */
  export type IncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incidents to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident create
   */
  export type IncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Incident.
     */
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }

  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incident createManyAndReturn
   */
  export type IncidentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident update
   */
  export type IncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Incident.
     */
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
    /**
     * Limit how many Incidents to update.
     */
    limit?: number
  }

  /**
   * Incident updateManyAndReturn
   */
  export type IncidentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
    /**
     * Limit how many Incidents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Incident to update in case it exists.
     */
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     */
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }

  /**
   * Incident delete
   */
  export type IncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter which Incident to delete.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidents to delete
     */
    where?: IncidentWhereInput
    /**
     * Limit how many Incidents to delete.
     */
    limit?: number
  }

  /**
   * Incident without action
   */
  export type IncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceLine
   */

  export type AggregateInvoiceLine = {
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  export type InvoiceLineAvgAggregateOutputType = {
    quantity: number | null
    unitPriceCents: number | null
    amountCents: number | null
  }

  export type InvoiceLineSumAggregateOutputType = {
    quantity: number | null
    unitPriceCents: number | null
    amountCents: number | null
  }

  export type InvoiceLineMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    lineType: $Enums.InvoiceLineType | null
    quantity: number | null
    unitPriceCents: number | null
    amountCents: number | null
    sourceType: string | null
    sourceId: string | null
    createdAt: Date | null
  }

  export type InvoiceLineMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    lineType: $Enums.InvoiceLineType | null
    quantity: number | null
    unitPriceCents: number | null
    amountCents: number | null
    sourceType: string | null
    sourceId: string | null
    createdAt: Date | null
  }

  export type InvoiceLineCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    lineType: number
    quantity: number
    unitPriceCents: number
    amountCents: number
    sourceType: number
    sourceId: number
    createdAt: number
    _all: number
  }


  export type InvoiceLineAvgAggregateInputType = {
    quantity?: true
    unitPriceCents?: true
    amountCents?: true
  }

  export type InvoiceLineSumAggregateInputType = {
    quantity?: true
    unitPriceCents?: true
    amountCents?: true
  }

  export type InvoiceLineMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    lineType?: true
    quantity?: true
    unitPriceCents?: true
    amountCents?: true
    sourceType?: true
    sourceId?: true
    createdAt?: true
  }

  export type InvoiceLineMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    lineType?: true
    quantity?: true
    unitPriceCents?: true
    amountCents?: true
    sourceType?: true
    sourceId?: true
    createdAt?: true
  }

  export type InvoiceLineCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    lineType?: true
    quantity?: true
    unitPriceCents?: true
    amountCents?: true
    sourceType?: true
    sourceId?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLine to aggregate.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLines
    **/
    _count?: true | InvoiceLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type GetInvoiceLineAggregateType<T extends InvoiceLineAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLine[P]>
      : GetScalarType<T[P], AggregateInvoiceLine[P]>
  }




  export type InvoiceLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithAggregationInput | InvoiceLineOrderByWithAggregationInput[]
    by: InvoiceLineScalarFieldEnum[] | InvoiceLineScalarFieldEnum
    having?: InvoiceLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLineCountAggregateInputType | true
    _avg?: InvoiceLineAvgAggregateInputType
    _sum?: InvoiceLineSumAggregateInputType
    _min?: InvoiceLineMinAggregateInputType
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type InvoiceLineGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    lineType: $Enums.InvoiceLineType
    quantity: number
    unitPriceCents: number
    amountCents: number
    sourceType: string | null
    sourceId: string | null
    createdAt: Date
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  type GetInvoiceLineGroupByPayload<T extends InvoiceLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    lineType?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    amountCents?: boolean
    sourceType?: boolean
    sourceId?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    lineType?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    amountCents?: boolean
    sourceType?: boolean
    sourceId?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    lineType?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    amountCents?: boolean
    sourceType?: boolean
    sourceId?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    lineType?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    amountCents?: boolean
    sourceType?: boolean
    sourceId?: boolean
    createdAt?: boolean
  }

  export type InvoiceLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "description" | "lineType" | "quantity" | "unitPriceCents" | "amountCents" | "sourceType" | "sourceId" | "createdAt", ExtArgs["result"]["invoiceLine"]>
  export type InvoiceLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceLine"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      lineType: $Enums.InvoiceLineType
      quantity: number
      unitPriceCents: number
      amountCents: number
      sourceType: string | null
      sourceId: string | null
      createdAt: Date
    }, ExtArgs["result"]["invoiceLine"]>
    composites: {}
  }

  type InvoiceLineGetPayload<S extends boolean | null | undefined | InvoiceLineDefaultArgs> = $Result.GetResult<Prisma.$InvoiceLinePayload, S>

  type InvoiceLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceLineCountAggregateInputType | true
    }

  export interface InvoiceLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLine'], meta: { name: 'InvoiceLine' } }
    /**
     * Find zero or one InvoiceLine that matches the filter.
     * @param {InvoiceLineFindUniqueArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceLineFindUniqueArgs>(args: SelectSubset<T, InvoiceLineFindUniqueArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceLineFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceLineFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceLineFindFirstArgs>(args?: SelectSubset<T, InvoiceLineFindFirstArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceLineFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany()
     * 
     * // Get first 10 InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceLineFindManyArgs>(args?: SelectSubset<T, InvoiceLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceLine.
     * @param {InvoiceLineCreateArgs} args - Arguments to create a InvoiceLine.
     * @example
     * // Create one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.create({
     *   data: {
     *     // ... data to create a InvoiceLine
     *   }
     * })
     * 
     */
    create<T extends InvoiceLineCreateArgs>(args: SelectSubset<T, InvoiceLineCreateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceLines.
     * @param {InvoiceLineCreateManyArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceLineCreateManyArgs>(args?: SelectSubset<T, InvoiceLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceLines and returns the data saved in the database.
     * @param {InvoiceLineCreateManyAndReturnArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceLines and only return the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceLineCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceLine.
     * @param {InvoiceLineDeleteArgs} args - Arguments to delete one InvoiceLine.
     * @example
     * // Delete one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLine
     *   }
     * })
     * 
     */
    delete<T extends InvoiceLineDeleteArgs>(args: SelectSubset<T, InvoiceLineDeleteArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceLine.
     * @param {InvoiceLineUpdateArgs} args - Arguments to update one InvoiceLine.
     * @example
     * // Update one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceLineUpdateArgs>(args: SelectSubset<T, InvoiceLineUpdateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceLines.
     * @param {InvoiceLineDeleteManyArgs} args - Arguments to filter InvoiceLines to delete.
     * @example
     * // Delete a few InvoiceLines
     * const { count } = await prisma.invoiceLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceLineDeleteManyArgs>(args?: SelectSubset<T, InvoiceLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceLineUpdateManyArgs>(args: SelectSubset<T, InvoiceLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLines and returns the data updated in the database.
     * @param {InvoiceLineUpdateManyAndReturnArgs} args - Arguments to update many InvoiceLines.
     * @example
     * // Update many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceLines and only return the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceLineUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceLine.
     * @param {InvoiceLineUpsertArgs} args - Arguments to update or create a InvoiceLine.
     * @example
     * // Update or create a InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.upsert({
     *   create: {
     *     // ... data to create a InvoiceLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLine we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceLineUpsertArgs>(args: SelectSubset<T, InvoiceLineUpsertArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineCountArgs} args - Arguments to filter InvoiceLines to count.
     * @example
     * // Count the number of InvoiceLines
     * const count = await prisma.invoiceLine.count({
     *   where: {
     *     // ... the filter for the InvoiceLines we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLineCountArgs>(
      args?: Subset<T, InvoiceLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLineAggregateArgs>(args: Subset<T, InvoiceLineAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLineAggregateType<T>>

    /**
     * Group by InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLineGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceLine model
   */
  readonly fields: InvoiceLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceLine model
   */
  interface InvoiceLineFieldRefs {
    readonly id: FieldRef<"InvoiceLine", 'String'>
    readonly invoiceId: FieldRef<"InvoiceLine", 'String'>
    readonly description: FieldRef<"InvoiceLine", 'String'>
    readonly lineType: FieldRef<"InvoiceLine", 'InvoiceLineType'>
    readonly quantity: FieldRef<"InvoiceLine", 'Int'>
    readonly unitPriceCents: FieldRef<"InvoiceLine", 'Int'>
    readonly amountCents: FieldRef<"InvoiceLine", 'Int'>
    readonly sourceType: FieldRef<"InvoiceLine", 'String'>
    readonly sourceId: FieldRef<"InvoiceLine", 'String'>
    readonly createdAt: FieldRef<"InvoiceLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceLine findUnique
   */
  export type InvoiceLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findUniqueOrThrow
   */
  export type InvoiceLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findFirst
   */
  export type InvoiceLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findFirstOrThrow
   */
  export type InvoiceLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findMany
   */
  export type InvoiceLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLines to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine create
   */
  export type InvoiceLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLine.
     */
    data: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
  }

  /**
   * InvoiceLine createMany
   */
  export type InvoiceLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceLine createManyAndReturn
   */
  export type InvoiceLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLine update
   */
  export type InvoiceLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLine.
     */
    data: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLine to update.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine updateMany
   */
  export type InvoiceLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLines.
     */
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLines to update
     */
    where?: InvoiceLineWhereInput
    /**
     * Limit how many InvoiceLines to update.
     */
    limit?: number
  }

  /**
   * InvoiceLine updateManyAndReturn
   */
  export type InvoiceLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceLines.
     */
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLines to update
     */
    where?: InvoiceLineWhereInput
    /**
     * Limit how many InvoiceLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLine upsert
   */
  export type InvoiceLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLine to update in case it exists.
     */
    where: InvoiceLineWhereUniqueInput
    /**
     * In case the InvoiceLine found by the `where` argument doesn't exist, create a new InvoiceLine with this data.
     */
    create: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
    /**
     * In case the InvoiceLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
  }

  /**
   * InvoiceLine delete
   */
  export type InvoiceLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter which InvoiceLine to delete.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine deleteMany
   */
  export type InvoiceLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLines to delete
     */
    where?: InvoiceLineWhereInput
    /**
     * Limit how many InvoiceLines to delete.
     */
    limit?: number
  }

  /**
   * InvoiceLine without action
   */
  export type InvoiceLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    audience: string | null
    type: string | null
    title: string | null
    body: string | null
    severity: string | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    audience: string | null
    type: string | null
    title: string | null
    body: string | null
    severity: string | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    orgId: number
    audience: number
    type: number
    title: number
    body: number
    severity: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    orgId?: true
    audience?: true
    type?: true
    title?: true
    body?: true
    severity?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    orgId?: true
    audience?: true
    type?: true
    title?: true
    body?: true
    severity?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    orgId?: true
    audience?: true
    type?: true
    title?: true
    body?: true
    severity?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    orgId: string | null
    audience: string
    type: string
    title: string
    body: string
    severity: string
    readAt: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    audience?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    severity?: boolean
    readAt?: boolean
    createdAt?: boolean
    org?: boolean | Notification$orgArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    audience?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    severity?: boolean
    readAt?: boolean
    createdAt?: boolean
    org?: boolean | Notification$orgArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    audience?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    severity?: boolean
    readAt?: boolean
    createdAt?: boolean
    org?: boolean | Notification$orgArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    orgId?: boolean
    audience?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    severity?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "audience" | "type" | "title" | "body" | "severity" | "readAt" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | Notification$orgArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | Notification$orgArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | Notification$orgArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string | null
      audience: string
      type: string
      title: string
      body: string
      severity: string
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends Notification$orgArgs<ExtArgs> = {}>(args?: Subset<T, Notification$orgArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly orgId: FieldRef<"Notification", 'String'>
    readonly audience: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly severity: FieldRef<"Notification", 'String'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.org
   */
  export type Notification$orgArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Org
     */
    select?: OrgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Org
     */
    omit?: OrgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgInclude<ExtArgs> | null
    where?: OrgWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model PricePlan
   */

  export type AggregatePricePlan = {
    _count: PricePlanCountAggregateOutputType | null
    _min: PricePlanMinAggregateOutputType | null
    _max: PricePlanMaxAggregateOutputType | null
  }

  export type PricePlanMinAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricePlanMaxAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricePlanCountAggregateOutputType = {
    id: number
    key: number
    name: number
    description: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PricePlanMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricePlanMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricePlanCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PricePlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricePlan to aggregate.
     */
    where?: PricePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricePlans to fetch.
     */
    orderBy?: PricePlanOrderByWithRelationInput | PricePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PricePlans
    **/
    _count?: true | PricePlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricePlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricePlanMaxAggregateInputType
  }

  export type GetPricePlanAggregateType<T extends PricePlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePricePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricePlan[P]>
      : GetScalarType<T[P], AggregatePricePlan[P]>
  }




  export type PricePlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricePlanWhereInput
    orderBy?: PricePlanOrderByWithAggregationInput | PricePlanOrderByWithAggregationInput[]
    by: PricePlanScalarFieldEnum[] | PricePlanScalarFieldEnum
    having?: PricePlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricePlanCountAggregateInputType | true
    _min?: PricePlanMinAggregateInputType
    _max?: PricePlanMaxAggregateInputType
  }

  export type PricePlanGroupByOutputType = {
    id: string
    key: string
    name: string
    description: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: PricePlanCountAggregateOutputType | null
    _min: PricePlanMinAggregateOutputType | null
    _max: PricePlanMaxAggregateOutputType | null
  }

  type GetPricePlanGroupByPayload<T extends PricePlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricePlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricePlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricePlanGroupByOutputType[P]>
            : GetScalarType<T[P], PricePlanGroupByOutputType[P]>
        }
      >
    >


  export type PricePlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prices?: boolean | PricePlan$pricesArgs<ExtArgs>
    offers?: boolean | PricePlan$offersArgs<ExtArgs>
    overrides?: boolean | PricePlan$overridesArgs<ExtArgs>
    asDefaultFor?: boolean | PricePlan$asDefaultForArgs<ExtArgs>
    invites?: boolean | PricePlan$invitesArgs<ExtArgs>
    _count?: boolean | PricePlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricePlan"]>

  export type PricePlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pricePlan"]>

  export type PricePlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pricePlan"]>

  export type PricePlanSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PricePlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "name" | "description" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["pricePlan"]>
  export type PricePlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prices?: boolean | PricePlan$pricesArgs<ExtArgs>
    offers?: boolean | PricePlan$offersArgs<ExtArgs>
    overrides?: boolean | PricePlan$overridesArgs<ExtArgs>
    asDefaultFor?: boolean | PricePlan$asDefaultForArgs<ExtArgs>
    invites?: boolean | PricePlan$invitesArgs<ExtArgs>
    _count?: boolean | PricePlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PricePlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PricePlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PricePlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PricePlan"
    objects: {
      prices: Prisma.$PlanPricePayload<ExtArgs>[]
      offers: Prisma.$OfferPayload<ExtArgs>[]
      overrides: Prisma.$TenantPriceOverridePayload<ExtArgs>[]
      asDefaultFor: Prisma.$GlobalMonetizationConfigPayload<ExtArgs>[]
      invites: Prisma.$OnboardingInvitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      name: string
      description: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pricePlan"]>
    composites: {}
  }

  type PricePlanGetPayload<S extends boolean | null | undefined | PricePlanDefaultArgs> = $Result.GetResult<Prisma.$PricePlanPayload, S>

  type PricePlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PricePlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PricePlanCountAggregateInputType | true
    }

  export interface PricePlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PricePlan'], meta: { name: 'PricePlan' } }
    /**
     * Find zero or one PricePlan that matches the filter.
     * @param {PricePlanFindUniqueArgs} args - Arguments to find a PricePlan
     * @example
     * // Get one PricePlan
     * const pricePlan = await prisma.pricePlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PricePlanFindUniqueArgs>(args: SelectSubset<T, PricePlanFindUniqueArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PricePlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PricePlanFindUniqueOrThrowArgs} args - Arguments to find a PricePlan
     * @example
     * // Get one PricePlan
     * const pricePlan = await prisma.pricePlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PricePlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PricePlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricePlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricePlanFindFirstArgs} args - Arguments to find a PricePlan
     * @example
     * // Get one PricePlan
     * const pricePlan = await prisma.pricePlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PricePlanFindFirstArgs>(args?: SelectSubset<T, PricePlanFindFirstArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricePlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricePlanFindFirstOrThrowArgs} args - Arguments to find a PricePlan
     * @example
     * // Get one PricePlan
     * const pricePlan = await prisma.pricePlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PricePlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PricePlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PricePlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricePlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricePlans
     * const pricePlans = await prisma.pricePlan.findMany()
     * 
     * // Get first 10 PricePlans
     * const pricePlans = await prisma.pricePlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricePlanWithIdOnly = await prisma.pricePlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PricePlanFindManyArgs>(args?: SelectSubset<T, PricePlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PricePlan.
     * @param {PricePlanCreateArgs} args - Arguments to create a PricePlan.
     * @example
     * // Create one PricePlan
     * const PricePlan = await prisma.pricePlan.create({
     *   data: {
     *     // ... data to create a PricePlan
     *   }
     * })
     * 
     */
    create<T extends PricePlanCreateArgs>(args: SelectSubset<T, PricePlanCreateArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PricePlans.
     * @param {PricePlanCreateManyArgs} args - Arguments to create many PricePlans.
     * @example
     * // Create many PricePlans
     * const pricePlan = await prisma.pricePlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PricePlanCreateManyArgs>(args?: SelectSubset<T, PricePlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PricePlans and returns the data saved in the database.
     * @param {PricePlanCreateManyAndReturnArgs} args - Arguments to create many PricePlans.
     * @example
     * // Create many PricePlans
     * const pricePlan = await prisma.pricePlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PricePlans and only return the `id`
     * const pricePlanWithIdOnly = await prisma.pricePlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PricePlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PricePlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PricePlan.
     * @param {PricePlanDeleteArgs} args - Arguments to delete one PricePlan.
     * @example
     * // Delete one PricePlan
     * const PricePlan = await prisma.pricePlan.delete({
     *   where: {
     *     // ... filter to delete one PricePlan
     *   }
     * })
     * 
     */
    delete<T extends PricePlanDeleteArgs>(args: SelectSubset<T, PricePlanDeleteArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PricePlan.
     * @param {PricePlanUpdateArgs} args - Arguments to update one PricePlan.
     * @example
     * // Update one PricePlan
     * const pricePlan = await prisma.pricePlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PricePlanUpdateArgs>(args: SelectSubset<T, PricePlanUpdateArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PricePlans.
     * @param {PricePlanDeleteManyArgs} args - Arguments to filter PricePlans to delete.
     * @example
     * // Delete a few PricePlans
     * const { count } = await prisma.pricePlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PricePlanDeleteManyArgs>(args?: SelectSubset<T, PricePlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricePlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricePlans
     * const pricePlan = await prisma.pricePlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PricePlanUpdateManyArgs>(args: SelectSubset<T, PricePlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricePlans and returns the data updated in the database.
     * @param {PricePlanUpdateManyAndReturnArgs} args - Arguments to update many PricePlans.
     * @example
     * // Update many PricePlans
     * const pricePlan = await prisma.pricePlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PricePlans and only return the `id`
     * const pricePlanWithIdOnly = await prisma.pricePlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PricePlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PricePlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PricePlan.
     * @param {PricePlanUpsertArgs} args - Arguments to update or create a PricePlan.
     * @example
     * // Update or create a PricePlan
     * const pricePlan = await prisma.pricePlan.upsert({
     *   create: {
     *     // ... data to create a PricePlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricePlan we want to update
     *   }
     * })
     */
    upsert<T extends PricePlanUpsertArgs>(args: SelectSubset<T, PricePlanUpsertArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PricePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricePlanCountArgs} args - Arguments to filter PricePlans to count.
     * @example
     * // Count the number of PricePlans
     * const count = await prisma.pricePlan.count({
     *   where: {
     *     // ... the filter for the PricePlans we want to count
     *   }
     * })
    **/
    count<T extends PricePlanCountArgs>(
      args?: Subset<T, PricePlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricePlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricePlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricePlanAggregateArgs>(args: Subset<T, PricePlanAggregateArgs>): Prisma.PrismaPromise<GetPricePlanAggregateType<T>>

    /**
     * Group by PricePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricePlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricePlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricePlanGroupByArgs['orderBy'] }
        : { orderBy?: PricePlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricePlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricePlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PricePlan model
   */
  readonly fields: PricePlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PricePlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PricePlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prices<T extends PricePlan$pricesArgs<ExtArgs> = {}>(args?: Subset<T, PricePlan$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offers<T extends PricePlan$offersArgs<ExtArgs> = {}>(args?: Subset<T, PricePlan$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overrides<T extends PricePlan$overridesArgs<ExtArgs> = {}>(args?: Subset<T, PricePlan$overridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asDefaultFor<T extends PricePlan$asDefaultForArgs<ExtArgs> = {}>(args?: Subset<T, PricePlan$asDefaultForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invites<T extends PricePlan$invitesArgs<ExtArgs> = {}>(args?: Subset<T, PricePlan$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PricePlan model
   */
  interface PricePlanFieldRefs {
    readonly id: FieldRef<"PricePlan", 'String'>
    readonly key: FieldRef<"PricePlan", 'String'>
    readonly name: FieldRef<"PricePlan", 'String'>
    readonly description: FieldRef<"PricePlan", 'String'>
    readonly active: FieldRef<"PricePlan", 'Boolean'>
    readonly createdAt: FieldRef<"PricePlan", 'DateTime'>
    readonly updatedAt: FieldRef<"PricePlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PricePlan findUnique
   */
  export type PricePlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    /**
     * Filter, which PricePlan to fetch.
     */
    where: PricePlanWhereUniqueInput
  }

  /**
   * PricePlan findUniqueOrThrow
   */
  export type PricePlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    /**
     * Filter, which PricePlan to fetch.
     */
    where: PricePlanWhereUniqueInput
  }

  /**
   * PricePlan findFirst
   */
  export type PricePlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    /**
     * Filter, which PricePlan to fetch.
     */
    where?: PricePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricePlans to fetch.
     */
    orderBy?: PricePlanOrderByWithRelationInput | PricePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricePlans.
     */
    cursor?: PricePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricePlans.
     */
    distinct?: PricePlanScalarFieldEnum | PricePlanScalarFieldEnum[]
  }

  /**
   * PricePlan findFirstOrThrow
   */
  export type PricePlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    /**
     * Filter, which PricePlan to fetch.
     */
    where?: PricePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricePlans to fetch.
     */
    orderBy?: PricePlanOrderByWithRelationInput | PricePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricePlans.
     */
    cursor?: PricePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricePlans.
     */
    distinct?: PricePlanScalarFieldEnum | PricePlanScalarFieldEnum[]
  }

  /**
   * PricePlan findMany
   */
  export type PricePlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    /**
     * Filter, which PricePlans to fetch.
     */
    where?: PricePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricePlans to fetch.
     */
    orderBy?: PricePlanOrderByWithRelationInput | PricePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PricePlans.
     */
    cursor?: PricePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricePlans.
     */
    skip?: number
    distinct?: PricePlanScalarFieldEnum | PricePlanScalarFieldEnum[]
  }

  /**
   * PricePlan create
   */
  export type PricePlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    /**
     * The data needed to create a PricePlan.
     */
    data: XOR<PricePlanCreateInput, PricePlanUncheckedCreateInput>
  }

  /**
   * PricePlan createMany
   */
  export type PricePlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PricePlans.
     */
    data: PricePlanCreateManyInput | PricePlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PricePlan createManyAndReturn
   */
  export type PricePlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * The data used to create many PricePlans.
     */
    data: PricePlanCreateManyInput | PricePlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PricePlan update
   */
  export type PricePlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    /**
     * The data needed to update a PricePlan.
     */
    data: XOR<PricePlanUpdateInput, PricePlanUncheckedUpdateInput>
    /**
     * Choose, which PricePlan to update.
     */
    where: PricePlanWhereUniqueInput
  }

  /**
   * PricePlan updateMany
   */
  export type PricePlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PricePlans.
     */
    data: XOR<PricePlanUpdateManyMutationInput, PricePlanUncheckedUpdateManyInput>
    /**
     * Filter which PricePlans to update
     */
    where?: PricePlanWhereInput
    /**
     * Limit how many PricePlans to update.
     */
    limit?: number
  }

  /**
   * PricePlan updateManyAndReturn
   */
  export type PricePlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * The data used to update PricePlans.
     */
    data: XOR<PricePlanUpdateManyMutationInput, PricePlanUncheckedUpdateManyInput>
    /**
     * Filter which PricePlans to update
     */
    where?: PricePlanWhereInput
    /**
     * Limit how many PricePlans to update.
     */
    limit?: number
  }

  /**
   * PricePlan upsert
   */
  export type PricePlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    /**
     * The filter to search for the PricePlan to update in case it exists.
     */
    where: PricePlanWhereUniqueInput
    /**
     * In case the PricePlan found by the `where` argument doesn't exist, create a new PricePlan with this data.
     */
    create: XOR<PricePlanCreateInput, PricePlanUncheckedCreateInput>
    /**
     * In case the PricePlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricePlanUpdateInput, PricePlanUncheckedUpdateInput>
  }

  /**
   * PricePlan delete
   */
  export type PricePlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    /**
     * Filter which PricePlan to delete.
     */
    where: PricePlanWhereUniqueInput
  }

  /**
   * PricePlan deleteMany
   */
  export type PricePlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricePlans to delete
     */
    where?: PricePlanWhereInput
    /**
     * Limit how many PricePlans to delete.
     */
    limit?: number
  }

  /**
   * PricePlan.prices
   */
  export type PricePlan$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    where?: PlanPriceWhereInput
    orderBy?: PlanPriceOrderByWithRelationInput | PlanPriceOrderByWithRelationInput[]
    cursor?: PlanPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanPriceScalarFieldEnum | PlanPriceScalarFieldEnum[]
  }

  /**
   * PricePlan.offers
   */
  export type PricePlan$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * PricePlan.overrides
   */
  export type PricePlan$overridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    where?: TenantPriceOverrideWhereInput
    orderBy?: TenantPriceOverrideOrderByWithRelationInput | TenantPriceOverrideOrderByWithRelationInput[]
    cursor?: TenantPriceOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantPriceOverrideScalarFieldEnum | TenantPriceOverrideScalarFieldEnum[]
  }

  /**
   * PricePlan.asDefaultFor
   */
  export type PricePlan$asDefaultForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    where?: GlobalMonetizationConfigWhereInput
    orderBy?: GlobalMonetizationConfigOrderByWithRelationInput | GlobalMonetizationConfigOrderByWithRelationInput[]
    cursor?: GlobalMonetizationConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GlobalMonetizationConfigScalarFieldEnum | GlobalMonetizationConfigScalarFieldEnum[]
  }

  /**
   * PricePlan.invites
   */
  export type PricePlan$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    where?: OnboardingInviteWhereInput
    orderBy?: OnboardingInviteOrderByWithRelationInput | OnboardingInviteOrderByWithRelationInput[]
    cursor?: OnboardingInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnboardingInviteScalarFieldEnum | OnboardingInviteScalarFieldEnum[]
  }

  /**
   * PricePlan without action
   */
  export type PricePlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanPrice
   */

  export type AggregatePlanPrice = {
    _count: PlanPriceCountAggregateOutputType | null
    _avg: PlanPriceAvgAggregateOutputType | null
    _sum: PlanPriceSumAggregateOutputType | null
    _min: PlanPriceMinAggregateOutputType | null
    _max: PlanPriceMaxAggregateOutputType | null
  }

  export type PlanPriceAvgAggregateOutputType = {
    unitAmountCents: number | null
    trialDays: number | null
  }

  export type PlanPriceSumAggregateOutputType = {
    unitAmountCents: number | null
    trialDays: number | null
  }

  export type PlanPriceMinAggregateOutputType = {
    id: string | null
    planId: string | null
    currency: string | null
    unitAmountCents: number | null
    cadence: $Enums.BillingCadence | null
    trialDays: number | null
    active: boolean | null
    stripePriceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanPriceMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    currency: string | null
    unitAmountCents: number | null
    cadence: $Enums.BillingCadence | null
    trialDays: number | null
    active: boolean | null
    stripePriceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanPriceCountAggregateOutputType = {
    id: number
    planId: number
    currency: number
    unitAmountCents: number
    cadence: number
    trialDays: number
    active: number
    stripePriceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanPriceAvgAggregateInputType = {
    unitAmountCents?: true
    trialDays?: true
  }

  export type PlanPriceSumAggregateInputType = {
    unitAmountCents?: true
    trialDays?: true
  }

  export type PlanPriceMinAggregateInputType = {
    id?: true
    planId?: true
    currency?: true
    unitAmountCents?: true
    cadence?: true
    trialDays?: true
    active?: true
    stripePriceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanPriceMaxAggregateInputType = {
    id?: true
    planId?: true
    currency?: true
    unitAmountCents?: true
    cadence?: true
    trialDays?: true
    active?: true
    stripePriceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanPriceCountAggregateInputType = {
    id?: true
    planId?: true
    currency?: true
    unitAmountCents?: true
    cadence?: true
    trialDays?: true
    active?: true
    stripePriceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanPrice to aggregate.
     */
    where?: PlanPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPrices to fetch.
     */
    orderBy?: PlanPriceOrderByWithRelationInput | PlanPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanPrices
    **/
    _count?: true | PlanPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanPriceMaxAggregateInputType
  }

  export type GetPlanPriceAggregateType<T extends PlanPriceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanPrice[P]>
      : GetScalarType<T[P], AggregatePlanPrice[P]>
  }




  export type PlanPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanPriceWhereInput
    orderBy?: PlanPriceOrderByWithAggregationInput | PlanPriceOrderByWithAggregationInput[]
    by: PlanPriceScalarFieldEnum[] | PlanPriceScalarFieldEnum
    having?: PlanPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanPriceCountAggregateInputType | true
    _avg?: PlanPriceAvgAggregateInputType
    _sum?: PlanPriceSumAggregateInputType
    _min?: PlanPriceMinAggregateInputType
    _max?: PlanPriceMaxAggregateInputType
  }

  export type PlanPriceGroupByOutputType = {
    id: string
    planId: string
    currency: string
    unitAmountCents: number
    cadence: $Enums.BillingCadence
    trialDays: number | null
    active: boolean
    stripePriceId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlanPriceCountAggregateOutputType | null
    _avg: PlanPriceAvgAggregateOutputType | null
    _sum: PlanPriceSumAggregateOutputType | null
    _min: PlanPriceMinAggregateOutputType | null
    _max: PlanPriceMaxAggregateOutputType | null
  }

  type GetPlanPriceGroupByPayload<T extends PlanPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanPriceGroupByOutputType[P]>
            : GetScalarType<T[P], PlanPriceGroupByOutputType[P]>
        }
      >
    >


  export type PlanPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    currency?: boolean
    unitAmountCents?: boolean
    cadence?: boolean
    trialDays?: boolean
    active?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    overrides?: boolean | PlanPrice$overridesArgs<ExtArgs>
    asDefaultFor?: boolean | PlanPrice$asDefaultForArgs<ExtArgs>
    invites?: boolean | PlanPrice$invitesArgs<ExtArgs>
    plan?: boolean | PricePlanDefaultArgs<ExtArgs>
    _count?: boolean | PlanPriceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planPrice"]>

  export type PlanPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    currency?: boolean
    unitAmountCents?: boolean
    cadence?: boolean
    trialDays?: boolean
    active?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PricePlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planPrice"]>

  export type PlanPriceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    currency?: boolean
    unitAmountCents?: boolean
    cadence?: boolean
    trialDays?: boolean
    active?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PricePlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planPrice"]>

  export type PlanPriceSelectScalar = {
    id?: boolean
    planId?: boolean
    currency?: boolean
    unitAmountCents?: boolean
    cadence?: boolean
    trialDays?: boolean
    active?: boolean
    stripePriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "currency" | "unitAmountCents" | "cadence" | "trialDays" | "active" | "stripePriceId" | "createdAt" | "updatedAt", ExtArgs["result"]["planPrice"]>
  export type PlanPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    overrides?: boolean | PlanPrice$overridesArgs<ExtArgs>
    asDefaultFor?: boolean | PlanPrice$asDefaultForArgs<ExtArgs>
    invites?: boolean | PlanPrice$invitesArgs<ExtArgs>
    plan?: boolean | PricePlanDefaultArgs<ExtArgs>
    _count?: boolean | PlanPriceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PricePlanDefaultArgs<ExtArgs>
  }
  export type PlanPriceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PricePlanDefaultArgs<ExtArgs>
  }

  export type $PlanPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanPrice"
    objects: {
      overrides: Prisma.$TenantPriceOverridePayload<ExtArgs>[]
      asDefaultFor: Prisma.$GlobalMonetizationConfigPayload<ExtArgs>[]
      invites: Prisma.$OnboardingInvitePayload<ExtArgs>[]
      plan: Prisma.$PricePlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      currency: string
      unitAmountCents: number
      cadence: $Enums.BillingCadence
      trialDays: number | null
      active: boolean
      stripePriceId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planPrice"]>
    composites: {}
  }

  type PlanPriceGetPayload<S extends boolean | null | undefined | PlanPriceDefaultArgs> = $Result.GetResult<Prisma.$PlanPricePayload, S>

  type PlanPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanPriceCountAggregateInputType | true
    }

  export interface PlanPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanPrice'], meta: { name: 'PlanPrice' } }
    /**
     * Find zero or one PlanPrice that matches the filter.
     * @param {PlanPriceFindUniqueArgs} args - Arguments to find a PlanPrice
     * @example
     * // Get one PlanPrice
     * const planPrice = await prisma.planPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanPriceFindUniqueArgs>(args: SelectSubset<T, PlanPriceFindUniqueArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanPriceFindUniqueOrThrowArgs} args - Arguments to find a PlanPrice
     * @example
     * // Get one PlanPrice
     * const planPrice = await prisma.planPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPriceFindFirstArgs} args - Arguments to find a PlanPrice
     * @example
     * // Get one PlanPrice
     * const planPrice = await prisma.planPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanPriceFindFirstArgs>(args?: SelectSubset<T, PlanPriceFindFirstArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPriceFindFirstOrThrowArgs} args - Arguments to find a PlanPrice
     * @example
     * // Get one PlanPrice
     * const planPrice = await prisma.planPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanPrices
     * const planPrices = await prisma.planPrice.findMany()
     * 
     * // Get first 10 PlanPrices
     * const planPrices = await prisma.planPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planPriceWithIdOnly = await prisma.planPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanPriceFindManyArgs>(args?: SelectSubset<T, PlanPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanPrice.
     * @param {PlanPriceCreateArgs} args - Arguments to create a PlanPrice.
     * @example
     * // Create one PlanPrice
     * const PlanPrice = await prisma.planPrice.create({
     *   data: {
     *     // ... data to create a PlanPrice
     *   }
     * })
     * 
     */
    create<T extends PlanPriceCreateArgs>(args: SelectSubset<T, PlanPriceCreateArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanPrices.
     * @param {PlanPriceCreateManyArgs} args - Arguments to create many PlanPrices.
     * @example
     * // Create many PlanPrices
     * const planPrice = await prisma.planPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanPriceCreateManyArgs>(args?: SelectSubset<T, PlanPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanPrices and returns the data saved in the database.
     * @param {PlanPriceCreateManyAndReturnArgs} args - Arguments to create many PlanPrices.
     * @example
     * // Create many PlanPrices
     * const planPrice = await prisma.planPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanPrices and only return the `id`
     * const planPriceWithIdOnly = await prisma.planPrice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanPrice.
     * @param {PlanPriceDeleteArgs} args - Arguments to delete one PlanPrice.
     * @example
     * // Delete one PlanPrice
     * const PlanPrice = await prisma.planPrice.delete({
     *   where: {
     *     // ... filter to delete one PlanPrice
     *   }
     * })
     * 
     */
    delete<T extends PlanPriceDeleteArgs>(args: SelectSubset<T, PlanPriceDeleteArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanPrice.
     * @param {PlanPriceUpdateArgs} args - Arguments to update one PlanPrice.
     * @example
     * // Update one PlanPrice
     * const planPrice = await prisma.planPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanPriceUpdateArgs>(args: SelectSubset<T, PlanPriceUpdateArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanPrices.
     * @param {PlanPriceDeleteManyArgs} args - Arguments to filter PlanPrices to delete.
     * @example
     * // Delete a few PlanPrices
     * const { count } = await prisma.planPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanPriceDeleteManyArgs>(args?: SelectSubset<T, PlanPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanPrices
     * const planPrice = await prisma.planPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanPriceUpdateManyArgs>(args: SelectSubset<T, PlanPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanPrices and returns the data updated in the database.
     * @param {PlanPriceUpdateManyAndReturnArgs} args - Arguments to update many PlanPrices.
     * @example
     * // Update many PlanPrices
     * const planPrice = await prisma.planPrice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanPrices and only return the `id`
     * const planPriceWithIdOnly = await prisma.planPrice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanPriceUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanPriceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanPrice.
     * @param {PlanPriceUpsertArgs} args - Arguments to update or create a PlanPrice.
     * @example
     * // Update or create a PlanPrice
     * const planPrice = await prisma.planPrice.upsert({
     *   create: {
     *     // ... data to create a PlanPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanPrice we want to update
     *   }
     * })
     */
    upsert<T extends PlanPriceUpsertArgs>(args: SelectSubset<T, PlanPriceUpsertArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPriceCountArgs} args - Arguments to filter PlanPrices to count.
     * @example
     * // Count the number of PlanPrices
     * const count = await prisma.planPrice.count({
     *   where: {
     *     // ... the filter for the PlanPrices we want to count
     *   }
     * })
    **/
    count<T extends PlanPriceCountArgs>(
      args?: Subset<T, PlanPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanPriceAggregateArgs>(args: Subset<T, PlanPriceAggregateArgs>): Prisma.PrismaPromise<GetPlanPriceAggregateType<T>>

    /**
     * Group by PlanPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanPriceGroupByArgs['orderBy'] }
        : { orderBy?: PlanPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanPrice model
   */
  readonly fields: PlanPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    overrides<T extends PlanPrice$overridesArgs<ExtArgs> = {}>(args?: Subset<T, PlanPrice$overridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asDefaultFor<T extends PlanPrice$asDefaultForArgs<ExtArgs> = {}>(args?: Subset<T, PlanPrice$asDefaultForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invites<T extends PlanPrice$invitesArgs<ExtArgs> = {}>(args?: Subset<T, PlanPrice$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plan<T extends PricePlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PricePlanDefaultArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanPrice model
   */
  interface PlanPriceFieldRefs {
    readonly id: FieldRef<"PlanPrice", 'String'>
    readonly planId: FieldRef<"PlanPrice", 'String'>
    readonly currency: FieldRef<"PlanPrice", 'String'>
    readonly unitAmountCents: FieldRef<"PlanPrice", 'Int'>
    readonly cadence: FieldRef<"PlanPrice", 'BillingCadence'>
    readonly trialDays: FieldRef<"PlanPrice", 'Int'>
    readonly active: FieldRef<"PlanPrice", 'Boolean'>
    readonly stripePriceId: FieldRef<"PlanPrice", 'String'>
    readonly createdAt: FieldRef<"PlanPrice", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanPrice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanPrice findUnique
   */
  export type PlanPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    /**
     * Filter, which PlanPrice to fetch.
     */
    where: PlanPriceWhereUniqueInput
  }

  /**
   * PlanPrice findUniqueOrThrow
   */
  export type PlanPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    /**
     * Filter, which PlanPrice to fetch.
     */
    where: PlanPriceWhereUniqueInput
  }

  /**
   * PlanPrice findFirst
   */
  export type PlanPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    /**
     * Filter, which PlanPrice to fetch.
     */
    where?: PlanPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPrices to fetch.
     */
    orderBy?: PlanPriceOrderByWithRelationInput | PlanPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanPrices.
     */
    cursor?: PlanPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanPrices.
     */
    distinct?: PlanPriceScalarFieldEnum | PlanPriceScalarFieldEnum[]
  }

  /**
   * PlanPrice findFirstOrThrow
   */
  export type PlanPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    /**
     * Filter, which PlanPrice to fetch.
     */
    where?: PlanPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPrices to fetch.
     */
    orderBy?: PlanPriceOrderByWithRelationInput | PlanPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanPrices.
     */
    cursor?: PlanPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanPrices.
     */
    distinct?: PlanPriceScalarFieldEnum | PlanPriceScalarFieldEnum[]
  }

  /**
   * PlanPrice findMany
   */
  export type PlanPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    /**
     * Filter, which PlanPrices to fetch.
     */
    where?: PlanPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPrices to fetch.
     */
    orderBy?: PlanPriceOrderByWithRelationInput | PlanPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanPrices.
     */
    cursor?: PlanPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPrices.
     */
    skip?: number
    distinct?: PlanPriceScalarFieldEnum | PlanPriceScalarFieldEnum[]
  }

  /**
   * PlanPrice create
   */
  export type PlanPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanPrice.
     */
    data: XOR<PlanPriceCreateInput, PlanPriceUncheckedCreateInput>
  }

  /**
   * PlanPrice createMany
   */
  export type PlanPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanPrices.
     */
    data: PlanPriceCreateManyInput | PlanPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanPrice createManyAndReturn
   */
  export type PlanPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * The data used to create many PlanPrices.
     */
    data: PlanPriceCreateManyInput | PlanPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanPrice update
   */
  export type PlanPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanPrice.
     */
    data: XOR<PlanPriceUpdateInput, PlanPriceUncheckedUpdateInput>
    /**
     * Choose, which PlanPrice to update.
     */
    where: PlanPriceWhereUniqueInput
  }

  /**
   * PlanPrice updateMany
   */
  export type PlanPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanPrices.
     */
    data: XOR<PlanPriceUpdateManyMutationInput, PlanPriceUncheckedUpdateManyInput>
    /**
     * Filter which PlanPrices to update
     */
    where?: PlanPriceWhereInput
    /**
     * Limit how many PlanPrices to update.
     */
    limit?: number
  }

  /**
   * PlanPrice updateManyAndReturn
   */
  export type PlanPriceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * The data used to update PlanPrices.
     */
    data: XOR<PlanPriceUpdateManyMutationInput, PlanPriceUncheckedUpdateManyInput>
    /**
     * Filter which PlanPrices to update
     */
    where?: PlanPriceWhereInput
    /**
     * Limit how many PlanPrices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanPrice upsert
   */
  export type PlanPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanPrice to update in case it exists.
     */
    where: PlanPriceWhereUniqueInput
    /**
     * In case the PlanPrice found by the `where` argument doesn't exist, create a new PlanPrice with this data.
     */
    create: XOR<PlanPriceCreateInput, PlanPriceUncheckedCreateInput>
    /**
     * In case the PlanPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanPriceUpdateInput, PlanPriceUncheckedUpdateInput>
  }

  /**
   * PlanPrice delete
   */
  export type PlanPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    /**
     * Filter which PlanPrice to delete.
     */
    where: PlanPriceWhereUniqueInput
  }

  /**
   * PlanPrice deleteMany
   */
  export type PlanPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanPrices to delete
     */
    where?: PlanPriceWhereInput
    /**
     * Limit how many PlanPrices to delete.
     */
    limit?: number
  }

  /**
   * PlanPrice.overrides
   */
  export type PlanPrice$overridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    where?: TenantPriceOverrideWhereInput
    orderBy?: TenantPriceOverrideOrderByWithRelationInput | TenantPriceOverrideOrderByWithRelationInput[]
    cursor?: TenantPriceOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantPriceOverrideScalarFieldEnum | TenantPriceOverrideScalarFieldEnum[]
  }

  /**
   * PlanPrice.asDefaultFor
   */
  export type PlanPrice$asDefaultForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    where?: GlobalMonetizationConfigWhereInput
    orderBy?: GlobalMonetizationConfigOrderByWithRelationInput | GlobalMonetizationConfigOrderByWithRelationInput[]
    cursor?: GlobalMonetizationConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GlobalMonetizationConfigScalarFieldEnum | GlobalMonetizationConfigScalarFieldEnum[]
  }

  /**
   * PlanPrice.invites
   */
  export type PlanPrice$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    where?: OnboardingInviteWhereInput
    orderBy?: OnboardingInviteOrderByWithRelationInput | OnboardingInviteOrderByWithRelationInput[]
    cursor?: OnboardingInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnboardingInviteScalarFieldEnum | OnboardingInviteScalarFieldEnum[]
  }

  /**
   * PlanPrice without action
   */
  export type PlanPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
  }


  /**
   * Model Offer
   */

  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    percentOff: number | null
    amountOffCents: number | null
    durationMonths: number | null
  }

  export type OfferSumAggregateOutputType = {
    percentOff: number | null
    amountOffCents: number | null
    durationMonths: number | null
  }

  export type OfferMinAggregateOutputType = {
    id: string | null
    name: string | null
    percentOff: number | null
    amountOffCents: number | null
    duration: string | null
    durationMonths: number | null
    appliesToPlanId: string | null
    startsAt: Date | null
    endsAt: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferMaxAggregateOutputType = {
    id: string | null
    name: string | null
    percentOff: number | null
    amountOffCents: number | null
    duration: string | null
    durationMonths: number | null
    appliesToPlanId: string | null
    startsAt: Date | null
    endsAt: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    name: number
    percentOff: number
    amountOffCents: number
    duration: number
    durationMonths: number
    appliesToPlanId: number
    startsAt: number
    endsAt: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    percentOff?: true
    amountOffCents?: true
    durationMonths?: true
  }

  export type OfferSumAggregateInputType = {
    percentOff?: true
    amountOffCents?: true
    durationMonths?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    name?: true
    percentOff?: true
    amountOffCents?: true
    duration?: true
    durationMonths?: true
    appliesToPlanId?: true
    startsAt?: true
    endsAt?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    name?: true
    percentOff?: true
    amountOffCents?: true
    duration?: true
    durationMonths?: true
    appliesToPlanId?: true
    startsAt?: true
    endsAt?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    name?: true
    percentOff?: true
    amountOffCents?: true
    duration?: true
    durationMonths?: true
    appliesToPlanId?: true
    startsAt?: true
    endsAt?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithAggregationInput | OfferOrderByWithAggregationInput[]
    by: OfferScalarFieldEnum[] | OfferScalarFieldEnum
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }

  export type OfferGroupByOutputType = {
    id: string
    name: string
    percentOff: number | null
    amountOffCents: number | null
    duration: string | null
    durationMonths: number | null
    appliesToPlanId: string | null
    startsAt: Date | null
    endsAt: Date | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    duration?: boolean
    durationMonths?: boolean
    appliesToPlanId?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appliesToPlan?: boolean | Offer$appliesToPlanArgs<ExtArgs>
    invites?: boolean | Offer$invitesArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    duration?: boolean
    durationMonths?: boolean
    appliesToPlanId?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appliesToPlan?: boolean | Offer$appliesToPlanArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    duration?: boolean
    durationMonths?: boolean
    appliesToPlanId?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appliesToPlan?: boolean | Offer$appliesToPlanArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectScalar = {
    id?: boolean
    name?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    duration?: boolean
    durationMonths?: boolean
    appliesToPlanId?: boolean
    startsAt?: boolean
    endsAt?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "percentOff" | "amountOffCents" | "duration" | "durationMonths" | "appliesToPlanId" | "startsAt" | "endsAt" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["offer"]>
  export type OfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appliesToPlan?: boolean | Offer$appliesToPlanArgs<ExtArgs>
    invites?: boolean | Offer$invitesArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appliesToPlan?: boolean | Offer$appliesToPlanArgs<ExtArgs>
  }
  export type OfferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appliesToPlan?: boolean | Offer$appliesToPlanArgs<ExtArgs>
  }

  export type $OfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Offer"
    objects: {
      appliesToPlan: Prisma.$PricePlanPayload<ExtArgs> | null
      invites: Prisma.$OnboardingInvitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      percentOff: number | null
      amountOffCents: number | null
      duration: string | null
      durationMonths: number | null
      appliesToPlanId: string | null
      startsAt: Date | null
      endsAt: Date | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["offer"]>
    composites: {}
  }

  type OfferGetPayload<S extends boolean | null | undefined | OfferDefaultArgs> = $Result.GetResult<Prisma.$OfferPayload, S>

  type OfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offer'], meta: { name: 'Offer' } }
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferFindUniqueArgs>(args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Offer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferFindFirstArgs>(args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferFindManyArgs>(args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
     */
    create<T extends OfferCreateArgs>(args: SelectSubset<T, OfferCreateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Offers.
     * @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferCreateManyArgs>(args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Offers and returns the data saved in the database.
     * @param {OfferCreateManyAndReturnArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
     */
    delete<T extends OfferDeleteArgs>(args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferUpdateArgs>(args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferDeleteManyArgs>(args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferUpdateManyArgs>(args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers and returns the data updated in the database.
     * @param {OfferUpdateManyAndReturnArgs} args - Arguments to update many Offers.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OfferUpdateManyAndReturnArgs>(args: SelectSubset<T, OfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
     */
    upsert<T extends OfferUpsertArgs>(args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Offer model
   */
  readonly fields: OfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appliesToPlan<T extends Offer$appliesToPlanArgs<ExtArgs> = {}>(args?: Subset<T, Offer$appliesToPlanArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invites<T extends Offer$invitesArgs<ExtArgs> = {}>(args?: Subset<T, Offer$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Offer model
   */
  interface OfferFieldRefs {
    readonly id: FieldRef<"Offer", 'String'>
    readonly name: FieldRef<"Offer", 'String'>
    readonly percentOff: FieldRef<"Offer", 'Int'>
    readonly amountOffCents: FieldRef<"Offer", 'Int'>
    readonly duration: FieldRef<"Offer", 'String'>
    readonly durationMonths: FieldRef<"Offer", 'Int'>
    readonly appliesToPlanId: FieldRef<"Offer", 'String'>
    readonly startsAt: FieldRef<"Offer", 'DateTime'>
    readonly endsAt: FieldRef<"Offer", 'DateTime'>
    readonly active: FieldRef<"Offer", 'Boolean'>
    readonly createdAt: FieldRef<"Offer", 'DateTime'>
    readonly updatedAt: FieldRef<"Offer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer create
   */
  export type OfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }

  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Offer createManyAndReturn
   */
  export type OfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer update
   */
  export type OfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to update.
     */
    limit?: number
  }

  /**
   * Offer updateManyAndReturn
   */
  export type OfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }

  /**
   * Offer delete
   */
  export type OfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to delete.
     */
    limit?: number
  }

  /**
   * Offer.appliesToPlan
   */
  export type Offer$appliesToPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    where?: PricePlanWhereInput
  }

  /**
   * Offer.invites
   */
  export type Offer$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    where?: OnboardingInviteWhereInput
    orderBy?: OnboardingInviteOrderByWithRelationInput | OnboardingInviteOrderByWithRelationInput[]
    cursor?: OnboardingInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnboardingInviteScalarFieldEnum | OnboardingInviteScalarFieldEnum[]
  }

  /**
   * Offer without action
   */
  export type OfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    percentOff: number | null
    amountOffCents: number | null
    durationMonths: number | null
    maxRedemptions: number | null
  }

  export type CouponSumAggregateOutputType = {
    percentOff: number | null
    amountOffCents: number | null
    durationMonths: number | null
    maxRedemptions: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    percentOff: number | null
    amountOffCents: number | null
    duration: string | null
    durationMonths: number | null
    startsAt: Date | null
    endsAt: Date | null
    maxRedemptions: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    percentOff: number | null
    amountOffCents: number | null
    duration: string | null
    durationMonths: number | null
    startsAt: Date | null
    endsAt: Date | null
    maxRedemptions: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    code: number
    name: number
    percentOff: number
    amountOffCents: number
    duration: number
    durationMonths: number
    startsAt: number
    endsAt: number
    maxRedemptions: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    percentOff?: true
    amountOffCents?: true
    durationMonths?: true
    maxRedemptions?: true
  }

  export type CouponSumAggregateInputType = {
    percentOff?: true
    amountOffCents?: true
    durationMonths?: true
    maxRedemptions?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    percentOff?: true
    amountOffCents?: true
    duration?: true
    durationMonths?: true
    startsAt?: true
    endsAt?: true
    maxRedemptions?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    percentOff?: true
    amountOffCents?: true
    duration?: true
    durationMonths?: true
    startsAt?: true
    endsAt?: true
    maxRedemptions?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    percentOff?: true
    amountOffCents?: true
    duration?: true
    durationMonths?: true
    startsAt?: true
    endsAt?: true
    maxRedemptions?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    code: string
    name: string | null
    percentOff: number | null
    amountOffCents: number | null
    duration: string | null
    durationMonths: number | null
    startsAt: Date | null
    endsAt: Date | null
    maxRedemptions: number | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    duration?: boolean
    durationMonths?: boolean
    startsAt?: boolean
    endsAt?: boolean
    maxRedemptions?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invites?: boolean | Coupon$invitesArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    duration?: boolean
    durationMonths?: boolean
    startsAt?: boolean
    endsAt?: boolean
    maxRedemptions?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    duration?: boolean
    durationMonths?: boolean
    startsAt?: boolean
    endsAt?: boolean
    maxRedemptions?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    duration?: boolean
    durationMonths?: boolean
    startsAt?: boolean
    endsAt?: boolean
    maxRedemptions?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "percentOff" | "amountOffCents" | "duration" | "durationMonths" | "startsAt" | "endsAt" | "maxRedemptions" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["coupon"]>
  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invites?: boolean | Coupon$invitesArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      invites: Prisma.$OnboardingInvitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string | null
      percentOff: number | null
      amountOffCents: number | null
      duration: string | null
      durationMonths: number | null
      startsAt: Date | null
      endsAt: Date | null
      maxRedemptions: number | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {CouponUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CouponUpdateManyAndReturnArgs>(args: SelectSubset<T, CouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invites<T extends Coupon$invitesArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'String'>
    readonly code: FieldRef<"Coupon", 'String'>
    readonly name: FieldRef<"Coupon", 'String'>
    readonly percentOff: FieldRef<"Coupon", 'Int'>
    readonly amountOffCents: FieldRef<"Coupon", 'Int'>
    readonly duration: FieldRef<"Coupon", 'String'>
    readonly durationMonths: FieldRef<"Coupon", 'Int'>
    readonly startsAt: FieldRef<"Coupon", 'DateTime'>
    readonly endsAt: FieldRef<"Coupon", 'DateTime'>
    readonly maxRedemptions: FieldRef<"Coupon", 'Int'>
    readonly active: FieldRef<"Coupon", 'Boolean'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
    readonly updatedAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon updateManyAndReturn
   */
  export type CouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number
  }

  /**
   * Coupon.invites
   */
  export type Coupon$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    where?: OnboardingInviteWhereInput
    orderBy?: OnboardingInviteOrderByWithRelationInput | OnboardingInviteOrderByWithRelationInput[]
    cursor?: OnboardingInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnboardingInviteScalarFieldEnum | OnboardingInviteScalarFieldEnum[]
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Model TenantPriceOverride
   */

  export type AggregateTenantPriceOverride = {
    _count: TenantPriceOverrideCountAggregateOutputType | null
    _avg: TenantPriceOverrideAvgAggregateOutputType | null
    _sum: TenantPriceOverrideSumAggregateOutputType | null
    _min: TenantPriceOverrideMinAggregateOutputType | null
    _max: TenantPriceOverrideMaxAggregateOutputType | null
  }

  export type TenantPriceOverrideAvgAggregateOutputType = {
    percentOff: number | null
    amountOffCents: number | null
    priceCents: number | null
  }

  export type TenantPriceOverrideSumAggregateOutputType = {
    percentOff: number | null
    amountOffCents: number | null
    priceCents: number | null
  }

  export type TenantPriceOverrideMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    planId: string | null
    priceId: string | null
    type: $Enums.OverrideType | null
    percentOff: number | null
    amountOffCents: number | null
    priceCents: number | null
    startsAt: Date | null
    endsAt: Date | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantPriceOverrideMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    planId: string | null
    priceId: string | null
    type: $Enums.OverrideType | null
    percentOff: number | null
    amountOffCents: number | null
    priceCents: number | null
    startsAt: Date | null
    endsAt: Date | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantPriceOverrideCountAggregateOutputType = {
    id: number
    orgId: number
    planId: number
    priceId: number
    type: number
    percentOff: number
    amountOffCents: number
    priceCents: number
    startsAt: number
    endsAt: number
    reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantPriceOverrideAvgAggregateInputType = {
    percentOff?: true
    amountOffCents?: true
    priceCents?: true
  }

  export type TenantPriceOverrideSumAggregateInputType = {
    percentOff?: true
    amountOffCents?: true
    priceCents?: true
  }

  export type TenantPriceOverrideMinAggregateInputType = {
    id?: true
    orgId?: true
    planId?: true
    priceId?: true
    type?: true
    percentOff?: true
    amountOffCents?: true
    priceCents?: true
    startsAt?: true
    endsAt?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantPriceOverrideMaxAggregateInputType = {
    id?: true
    orgId?: true
    planId?: true
    priceId?: true
    type?: true
    percentOff?: true
    amountOffCents?: true
    priceCents?: true
    startsAt?: true
    endsAt?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantPriceOverrideCountAggregateInputType = {
    id?: true
    orgId?: true
    planId?: true
    priceId?: true
    type?: true
    percentOff?: true
    amountOffCents?: true
    priceCents?: true
    startsAt?: true
    endsAt?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantPriceOverrideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantPriceOverride to aggregate.
     */
    where?: TenantPriceOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantPriceOverrides to fetch.
     */
    orderBy?: TenantPriceOverrideOrderByWithRelationInput | TenantPriceOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantPriceOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantPriceOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantPriceOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantPriceOverrides
    **/
    _count?: true | TenantPriceOverrideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantPriceOverrideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantPriceOverrideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantPriceOverrideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantPriceOverrideMaxAggregateInputType
  }

  export type GetTenantPriceOverrideAggregateType<T extends TenantPriceOverrideAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantPriceOverride]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantPriceOverride[P]>
      : GetScalarType<T[P], AggregateTenantPriceOverride[P]>
  }




  export type TenantPriceOverrideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantPriceOverrideWhereInput
    orderBy?: TenantPriceOverrideOrderByWithAggregationInput | TenantPriceOverrideOrderByWithAggregationInput[]
    by: TenantPriceOverrideScalarFieldEnum[] | TenantPriceOverrideScalarFieldEnum
    having?: TenantPriceOverrideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantPriceOverrideCountAggregateInputType | true
    _avg?: TenantPriceOverrideAvgAggregateInputType
    _sum?: TenantPriceOverrideSumAggregateInputType
    _min?: TenantPriceOverrideMinAggregateInputType
    _max?: TenantPriceOverrideMaxAggregateInputType
  }

  export type TenantPriceOverrideGroupByOutputType = {
    id: string
    orgId: string
    planId: string | null
    priceId: string | null
    type: $Enums.OverrideType
    percentOff: number | null
    amountOffCents: number | null
    priceCents: number | null
    startsAt: Date | null
    endsAt: Date | null
    reason: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantPriceOverrideCountAggregateOutputType | null
    _avg: TenantPriceOverrideAvgAggregateOutputType | null
    _sum: TenantPriceOverrideSumAggregateOutputType | null
    _min: TenantPriceOverrideMinAggregateOutputType | null
    _max: TenantPriceOverrideMaxAggregateOutputType | null
  }

  type GetTenantPriceOverrideGroupByPayload<T extends TenantPriceOverrideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantPriceOverrideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantPriceOverrideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantPriceOverrideGroupByOutputType[P]>
            : GetScalarType<T[P], TenantPriceOverrideGroupByOutputType[P]>
        }
      >
    >


  export type TenantPriceOverrideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    planId?: boolean
    priceId?: boolean
    type?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    priceCents?: boolean
    startsAt?: boolean
    endsAt?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
    plan?: boolean | TenantPriceOverride$planArgs<ExtArgs>
    price?: boolean | TenantPriceOverride$priceArgs<ExtArgs>
  }, ExtArgs["result"]["tenantPriceOverride"]>

  export type TenantPriceOverrideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    planId?: boolean
    priceId?: boolean
    type?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    priceCents?: boolean
    startsAt?: boolean
    endsAt?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
    plan?: boolean | TenantPriceOverride$planArgs<ExtArgs>
    price?: boolean | TenantPriceOverride$priceArgs<ExtArgs>
  }, ExtArgs["result"]["tenantPriceOverride"]>

  export type TenantPriceOverrideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    planId?: boolean
    priceId?: boolean
    type?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    priceCents?: boolean
    startsAt?: boolean
    endsAt?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
    plan?: boolean | TenantPriceOverride$planArgs<ExtArgs>
    price?: boolean | TenantPriceOverride$priceArgs<ExtArgs>
  }, ExtArgs["result"]["tenantPriceOverride"]>

  export type TenantPriceOverrideSelectScalar = {
    id?: boolean
    orgId?: boolean
    planId?: boolean
    priceId?: boolean
    type?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    priceCents?: boolean
    startsAt?: boolean
    endsAt?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantPriceOverrideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "planId" | "priceId" | "type" | "percentOff" | "amountOffCents" | "priceCents" | "startsAt" | "endsAt" | "reason" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantPriceOverride"]>
  export type TenantPriceOverrideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
    plan?: boolean | TenantPriceOverride$planArgs<ExtArgs>
    price?: boolean | TenantPriceOverride$priceArgs<ExtArgs>
  }
  export type TenantPriceOverrideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
    plan?: boolean | TenantPriceOverride$planArgs<ExtArgs>
    price?: boolean | TenantPriceOverride$priceArgs<ExtArgs>
  }
  export type TenantPriceOverrideIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
    plan?: boolean | TenantPriceOverride$planArgs<ExtArgs>
    price?: boolean | TenantPriceOverride$priceArgs<ExtArgs>
  }

  export type $TenantPriceOverridePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantPriceOverride"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
      plan: Prisma.$PricePlanPayload<ExtArgs> | null
      price: Prisma.$PlanPricePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      planId: string | null
      priceId: string | null
      type: $Enums.OverrideType
      percentOff: number | null
      amountOffCents: number | null
      priceCents: number | null
      startsAt: Date | null
      endsAt: Date | null
      reason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantPriceOverride"]>
    composites: {}
  }

  type TenantPriceOverrideGetPayload<S extends boolean | null | undefined | TenantPriceOverrideDefaultArgs> = $Result.GetResult<Prisma.$TenantPriceOverridePayload, S>

  type TenantPriceOverrideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantPriceOverrideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantPriceOverrideCountAggregateInputType | true
    }

  export interface TenantPriceOverrideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantPriceOverride'], meta: { name: 'TenantPriceOverride' } }
    /**
     * Find zero or one TenantPriceOverride that matches the filter.
     * @param {TenantPriceOverrideFindUniqueArgs} args - Arguments to find a TenantPriceOverride
     * @example
     * // Get one TenantPriceOverride
     * const tenantPriceOverride = await prisma.tenantPriceOverride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantPriceOverrideFindUniqueArgs>(args: SelectSubset<T, TenantPriceOverrideFindUniqueArgs<ExtArgs>>): Prisma__TenantPriceOverrideClient<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantPriceOverride that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantPriceOverrideFindUniqueOrThrowArgs} args - Arguments to find a TenantPriceOverride
     * @example
     * // Get one TenantPriceOverride
     * const tenantPriceOverride = await prisma.tenantPriceOverride.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantPriceOverrideFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantPriceOverrideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantPriceOverrideClient<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantPriceOverride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantPriceOverrideFindFirstArgs} args - Arguments to find a TenantPriceOverride
     * @example
     * // Get one TenantPriceOverride
     * const tenantPriceOverride = await prisma.tenantPriceOverride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantPriceOverrideFindFirstArgs>(args?: SelectSubset<T, TenantPriceOverrideFindFirstArgs<ExtArgs>>): Prisma__TenantPriceOverrideClient<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantPriceOverride that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantPriceOverrideFindFirstOrThrowArgs} args - Arguments to find a TenantPriceOverride
     * @example
     * // Get one TenantPriceOverride
     * const tenantPriceOverride = await prisma.tenantPriceOverride.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantPriceOverrideFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantPriceOverrideFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantPriceOverrideClient<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantPriceOverrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantPriceOverrideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantPriceOverrides
     * const tenantPriceOverrides = await prisma.tenantPriceOverride.findMany()
     * 
     * // Get first 10 TenantPriceOverrides
     * const tenantPriceOverrides = await prisma.tenantPriceOverride.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantPriceOverrideWithIdOnly = await prisma.tenantPriceOverride.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantPriceOverrideFindManyArgs>(args?: SelectSubset<T, TenantPriceOverrideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantPriceOverride.
     * @param {TenantPriceOverrideCreateArgs} args - Arguments to create a TenantPriceOverride.
     * @example
     * // Create one TenantPriceOverride
     * const TenantPriceOverride = await prisma.tenantPriceOverride.create({
     *   data: {
     *     // ... data to create a TenantPriceOverride
     *   }
     * })
     * 
     */
    create<T extends TenantPriceOverrideCreateArgs>(args: SelectSubset<T, TenantPriceOverrideCreateArgs<ExtArgs>>): Prisma__TenantPriceOverrideClient<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantPriceOverrides.
     * @param {TenantPriceOverrideCreateManyArgs} args - Arguments to create many TenantPriceOverrides.
     * @example
     * // Create many TenantPriceOverrides
     * const tenantPriceOverride = await prisma.tenantPriceOverride.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantPriceOverrideCreateManyArgs>(args?: SelectSubset<T, TenantPriceOverrideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantPriceOverrides and returns the data saved in the database.
     * @param {TenantPriceOverrideCreateManyAndReturnArgs} args - Arguments to create many TenantPriceOverrides.
     * @example
     * // Create many TenantPriceOverrides
     * const tenantPriceOverride = await prisma.tenantPriceOverride.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantPriceOverrides and only return the `id`
     * const tenantPriceOverrideWithIdOnly = await prisma.tenantPriceOverride.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantPriceOverrideCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantPriceOverrideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantPriceOverride.
     * @param {TenantPriceOverrideDeleteArgs} args - Arguments to delete one TenantPriceOverride.
     * @example
     * // Delete one TenantPriceOverride
     * const TenantPriceOverride = await prisma.tenantPriceOverride.delete({
     *   where: {
     *     // ... filter to delete one TenantPriceOverride
     *   }
     * })
     * 
     */
    delete<T extends TenantPriceOverrideDeleteArgs>(args: SelectSubset<T, TenantPriceOverrideDeleteArgs<ExtArgs>>): Prisma__TenantPriceOverrideClient<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantPriceOverride.
     * @param {TenantPriceOverrideUpdateArgs} args - Arguments to update one TenantPriceOverride.
     * @example
     * // Update one TenantPriceOverride
     * const tenantPriceOverride = await prisma.tenantPriceOverride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantPriceOverrideUpdateArgs>(args: SelectSubset<T, TenantPriceOverrideUpdateArgs<ExtArgs>>): Prisma__TenantPriceOverrideClient<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantPriceOverrides.
     * @param {TenantPriceOverrideDeleteManyArgs} args - Arguments to filter TenantPriceOverrides to delete.
     * @example
     * // Delete a few TenantPriceOverrides
     * const { count } = await prisma.tenantPriceOverride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantPriceOverrideDeleteManyArgs>(args?: SelectSubset<T, TenantPriceOverrideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantPriceOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantPriceOverrideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantPriceOverrides
     * const tenantPriceOverride = await prisma.tenantPriceOverride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantPriceOverrideUpdateManyArgs>(args: SelectSubset<T, TenantPriceOverrideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantPriceOverrides and returns the data updated in the database.
     * @param {TenantPriceOverrideUpdateManyAndReturnArgs} args - Arguments to update many TenantPriceOverrides.
     * @example
     * // Update many TenantPriceOverrides
     * const tenantPriceOverride = await prisma.tenantPriceOverride.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantPriceOverrides and only return the `id`
     * const tenantPriceOverrideWithIdOnly = await prisma.tenantPriceOverride.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantPriceOverrideUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantPriceOverrideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantPriceOverride.
     * @param {TenantPriceOverrideUpsertArgs} args - Arguments to update or create a TenantPriceOverride.
     * @example
     * // Update or create a TenantPriceOverride
     * const tenantPriceOverride = await prisma.tenantPriceOverride.upsert({
     *   create: {
     *     // ... data to create a TenantPriceOverride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantPriceOverride we want to update
     *   }
     * })
     */
    upsert<T extends TenantPriceOverrideUpsertArgs>(args: SelectSubset<T, TenantPriceOverrideUpsertArgs<ExtArgs>>): Prisma__TenantPriceOverrideClient<$Result.GetResult<Prisma.$TenantPriceOverridePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantPriceOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantPriceOverrideCountArgs} args - Arguments to filter TenantPriceOverrides to count.
     * @example
     * // Count the number of TenantPriceOverrides
     * const count = await prisma.tenantPriceOverride.count({
     *   where: {
     *     // ... the filter for the TenantPriceOverrides we want to count
     *   }
     * })
    **/
    count<T extends TenantPriceOverrideCountArgs>(
      args?: Subset<T, TenantPriceOverrideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantPriceOverrideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantPriceOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantPriceOverrideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantPriceOverrideAggregateArgs>(args: Subset<T, TenantPriceOverrideAggregateArgs>): Prisma.PrismaPromise<GetTenantPriceOverrideAggregateType<T>>

    /**
     * Group by TenantPriceOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantPriceOverrideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantPriceOverrideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantPriceOverrideGroupByArgs['orderBy'] }
        : { orderBy?: TenantPriceOverrideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantPriceOverrideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantPriceOverrideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantPriceOverride model
   */
  readonly fields: TenantPriceOverrideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantPriceOverride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantPriceOverrideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends TenantPriceOverride$planArgs<ExtArgs> = {}>(args?: Subset<T, TenantPriceOverride$planArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    price<T extends TenantPriceOverride$priceArgs<ExtArgs> = {}>(args?: Subset<T, TenantPriceOverride$priceArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantPriceOverride model
   */
  interface TenantPriceOverrideFieldRefs {
    readonly id: FieldRef<"TenantPriceOverride", 'String'>
    readonly orgId: FieldRef<"TenantPriceOverride", 'String'>
    readonly planId: FieldRef<"TenantPriceOverride", 'String'>
    readonly priceId: FieldRef<"TenantPriceOverride", 'String'>
    readonly type: FieldRef<"TenantPriceOverride", 'OverrideType'>
    readonly percentOff: FieldRef<"TenantPriceOverride", 'Int'>
    readonly amountOffCents: FieldRef<"TenantPriceOverride", 'Int'>
    readonly priceCents: FieldRef<"TenantPriceOverride", 'Int'>
    readonly startsAt: FieldRef<"TenantPriceOverride", 'DateTime'>
    readonly endsAt: FieldRef<"TenantPriceOverride", 'DateTime'>
    readonly reason: FieldRef<"TenantPriceOverride", 'String'>
    readonly createdAt: FieldRef<"TenantPriceOverride", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantPriceOverride", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantPriceOverride findUnique
   */
  export type TenantPriceOverrideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    /**
     * Filter, which TenantPriceOverride to fetch.
     */
    where: TenantPriceOverrideWhereUniqueInput
  }

  /**
   * TenantPriceOverride findUniqueOrThrow
   */
  export type TenantPriceOverrideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    /**
     * Filter, which TenantPriceOverride to fetch.
     */
    where: TenantPriceOverrideWhereUniqueInput
  }

  /**
   * TenantPriceOverride findFirst
   */
  export type TenantPriceOverrideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    /**
     * Filter, which TenantPriceOverride to fetch.
     */
    where?: TenantPriceOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantPriceOverrides to fetch.
     */
    orderBy?: TenantPriceOverrideOrderByWithRelationInput | TenantPriceOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantPriceOverrides.
     */
    cursor?: TenantPriceOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantPriceOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantPriceOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantPriceOverrides.
     */
    distinct?: TenantPriceOverrideScalarFieldEnum | TenantPriceOverrideScalarFieldEnum[]
  }

  /**
   * TenantPriceOverride findFirstOrThrow
   */
  export type TenantPriceOverrideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    /**
     * Filter, which TenantPriceOverride to fetch.
     */
    where?: TenantPriceOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantPriceOverrides to fetch.
     */
    orderBy?: TenantPriceOverrideOrderByWithRelationInput | TenantPriceOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantPriceOverrides.
     */
    cursor?: TenantPriceOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantPriceOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantPriceOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantPriceOverrides.
     */
    distinct?: TenantPriceOverrideScalarFieldEnum | TenantPriceOverrideScalarFieldEnum[]
  }

  /**
   * TenantPriceOverride findMany
   */
  export type TenantPriceOverrideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    /**
     * Filter, which TenantPriceOverrides to fetch.
     */
    where?: TenantPriceOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantPriceOverrides to fetch.
     */
    orderBy?: TenantPriceOverrideOrderByWithRelationInput | TenantPriceOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantPriceOverrides.
     */
    cursor?: TenantPriceOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantPriceOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantPriceOverrides.
     */
    skip?: number
    distinct?: TenantPriceOverrideScalarFieldEnum | TenantPriceOverrideScalarFieldEnum[]
  }

  /**
   * TenantPriceOverride create
   */
  export type TenantPriceOverrideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantPriceOverride.
     */
    data: XOR<TenantPriceOverrideCreateInput, TenantPriceOverrideUncheckedCreateInput>
  }

  /**
   * TenantPriceOverride createMany
   */
  export type TenantPriceOverrideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantPriceOverrides.
     */
    data: TenantPriceOverrideCreateManyInput | TenantPriceOverrideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantPriceOverride createManyAndReturn
   */
  export type TenantPriceOverrideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * The data used to create many TenantPriceOverrides.
     */
    data: TenantPriceOverrideCreateManyInput | TenantPriceOverrideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantPriceOverride update
   */
  export type TenantPriceOverrideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantPriceOverride.
     */
    data: XOR<TenantPriceOverrideUpdateInput, TenantPriceOverrideUncheckedUpdateInput>
    /**
     * Choose, which TenantPriceOverride to update.
     */
    where: TenantPriceOverrideWhereUniqueInput
  }

  /**
   * TenantPriceOverride updateMany
   */
  export type TenantPriceOverrideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantPriceOverrides.
     */
    data: XOR<TenantPriceOverrideUpdateManyMutationInput, TenantPriceOverrideUncheckedUpdateManyInput>
    /**
     * Filter which TenantPriceOverrides to update
     */
    where?: TenantPriceOverrideWhereInput
    /**
     * Limit how many TenantPriceOverrides to update.
     */
    limit?: number
  }

  /**
   * TenantPriceOverride updateManyAndReturn
   */
  export type TenantPriceOverrideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * The data used to update TenantPriceOverrides.
     */
    data: XOR<TenantPriceOverrideUpdateManyMutationInput, TenantPriceOverrideUncheckedUpdateManyInput>
    /**
     * Filter which TenantPriceOverrides to update
     */
    where?: TenantPriceOverrideWhereInput
    /**
     * Limit how many TenantPriceOverrides to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantPriceOverride upsert
   */
  export type TenantPriceOverrideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantPriceOverride to update in case it exists.
     */
    where: TenantPriceOverrideWhereUniqueInput
    /**
     * In case the TenantPriceOverride found by the `where` argument doesn't exist, create a new TenantPriceOverride with this data.
     */
    create: XOR<TenantPriceOverrideCreateInput, TenantPriceOverrideUncheckedCreateInput>
    /**
     * In case the TenantPriceOverride was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantPriceOverrideUpdateInput, TenantPriceOverrideUncheckedUpdateInput>
  }

  /**
   * TenantPriceOverride delete
   */
  export type TenantPriceOverrideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
    /**
     * Filter which TenantPriceOverride to delete.
     */
    where: TenantPriceOverrideWhereUniqueInput
  }

  /**
   * TenantPriceOverride deleteMany
   */
  export type TenantPriceOverrideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantPriceOverrides to delete
     */
    where?: TenantPriceOverrideWhereInput
    /**
     * Limit how many TenantPriceOverrides to delete.
     */
    limit?: number
  }

  /**
   * TenantPriceOverride.plan
   */
  export type TenantPriceOverride$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    where?: PricePlanWhereInput
  }

  /**
   * TenantPriceOverride.price
   */
  export type TenantPriceOverride$priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    where?: PlanPriceWhereInput
  }

  /**
   * TenantPriceOverride without action
   */
  export type TenantPriceOverrideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantPriceOverride
     */
    select?: TenantPriceOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantPriceOverride
     */
    omit?: TenantPriceOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantPriceOverrideInclude<ExtArgs> | null
  }


  /**
   * Model GlobalMonetizationConfig
   */

  export type AggregateGlobalMonetizationConfig = {
    _count: GlobalMonetizationConfigCountAggregateOutputType | null
    _avg: GlobalMonetizationConfigAvgAggregateOutputType | null
    _sum: GlobalMonetizationConfigSumAggregateOutputType | null
    _min: GlobalMonetizationConfigMinAggregateOutputType | null
    _max: GlobalMonetizationConfigMaxAggregateOutputType | null
  }

  export type GlobalMonetizationConfigAvgAggregateOutputType = {
    defaultTrialDays: number | null
  }

  export type GlobalMonetizationConfigSumAggregateOutputType = {
    defaultTrialDays: number | null
  }

  export type GlobalMonetizationConfigMinAggregateOutputType = {
    id: string | null
    defaultPlanId: string | null
    defaultPriceId: string | null
    defaultTrialDays: number | null
    publicOnboarding: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalMonetizationConfigMaxAggregateOutputType = {
    id: string | null
    defaultPlanId: string | null
    defaultPriceId: string | null
    defaultTrialDays: number | null
    publicOnboarding: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalMonetizationConfigCountAggregateOutputType = {
    id: number
    defaultPlanId: number
    defaultPriceId: number
    defaultTrialDays: number
    publicOnboarding: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GlobalMonetizationConfigAvgAggregateInputType = {
    defaultTrialDays?: true
  }

  export type GlobalMonetizationConfigSumAggregateInputType = {
    defaultTrialDays?: true
  }

  export type GlobalMonetizationConfigMinAggregateInputType = {
    id?: true
    defaultPlanId?: true
    defaultPriceId?: true
    defaultTrialDays?: true
    publicOnboarding?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalMonetizationConfigMaxAggregateInputType = {
    id?: true
    defaultPlanId?: true
    defaultPriceId?: true
    defaultTrialDays?: true
    publicOnboarding?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalMonetizationConfigCountAggregateInputType = {
    id?: true
    defaultPlanId?: true
    defaultPriceId?: true
    defaultTrialDays?: true
    publicOnboarding?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GlobalMonetizationConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalMonetizationConfig to aggregate.
     */
    where?: GlobalMonetizationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalMonetizationConfigs to fetch.
     */
    orderBy?: GlobalMonetizationConfigOrderByWithRelationInput | GlobalMonetizationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlobalMonetizationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalMonetizationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalMonetizationConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlobalMonetizationConfigs
    **/
    _count?: true | GlobalMonetizationConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GlobalMonetizationConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GlobalMonetizationConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalMonetizationConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalMonetizationConfigMaxAggregateInputType
  }

  export type GetGlobalMonetizationConfigAggregateType<T extends GlobalMonetizationConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobalMonetizationConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobalMonetizationConfig[P]>
      : GetScalarType<T[P], AggregateGlobalMonetizationConfig[P]>
  }




  export type GlobalMonetizationConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlobalMonetizationConfigWhereInput
    orderBy?: GlobalMonetizationConfigOrderByWithAggregationInput | GlobalMonetizationConfigOrderByWithAggregationInput[]
    by: GlobalMonetizationConfigScalarFieldEnum[] | GlobalMonetizationConfigScalarFieldEnum
    having?: GlobalMonetizationConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalMonetizationConfigCountAggregateInputType | true
    _avg?: GlobalMonetizationConfigAvgAggregateInputType
    _sum?: GlobalMonetizationConfigSumAggregateInputType
    _min?: GlobalMonetizationConfigMinAggregateInputType
    _max?: GlobalMonetizationConfigMaxAggregateInputType
  }

  export type GlobalMonetizationConfigGroupByOutputType = {
    id: string
    defaultPlanId: string | null
    defaultPriceId: string | null
    defaultTrialDays: number | null
    publicOnboarding: boolean
    createdAt: Date
    updatedAt: Date
    _count: GlobalMonetizationConfigCountAggregateOutputType | null
    _avg: GlobalMonetizationConfigAvgAggregateOutputType | null
    _sum: GlobalMonetizationConfigSumAggregateOutputType | null
    _min: GlobalMonetizationConfigMinAggregateOutputType | null
    _max: GlobalMonetizationConfigMaxAggregateOutputType | null
  }

  type GetGlobalMonetizationConfigGroupByPayload<T extends GlobalMonetizationConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlobalMonetizationConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalMonetizationConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalMonetizationConfigGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalMonetizationConfigGroupByOutputType[P]>
        }
      >
    >


  export type GlobalMonetizationConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defaultPlanId?: boolean
    defaultPriceId?: boolean
    defaultTrialDays?: boolean
    publicOnboarding?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultPlan?: boolean | GlobalMonetizationConfig$defaultPlanArgs<ExtArgs>
    defaultPrice?: boolean | GlobalMonetizationConfig$defaultPriceArgs<ExtArgs>
  }, ExtArgs["result"]["globalMonetizationConfig"]>

  export type GlobalMonetizationConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defaultPlanId?: boolean
    defaultPriceId?: boolean
    defaultTrialDays?: boolean
    publicOnboarding?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultPlan?: boolean | GlobalMonetizationConfig$defaultPlanArgs<ExtArgs>
    defaultPrice?: boolean | GlobalMonetizationConfig$defaultPriceArgs<ExtArgs>
  }, ExtArgs["result"]["globalMonetizationConfig"]>

  export type GlobalMonetizationConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defaultPlanId?: boolean
    defaultPriceId?: boolean
    defaultTrialDays?: boolean
    publicOnboarding?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultPlan?: boolean | GlobalMonetizationConfig$defaultPlanArgs<ExtArgs>
    defaultPrice?: boolean | GlobalMonetizationConfig$defaultPriceArgs<ExtArgs>
  }, ExtArgs["result"]["globalMonetizationConfig"]>

  export type GlobalMonetizationConfigSelectScalar = {
    id?: boolean
    defaultPlanId?: boolean
    defaultPriceId?: boolean
    defaultTrialDays?: boolean
    publicOnboarding?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GlobalMonetizationConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "defaultPlanId" | "defaultPriceId" | "defaultTrialDays" | "publicOnboarding" | "createdAt" | "updatedAt", ExtArgs["result"]["globalMonetizationConfig"]>
  export type GlobalMonetizationConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultPlan?: boolean | GlobalMonetizationConfig$defaultPlanArgs<ExtArgs>
    defaultPrice?: boolean | GlobalMonetizationConfig$defaultPriceArgs<ExtArgs>
  }
  export type GlobalMonetizationConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultPlan?: boolean | GlobalMonetizationConfig$defaultPlanArgs<ExtArgs>
    defaultPrice?: boolean | GlobalMonetizationConfig$defaultPriceArgs<ExtArgs>
  }
  export type GlobalMonetizationConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultPlan?: boolean | GlobalMonetizationConfig$defaultPlanArgs<ExtArgs>
    defaultPrice?: boolean | GlobalMonetizationConfig$defaultPriceArgs<ExtArgs>
  }

  export type $GlobalMonetizationConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GlobalMonetizationConfig"
    objects: {
      defaultPlan: Prisma.$PricePlanPayload<ExtArgs> | null
      defaultPrice: Prisma.$PlanPricePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      defaultPlanId: string | null
      defaultPriceId: string | null
      defaultTrialDays: number | null
      publicOnboarding: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["globalMonetizationConfig"]>
    composites: {}
  }

  type GlobalMonetizationConfigGetPayload<S extends boolean | null | undefined | GlobalMonetizationConfigDefaultArgs> = $Result.GetResult<Prisma.$GlobalMonetizationConfigPayload, S>

  type GlobalMonetizationConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GlobalMonetizationConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GlobalMonetizationConfigCountAggregateInputType | true
    }

  export interface GlobalMonetizationConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlobalMonetizationConfig'], meta: { name: 'GlobalMonetizationConfig' } }
    /**
     * Find zero or one GlobalMonetizationConfig that matches the filter.
     * @param {GlobalMonetizationConfigFindUniqueArgs} args - Arguments to find a GlobalMonetizationConfig
     * @example
     * // Get one GlobalMonetizationConfig
     * const globalMonetizationConfig = await prisma.globalMonetizationConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlobalMonetizationConfigFindUniqueArgs>(args: SelectSubset<T, GlobalMonetizationConfigFindUniqueArgs<ExtArgs>>): Prisma__GlobalMonetizationConfigClient<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GlobalMonetizationConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GlobalMonetizationConfigFindUniqueOrThrowArgs} args - Arguments to find a GlobalMonetizationConfig
     * @example
     * // Get one GlobalMonetizationConfig
     * const globalMonetizationConfig = await prisma.globalMonetizationConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlobalMonetizationConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, GlobalMonetizationConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlobalMonetizationConfigClient<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlobalMonetizationConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalMonetizationConfigFindFirstArgs} args - Arguments to find a GlobalMonetizationConfig
     * @example
     * // Get one GlobalMonetizationConfig
     * const globalMonetizationConfig = await prisma.globalMonetizationConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlobalMonetizationConfigFindFirstArgs>(args?: SelectSubset<T, GlobalMonetizationConfigFindFirstArgs<ExtArgs>>): Prisma__GlobalMonetizationConfigClient<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlobalMonetizationConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalMonetizationConfigFindFirstOrThrowArgs} args - Arguments to find a GlobalMonetizationConfig
     * @example
     * // Get one GlobalMonetizationConfig
     * const globalMonetizationConfig = await prisma.globalMonetizationConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlobalMonetizationConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, GlobalMonetizationConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlobalMonetizationConfigClient<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GlobalMonetizationConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalMonetizationConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlobalMonetizationConfigs
     * const globalMonetizationConfigs = await prisma.globalMonetizationConfig.findMany()
     * 
     * // Get first 10 GlobalMonetizationConfigs
     * const globalMonetizationConfigs = await prisma.globalMonetizationConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const globalMonetizationConfigWithIdOnly = await prisma.globalMonetizationConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlobalMonetizationConfigFindManyArgs>(args?: SelectSubset<T, GlobalMonetizationConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GlobalMonetizationConfig.
     * @param {GlobalMonetizationConfigCreateArgs} args - Arguments to create a GlobalMonetizationConfig.
     * @example
     * // Create one GlobalMonetizationConfig
     * const GlobalMonetizationConfig = await prisma.globalMonetizationConfig.create({
     *   data: {
     *     // ... data to create a GlobalMonetizationConfig
     *   }
     * })
     * 
     */
    create<T extends GlobalMonetizationConfigCreateArgs>(args: SelectSubset<T, GlobalMonetizationConfigCreateArgs<ExtArgs>>): Prisma__GlobalMonetizationConfigClient<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GlobalMonetizationConfigs.
     * @param {GlobalMonetizationConfigCreateManyArgs} args - Arguments to create many GlobalMonetizationConfigs.
     * @example
     * // Create many GlobalMonetizationConfigs
     * const globalMonetizationConfig = await prisma.globalMonetizationConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlobalMonetizationConfigCreateManyArgs>(args?: SelectSubset<T, GlobalMonetizationConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GlobalMonetizationConfigs and returns the data saved in the database.
     * @param {GlobalMonetizationConfigCreateManyAndReturnArgs} args - Arguments to create many GlobalMonetizationConfigs.
     * @example
     * // Create many GlobalMonetizationConfigs
     * const globalMonetizationConfig = await prisma.globalMonetizationConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GlobalMonetizationConfigs and only return the `id`
     * const globalMonetizationConfigWithIdOnly = await prisma.globalMonetizationConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlobalMonetizationConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, GlobalMonetizationConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GlobalMonetizationConfig.
     * @param {GlobalMonetizationConfigDeleteArgs} args - Arguments to delete one GlobalMonetizationConfig.
     * @example
     * // Delete one GlobalMonetizationConfig
     * const GlobalMonetizationConfig = await prisma.globalMonetizationConfig.delete({
     *   where: {
     *     // ... filter to delete one GlobalMonetizationConfig
     *   }
     * })
     * 
     */
    delete<T extends GlobalMonetizationConfigDeleteArgs>(args: SelectSubset<T, GlobalMonetizationConfigDeleteArgs<ExtArgs>>): Prisma__GlobalMonetizationConfigClient<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GlobalMonetizationConfig.
     * @param {GlobalMonetizationConfigUpdateArgs} args - Arguments to update one GlobalMonetizationConfig.
     * @example
     * // Update one GlobalMonetizationConfig
     * const globalMonetizationConfig = await prisma.globalMonetizationConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlobalMonetizationConfigUpdateArgs>(args: SelectSubset<T, GlobalMonetizationConfigUpdateArgs<ExtArgs>>): Prisma__GlobalMonetizationConfigClient<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GlobalMonetizationConfigs.
     * @param {GlobalMonetizationConfigDeleteManyArgs} args - Arguments to filter GlobalMonetizationConfigs to delete.
     * @example
     * // Delete a few GlobalMonetizationConfigs
     * const { count } = await prisma.globalMonetizationConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlobalMonetizationConfigDeleteManyArgs>(args?: SelectSubset<T, GlobalMonetizationConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalMonetizationConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalMonetizationConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlobalMonetizationConfigs
     * const globalMonetizationConfig = await prisma.globalMonetizationConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlobalMonetizationConfigUpdateManyArgs>(args: SelectSubset<T, GlobalMonetizationConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalMonetizationConfigs and returns the data updated in the database.
     * @param {GlobalMonetizationConfigUpdateManyAndReturnArgs} args - Arguments to update many GlobalMonetizationConfigs.
     * @example
     * // Update many GlobalMonetizationConfigs
     * const globalMonetizationConfig = await prisma.globalMonetizationConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GlobalMonetizationConfigs and only return the `id`
     * const globalMonetizationConfigWithIdOnly = await prisma.globalMonetizationConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GlobalMonetizationConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, GlobalMonetizationConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GlobalMonetizationConfig.
     * @param {GlobalMonetizationConfigUpsertArgs} args - Arguments to update or create a GlobalMonetizationConfig.
     * @example
     * // Update or create a GlobalMonetizationConfig
     * const globalMonetizationConfig = await prisma.globalMonetizationConfig.upsert({
     *   create: {
     *     // ... data to create a GlobalMonetizationConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlobalMonetizationConfig we want to update
     *   }
     * })
     */
    upsert<T extends GlobalMonetizationConfigUpsertArgs>(args: SelectSubset<T, GlobalMonetizationConfigUpsertArgs<ExtArgs>>): Prisma__GlobalMonetizationConfigClient<$Result.GetResult<Prisma.$GlobalMonetizationConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GlobalMonetizationConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalMonetizationConfigCountArgs} args - Arguments to filter GlobalMonetizationConfigs to count.
     * @example
     * // Count the number of GlobalMonetizationConfigs
     * const count = await prisma.globalMonetizationConfig.count({
     *   where: {
     *     // ... the filter for the GlobalMonetizationConfigs we want to count
     *   }
     * })
    **/
    count<T extends GlobalMonetizationConfigCountArgs>(
      args?: Subset<T, GlobalMonetizationConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalMonetizationConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlobalMonetizationConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalMonetizationConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalMonetizationConfigAggregateArgs>(args: Subset<T, GlobalMonetizationConfigAggregateArgs>): Prisma.PrismaPromise<GetGlobalMonetizationConfigAggregateType<T>>

    /**
     * Group by GlobalMonetizationConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalMonetizationConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalMonetizationConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalMonetizationConfigGroupByArgs['orderBy'] }
        : { orderBy?: GlobalMonetizationConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalMonetizationConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalMonetizationConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlobalMonetizationConfig model
   */
  readonly fields: GlobalMonetizationConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlobalMonetizationConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlobalMonetizationConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defaultPlan<T extends GlobalMonetizationConfig$defaultPlanArgs<ExtArgs> = {}>(args?: Subset<T, GlobalMonetizationConfig$defaultPlanArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    defaultPrice<T extends GlobalMonetizationConfig$defaultPriceArgs<ExtArgs> = {}>(args?: Subset<T, GlobalMonetizationConfig$defaultPriceArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GlobalMonetizationConfig model
   */
  interface GlobalMonetizationConfigFieldRefs {
    readonly id: FieldRef<"GlobalMonetizationConfig", 'String'>
    readonly defaultPlanId: FieldRef<"GlobalMonetizationConfig", 'String'>
    readonly defaultPriceId: FieldRef<"GlobalMonetizationConfig", 'String'>
    readonly defaultTrialDays: FieldRef<"GlobalMonetizationConfig", 'Int'>
    readonly publicOnboarding: FieldRef<"GlobalMonetizationConfig", 'Boolean'>
    readonly createdAt: FieldRef<"GlobalMonetizationConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"GlobalMonetizationConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GlobalMonetizationConfig findUnique
   */
  export type GlobalMonetizationConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    /**
     * Filter, which GlobalMonetizationConfig to fetch.
     */
    where: GlobalMonetizationConfigWhereUniqueInput
  }

  /**
   * GlobalMonetizationConfig findUniqueOrThrow
   */
  export type GlobalMonetizationConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    /**
     * Filter, which GlobalMonetizationConfig to fetch.
     */
    where: GlobalMonetizationConfigWhereUniqueInput
  }

  /**
   * GlobalMonetizationConfig findFirst
   */
  export type GlobalMonetizationConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    /**
     * Filter, which GlobalMonetizationConfig to fetch.
     */
    where?: GlobalMonetizationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalMonetizationConfigs to fetch.
     */
    orderBy?: GlobalMonetizationConfigOrderByWithRelationInput | GlobalMonetizationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalMonetizationConfigs.
     */
    cursor?: GlobalMonetizationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalMonetizationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalMonetizationConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalMonetizationConfigs.
     */
    distinct?: GlobalMonetizationConfigScalarFieldEnum | GlobalMonetizationConfigScalarFieldEnum[]
  }

  /**
   * GlobalMonetizationConfig findFirstOrThrow
   */
  export type GlobalMonetizationConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    /**
     * Filter, which GlobalMonetizationConfig to fetch.
     */
    where?: GlobalMonetizationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalMonetizationConfigs to fetch.
     */
    orderBy?: GlobalMonetizationConfigOrderByWithRelationInput | GlobalMonetizationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalMonetizationConfigs.
     */
    cursor?: GlobalMonetizationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalMonetizationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalMonetizationConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalMonetizationConfigs.
     */
    distinct?: GlobalMonetizationConfigScalarFieldEnum | GlobalMonetizationConfigScalarFieldEnum[]
  }

  /**
   * GlobalMonetizationConfig findMany
   */
  export type GlobalMonetizationConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    /**
     * Filter, which GlobalMonetizationConfigs to fetch.
     */
    where?: GlobalMonetizationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalMonetizationConfigs to fetch.
     */
    orderBy?: GlobalMonetizationConfigOrderByWithRelationInput | GlobalMonetizationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlobalMonetizationConfigs.
     */
    cursor?: GlobalMonetizationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalMonetizationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalMonetizationConfigs.
     */
    skip?: number
    distinct?: GlobalMonetizationConfigScalarFieldEnum | GlobalMonetizationConfigScalarFieldEnum[]
  }

  /**
   * GlobalMonetizationConfig create
   */
  export type GlobalMonetizationConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a GlobalMonetizationConfig.
     */
    data: XOR<GlobalMonetizationConfigCreateInput, GlobalMonetizationConfigUncheckedCreateInput>
  }

  /**
   * GlobalMonetizationConfig createMany
   */
  export type GlobalMonetizationConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlobalMonetizationConfigs.
     */
    data: GlobalMonetizationConfigCreateManyInput | GlobalMonetizationConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalMonetizationConfig createManyAndReturn
   */
  export type GlobalMonetizationConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * The data used to create many GlobalMonetizationConfigs.
     */
    data: GlobalMonetizationConfigCreateManyInput | GlobalMonetizationConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GlobalMonetizationConfig update
   */
  export type GlobalMonetizationConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a GlobalMonetizationConfig.
     */
    data: XOR<GlobalMonetizationConfigUpdateInput, GlobalMonetizationConfigUncheckedUpdateInput>
    /**
     * Choose, which GlobalMonetizationConfig to update.
     */
    where: GlobalMonetizationConfigWhereUniqueInput
  }

  /**
   * GlobalMonetizationConfig updateMany
   */
  export type GlobalMonetizationConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlobalMonetizationConfigs.
     */
    data: XOR<GlobalMonetizationConfigUpdateManyMutationInput, GlobalMonetizationConfigUncheckedUpdateManyInput>
    /**
     * Filter which GlobalMonetizationConfigs to update
     */
    where?: GlobalMonetizationConfigWhereInput
    /**
     * Limit how many GlobalMonetizationConfigs to update.
     */
    limit?: number
  }

  /**
   * GlobalMonetizationConfig updateManyAndReturn
   */
  export type GlobalMonetizationConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * The data used to update GlobalMonetizationConfigs.
     */
    data: XOR<GlobalMonetizationConfigUpdateManyMutationInput, GlobalMonetizationConfigUncheckedUpdateManyInput>
    /**
     * Filter which GlobalMonetizationConfigs to update
     */
    where?: GlobalMonetizationConfigWhereInput
    /**
     * Limit how many GlobalMonetizationConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GlobalMonetizationConfig upsert
   */
  export type GlobalMonetizationConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the GlobalMonetizationConfig to update in case it exists.
     */
    where: GlobalMonetizationConfigWhereUniqueInput
    /**
     * In case the GlobalMonetizationConfig found by the `where` argument doesn't exist, create a new GlobalMonetizationConfig with this data.
     */
    create: XOR<GlobalMonetizationConfigCreateInput, GlobalMonetizationConfigUncheckedCreateInput>
    /**
     * In case the GlobalMonetizationConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlobalMonetizationConfigUpdateInput, GlobalMonetizationConfigUncheckedUpdateInput>
  }

  /**
   * GlobalMonetizationConfig delete
   */
  export type GlobalMonetizationConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
    /**
     * Filter which GlobalMonetizationConfig to delete.
     */
    where: GlobalMonetizationConfigWhereUniqueInput
  }

  /**
   * GlobalMonetizationConfig deleteMany
   */
  export type GlobalMonetizationConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalMonetizationConfigs to delete
     */
    where?: GlobalMonetizationConfigWhereInput
    /**
     * Limit how many GlobalMonetizationConfigs to delete.
     */
    limit?: number
  }

  /**
   * GlobalMonetizationConfig.defaultPlan
   */
  export type GlobalMonetizationConfig$defaultPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    where?: PricePlanWhereInput
  }

  /**
   * GlobalMonetizationConfig.defaultPrice
   */
  export type GlobalMonetizationConfig$defaultPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    where?: PlanPriceWhereInput
  }

  /**
   * GlobalMonetizationConfig without action
   */
  export type GlobalMonetizationConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalMonetizationConfig
     */
    select?: GlobalMonetizationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalMonetizationConfig
     */
    omit?: GlobalMonetizationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalMonetizationConfigInclude<ExtArgs> | null
  }


  /**
   * Model OnboardingInvite
   */

  export type AggregateOnboardingInvite = {
    _count: OnboardingInviteCountAggregateOutputType | null
    _avg: OnboardingInviteAvgAggregateOutputType | null
    _sum: OnboardingInviteSumAggregateOutputType | null
    _min: OnboardingInviteMinAggregateOutputType | null
    _max: OnboardingInviteMaxAggregateOutputType | null
  }

  export type OnboardingInviteAvgAggregateOutputType = {
    trialDays: number | null
  }

  export type OnboardingInviteSumAggregateOutputType = {
    trialDays: number | null
  }

  export type OnboardingInviteMinAggregateOutputType = {
    id: string | null
    token: string | null
    email: string | null
    planId: string | null
    priceId: string | null
    offerId: string | null
    couponId: string | null
    trialDays: number | null
    expiresAt: Date | null
    usedAt: Date | null
    note: string | null
    createdAt: Date | null
  }

  export type OnboardingInviteMaxAggregateOutputType = {
    id: string | null
    token: string | null
    email: string | null
    planId: string | null
    priceId: string | null
    offerId: string | null
    couponId: string | null
    trialDays: number | null
    expiresAt: Date | null
    usedAt: Date | null
    note: string | null
    createdAt: Date | null
  }

  export type OnboardingInviteCountAggregateOutputType = {
    id: number
    token: number
    email: number
    planId: number
    priceId: number
    offerId: number
    couponId: number
    trialDays: number
    expiresAt: number
    usedAt: number
    note: number
    createdAt: number
    _all: number
  }


  export type OnboardingInviteAvgAggregateInputType = {
    trialDays?: true
  }

  export type OnboardingInviteSumAggregateInputType = {
    trialDays?: true
  }

  export type OnboardingInviteMinAggregateInputType = {
    id?: true
    token?: true
    email?: true
    planId?: true
    priceId?: true
    offerId?: true
    couponId?: true
    trialDays?: true
    expiresAt?: true
    usedAt?: true
    note?: true
    createdAt?: true
  }

  export type OnboardingInviteMaxAggregateInputType = {
    id?: true
    token?: true
    email?: true
    planId?: true
    priceId?: true
    offerId?: true
    couponId?: true
    trialDays?: true
    expiresAt?: true
    usedAt?: true
    note?: true
    createdAt?: true
  }

  export type OnboardingInviteCountAggregateInputType = {
    id?: true
    token?: true
    email?: true
    planId?: true
    priceId?: true
    offerId?: true
    couponId?: true
    trialDays?: true
    expiresAt?: true
    usedAt?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type OnboardingInviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingInvite to aggregate.
     */
    where?: OnboardingInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingInvites to fetch.
     */
    orderBy?: OnboardingInviteOrderByWithRelationInput | OnboardingInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnboardingInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnboardingInvites
    **/
    _count?: true | OnboardingInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OnboardingInviteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OnboardingInviteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnboardingInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnboardingInviteMaxAggregateInputType
  }

  export type GetOnboardingInviteAggregateType<T extends OnboardingInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateOnboardingInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnboardingInvite[P]>
      : GetScalarType<T[P], AggregateOnboardingInvite[P]>
  }




  export type OnboardingInviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingInviteWhereInput
    orderBy?: OnboardingInviteOrderByWithAggregationInput | OnboardingInviteOrderByWithAggregationInput[]
    by: OnboardingInviteScalarFieldEnum[] | OnboardingInviteScalarFieldEnum
    having?: OnboardingInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnboardingInviteCountAggregateInputType | true
    _avg?: OnboardingInviteAvgAggregateInputType
    _sum?: OnboardingInviteSumAggregateInputType
    _min?: OnboardingInviteMinAggregateInputType
    _max?: OnboardingInviteMaxAggregateInputType
  }

  export type OnboardingInviteGroupByOutputType = {
    id: string
    token: string
    email: string | null
    planId: string | null
    priceId: string | null
    offerId: string | null
    couponId: string | null
    trialDays: number | null
    expiresAt: Date
    usedAt: Date | null
    note: string | null
    createdAt: Date
    _count: OnboardingInviteCountAggregateOutputType | null
    _avg: OnboardingInviteAvgAggregateOutputType | null
    _sum: OnboardingInviteSumAggregateOutputType | null
    _min: OnboardingInviteMinAggregateOutputType | null
    _max: OnboardingInviteMaxAggregateOutputType | null
  }

  type GetOnboardingInviteGroupByPayload<T extends OnboardingInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnboardingInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnboardingInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnboardingInviteGroupByOutputType[P]>
            : GetScalarType<T[P], OnboardingInviteGroupByOutputType[P]>
        }
      >
    >


  export type OnboardingInviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    planId?: boolean
    priceId?: boolean
    offerId?: boolean
    couponId?: boolean
    trialDays?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    note?: boolean
    createdAt?: boolean
    plan?: boolean | OnboardingInvite$planArgs<ExtArgs>
    price?: boolean | OnboardingInvite$priceArgs<ExtArgs>
    offer?: boolean | OnboardingInvite$offerArgs<ExtArgs>
    coupon?: boolean | OnboardingInvite$couponArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingInvite"]>

  export type OnboardingInviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    planId?: boolean
    priceId?: boolean
    offerId?: boolean
    couponId?: boolean
    trialDays?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    note?: boolean
    createdAt?: boolean
    plan?: boolean | OnboardingInvite$planArgs<ExtArgs>
    price?: boolean | OnboardingInvite$priceArgs<ExtArgs>
    offer?: boolean | OnboardingInvite$offerArgs<ExtArgs>
    coupon?: boolean | OnboardingInvite$couponArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingInvite"]>

  export type OnboardingInviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    planId?: boolean
    priceId?: boolean
    offerId?: boolean
    couponId?: boolean
    trialDays?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    note?: boolean
    createdAt?: boolean
    plan?: boolean | OnboardingInvite$planArgs<ExtArgs>
    price?: boolean | OnboardingInvite$priceArgs<ExtArgs>
    offer?: boolean | OnboardingInvite$offerArgs<ExtArgs>
    coupon?: boolean | OnboardingInvite$couponArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingInvite"]>

  export type OnboardingInviteSelectScalar = {
    id?: boolean
    token?: boolean
    email?: boolean
    planId?: boolean
    priceId?: boolean
    offerId?: boolean
    couponId?: boolean
    trialDays?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type OnboardingInviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "email" | "planId" | "priceId" | "offerId" | "couponId" | "trialDays" | "expiresAt" | "usedAt" | "note" | "createdAt", ExtArgs["result"]["onboardingInvite"]>
  export type OnboardingInviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | OnboardingInvite$planArgs<ExtArgs>
    price?: boolean | OnboardingInvite$priceArgs<ExtArgs>
    offer?: boolean | OnboardingInvite$offerArgs<ExtArgs>
    coupon?: boolean | OnboardingInvite$couponArgs<ExtArgs>
  }
  export type OnboardingInviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | OnboardingInvite$planArgs<ExtArgs>
    price?: boolean | OnboardingInvite$priceArgs<ExtArgs>
    offer?: boolean | OnboardingInvite$offerArgs<ExtArgs>
    coupon?: boolean | OnboardingInvite$couponArgs<ExtArgs>
  }
  export type OnboardingInviteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | OnboardingInvite$planArgs<ExtArgs>
    price?: boolean | OnboardingInvite$priceArgs<ExtArgs>
    offer?: boolean | OnboardingInvite$offerArgs<ExtArgs>
    coupon?: boolean | OnboardingInvite$couponArgs<ExtArgs>
  }

  export type $OnboardingInvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnboardingInvite"
    objects: {
      plan: Prisma.$PricePlanPayload<ExtArgs> | null
      price: Prisma.$PlanPricePayload<ExtArgs> | null
      offer: Prisma.$OfferPayload<ExtArgs> | null
      coupon: Prisma.$CouponPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      email: string | null
      planId: string | null
      priceId: string | null
      offerId: string | null
      couponId: string | null
      trialDays: number | null
      expiresAt: Date
      usedAt: Date | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["onboardingInvite"]>
    composites: {}
  }

  type OnboardingInviteGetPayload<S extends boolean | null | undefined | OnboardingInviteDefaultArgs> = $Result.GetResult<Prisma.$OnboardingInvitePayload, S>

  type OnboardingInviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OnboardingInviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OnboardingInviteCountAggregateInputType | true
    }

  export interface OnboardingInviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnboardingInvite'], meta: { name: 'OnboardingInvite' } }
    /**
     * Find zero or one OnboardingInvite that matches the filter.
     * @param {OnboardingInviteFindUniqueArgs} args - Arguments to find a OnboardingInvite
     * @example
     * // Get one OnboardingInvite
     * const onboardingInvite = await prisma.onboardingInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnboardingInviteFindUniqueArgs>(args: SelectSubset<T, OnboardingInviteFindUniqueArgs<ExtArgs>>): Prisma__OnboardingInviteClient<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OnboardingInvite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OnboardingInviteFindUniqueOrThrowArgs} args - Arguments to find a OnboardingInvite
     * @example
     * // Get one OnboardingInvite
     * const onboardingInvite = await prisma.onboardingInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnboardingInviteFindUniqueOrThrowArgs>(args: SelectSubset<T, OnboardingInviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnboardingInviteClient<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnboardingInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInviteFindFirstArgs} args - Arguments to find a OnboardingInvite
     * @example
     * // Get one OnboardingInvite
     * const onboardingInvite = await prisma.onboardingInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnboardingInviteFindFirstArgs>(args?: SelectSubset<T, OnboardingInviteFindFirstArgs<ExtArgs>>): Prisma__OnboardingInviteClient<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnboardingInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInviteFindFirstOrThrowArgs} args - Arguments to find a OnboardingInvite
     * @example
     * // Get one OnboardingInvite
     * const onboardingInvite = await prisma.onboardingInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnboardingInviteFindFirstOrThrowArgs>(args?: SelectSubset<T, OnboardingInviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnboardingInviteClient<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OnboardingInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnboardingInvites
     * const onboardingInvites = await prisma.onboardingInvite.findMany()
     * 
     * // Get first 10 OnboardingInvites
     * const onboardingInvites = await prisma.onboardingInvite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onboardingInviteWithIdOnly = await prisma.onboardingInvite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnboardingInviteFindManyArgs>(args?: SelectSubset<T, OnboardingInviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OnboardingInvite.
     * @param {OnboardingInviteCreateArgs} args - Arguments to create a OnboardingInvite.
     * @example
     * // Create one OnboardingInvite
     * const OnboardingInvite = await prisma.onboardingInvite.create({
     *   data: {
     *     // ... data to create a OnboardingInvite
     *   }
     * })
     * 
     */
    create<T extends OnboardingInviteCreateArgs>(args: SelectSubset<T, OnboardingInviteCreateArgs<ExtArgs>>): Prisma__OnboardingInviteClient<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OnboardingInvites.
     * @param {OnboardingInviteCreateManyArgs} args - Arguments to create many OnboardingInvites.
     * @example
     * // Create many OnboardingInvites
     * const onboardingInvite = await prisma.onboardingInvite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnboardingInviteCreateManyArgs>(args?: SelectSubset<T, OnboardingInviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnboardingInvites and returns the data saved in the database.
     * @param {OnboardingInviteCreateManyAndReturnArgs} args - Arguments to create many OnboardingInvites.
     * @example
     * // Create many OnboardingInvites
     * const onboardingInvite = await prisma.onboardingInvite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnboardingInvites and only return the `id`
     * const onboardingInviteWithIdOnly = await prisma.onboardingInvite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnboardingInviteCreateManyAndReturnArgs>(args?: SelectSubset<T, OnboardingInviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OnboardingInvite.
     * @param {OnboardingInviteDeleteArgs} args - Arguments to delete one OnboardingInvite.
     * @example
     * // Delete one OnboardingInvite
     * const OnboardingInvite = await prisma.onboardingInvite.delete({
     *   where: {
     *     // ... filter to delete one OnboardingInvite
     *   }
     * })
     * 
     */
    delete<T extends OnboardingInviteDeleteArgs>(args: SelectSubset<T, OnboardingInviteDeleteArgs<ExtArgs>>): Prisma__OnboardingInviteClient<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OnboardingInvite.
     * @param {OnboardingInviteUpdateArgs} args - Arguments to update one OnboardingInvite.
     * @example
     * // Update one OnboardingInvite
     * const onboardingInvite = await prisma.onboardingInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnboardingInviteUpdateArgs>(args: SelectSubset<T, OnboardingInviteUpdateArgs<ExtArgs>>): Prisma__OnboardingInviteClient<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OnboardingInvites.
     * @param {OnboardingInviteDeleteManyArgs} args - Arguments to filter OnboardingInvites to delete.
     * @example
     * // Delete a few OnboardingInvites
     * const { count } = await prisma.onboardingInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnboardingInviteDeleteManyArgs>(args?: SelectSubset<T, OnboardingInviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnboardingInvites
     * const onboardingInvite = await prisma.onboardingInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnboardingInviteUpdateManyArgs>(args: SelectSubset<T, OnboardingInviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingInvites and returns the data updated in the database.
     * @param {OnboardingInviteUpdateManyAndReturnArgs} args - Arguments to update many OnboardingInvites.
     * @example
     * // Update many OnboardingInvites
     * const onboardingInvite = await prisma.onboardingInvite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OnboardingInvites and only return the `id`
     * const onboardingInviteWithIdOnly = await prisma.onboardingInvite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OnboardingInviteUpdateManyAndReturnArgs>(args: SelectSubset<T, OnboardingInviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OnboardingInvite.
     * @param {OnboardingInviteUpsertArgs} args - Arguments to update or create a OnboardingInvite.
     * @example
     * // Update or create a OnboardingInvite
     * const onboardingInvite = await prisma.onboardingInvite.upsert({
     *   create: {
     *     // ... data to create a OnboardingInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnboardingInvite we want to update
     *   }
     * })
     */
    upsert<T extends OnboardingInviteUpsertArgs>(args: SelectSubset<T, OnboardingInviteUpsertArgs<ExtArgs>>): Prisma__OnboardingInviteClient<$Result.GetResult<Prisma.$OnboardingInvitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OnboardingInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInviteCountArgs} args - Arguments to filter OnboardingInvites to count.
     * @example
     * // Count the number of OnboardingInvites
     * const count = await prisma.onboardingInvite.count({
     *   where: {
     *     // ... the filter for the OnboardingInvites we want to count
     *   }
     * })
    **/
    count<T extends OnboardingInviteCountArgs>(
      args?: Subset<T, OnboardingInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnboardingInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnboardingInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnboardingInviteAggregateArgs>(args: Subset<T, OnboardingInviteAggregateArgs>): Prisma.PrismaPromise<GetOnboardingInviteAggregateType<T>>

    /**
     * Group by OnboardingInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnboardingInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnboardingInviteGroupByArgs['orderBy'] }
        : { orderBy?: OnboardingInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnboardingInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnboardingInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnboardingInvite model
   */
  readonly fields: OnboardingInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnboardingInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnboardingInviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends OnboardingInvite$planArgs<ExtArgs> = {}>(args?: Subset<T, OnboardingInvite$planArgs<ExtArgs>>): Prisma__PricePlanClient<$Result.GetResult<Prisma.$PricePlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    price<T extends OnboardingInvite$priceArgs<ExtArgs> = {}>(args?: Subset<T, OnboardingInvite$priceArgs<ExtArgs>>): Prisma__PlanPriceClient<$Result.GetResult<Prisma.$PlanPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    offer<T extends OnboardingInvite$offerArgs<ExtArgs> = {}>(args?: Subset<T, OnboardingInvite$offerArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    coupon<T extends OnboardingInvite$couponArgs<ExtArgs> = {}>(args?: Subset<T, OnboardingInvite$couponArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnboardingInvite model
   */
  interface OnboardingInviteFieldRefs {
    readonly id: FieldRef<"OnboardingInvite", 'String'>
    readonly token: FieldRef<"OnboardingInvite", 'String'>
    readonly email: FieldRef<"OnboardingInvite", 'String'>
    readonly planId: FieldRef<"OnboardingInvite", 'String'>
    readonly priceId: FieldRef<"OnboardingInvite", 'String'>
    readonly offerId: FieldRef<"OnboardingInvite", 'String'>
    readonly couponId: FieldRef<"OnboardingInvite", 'String'>
    readonly trialDays: FieldRef<"OnboardingInvite", 'Int'>
    readonly expiresAt: FieldRef<"OnboardingInvite", 'DateTime'>
    readonly usedAt: FieldRef<"OnboardingInvite", 'DateTime'>
    readonly note: FieldRef<"OnboardingInvite", 'String'>
    readonly createdAt: FieldRef<"OnboardingInvite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OnboardingInvite findUnique
   */
  export type OnboardingInviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingInvite to fetch.
     */
    where: OnboardingInviteWhereUniqueInput
  }

  /**
   * OnboardingInvite findUniqueOrThrow
   */
  export type OnboardingInviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingInvite to fetch.
     */
    where: OnboardingInviteWhereUniqueInput
  }

  /**
   * OnboardingInvite findFirst
   */
  export type OnboardingInviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingInvite to fetch.
     */
    where?: OnboardingInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingInvites to fetch.
     */
    orderBy?: OnboardingInviteOrderByWithRelationInput | OnboardingInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingInvites.
     */
    cursor?: OnboardingInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingInvites.
     */
    distinct?: OnboardingInviteScalarFieldEnum | OnboardingInviteScalarFieldEnum[]
  }

  /**
   * OnboardingInvite findFirstOrThrow
   */
  export type OnboardingInviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingInvite to fetch.
     */
    where?: OnboardingInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingInvites to fetch.
     */
    orderBy?: OnboardingInviteOrderByWithRelationInput | OnboardingInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingInvites.
     */
    cursor?: OnboardingInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingInvites.
     */
    distinct?: OnboardingInviteScalarFieldEnum | OnboardingInviteScalarFieldEnum[]
  }

  /**
   * OnboardingInvite findMany
   */
  export type OnboardingInviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingInvites to fetch.
     */
    where?: OnboardingInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingInvites to fetch.
     */
    orderBy?: OnboardingInviteOrderByWithRelationInput | OnboardingInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnboardingInvites.
     */
    cursor?: OnboardingInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingInvites.
     */
    skip?: number
    distinct?: OnboardingInviteScalarFieldEnum | OnboardingInviteScalarFieldEnum[]
  }

  /**
   * OnboardingInvite create
   */
  export type OnboardingInviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    /**
     * The data needed to create a OnboardingInvite.
     */
    data: XOR<OnboardingInviteCreateInput, OnboardingInviteUncheckedCreateInput>
  }

  /**
   * OnboardingInvite createMany
   */
  export type OnboardingInviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnboardingInvites.
     */
    data: OnboardingInviteCreateManyInput | OnboardingInviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnboardingInvite createManyAndReturn
   */
  export type OnboardingInviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * The data used to create many OnboardingInvites.
     */
    data: OnboardingInviteCreateManyInput | OnboardingInviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingInvite update
   */
  export type OnboardingInviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    /**
     * The data needed to update a OnboardingInvite.
     */
    data: XOR<OnboardingInviteUpdateInput, OnboardingInviteUncheckedUpdateInput>
    /**
     * Choose, which OnboardingInvite to update.
     */
    where: OnboardingInviteWhereUniqueInput
  }

  /**
   * OnboardingInvite updateMany
   */
  export type OnboardingInviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnboardingInvites.
     */
    data: XOR<OnboardingInviteUpdateManyMutationInput, OnboardingInviteUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingInvites to update
     */
    where?: OnboardingInviteWhereInput
    /**
     * Limit how many OnboardingInvites to update.
     */
    limit?: number
  }

  /**
   * OnboardingInvite updateManyAndReturn
   */
  export type OnboardingInviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * The data used to update OnboardingInvites.
     */
    data: XOR<OnboardingInviteUpdateManyMutationInput, OnboardingInviteUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingInvites to update
     */
    where?: OnboardingInviteWhereInput
    /**
     * Limit how many OnboardingInvites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingInvite upsert
   */
  export type OnboardingInviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    /**
     * The filter to search for the OnboardingInvite to update in case it exists.
     */
    where: OnboardingInviteWhereUniqueInput
    /**
     * In case the OnboardingInvite found by the `where` argument doesn't exist, create a new OnboardingInvite with this data.
     */
    create: XOR<OnboardingInviteCreateInput, OnboardingInviteUncheckedCreateInput>
    /**
     * In case the OnboardingInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnboardingInviteUpdateInput, OnboardingInviteUncheckedUpdateInput>
  }

  /**
   * OnboardingInvite delete
   */
  export type OnboardingInviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
    /**
     * Filter which OnboardingInvite to delete.
     */
    where: OnboardingInviteWhereUniqueInput
  }

  /**
   * OnboardingInvite deleteMany
   */
  export type OnboardingInviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingInvites to delete
     */
    where?: OnboardingInviteWhereInput
    /**
     * Limit how many OnboardingInvites to delete.
     */
    limit?: number
  }

  /**
   * OnboardingInvite.plan
   */
  export type OnboardingInvite$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricePlan
     */
    select?: PricePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricePlan
     */
    omit?: PricePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricePlanInclude<ExtArgs> | null
    where?: PricePlanWhereInput
  }

  /**
   * OnboardingInvite.price
   */
  export type OnboardingInvite$priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPrice
     */
    select?: PlanPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPrice
     */
    omit?: PlanPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPriceInclude<ExtArgs> | null
    where?: PlanPriceWhereInput
  }

  /**
   * OnboardingInvite.offer
   */
  export type OnboardingInvite$offerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
  }

  /**
   * OnboardingInvite.coupon
   */
  export type OnboardingInvite$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
  }

  /**
   * OnboardingInvite without action
   */
  export type OnboardingInviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvite
     */
    select?: OnboardingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvite
     */
    omit?: OnboardingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInviteInclude<ExtArgs> | null
  }


  /**
   * Model InfrastructureMetric
   */

  export type AggregateInfrastructureMetric = {
    _count: InfrastructureMetricCountAggregateOutputType | null
    _avg: InfrastructureMetricAvgAggregateOutputType | null
    _sum: InfrastructureMetricSumAggregateOutputType | null
    _min: InfrastructureMetricMinAggregateOutputType | null
    _max: InfrastructureMetricMaxAggregateOutputType | null
  }

  export type InfrastructureMetricAvgAggregateOutputType = {
    value: number | null
  }

  export type InfrastructureMetricSumAggregateOutputType = {
    value: number | null
  }

  export type InfrastructureMetricMinAggregateOutputType = {
    id: string | null
    service: $Enums.InfrastructureService | null
    metric: $Enums.MetricType | null
    value: number | null
    timestamp: Date | null
  }

  export type InfrastructureMetricMaxAggregateOutputType = {
    id: string | null
    service: $Enums.InfrastructureService | null
    metric: $Enums.MetricType | null
    value: number | null
    timestamp: Date | null
  }

  export type InfrastructureMetricCountAggregateOutputType = {
    id: number
    service: number
    metric: number
    value: number
    timestamp: number
    metadata: number
    _all: number
  }


  export type InfrastructureMetricAvgAggregateInputType = {
    value?: true
  }

  export type InfrastructureMetricSumAggregateInputType = {
    value?: true
  }

  export type InfrastructureMetricMinAggregateInputType = {
    id?: true
    service?: true
    metric?: true
    value?: true
    timestamp?: true
  }

  export type InfrastructureMetricMaxAggregateInputType = {
    id?: true
    service?: true
    metric?: true
    value?: true
    timestamp?: true
  }

  export type InfrastructureMetricCountAggregateInputType = {
    id?: true
    service?: true
    metric?: true
    value?: true
    timestamp?: true
    metadata?: true
    _all?: true
  }

  export type InfrastructureMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfrastructureMetric to aggregate.
     */
    where?: InfrastructureMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfrastructureMetrics to fetch.
     */
    orderBy?: InfrastructureMetricOrderByWithRelationInput | InfrastructureMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InfrastructureMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfrastructureMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfrastructureMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InfrastructureMetrics
    **/
    _count?: true | InfrastructureMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfrastructureMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfrastructureMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfrastructureMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfrastructureMetricMaxAggregateInputType
  }

  export type GetInfrastructureMetricAggregateType<T extends InfrastructureMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateInfrastructureMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfrastructureMetric[P]>
      : GetScalarType<T[P], AggregateInfrastructureMetric[P]>
  }




  export type InfrastructureMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfrastructureMetricWhereInput
    orderBy?: InfrastructureMetricOrderByWithAggregationInput | InfrastructureMetricOrderByWithAggregationInput[]
    by: InfrastructureMetricScalarFieldEnum[] | InfrastructureMetricScalarFieldEnum
    having?: InfrastructureMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfrastructureMetricCountAggregateInputType | true
    _avg?: InfrastructureMetricAvgAggregateInputType
    _sum?: InfrastructureMetricSumAggregateInputType
    _min?: InfrastructureMetricMinAggregateInputType
    _max?: InfrastructureMetricMaxAggregateInputType
  }

  export type InfrastructureMetricGroupByOutputType = {
    id: string
    service: $Enums.InfrastructureService
    metric: $Enums.MetricType
    value: number
    timestamp: Date
    metadata: JsonValue | null
    _count: InfrastructureMetricCountAggregateOutputType | null
    _avg: InfrastructureMetricAvgAggregateOutputType | null
    _sum: InfrastructureMetricSumAggregateOutputType | null
    _min: InfrastructureMetricMinAggregateOutputType | null
    _max: InfrastructureMetricMaxAggregateOutputType | null
  }

  type GetInfrastructureMetricGroupByPayload<T extends InfrastructureMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfrastructureMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfrastructureMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfrastructureMetricGroupByOutputType[P]>
            : GetScalarType<T[P], InfrastructureMetricGroupByOutputType[P]>
        }
      >
    >


  export type InfrastructureMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    metric?: boolean
    value?: boolean
    timestamp?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["infrastructureMetric"]>

  export type InfrastructureMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    metric?: boolean
    value?: boolean
    timestamp?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["infrastructureMetric"]>

  export type InfrastructureMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    metric?: boolean
    value?: boolean
    timestamp?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["infrastructureMetric"]>

  export type InfrastructureMetricSelectScalar = {
    id?: boolean
    service?: boolean
    metric?: boolean
    value?: boolean
    timestamp?: boolean
    metadata?: boolean
  }

  export type InfrastructureMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service" | "metric" | "value" | "timestamp" | "metadata", ExtArgs["result"]["infrastructureMetric"]>

  export type $InfrastructureMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InfrastructureMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service: $Enums.InfrastructureService
      metric: $Enums.MetricType
      value: number
      timestamp: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["infrastructureMetric"]>
    composites: {}
  }

  type InfrastructureMetricGetPayload<S extends boolean | null | undefined | InfrastructureMetricDefaultArgs> = $Result.GetResult<Prisma.$InfrastructureMetricPayload, S>

  type InfrastructureMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InfrastructureMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InfrastructureMetricCountAggregateInputType | true
    }

  export interface InfrastructureMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InfrastructureMetric'], meta: { name: 'InfrastructureMetric' } }
    /**
     * Find zero or one InfrastructureMetric that matches the filter.
     * @param {InfrastructureMetricFindUniqueArgs} args - Arguments to find a InfrastructureMetric
     * @example
     * // Get one InfrastructureMetric
     * const infrastructureMetric = await prisma.infrastructureMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InfrastructureMetricFindUniqueArgs>(args: SelectSubset<T, InfrastructureMetricFindUniqueArgs<ExtArgs>>): Prisma__InfrastructureMetricClient<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InfrastructureMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InfrastructureMetricFindUniqueOrThrowArgs} args - Arguments to find a InfrastructureMetric
     * @example
     * // Get one InfrastructureMetric
     * const infrastructureMetric = await prisma.infrastructureMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InfrastructureMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, InfrastructureMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InfrastructureMetricClient<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InfrastructureMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureMetricFindFirstArgs} args - Arguments to find a InfrastructureMetric
     * @example
     * // Get one InfrastructureMetric
     * const infrastructureMetric = await prisma.infrastructureMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InfrastructureMetricFindFirstArgs>(args?: SelectSubset<T, InfrastructureMetricFindFirstArgs<ExtArgs>>): Prisma__InfrastructureMetricClient<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InfrastructureMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureMetricFindFirstOrThrowArgs} args - Arguments to find a InfrastructureMetric
     * @example
     * // Get one InfrastructureMetric
     * const infrastructureMetric = await prisma.infrastructureMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InfrastructureMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, InfrastructureMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__InfrastructureMetricClient<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InfrastructureMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InfrastructureMetrics
     * const infrastructureMetrics = await prisma.infrastructureMetric.findMany()
     * 
     * // Get first 10 InfrastructureMetrics
     * const infrastructureMetrics = await prisma.infrastructureMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const infrastructureMetricWithIdOnly = await prisma.infrastructureMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InfrastructureMetricFindManyArgs>(args?: SelectSubset<T, InfrastructureMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InfrastructureMetric.
     * @param {InfrastructureMetricCreateArgs} args - Arguments to create a InfrastructureMetric.
     * @example
     * // Create one InfrastructureMetric
     * const InfrastructureMetric = await prisma.infrastructureMetric.create({
     *   data: {
     *     // ... data to create a InfrastructureMetric
     *   }
     * })
     * 
     */
    create<T extends InfrastructureMetricCreateArgs>(args: SelectSubset<T, InfrastructureMetricCreateArgs<ExtArgs>>): Prisma__InfrastructureMetricClient<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InfrastructureMetrics.
     * @param {InfrastructureMetricCreateManyArgs} args - Arguments to create many InfrastructureMetrics.
     * @example
     * // Create many InfrastructureMetrics
     * const infrastructureMetric = await prisma.infrastructureMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InfrastructureMetricCreateManyArgs>(args?: SelectSubset<T, InfrastructureMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InfrastructureMetrics and returns the data saved in the database.
     * @param {InfrastructureMetricCreateManyAndReturnArgs} args - Arguments to create many InfrastructureMetrics.
     * @example
     * // Create many InfrastructureMetrics
     * const infrastructureMetric = await prisma.infrastructureMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InfrastructureMetrics and only return the `id`
     * const infrastructureMetricWithIdOnly = await prisma.infrastructureMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InfrastructureMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, InfrastructureMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InfrastructureMetric.
     * @param {InfrastructureMetricDeleteArgs} args - Arguments to delete one InfrastructureMetric.
     * @example
     * // Delete one InfrastructureMetric
     * const InfrastructureMetric = await prisma.infrastructureMetric.delete({
     *   where: {
     *     // ... filter to delete one InfrastructureMetric
     *   }
     * })
     * 
     */
    delete<T extends InfrastructureMetricDeleteArgs>(args: SelectSubset<T, InfrastructureMetricDeleteArgs<ExtArgs>>): Prisma__InfrastructureMetricClient<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InfrastructureMetric.
     * @param {InfrastructureMetricUpdateArgs} args - Arguments to update one InfrastructureMetric.
     * @example
     * // Update one InfrastructureMetric
     * const infrastructureMetric = await prisma.infrastructureMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InfrastructureMetricUpdateArgs>(args: SelectSubset<T, InfrastructureMetricUpdateArgs<ExtArgs>>): Prisma__InfrastructureMetricClient<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InfrastructureMetrics.
     * @param {InfrastructureMetricDeleteManyArgs} args - Arguments to filter InfrastructureMetrics to delete.
     * @example
     * // Delete a few InfrastructureMetrics
     * const { count } = await prisma.infrastructureMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InfrastructureMetricDeleteManyArgs>(args?: SelectSubset<T, InfrastructureMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InfrastructureMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InfrastructureMetrics
     * const infrastructureMetric = await prisma.infrastructureMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InfrastructureMetricUpdateManyArgs>(args: SelectSubset<T, InfrastructureMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InfrastructureMetrics and returns the data updated in the database.
     * @param {InfrastructureMetricUpdateManyAndReturnArgs} args - Arguments to update many InfrastructureMetrics.
     * @example
     * // Update many InfrastructureMetrics
     * const infrastructureMetric = await prisma.infrastructureMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InfrastructureMetrics and only return the `id`
     * const infrastructureMetricWithIdOnly = await prisma.infrastructureMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InfrastructureMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, InfrastructureMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InfrastructureMetric.
     * @param {InfrastructureMetricUpsertArgs} args - Arguments to update or create a InfrastructureMetric.
     * @example
     * // Update or create a InfrastructureMetric
     * const infrastructureMetric = await prisma.infrastructureMetric.upsert({
     *   create: {
     *     // ... data to create a InfrastructureMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InfrastructureMetric we want to update
     *   }
     * })
     */
    upsert<T extends InfrastructureMetricUpsertArgs>(args: SelectSubset<T, InfrastructureMetricUpsertArgs<ExtArgs>>): Prisma__InfrastructureMetricClient<$Result.GetResult<Prisma.$InfrastructureMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InfrastructureMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureMetricCountArgs} args - Arguments to filter InfrastructureMetrics to count.
     * @example
     * // Count the number of InfrastructureMetrics
     * const count = await prisma.infrastructureMetric.count({
     *   where: {
     *     // ... the filter for the InfrastructureMetrics we want to count
     *   }
     * })
    **/
    count<T extends InfrastructureMetricCountArgs>(
      args?: Subset<T, InfrastructureMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfrastructureMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InfrastructureMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfrastructureMetricAggregateArgs>(args: Subset<T, InfrastructureMetricAggregateArgs>): Prisma.PrismaPromise<GetInfrastructureMetricAggregateType<T>>

    /**
     * Group by InfrastructureMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfrastructureMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfrastructureMetricGroupByArgs['orderBy'] }
        : { orderBy?: InfrastructureMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfrastructureMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfrastructureMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InfrastructureMetric model
   */
  readonly fields: InfrastructureMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InfrastructureMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InfrastructureMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InfrastructureMetric model
   */
  interface InfrastructureMetricFieldRefs {
    readonly id: FieldRef<"InfrastructureMetric", 'String'>
    readonly service: FieldRef<"InfrastructureMetric", 'InfrastructureService'>
    readonly metric: FieldRef<"InfrastructureMetric", 'MetricType'>
    readonly value: FieldRef<"InfrastructureMetric", 'Float'>
    readonly timestamp: FieldRef<"InfrastructureMetric", 'DateTime'>
    readonly metadata: FieldRef<"InfrastructureMetric", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * InfrastructureMetric findUnique
   */
  export type InfrastructureMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * Filter, which InfrastructureMetric to fetch.
     */
    where: InfrastructureMetricWhereUniqueInput
  }

  /**
   * InfrastructureMetric findUniqueOrThrow
   */
  export type InfrastructureMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * Filter, which InfrastructureMetric to fetch.
     */
    where: InfrastructureMetricWhereUniqueInput
  }

  /**
   * InfrastructureMetric findFirst
   */
  export type InfrastructureMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * Filter, which InfrastructureMetric to fetch.
     */
    where?: InfrastructureMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfrastructureMetrics to fetch.
     */
    orderBy?: InfrastructureMetricOrderByWithRelationInput | InfrastructureMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfrastructureMetrics.
     */
    cursor?: InfrastructureMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfrastructureMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfrastructureMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfrastructureMetrics.
     */
    distinct?: InfrastructureMetricScalarFieldEnum | InfrastructureMetricScalarFieldEnum[]
  }

  /**
   * InfrastructureMetric findFirstOrThrow
   */
  export type InfrastructureMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * Filter, which InfrastructureMetric to fetch.
     */
    where?: InfrastructureMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfrastructureMetrics to fetch.
     */
    orderBy?: InfrastructureMetricOrderByWithRelationInput | InfrastructureMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfrastructureMetrics.
     */
    cursor?: InfrastructureMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfrastructureMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfrastructureMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfrastructureMetrics.
     */
    distinct?: InfrastructureMetricScalarFieldEnum | InfrastructureMetricScalarFieldEnum[]
  }

  /**
   * InfrastructureMetric findMany
   */
  export type InfrastructureMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * Filter, which InfrastructureMetrics to fetch.
     */
    where?: InfrastructureMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfrastructureMetrics to fetch.
     */
    orderBy?: InfrastructureMetricOrderByWithRelationInput | InfrastructureMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InfrastructureMetrics.
     */
    cursor?: InfrastructureMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfrastructureMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfrastructureMetrics.
     */
    skip?: number
    distinct?: InfrastructureMetricScalarFieldEnum | InfrastructureMetricScalarFieldEnum[]
  }

  /**
   * InfrastructureMetric create
   */
  export type InfrastructureMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * The data needed to create a InfrastructureMetric.
     */
    data: XOR<InfrastructureMetricCreateInput, InfrastructureMetricUncheckedCreateInput>
  }

  /**
   * InfrastructureMetric createMany
   */
  export type InfrastructureMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InfrastructureMetrics.
     */
    data: InfrastructureMetricCreateManyInput | InfrastructureMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InfrastructureMetric createManyAndReturn
   */
  export type InfrastructureMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * The data used to create many InfrastructureMetrics.
     */
    data: InfrastructureMetricCreateManyInput | InfrastructureMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InfrastructureMetric update
   */
  export type InfrastructureMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * The data needed to update a InfrastructureMetric.
     */
    data: XOR<InfrastructureMetricUpdateInput, InfrastructureMetricUncheckedUpdateInput>
    /**
     * Choose, which InfrastructureMetric to update.
     */
    where: InfrastructureMetricWhereUniqueInput
  }

  /**
   * InfrastructureMetric updateMany
   */
  export type InfrastructureMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InfrastructureMetrics.
     */
    data: XOR<InfrastructureMetricUpdateManyMutationInput, InfrastructureMetricUncheckedUpdateManyInput>
    /**
     * Filter which InfrastructureMetrics to update
     */
    where?: InfrastructureMetricWhereInput
    /**
     * Limit how many InfrastructureMetrics to update.
     */
    limit?: number
  }

  /**
   * InfrastructureMetric updateManyAndReturn
   */
  export type InfrastructureMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * The data used to update InfrastructureMetrics.
     */
    data: XOR<InfrastructureMetricUpdateManyMutationInput, InfrastructureMetricUncheckedUpdateManyInput>
    /**
     * Filter which InfrastructureMetrics to update
     */
    where?: InfrastructureMetricWhereInput
    /**
     * Limit how many InfrastructureMetrics to update.
     */
    limit?: number
  }

  /**
   * InfrastructureMetric upsert
   */
  export type InfrastructureMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * The filter to search for the InfrastructureMetric to update in case it exists.
     */
    where: InfrastructureMetricWhereUniqueInput
    /**
     * In case the InfrastructureMetric found by the `where` argument doesn't exist, create a new InfrastructureMetric with this data.
     */
    create: XOR<InfrastructureMetricCreateInput, InfrastructureMetricUncheckedCreateInput>
    /**
     * In case the InfrastructureMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InfrastructureMetricUpdateInput, InfrastructureMetricUncheckedUpdateInput>
  }

  /**
   * InfrastructureMetric delete
   */
  export type InfrastructureMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
    /**
     * Filter which InfrastructureMetric to delete.
     */
    where: InfrastructureMetricWhereUniqueInput
  }

  /**
   * InfrastructureMetric deleteMany
   */
  export type InfrastructureMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfrastructureMetrics to delete
     */
    where?: InfrastructureMetricWhereInput
    /**
     * Limit how many InfrastructureMetrics to delete.
     */
    limit?: number
  }

  /**
   * InfrastructureMetric without action
   */
  export type InfrastructureMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureMetric
     */
    select?: InfrastructureMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureMetric
     */
    omit?: InfrastructureMetricOmit<ExtArgs> | null
  }


  /**
   * Model InfrastructureLimit
   */

  export type AggregateInfrastructureLimit = {
    _count: InfrastructureLimitCountAggregateOutputType | null
    _avg: InfrastructureLimitAvgAggregateOutputType | null
    _sum: InfrastructureLimitSumAggregateOutputType | null
    _min: InfrastructureLimitMinAggregateOutputType | null
    _max: InfrastructureLimitMaxAggregateOutputType | null
  }

  export type InfrastructureLimitAvgAggregateOutputType = {
    limitValue: number | null
    warningPercent: number | null
    criticalPercent: number | null
  }

  export type InfrastructureLimitSumAggregateOutputType = {
    limitValue: number | null
    warningPercent: number | null
    criticalPercent: number | null
  }

  export type InfrastructureLimitMinAggregateOutputType = {
    id: string | null
    service: $Enums.InfrastructureService | null
    metric: $Enums.MetricType | null
    currentPlan: string | null
    limitValue: number | null
    warningPercent: number | null
    criticalPercent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InfrastructureLimitMaxAggregateOutputType = {
    id: string | null
    service: $Enums.InfrastructureService | null
    metric: $Enums.MetricType | null
    currentPlan: string | null
    limitValue: number | null
    warningPercent: number | null
    criticalPercent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InfrastructureLimitCountAggregateOutputType = {
    id: number
    service: number
    metric: number
    currentPlan: number
    limitValue: number
    warningPercent: number
    criticalPercent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InfrastructureLimitAvgAggregateInputType = {
    limitValue?: true
    warningPercent?: true
    criticalPercent?: true
  }

  export type InfrastructureLimitSumAggregateInputType = {
    limitValue?: true
    warningPercent?: true
    criticalPercent?: true
  }

  export type InfrastructureLimitMinAggregateInputType = {
    id?: true
    service?: true
    metric?: true
    currentPlan?: true
    limitValue?: true
    warningPercent?: true
    criticalPercent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InfrastructureLimitMaxAggregateInputType = {
    id?: true
    service?: true
    metric?: true
    currentPlan?: true
    limitValue?: true
    warningPercent?: true
    criticalPercent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InfrastructureLimitCountAggregateInputType = {
    id?: true
    service?: true
    metric?: true
    currentPlan?: true
    limitValue?: true
    warningPercent?: true
    criticalPercent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InfrastructureLimitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfrastructureLimit to aggregate.
     */
    where?: InfrastructureLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfrastructureLimits to fetch.
     */
    orderBy?: InfrastructureLimitOrderByWithRelationInput | InfrastructureLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InfrastructureLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfrastructureLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfrastructureLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InfrastructureLimits
    **/
    _count?: true | InfrastructureLimitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfrastructureLimitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfrastructureLimitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfrastructureLimitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfrastructureLimitMaxAggregateInputType
  }

  export type GetInfrastructureLimitAggregateType<T extends InfrastructureLimitAggregateArgs> = {
        [P in keyof T & keyof AggregateInfrastructureLimit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfrastructureLimit[P]>
      : GetScalarType<T[P], AggregateInfrastructureLimit[P]>
  }




  export type InfrastructureLimitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfrastructureLimitWhereInput
    orderBy?: InfrastructureLimitOrderByWithAggregationInput | InfrastructureLimitOrderByWithAggregationInput[]
    by: InfrastructureLimitScalarFieldEnum[] | InfrastructureLimitScalarFieldEnum
    having?: InfrastructureLimitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfrastructureLimitCountAggregateInputType | true
    _avg?: InfrastructureLimitAvgAggregateInputType
    _sum?: InfrastructureLimitSumAggregateInputType
    _min?: InfrastructureLimitMinAggregateInputType
    _max?: InfrastructureLimitMaxAggregateInputType
  }

  export type InfrastructureLimitGroupByOutputType = {
    id: string
    service: $Enums.InfrastructureService
    metric: $Enums.MetricType
    currentPlan: string
    limitValue: number
    warningPercent: number
    criticalPercent: number
    createdAt: Date
    updatedAt: Date
    _count: InfrastructureLimitCountAggregateOutputType | null
    _avg: InfrastructureLimitAvgAggregateOutputType | null
    _sum: InfrastructureLimitSumAggregateOutputType | null
    _min: InfrastructureLimitMinAggregateOutputType | null
    _max: InfrastructureLimitMaxAggregateOutputType | null
  }

  type GetInfrastructureLimitGroupByPayload<T extends InfrastructureLimitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfrastructureLimitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfrastructureLimitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfrastructureLimitGroupByOutputType[P]>
            : GetScalarType<T[P], InfrastructureLimitGroupByOutputType[P]>
        }
      >
    >


  export type InfrastructureLimitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    metric?: boolean
    currentPlan?: boolean
    limitValue?: boolean
    warningPercent?: boolean
    criticalPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["infrastructureLimit"]>

  export type InfrastructureLimitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    metric?: boolean
    currentPlan?: boolean
    limitValue?: boolean
    warningPercent?: boolean
    criticalPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["infrastructureLimit"]>

  export type InfrastructureLimitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    metric?: boolean
    currentPlan?: boolean
    limitValue?: boolean
    warningPercent?: boolean
    criticalPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["infrastructureLimit"]>

  export type InfrastructureLimitSelectScalar = {
    id?: boolean
    service?: boolean
    metric?: boolean
    currentPlan?: boolean
    limitValue?: boolean
    warningPercent?: boolean
    criticalPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InfrastructureLimitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service" | "metric" | "currentPlan" | "limitValue" | "warningPercent" | "criticalPercent" | "createdAt" | "updatedAt", ExtArgs["result"]["infrastructureLimit"]>

  export type $InfrastructureLimitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InfrastructureLimit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service: $Enums.InfrastructureService
      metric: $Enums.MetricType
      currentPlan: string
      limitValue: number
      warningPercent: number
      criticalPercent: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["infrastructureLimit"]>
    composites: {}
  }

  type InfrastructureLimitGetPayload<S extends boolean | null | undefined | InfrastructureLimitDefaultArgs> = $Result.GetResult<Prisma.$InfrastructureLimitPayload, S>

  type InfrastructureLimitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InfrastructureLimitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InfrastructureLimitCountAggregateInputType | true
    }

  export interface InfrastructureLimitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InfrastructureLimit'], meta: { name: 'InfrastructureLimit' } }
    /**
     * Find zero or one InfrastructureLimit that matches the filter.
     * @param {InfrastructureLimitFindUniqueArgs} args - Arguments to find a InfrastructureLimit
     * @example
     * // Get one InfrastructureLimit
     * const infrastructureLimit = await prisma.infrastructureLimit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InfrastructureLimitFindUniqueArgs>(args: SelectSubset<T, InfrastructureLimitFindUniqueArgs<ExtArgs>>): Prisma__InfrastructureLimitClient<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InfrastructureLimit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InfrastructureLimitFindUniqueOrThrowArgs} args - Arguments to find a InfrastructureLimit
     * @example
     * // Get one InfrastructureLimit
     * const infrastructureLimit = await prisma.infrastructureLimit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InfrastructureLimitFindUniqueOrThrowArgs>(args: SelectSubset<T, InfrastructureLimitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InfrastructureLimitClient<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InfrastructureLimit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureLimitFindFirstArgs} args - Arguments to find a InfrastructureLimit
     * @example
     * // Get one InfrastructureLimit
     * const infrastructureLimit = await prisma.infrastructureLimit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InfrastructureLimitFindFirstArgs>(args?: SelectSubset<T, InfrastructureLimitFindFirstArgs<ExtArgs>>): Prisma__InfrastructureLimitClient<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InfrastructureLimit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureLimitFindFirstOrThrowArgs} args - Arguments to find a InfrastructureLimit
     * @example
     * // Get one InfrastructureLimit
     * const infrastructureLimit = await prisma.infrastructureLimit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InfrastructureLimitFindFirstOrThrowArgs>(args?: SelectSubset<T, InfrastructureLimitFindFirstOrThrowArgs<ExtArgs>>): Prisma__InfrastructureLimitClient<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InfrastructureLimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureLimitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InfrastructureLimits
     * const infrastructureLimits = await prisma.infrastructureLimit.findMany()
     * 
     * // Get first 10 InfrastructureLimits
     * const infrastructureLimits = await prisma.infrastructureLimit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const infrastructureLimitWithIdOnly = await prisma.infrastructureLimit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InfrastructureLimitFindManyArgs>(args?: SelectSubset<T, InfrastructureLimitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InfrastructureLimit.
     * @param {InfrastructureLimitCreateArgs} args - Arguments to create a InfrastructureLimit.
     * @example
     * // Create one InfrastructureLimit
     * const InfrastructureLimit = await prisma.infrastructureLimit.create({
     *   data: {
     *     // ... data to create a InfrastructureLimit
     *   }
     * })
     * 
     */
    create<T extends InfrastructureLimitCreateArgs>(args: SelectSubset<T, InfrastructureLimitCreateArgs<ExtArgs>>): Prisma__InfrastructureLimitClient<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InfrastructureLimits.
     * @param {InfrastructureLimitCreateManyArgs} args - Arguments to create many InfrastructureLimits.
     * @example
     * // Create many InfrastructureLimits
     * const infrastructureLimit = await prisma.infrastructureLimit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InfrastructureLimitCreateManyArgs>(args?: SelectSubset<T, InfrastructureLimitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InfrastructureLimits and returns the data saved in the database.
     * @param {InfrastructureLimitCreateManyAndReturnArgs} args - Arguments to create many InfrastructureLimits.
     * @example
     * // Create many InfrastructureLimits
     * const infrastructureLimit = await prisma.infrastructureLimit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InfrastructureLimits and only return the `id`
     * const infrastructureLimitWithIdOnly = await prisma.infrastructureLimit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InfrastructureLimitCreateManyAndReturnArgs>(args?: SelectSubset<T, InfrastructureLimitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InfrastructureLimit.
     * @param {InfrastructureLimitDeleteArgs} args - Arguments to delete one InfrastructureLimit.
     * @example
     * // Delete one InfrastructureLimit
     * const InfrastructureLimit = await prisma.infrastructureLimit.delete({
     *   where: {
     *     // ... filter to delete one InfrastructureLimit
     *   }
     * })
     * 
     */
    delete<T extends InfrastructureLimitDeleteArgs>(args: SelectSubset<T, InfrastructureLimitDeleteArgs<ExtArgs>>): Prisma__InfrastructureLimitClient<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InfrastructureLimit.
     * @param {InfrastructureLimitUpdateArgs} args - Arguments to update one InfrastructureLimit.
     * @example
     * // Update one InfrastructureLimit
     * const infrastructureLimit = await prisma.infrastructureLimit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InfrastructureLimitUpdateArgs>(args: SelectSubset<T, InfrastructureLimitUpdateArgs<ExtArgs>>): Prisma__InfrastructureLimitClient<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InfrastructureLimits.
     * @param {InfrastructureLimitDeleteManyArgs} args - Arguments to filter InfrastructureLimits to delete.
     * @example
     * // Delete a few InfrastructureLimits
     * const { count } = await prisma.infrastructureLimit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InfrastructureLimitDeleteManyArgs>(args?: SelectSubset<T, InfrastructureLimitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InfrastructureLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureLimitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InfrastructureLimits
     * const infrastructureLimit = await prisma.infrastructureLimit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InfrastructureLimitUpdateManyArgs>(args: SelectSubset<T, InfrastructureLimitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InfrastructureLimits and returns the data updated in the database.
     * @param {InfrastructureLimitUpdateManyAndReturnArgs} args - Arguments to update many InfrastructureLimits.
     * @example
     * // Update many InfrastructureLimits
     * const infrastructureLimit = await prisma.infrastructureLimit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InfrastructureLimits and only return the `id`
     * const infrastructureLimitWithIdOnly = await prisma.infrastructureLimit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InfrastructureLimitUpdateManyAndReturnArgs>(args: SelectSubset<T, InfrastructureLimitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InfrastructureLimit.
     * @param {InfrastructureLimitUpsertArgs} args - Arguments to update or create a InfrastructureLimit.
     * @example
     * // Update or create a InfrastructureLimit
     * const infrastructureLimit = await prisma.infrastructureLimit.upsert({
     *   create: {
     *     // ... data to create a InfrastructureLimit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InfrastructureLimit we want to update
     *   }
     * })
     */
    upsert<T extends InfrastructureLimitUpsertArgs>(args: SelectSubset<T, InfrastructureLimitUpsertArgs<ExtArgs>>): Prisma__InfrastructureLimitClient<$Result.GetResult<Prisma.$InfrastructureLimitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InfrastructureLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureLimitCountArgs} args - Arguments to filter InfrastructureLimits to count.
     * @example
     * // Count the number of InfrastructureLimits
     * const count = await prisma.infrastructureLimit.count({
     *   where: {
     *     // ... the filter for the InfrastructureLimits we want to count
     *   }
     * })
    **/
    count<T extends InfrastructureLimitCountArgs>(
      args?: Subset<T, InfrastructureLimitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfrastructureLimitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InfrastructureLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureLimitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfrastructureLimitAggregateArgs>(args: Subset<T, InfrastructureLimitAggregateArgs>): Prisma.PrismaPromise<GetInfrastructureLimitAggregateType<T>>

    /**
     * Group by InfrastructureLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfrastructureLimitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfrastructureLimitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfrastructureLimitGroupByArgs['orderBy'] }
        : { orderBy?: InfrastructureLimitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfrastructureLimitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfrastructureLimitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InfrastructureLimit model
   */
  readonly fields: InfrastructureLimitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InfrastructureLimit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InfrastructureLimitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InfrastructureLimit model
   */
  interface InfrastructureLimitFieldRefs {
    readonly id: FieldRef<"InfrastructureLimit", 'String'>
    readonly service: FieldRef<"InfrastructureLimit", 'InfrastructureService'>
    readonly metric: FieldRef<"InfrastructureLimit", 'MetricType'>
    readonly currentPlan: FieldRef<"InfrastructureLimit", 'String'>
    readonly limitValue: FieldRef<"InfrastructureLimit", 'Float'>
    readonly warningPercent: FieldRef<"InfrastructureLimit", 'Float'>
    readonly criticalPercent: FieldRef<"InfrastructureLimit", 'Float'>
    readonly createdAt: FieldRef<"InfrastructureLimit", 'DateTime'>
    readonly updatedAt: FieldRef<"InfrastructureLimit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InfrastructureLimit findUnique
   */
  export type InfrastructureLimitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * Filter, which InfrastructureLimit to fetch.
     */
    where: InfrastructureLimitWhereUniqueInput
  }

  /**
   * InfrastructureLimit findUniqueOrThrow
   */
  export type InfrastructureLimitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * Filter, which InfrastructureLimit to fetch.
     */
    where: InfrastructureLimitWhereUniqueInput
  }

  /**
   * InfrastructureLimit findFirst
   */
  export type InfrastructureLimitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * Filter, which InfrastructureLimit to fetch.
     */
    where?: InfrastructureLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfrastructureLimits to fetch.
     */
    orderBy?: InfrastructureLimitOrderByWithRelationInput | InfrastructureLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfrastructureLimits.
     */
    cursor?: InfrastructureLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfrastructureLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfrastructureLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfrastructureLimits.
     */
    distinct?: InfrastructureLimitScalarFieldEnum | InfrastructureLimitScalarFieldEnum[]
  }

  /**
   * InfrastructureLimit findFirstOrThrow
   */
  export type InfrastructureLimitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * Filter, which InfrastructureLimit to fetch.
     */
    where?: InfrastructureLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfrastructureLimits to fetch.
     */
    orderBy?: InfrastructureLimitOrderByWithRelationInput | InfrastructureLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfrastructureLimits.
     */
    cursor?: InfrastructureLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfrastructureLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfrastructureLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfrastructureLimits.
     */
    distinct?: InfrastructureLimitScalarFieldEnum | InfrastructureLimitScalarFieldEnum[]
  }

  /**
   * InfrastructureLimit findMany
   */
  export type InfrastructureLimitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * Filter, which InfrastructureLimits to fetch.
     */
    where?: InfrastructureLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfrastructureLimits to fetch.
     */
    orderBy?: InfrastructureLimitOrderByWithRelationInput | InfrastructureLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InfrastructureLimits.
     */
    cursor?: InfrastructureLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfrastructureLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfrastructureLimits.
     */
    skip?: number
    distinct?: InfrastructureLimitScalarFieldEnum | InfrastructureLimitScalarFieldEnum[]
  }

  /**
   * InfrastructureLimit create
   */
  export type InfrastructureLimitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * The data needed to create a InfrastructureLimit.
     */
    data: XOR<InfrastructureLimitCreateInput, InfrastructureLimitUncheckedCreateInput>
  }

  /**
   * InfrastructureLimit createMany
   */
  export type InfrastructureLimitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InfrastructureLimits.
     */
    data: InfrastructureLimitCreateManyInput | InfrastructureLimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InfrastructureLimit createManyAndReturn
   */
  export type InfrastructureLimitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * The data used to create many InfrastructureLimits.
     */
    data: InfrastructureLimitCreateManyInput | InfrastructureLimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InfrastructureLimit update
   */
  export type InfrastructureLimitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * The data needed to update a InfrastructureLimit.
     */
    data: XOR<InfrastructureLimitUpdateInput, InfrastructureLimitUncheckedUpdateInput>
    /**
     * Choose, which InfrastructureLimit to update.
     */
    where: InfrastructureLimitWhereUniqueInput
  }

  /**
   * InfrastructureLimit updateMany
   */
  export type InfrastructureLimitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InfrastructureLimits.
     */
    data: XOR<InfrastructureLimitUpdateManyMutationInput, InfrastructureLimitUncheckedUpdateManyInput>
    /**
     * Filter which InfrastructureLimits to update
     */
    where?: InfrastructureLimitWhereInput
    /**
     * Limit how many InfrastructureLimits to update.
     */
    limit?: number
  }

  /**
   * InfrastructureLimit updateManyAndReturn
   */
  export type InfrastructureLimitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * The data used to update InfrastructureLimits.
     */
    data: XOR<InfrastructureLimitUpdateManyMutationInput, InfrastructureLimitUncheckedUpdateManyInput>
    /**
     * Filter which InfrastructureLimits to update
     */
    where?: InfrastructureLimitWhereInput
    /**
     * Limit how many InfrastructureLimits to update.
     */
    limit?: number
  }

  /**
   * InfrastructureLimit upsert
   */
  export type InfrastructureLimitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * The filter to search for the InfrastructureLimit to update in case it exists.
     */
    where: InfrastructureLimitWhereUniqueInput
    /**
     * In case the InfrastructureLimit found by the `where` argument doesn't exist, create a new InfrastructureLimit with this data.
     */
    create: XOR<InfrastructureLimitCreateInput, InfrastructureLimitUncheckedCreateInput>
    /**
     * In case the InfrastructureLimit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InfrastructureLimitUpdateInput, InfrastructureLimitUncheckedUpdateInput>
  }

  /**
   * InfrastructureLimit delete
   */
  export type InfrastructureLimitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
    /**
     * Filter which InfrastructureLimit to delete.
     */
    where: InfrastructureLimitWhereUniqueInput
  }

  /**
   * InfrastructureLimit deleteMany
   */
  export type InfrastructureLimitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfrastructureLimits to delete
     */
    where?: InfrastructureLimitWhereInput
    /**
     * Limit how many InfrastructureLimits to delete.
     */
    limit?: number
  }

  /**
   * InfrastructureLimit without action
   */
  export type InfrastructureLimitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfrastructureLimit
     */
    select?: InfrastructureLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfrastructureLimit
     */
    omit?: InfrastructureLimitOmit<ExtArgs> | null
  }


  /**
   * Model ImportJob
   */

  export type AggregateImportJob = {
    _count: ImportJobCountAggregateOutputType | null
    _avg: ImportJobAvgAggregateOutputType | null
    _sum: ImportJobSumAggregateOutputType | null
    _min: ImportJobMinAggregateOutputType | null
    _max: ImportJobMaxAggregateOutputType | null
  }

  export type ImportJobAvgAggregateOutputType = {
    fileSize: number | null
    totalRecords: number | null
    processedRecords: number | null
    successCount: number | null
    errorCount: number | null
    skipCount: number | null
    progressPercent: number | null
  }

  export type ImportJobSumAggregateOutputType = {
    fileSize: number | null
    totalRecords: number | null
    processedRecords: number | null
    successCount: number | null
    errorCount: number | null
    skipCount: number | null
    progressPercent: number | null
  }

  export type ImportJobMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    userId: string | null
    entityType: $Enums.ImportEntityType | null
    status: $Enums.ImportStatus | null
    fileName: string | null
    fileSize: number | null
    totalRecords: number | null
    processedRecords: number | null
    successCount: number | null
    errorCount: number | null
    skipCount: number | null
    mappingId: string | null
    progressPercent: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorSummary: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImportJobMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    userId: string | null
    entityType: $Enums.ImportEntityType | null
    status: $Enums.ImportStatus | null
    fileName: string | null
    fileSize: number | null
    totalRecords: number | null
    processedRecords: number | null
    successCount: number | null
    errorCount: number | null
    skipCount: number | null
    mappingId: string | null
    progressPercent: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorSummary: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImportJobCountAggregateOutputType = {
    id: number
    orgId: number
    userId: number
    entityType: number
    status: number
    fileName: number
    fileSize: number
    totalRecords: number
    processedRecords: number
    successCount: number
    errorCount: number
    skipCount: number
    mappingId: number
    sampleData: number
    fieldMappings: number
    transformRules: number
    validationRules: number
    progressPercent: number
    startedAt: number
    completedAt: number
    errorSummary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImportJobAvgAggregateInputType = {
    fileSize?: true
    totalRecords?: true
    processedRecords?: true
    successCount?: true
    errorCount?: true
    skipCount?: true
    progressPercent?: true
  }

  export type ImportJobSumAggregateInputType = {
    fileSize?: true
    totalRecords?: true
    processedRecords?: true
    successCount?: true
    errorCount?: true
    skipCount?: true
    progressPercent?: true
  }

  export type ImportJobMinAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    entityType?: true
    status?: true
    fileName?: true
    fileSize?: true
    totalRecords?: true
    processedRecords?: true
    successCount?: true
    errorCount?: true
    skipCount?: true
    mappingId?: true
    progressPercent?: true
    startedAt?: true
    completedAt?: true
    errorSummary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImportJobMaxAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    entityType?: true
    status?: true
    fileName?: true
    fileSize?: true
    totalRecords?: true
    processedRecords?: true
    successCount?: true
    errorCount?: true
    skipCount?: true
    mappingId?: true
    progressPercent?: true
    startedAt?: true
    completedAt?: true
    errorSummary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImportJobCountAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    entityType?: true
    status?: true
    fileName?: true
    fileSize?: true
    totalRecords?: true
    processedRecords?: true
    successCount?: true
    errorCount?: true
    skipCount?: true
    mappingId?: true
    sampleData?: true
    fieldMappings?: true
    transformRules?: true
    validationRules?: true
    progressPercent?: true
    startedAt?: true
    completedAt?: true
    errorSummary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImportJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportJob to aggregate.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportJobs
    **/
    _count?: true | ImportJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportJobMaxAggregateInputType
  }

  export type GetImportJobAggregateType<T extends ImportJobAggregateArgs> = {
        [P in keyof T & keyof AggregateImportJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportJob[P]>
      : GetScalarType<T[P], AggregateImportJob[P]>
  }




  export type ImportJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportJobWhereInput
    orderBy?: ImportJobOrderByWithAggregationInput | ImportJobOrderByWithAggregationInput[]
    by: ImportJobScalarFieldEnum[] | ImportJobScalarFieldEnum
    having?: ImportJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportJobCountAggregateInputType | true
    _avg?: ImportJobAvgAggregateInputType
    _sum?: ImportJobSumAggregateInputType
    _min?: ImportJobMinAggregateInputType
    _max?: ImportJobMaxAggregateInputType
  }

  export type ImportJobGroupByOutputType = {
    id: string
    orgId: string
    userId: string
    entityType: $Enums.ImportEntityType
    status: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords: number
    processedRecords: number
    successCount: number
    errorCount: number
    skipCount: number
    mappingId: string | null
    sampleData: JsonValue | null
    fieldMappings: JsonValue | null
    transformRules: JsonValue | null
    validationRules: JsonValue | null
    progressPercent: number
    startedAt: Date | null
    completedAt: Date | null
    errorSummary: string | null
    createdAt: Date
    updatedAt: Date
    _count: ImportJobCountAggregateOutputType | null
    _avg: ImportJobAvgAggregateOutputType | null
    _sum: ImportJobSumAggregateOutputType | null
    _min: ImportJobMinAggregateOutputType | null
    _max: ImportJobMaxAggregateOutputType | null
  }

  type GetImportJobGroupByPayload<T extends ImportJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportJobGroupByOutputType[P]>
            : GetScalarType<T[P], ImportJobGroupByOutputType[P]>
        }
      >
    >


  export type ImportJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    entityType?: boolean
    status?: boolean
    fileName?: boolean
    fileSize?: boolean
    totalRecords?: boolean
    processedRecords?: boolean
    successCount?: boolean
    errorCount?: boolean
    skipCount?: boolean
    mappingId?: boolean
    sampleData?: boolean
    fieldMappings?: boolean
    transformRules?: boolean
    validationRules?: boolean
    progressPercent?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorSummary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    mapping?: boolean | ImportJob$mappingArgs<ExtArgs>
    errors?: boolean | ImportJob$errorsArgs<ExtArgs>
    _count?: boolean | ImportJobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importJob"]>

  export type ImportJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    entityType?: boolean
    status?: boolean
    fileName?: boolean
    fileSize?: boolean
    totalRecords?: boolean
    processedRecords?: boolean
    successCount?: boolean
    errorCount?: boolean
    skipCount?: boolean
    mappingId?: boolean
    sampleData?: boolean
    fieldMappings?: boolean
    transformRules?: boolean
    validationRules?: boolean
    progressPercent?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorSummary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    mapping?: boolean | ImportJob$mappingArgs<ExtArgs>
  }, ExtArgs["result"]["importJob"]>

  export type ImportJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    entityType?: boolean
    status?: boolean
    fileName?: boolean
    fileSize?: boolean
    totalRecords?: boolean
    processedRecords?: boolean
    successCount?: boolean
    errorCount?: boolean
    skipCount?: boolean
    mappingId?: boolean
    sampleData?: boolean
    fieldMappings?: boolean
    transformRules?: boolean
    validationRules?: boolean
    progressPercent?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorSummary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    mapping?: boolean | ImportJob$mappingArgs<ExtArgs>
  }, ExtArgs["result"]["importJob"]>

  export type ImportJobSelectScalar = {
    id?: boolean
    orgId?: boolean
    userId?: boolean
    entityType?: boolean
    status?: boolean
    fileName?: boolean
    fileSize?: boolean
    totalRecords?: boolean
    processedRecords?: boolean
    successCount?: boolean
    errorCount?: boolean
    skipCount?: boolean
    mappingId?: boolean
    sampleData?: boolean
    fieldMappings?: boolean
    transformRules?: boolean
    validationRules?: boolean
    progressPercent?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorSummary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImportJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "userId" | "entityType" | "status" | "fileName" | "fileSize" | "totalRecords" | "processedRecords" | "successCount" | "errorCount" | "skipCount" | "mappingId" | "sampleData" | "fieldMappings" | "transformRules" | "validationRules" | "progressPercent" | "startedAt" | "completedAt" | "errorSummary" | "createdAt" | "updatedAt", ExtArgs["result"]["importJob"]>
  export type ImportJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    mapping?: boolean | ImportJob$mappingArgs<ExtArgs>
    errors?: boolean | ImportJob$errorsArgs<ExtArgs>
    _count?: boolean | ImportJobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImportJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    mapping?: boolean | ImportJob$mappingArgs<ExtArgs>
  }
  export type ImportJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    mapping?: boolean | ImportJob$mappingArgs<ExtArgs>
  }

  export type $ImportJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportJob"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      mapping: Prisma.$ImportMappingPayload<ExtArgs> | null
      errors: Prisma.$ImportErrorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      userId: string
      entityType: $Enums.ImportEntityType
      status: $Enums.ImportStatus
      fileName: string
      fileSize: number
      totalRecords: number
      processedRecords: number
      successCount: number
      errorCount: number
      skipCount: number
      mappingId: string | null
      sampleData: Prisma.JsonValue | null
      fieldMappings: Prisma.JsonValue | null
      transformRules: Prisma.JsonValue | null
      validationRules: Prisma.JsonValue | null
      progressPercent: number
      startedAt: Date | null
      completedAt: Date | null
      errorSummary: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["importJob"]>
    composites: {}
  }

  type ImportJobGetPayload<S extends boolean | null | undefined | ImportJobDefaultArgs> = $Result.GetResult<Prisma.$ImportJobPayload, S>

  type ImportJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImportJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImportJobCountAggregateInputType | true
    }

  export interface ImportJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportJob'], meta: { name: 'ImportJob' } }
    /**
     * Find zero or one ImportJob that matches the filter.
     * @param {ImportJobFindUniqueArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportJobFindUniqueArgs>(args: SelectSubset<T, ImportJobFindUniqueArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImportJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImportJobFindUniqueOrThrowArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindFirstArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportJobFindFirstArgs>(args?: SelectSubset<T, ImportJobFindFirstArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindFirstOrThrowArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImportJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportJobs
     * const importJobs = await prisma.importJob.findMany()
     * 
     * // Get first 10 ImportJobs
     * const importJobs = await prisma.importJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importJobWithIdOnly = await prisma.importJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportJobFindManyArgs>(args?: SelectSubset<T, ImportJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImportJob.
     * @param {ImportJobCreateArgs} args - Arguments to create a ImportJob.
     * @example
     * // Create one ImportJob
     * const ImportJob = await prisma.importJob.create({
     *   data: {
     *     // ... data to create a ImportJob
     *   }
     * })
     * 
     */
    create<T extends ImportJobCreateArgs>(args: SelectSubset<T, ImportJobCreateArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImportJobs.
     * @param {ImportJobCreateManyArgs} args - Arguments to create many ImportJobs.
     * @example
     * // Create many ImportJobs
     * const importJob = await prisma.importJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportJobCreateManyArgs>(args?: SelectSubset<T, ImportJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportJobs and returns the data saved in the database.
     * @param {ImportJobCreateManyAndReturnArgs} args - Arguments to create many ImportJobs.
     * @example
     * // Create many ImportJobs
     * const importJob = await prisma.importJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportJobs and only return the `id`
     * const importJobWithIdOnly = await prisma.importJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImportJob.
     * @param {ImportJobDeleteArgs} args - Arguments to delete one ImportJob.
     * @example
     * // Delete one ImportJob
     * const ImportJob = await prisma.importJob.delete({
     *   where: {
     *     // ... filter to delete one ImportJob
     *   }
     * })
     * 
     */
    delete<T extends ImportJobDeleteArgs>(args: SelectSubset<T, ImportJobDeleteArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImportJob.
     * @param {ImportJobUpdateArgs} args - Arguments to update one ImportJob.
     * @example
     * // Update one ImportJob
     * const importJob = await prisma.importJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportJobUpdateArgs>(args: SelectSubset<T, ImportJobUpdateArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImportJobs.
     * @param {ImportJobDeleteManyArgs} args - Arguments to filter ImportJobs to delete.
     * @example
     * // Delete a few ImportJobs
     * const { count } = await prisma.importJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportJobDeleteManyArgs>(args?: SelectSubset<T, ImportJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportJobs
     * const importJob = await prisma.importJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportJobUpdateManyArgs>(args: SelectSubset<T, ImportJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportJobs and returns the data updated in the database.
     * @param {ImportJobUpdateManyAndReturnArgs} args - Arguments to update many ImportJobs.
     * @example
     * // Update many ImportJobs
     * const importJob = await prisma.importJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImportJobs and only return the `id`
     * const importJobWithIdOnly = await prisma.importJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImportJobUpdateManyAndReturnArgs>(args: SelectSubset<T, ImportJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImportJob.
     * @param {ImportJobUpsertArgs} args - Arguments to update or create a ImportJob.
     * @example
     * // Update or create a ImportJob
     * const importJob = await prisma.importJob.upsert({
     *   create: {
     *     // ... data to create a ImportJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportJob we want to update
     *   }
     * })
     */
    upsert<T extends ImportJobUpsertArgs>(args: SelectSubset<T, ImportJobUpsertArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobCountArgs} args - Arguments to filter ImportJobs to count.
     * @example
     * // Count the number of ImportJobs
     * const count = await prisma.importJob.count({
     *   where: {
     *     // ... the filter for the ImportJobs we want to count
     *   }
     * })
    **/
    count<T extends ImportJobCountArgs>(
      args?: Subset<T, ImportJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportJobAggregateArgs>(args: Subset<T, ImportJobAggregateArgs>): Prisma.PrismaPromise<GetImportJobAggregateType<T>>

    /**
     * Group by ImportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportJobGroupByArgs['orderBy'] }
        : { orderBy?: ImportJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportJob model
   */
  readonly fields: ImportJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mapping<T extends ImportJob$mappingArgs<ExtArgs> = {}>(args?: Subset<T, ImportJob$mappingArgs<ExtArgs>>): Prisma__ImportMappingClient<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    errors<T extends ImportJob$errorsArgs<ExtArgs> = {}>(args?: Subset<T, ImportJob$errorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportJob model
   */
  interface ImportJobFieldRefs {
    readonly id: FieldRef<"ImportJob", 'String'>
    readonly orgId: FieldRef<"ImportJob", 'String'>
    readonly userId: FieldRef<"ImportJob", 'String'>
    readonly entityType: FieldRef<"ImportJob", 'ImportEntityType'>
    readonly status: FieldRef<"ImportJob", 'ImportStatus'>
    readonly fileName: FieldRef<"ImportJob", 'String'>
    readonly fileSize: FieldRef<"ImportJob", 'Int'>
    readonly totalRecords: FieldRef<"ImportJob", 'Int'>
    readonly processedRecords: FieldRef<"ImportJob", 'Int'>
    readonly successCount: FieldRef<"ImportJob", 'Int'>
    readonly errorCount: FieldRef<"ImportJob", 'Int'>
    readonly skipCount: FieldRef<"ImportJob", 'Int'>
    readonly mappingId: FieldRef<"ImportJob", 'String'>
    readonly sampleData: FieldRef<"ImportJob", 'Json'>
    readonly fieldMappings: FieldRef<"ImportJob", 'Json'>
    readonly transformRules: FieldRef<"ImportJob", 'Json'>
    readonly validationRules: FieldRef<"ImportJob", 'Json'>
    readonly progressPercent: FieldRef<"ImportJob", 'Int'>
    readonly startedAt: FieldRef<"ImportJob", 'DateTime'>
    readonly completedAt: FieldRef<"ImportJob", 'DateTime'>
    readonly errorSummary: FieldRef<"ImportJob", 'String'>
    readonly createdAt: FieldRef<"ImportJob", 'DateTime'>
    readonly updatedAt: FieldRef<"ImportJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportJob findUnique
   */
  export type ImportJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob findUniqueOrThrow
   */
  export type ImportJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob findFirst
   */
  export type ImportJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportJobs.
     */
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob findFirstOrThrow
   */
  export type ImportJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportJobs.
     */
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob findMany
   */
  export type ImportJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJobs to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob create
   */
  export type ImportJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportJob.
     */
    data: XOR<ImportJobCreateInput, ImportJobUncheckedCreateInput>
  }

  /**
   * ImportJob createMany
   */
  export type ImportJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportJobs.
     */
    data: ImportJobCreateManyInput | ImportJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportJob createManyAndReturn
   */
  export type ImportJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * The data used to create many ImportJobs.
     */
    data: ImportJobCreateManyInput | ImportJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportJob update
   */
  export type ImportJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportJob.
     */
    data: XOR<ImportJobUpdateInput, ImportJobUncheckedUpdateInput>
    /**
     * Choose, which ImportJob to update.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob updateMany
   */
  export type ImportJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportJobs.
     */
    data: XOR<ImportJobUpdateManyMutationInput, ImportJobUncheckedUpdateManyInput>
    /**
     * Filter which ImportJobs to update
     */
    where?: ImportJobWhereInput
    /**
     * Limit how many ImportJobs to update.
     */
    limit?: number
  }

  /**
   * ImportJob updateManyAndReturn
   */
  export type ImportJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * The data used to update ImportJobs.
     */
    data: XOR<ImportJobUpdateManyMutationInput, ImportJobUncheckedUpdateManyInput>
    /**
     * Filter which ImportJobs to update
     */
    where?: ImportJobWhereInput
    /**
     * Limit how many ImportJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportJob upsert
   */
  export type ImportJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportJob to update in case it exists.
     */
    where: ImportJobWhereUniqueInput
    /**
     * In case the ImportJob found by the `where` argument doesn't exist, create a new ImportJob with this data.
     */
    create: XOR<ImportJobCreateInput, ImportJobUncheckedCreateInput>
    /**
     * In case the ImportJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportJobUpdateInput, ImportJobUncheckedUpdateInput>
  }

  /**
   * ImportJob delete
   */
  export type ImportJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter which ImportJob to delete.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob deleteMany
   */
  export type ImportJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportJobs to delete
     */
    where?: ImportJobWhereInput
    /**
     * Limit how many ImportJobs to delete.
     */
    limit?: number
  }

  /**
   * ImportJob.mapping
   */
  export type ImportJob$mappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    where?: ImportMappingWhereInput
  }

  /**
   * ImportJob.errors
   */
  export type ImportJob$errorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
    where?: ImportErrorWhereInput
    orderBy?: ImportErrorOrderByWithRelationInput | ImportErrorOrderByWithRelationInput[]
    cursor?: ImportErrorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportErrorScalarFieldEnum | ImportErrorScalarFieldEnum[]
  }

  /**
   * ImportJob without action
   */
  export type ImportJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
  }


  /**
   * Model ImportMapping
   */

  export type AggregateImportMapping = {
    _count: ImportMappingCountAggregateOutputType | null
    _avg: ImportMappingAvgAggregateOutputType | null
    _sum: ImportMappingSumAggregateOutputType | null
    _min: ImportMappingMinAggregateOutputType | null
    _max: ImportMappingMaxAggregateOutputType | null
  }

  export type ImportMappingAvgAggregateOutputType = {
    useCount: number | null
  }

  export type ImportMappingSumAggregateOutputType = {
    useCount: number | null
  }

  export type ImportMappingMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    entityType: $Enums.ImportEntityType | null
    sourceFormat: string | null
    isTemplate: boolean | null
    useCount: number | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImportMappingMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    entityType: $Enums.ImportEntityType | null
    sourceFormat: string | null
    isTemplate: boolean | null
    useCount: number | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImportMappingCountAggregateOutputType = {
    id: number
    orgId: number
    name: number
    entityType: number
    sourceFormat: number
    fieldMappings: number
    transformRules: number
    validationRules: number
    isTemplate: number
    useCount: number
    lastUsedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImportMappingAvgAggregateInputType = {
    useCount?: true
  }

  export type ImportMappingSumAggregateInputType = {
    useCount?: true
  }

  export type ImportMappingMinAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    entityType?: true
    sourceFormat?: true
    isTemplate?: true
    useCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImportMappingMaxAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    entityType?: true
    sourceFormat?: true
    isTemplate?: true
    useCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImportMappingCountAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    entityType?: true
    sourceFormat?: true
    fieldMappings?: true
    transformRules?: true
    validationRules?: true
    isTemplate?: true
    useCount?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImportMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportMapping to aggregate.
     */
    where?: ImportMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportMappings to fetch.
     */
    orderBy?: ImportMappingOrderByWithRelationInput | ImportMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportMappings
    **/
    _count?: true | ImportMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportMappingMaxAggregateInputType
  }

  export type GetImportMappingAggregateType<T extends ImportMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateImportMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportMapping[P]>
      : GetScalarType<T[P], AggregateImportMapping[P]>
  }




  export type ImportMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportMappingWhereInput
    orderBy?: ImportMappingOrderByWithAggregationInput | ImportMappingOrderByWithAggregationInput[]
    by: ImportMappingScalarFieldEnum[] | ImportMappingScalarFieldEnum
    having?: ImportMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportMappingCountAggregateInputType | true
    _avg?: ImportMappingAvgAggregateInputType
    _sum?: ImportMappingSumAggregateInputType
    _min?: ImportMappingMinAggregateInputType
    _max?: ImportMappingMaxAggregateInputType
  }

  export type ImportMappingGroupByOutputType = {
    id: string
    orgId: string
    name: string
    entityType: $Enums.ImportEntityType
    sourceFormat: string
    fieldMappings: JsonValue
    transformRules: JsonValue
    validationRules: JsonValue
    isTemplate: boolean
    useCount: number
    lastUsedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ImportMappingCountAggregateOutputType | null
    _avg: ImportMappingAvgAggregateOutputType | null
    _sum: ImportMappingSumAggregateOutputType | null
    _min: ImportMappingMinAggregateOutputType | null
    _max: ImportMappingMaxAggregateOutputType | null
  }

  type GetImportMappingGroupByPayload<T extends ImportMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportMappingGroupByOutputType[P]>
            : GetScalarType<T[P], ImportMappingGroupByOutputType[P]>
        }
      >
    >


  export type ImportMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    entityType?: boolean
    sourceFormat?: boolean
    fieldMappings?: boolean
    transformRules?: boolean
    validationRules?: boolean
    isTemplate?: boolean
    useCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
    jobs?: boolean | ImportMapping$jobsArgs<ExtArgs>
    _count?: boolean | ImportMappingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importMapping"]>

  export type ImportMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    entityType?: boolean
    sourceFormat?: boolean
    fieldMappings?: boolean
    transformRules?: boolean
    validationRules?: boolean
    isTemplate?: boolean
    useCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importMapping"]>

  export type ImportMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    entityType?: boolean
    sourceFormat?: boolean
    fieldMappings?: boolean
    transformRules?: boolean
    validationRules?: boolean
    isTemplate?: boolean
    useCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importMapping"]>

  export type ImportMappingSelectScalar = {
    id?: boolean
    orgId?: boolean
    name?: boolean
    entityType?: boolean
    sourceFormat?: boolean
    fieldMappings?: boolean
    transformRules?: boolean
    validationRules?: boolean
    isTemplate?: boolean
    useCount?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImportMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "name" | "entityType" | "sourceFormat" | "fieldMappings" | "transformRules" | "validationRules" | "isTemplate" | "useCount" | "lastUsedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["importMapping"]>
  export type ImportMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
    jobs?: boolean | ImportMapping$jobsArgs<ExtArgs>
    _count?: boolean | ImportMappingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImportMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }
  export type ImportMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrgDefaultArgs<ExtArgs>
  }

  export type $ImportMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportMapping"
    objects: {
      org: Prisma.$OrgPayload<ExtArgs>
      jobs: Prisma.$ImportJobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      name: string
      entityType: $Enums.ImportEntityType
      sourceFormat: string
      fieldMappings: Prisma.JsonValue
      transformRules: Prisma.JsonValue
      validationRules: Prisma.JsonValue
      isTemplate: boolean
      useCount: number
      lastUsedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["importMapping"]>
    composites: {}
  }

  type ImportMappingGetPayload<S extends boolean | null | undefined | ImportMappingDefaultArgs> = $Result.GetResult<Prisma.$ImportMappingPayload, S>

  type ImportMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImportMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImportMappingCountAggregateInputType | true
    }

  export interface ImportMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportMapping'], meta: { name: 'ImportMapping' } }
    /**
     * Find zero or one ImportMapping that matches the filter.
     * @param {ImportMappingFindUniqueArgs} args - Arguments to find a ImportMapping
     * @example
     * // Get one ImportMapping
     * const importMapping = await prisma.importMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportMappingFindUniqueArgs>(args: SelectSubset<T, ImportMappingFindUniqueArgs<ExtArgs>>): Prisma__ImportMappingClient<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImportMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImportMappingFindUniqueOrThrowArgs} args - Arguments to find a ImportMapping
     * @example
     * // Get one ImportMapping
     * const importMapping = await prisma.importMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportMappingClient<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMappingFindFirstArgs} args - Arguments to find a ImportMapping
     * @example
     * // Get one ImportMapping
     * const importMapping = await prisma.importMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportMappingFindFirstArgs>(args?: SelectSubset<T, ImportMappingFindFirstArgs<ExtArgs>>): Prisma__ImportMappingClient<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMappingFindFirstOrThrowArgs} args - Arguments to find a ImportMapping
     * @example
     * // Get one ImportMapping
     * const importMapping = await prisma.importMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportMappingClient<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImportMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportMappings
     * const importMappings = await prisma.importMapping.findMany()
     * 
     * // Get first 10 ImportMappings
     * const importMappings = await prisma.importMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importMappingWithIdOnly = await prisma.importMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportMappingFindManyArgs>(args?: SelectSubset<T, ImportMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImportMapping.
     * @param {ImportMappingCreateArgs} args - Arguments to create a ImportMapping.
     * @example
     * // Create one ImportMapping
     * const ImportMapping = await prisma.importMapping.create({
     *   data: {
     *     // ... data to create a ImportMapping
     *   }
     * })
     * 
     */
    create<T extends ImportMappingCreateArgs>(args: SelectSubset<T, ImportMappingCreateArgs<ExtArgs>>): Prisma__ImportMappingClient<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImportMappings.
     * @param {ImportMappingCreateManyArgs} args - Arguments to create many ImportMappings.
     * @example
     * // Create many ImportMappings
     * const importMapping = await prisma.importMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportMappingCreateManyArgs>(args?: SelectSubset<T, ImportMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportMappings and returns the data saved in the database.
     * @param {ImportMappingCreateManyAndReturnArgs} args - Arguments to create many ImportMappings.
     * @example
     * // Create many ImportMappings
     * const importMapping = await prisma.importMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportMappings and only return the `id`
     * const importMappingWithIdOnly = await prisma.importMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImportMapping.
     * @param {ImportMappingDeleteArgs} args - Arguments to delete one ImportMapping.
     * @example
     * // Delete one ImportMapping
     * const ImportMapping = await prisma.importMapping.delete({
     *   where: {
     *     // ... filter to delete one ImportMapping
     *   }
     * })
     * 
     */
    delete<T extends ImportMappingDeleteArgs>(args: SelectSubset<T, ImportMappingDeleteArgs<ExtArgs>>): Prisma__ImportMappingClient<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImportMapping.
     * @param {ImportMappingUpdateArgs} args - Arguments to update one ImportMapping.
     * @example
     * // Update one ImportMapping
     * const importMapping = await prisma.importMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportMappingUpdateArgs>(args: SelectSubset<T, ImportMappingUpdateArgs<ExtArgs>>): Prisma__ImportMappingClient<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImportMappings.
     * @param {ImportMappingDeleteManyArgs} args - Arguments to filter ImportMappings to delete.
     * @example
     * // Delete a few ImportMappings
     * const { count } = await prisma.importMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportMappingDeleteManyArgs>(args?: SelectSubset<T, ImportMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportMappings
     * const importMapping = await prisma.importMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportMappingUpdateManyArgs>(args: SelectSubset<T, ImportMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportMappings and returns the data updated in the database.
     * @param {ImportMappingUpdateManyAndReturnArgs} args - Arguments to update many ImportMappings.
     * @example
     * // Update many ImportMappings
     * const importMapping = await prisma.importMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImportMappings and only return the `id`
     * const importMappingWithIdOnly = await prisma.importMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImportMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, ImportMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImportMapping.
     * @param {ImportMappingUpsertArgs} args - Arguments to update or create a ImportMapping.
     * @example
     * // Update or create a ImportMapping
     * const importMapping = await prisma.importMapping.upsert({
     *   create: {
     *     // ... data to create a ImportMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportMapping we want to update
     *   }
     * })
     */
    upsert<T extends ImportMappingUpsertArgs>(args: SelectSubset<T, ImportMappingUpsertArgs<ExtArgs>>): Prisma__ImportMappingClient<$Result.GetResult<Prisma.$ImportMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImportMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMappingCountArgs} args - Arguments to filter ImportMappings to count.
     * @example
     * // Count the number of ImportMappings
     * const count = await prisma.importMapping.count({
     *   where: {
     *     // ... the filter for the ImportMappings we want to count
     *   }
     * })
    **/
    count<T extends ImportMappingCountArgs>(
      args?: Subset<T, ImportMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportMappingAggregateArgs>(args: Subset<T, ImportMappingAggregateArgs>): Prisma.PrismaPromise<GetImportMappingAggregateType<T>>

    /**
     * Group by ImportMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportMappingGroupByArgs['orderBy'] }
        : { orderBy?: ImportMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportMapping model
   */
  readonly fields: ImportMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrgDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrgDefaultArgs<ExtArgs>>): Prisma__OrgClient<$Result.GetResult<Prisma.$OrgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobs<T extends ImportMapping$jobsArgs<ExtArgs> = {}>(args?: Subset<T, ImportMapping$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportMapping model
   */
  interface ImportMappingFieldRefs {
    readonly id: FieldRef<"ImportMapping", 'String'>
    readonly orgId: FieldRef<"ImportMapping", 'String'>
    readonly name: FieldRef<"ImportMapping", 'String'>
    readonly entityType: FieldRef<"ImportMapping", 'ImportEntityType'>
    readonly sourceFormat: FieldRef<"ImportMapping", 'String'>
    readonly fieldMappings: FieldRef<"ImportMapping", 'Json'>
    readonly transformRules: FieldRef<"ImportMapping", 'Json'>
    readonly validationRules: FieldRef<"ImportMapping", 'Json'>
    readonly isTemplate: FieldRef<"ImportMapping", 'Boolean'>
    readonly useCount: FieldRef<"ImportMapping", 'Int'>
    readonly lastUsedAt: FieldRef<"ImportMapping", 'DateTime'>
    readonly createdAt: FieldRef<"ImportMapping", 'DateTime'>
    readonly updatedAt: FieldRef<"ImportMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportMapping findUnique
   */
  export type ImportMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    /**
     * Filter, which ImportMapping to fetch.
     */
    where: ImportMappingWhereUniqueInput
  }

  /**
   * ImportMapping findUniqueOrThrow
   */
  export type ImportMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    /**
     * Filter, which ImportMapping to fetch.
     */
    where: ImportMappingWhereUniqueInput
  }

  /**
   * ImportMapping findFirst
   */
  export type ImportMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    /**
     * Filter, which ImportMapping to fetch.
     */
    where?: ImportMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportMappings to fetch.
     */
    orderBy?: ImportMappingOrderByWithRelationInput | ImportMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportMappings.
     */
    cursor?: ImportMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportMappings.
     */
    distinct?: ImportMappingScalarFieldEnum | ImportMappingScalarFieldEnum[]
  }

  /**
   * ImportMapping findFirstOrThrow
   */
  export type ImportMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    /**
     * Filter, which ImportMapping to fetch.
     */
    where?: ImportMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportMappings to fetch.
     */
    orderBy?: ImportMappingOrderByWithRelationInput | ImportMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportMappings.
     */
    cursor?: ImportMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportMappings.
     */
    distinct?: ImportMappingScalarFieldEnum | ImportMappingScalarFieldEnum[]
  }

  /**
   * ImportMapping findMany
   */
  export type ImportMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    /**
     * Filter, which ImportMappings to fetch.
     */
    where?: ImportMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportMappings to fetch.
     */
    orderBy?: ImportMappingOrderByWithRelationInput | ImportMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportMappings.
     */
    cursor?: ImportMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportMappings.
     */
    skip?: number
    distinct?: ImportMappingScalarFieldEnum | ImportMappingScalarFieldEnum[]
  }

  /**
   * ImportMapping create
   */
  export type ImportMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportMapping.
     */
    data: XOR<ImportMappingCreateInput, ImportMappingUncheckedCreateInput>
  }

  /**
   * ImportMapping createMany
   */
  export type ImportMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportMappings.
     */
    data: ImportMappingCreateManyInput | ImportMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportMapping createManyAndReturn
   */
  export type ImportMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * The data used to create many ImportMappings.
     */
    data: ImportMappingCreateManyInput | ImportMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportMapping update
   */
  export type ImportMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportMapping.
     */
    data: XOR<ImportMappingUpdateInput, ImportMappingUncheckedUpdateInput>
    /**
     * Choose, which ImportMapping to update.
     */
    where: ImportMappingWhereUniqueInput
  }

  /**
   * ImportMapping updateMany
   */
  export type ImportMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportMappings.
     */
    data: XOR<ImportMappingUpdateManyMutationInput, ImportMappingUncheckedUpdateManyInput>
    /**
     * Filter which ImportMappings to update
     */
    where?: ImportMappingWhereInput
    /**
     * Limit how many ImportMappings to update.
     */
    limit?: number
  }

  /**
   * ImportMapping updateManyAndReturn
   */
  export type ImportMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * The data used to update ImportMappings.
     */
    data: XOR<ImportMappingUpdateManyMutationInput, ImportMappingUncheckedUpdateManyInput>
    /**
     * Filter which ImportMappings to update
     */
    where?: ImportMappingWhereInput
    /**
     * Limit how many ImportMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportMapping upsert
   */
  export type ImportMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportMapping to update in case it exists.
     */
    where: ImportMappingWhereUniqueInput
    /**
     * In case the ImportMapping found by the `where` argument doesn't exist, create a new ImportMapping with this data.
     */
    create: XOR<ImportMappingCreateInput, ImportMappingUncheckedCreateInput>
    /**
     * In case the ImportMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportMappingUpdateInput, ImportMappingUncheckedUpdateInput>
  }

  /**
   * ImportMapping delete
   */
  export type ImportMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
    /**
     * Filter which ImportMapping to delete.
     */
    where: ImportMappingWhereUniqueInput
  }

  /**
   * ImportMapping deleteMany
   */
  export type ImportMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportMappings to delete
     */
    where?: ImportMappingWhereInput
    /**
     * Limit how many ImportMappings to delete.
     */
    limit?: number
  }

  /**
   * ImportMapping.jobs
   */
  export type ImportMapping$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    where?: ImportJobWhereInput
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    cursor?: ImportJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportMapping without action
   */
  export type ImportMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMapping
     */
    select?: ImportMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportMapping
     */
    omit?: ImportMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMappingInclude<ExtArgs> | null
  }


  /**
   * Model ImportError
   */

  export type AggregateImportError = {
    _count: ImportErrorCountAggregateOutputType | null
    _avg: ImportErrorAvgAggregateOutputType | null
    _sum: ImportErrorSumAggregateOutputType | null
    _min: ImportErrorMinAggregateOutputType | null
    _max: ImportErrorMaxAggregateOutputType | null
  }

  export type ImportErrorAvgAggregateOutputType = {
    rowNumber: number | null
  }

  export type ImportErrorSumAggregateOutputType = {
    rowNumber: number | null
  }

  export type ImportErrorMinAggregateOutputType = {
    id: string | null
    importJobId: string | null
    rowNumber: number | null
    fieldName: string | null
    errorType: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type ImportErrorMaxAggregateOutputType = {
    id: string | null
    importJobId: string | null
    rowNumber: number | null
    fieldName: string | null
    errorType: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type ImportErrorCountAggregateOutputType = {
    id: number
    importJobId: number
    rowNumber: number
    fieldName: number
    errorType: number
    errorMessage: number
    rawData: number
    createdAt: number
    _all: number
  }


  export type ImportErrorAvgAggregateInputType = {
    rowNumber?: true
  }

  export type ImportErrorSumAggregateInputType = {
    rowNumber?: true
  }

  export type ImportErrorMinAggregateInputType = {
    id?: true
    importJobId?: true
    rowNumber?: true
    fieldName?: true
    errorType?: true
    errorMessage?: true
    createdAt?: true
  }

  export type ImportErrorMaxAggregateInputType = {
    id?: true
    importJobId?: true
    rowNumber?: true
    fieldName?: true
    errorType?: true
    errorMessage?: true
    createdAt?: true
  }

  export type ImportErrorCountAggregateInputType = {
    id?: true
    importJobId?: true
    rowNumber?: true
    fieldName?: true
    errorType?: true
    errorMessage?: true
    rawData?: true
    createdAt?: true
    _all?: true
  }

  export type ImportErrorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportError to aggregate.
     */
    where?: ImportErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportErrors to fetch.
     */
    orderBy?: ImportErrorOrderByWithRelationInput | ImportErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportErrors
    **/
    _count?: true | ImportErrorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportErrorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportErrorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportErrorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportErrorMaxAggregateInputType
  }

  export type GetImportErrorAggregateType<T extends ImportErrorAggregateArgs> = {
        [P in keyof T & keyof AggregateImportError]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportError[P]>
      : GetScalarType<T[P], AggregateImportError[P]>
  }




  export type ImportErrorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportErrorWhereInput
    orderBy?: ImportErrorOrderByWithAggregationInput | ImportErrorOrderByWithAggregationInput[]
    by: ImportErrorScalarFieldEnum[] | ImportErrorScalarFieldEnum
    having?: ImportErrorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportErrorCountAggregateInputType | true
    _avg?: ImportErrorAvgAggregateInputType
    _sum?: ImportErrorSumAggregateInputType
    _min?: ImportErrorMinAggregateInputType
    _max?: ImportErrorMaxAggregateInputType
  }

  export type ImportErrorGroupByOutputType = {
    id: string
    importJobId: string
    rowNumber: number
    fieldName: string | null
    errorType: string
    errorMessage: string
    rawData: JsonValue | null
    createdAt: Date
    _count: ImportErrorCountAggregateOutputType | null
    _avg: ImportErrorAvgAggregateOutputType | null
    _sum: ImportErrorSumAggregateOutputType | null
    _min: ImportErrorMinAggregateOutputType | null
    _max: ImportErrorMaxAggregateOutputType | null
  }

  type GetImportErrorGroupByPayload<T extends ImportErrorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportErrorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportErrorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportErrorGroupByOutputType[P]>
            : GetScalarType<T[P], ImportErrorGroupByOutputType[P]>
        }
      >
    >


  export type ImportErrorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    importJobId?: boolean
    rowNumber?: boolean
    fieldName?: boolean
    errorType?: boolean
    errorMessage?: boolean
    rawData?: boolean
    createdAt?: boolean
    importJob?: boolean | ImportJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importError"]>

  export type ImportErrorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    importJobId?: boolean
    rowNumber?: boolean
    fieldName?: boolean
    errorType?: boolean
    errorMessage?: boolean
    rawData?: boolean
    createdAt?: boolean
    importJob?: boolean | ImportJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importError"]>

  export type ImportErrorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    importJobId?: boolean
    rowNumber?: boolean
    fieldName?: boolean
    errorType?: boolean
    errorMessage?: boolean
    rawData?: boolean
    createdAt?: boolean
    importJob?: boolean | ImportJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importError"]>

  export type ImportErrorSelectScalar = {
    id?: boolean
    importJobId?: boolean
    rowNumber?: boolean
    fieldName?: boolean
    errorType?: boolean
    errorMessage?: boolean
    rawData?: boolean
    createdAt?: boolean
  }

  export type ImportErrorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "importJobId" | "rowNumber" | "fieldName" | "errorType" | "errorMessage" | "rawData" | "createdAt", ExtArgs["result"]["importError"]>
  export type ImportErrorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importJob?: boolean | ImportJobDefaultArgs<ExtArgs>
  }
  export type ImportErrorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importJob?: boolean | ImportJobDefaultArgs<ExtArgs>
  }
  export type ImportErrorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importJob?: boolean | ImportJobDefaultArgs<ExtArgs>
  }

  export type $ImportErrorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportError"
    objects: {
      importJob: Prisma.$ImportJobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      importJobId: string
      rowNumber: number
      fieldName: string | null
      errorType: string
      errorMessage: string
      rawData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["importError"]>
    composites: {}
  }

  type ImportErrorGetPayload<S extends boolean | null | undefined | ImportErrorDefaultArgs> = $Result.GetResult<Prisma.$ImportErrorPayload, S>

  type ImportErrorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImportErrorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImportErrorCountAggregateInputType | true
    }

  export interface ImportErrorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportError'], meta: { name: 'ImportError' } }
    /**
     * Find zero or one ImportError that matches the filter.
     * @param {ImportErrorFindUniqueArgs} args - Arguments to find a ImportError
     * @example
     * // Get one ImportError
     * const importError = await prisma.importError.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportErrorFindUniqueArgs>(args: SelectSubset<T, ImportErrorFindUniqueArgs<ExtArgs>>): Prisma__ImportErrorClient<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImportError that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImportErrorFindUniqueOrThrowArgs} args - Arguments to find a ImportError
     * @example
     * // Get one ImportError
     * const importError = await prisma.importError.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportErrorFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportErrorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportErrorClient<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportError that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportErrorFindFirstArgs} args - Arguments to find a ImportError
     * @example
     * // Get one ImportError
     * const importError = await prisma.importError.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportErrorFindFirstArgs>(args?: SelectSubset<T, ImportErrorFindFirstArgs<ExtArgs>>): Prisma__ImportErrorClient<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportError that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportErrorFindFirstOrThrowArgs} args - Arguments to find a ImportError
     * @example
     * // Get one ImportError
     * const importError = await prisma.importError.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportErrorFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportErrorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportErrorClient<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImportErrors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportErrorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportErrors
     * const importErrors = await prisma.importError.findMany()
     * 
     * // Get first 10 ImportErrors
     * const importErrors = await prisma.importError.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importErrorWithIdOnly = await prisma.importError.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportErrorFindManyArgs>(args?: SelectSubset<T, ImportErrorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImportError.
     * @param {ImportErrorCreateArgs} args - Arguments to create a ImportError.
     * @example
     * // Create one ImportError
     * const ImportError = await prisma.importError.create({
     *   data: {
     *     // ... data to create a ImportError
     *   }
     * })
     * 
     */
    create<T extends ImportErrorCreateArgs>(args: SelectSubset<T, ImportErrorCreateArgs<ExtArgs>>): Prisma__ImportErrorClient<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImportErrors.
     * @param {ImportErrorCreateManyArgs} args - Arguments to create many ImportErrors.
     * @example
     * // Create many ImportErrors
     * const importError = await prisma.importError.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportErrorCreateManyArgs>(args?: SelectSubset<T, ImportErrorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportErrors and returns the data saved in the database.
     * @param {ImportErrorCreateManyAndReturnArgs} args - Arguments to create many ImportErrors.
     * @example
     * // Create many ImportErrors
     * const importError = await prisma.importError.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportErrors and only return the `id`
     * const importErrorWithIdOnly = await prisma.importError.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportErrorCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportErrorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImportError.
     * @param {ImportErrorDeleteArgs} args - Arguments to delete one ImportError.
     * @example
     * // Delete one ImportError
     * const ImportError = await prisma.importError.delete({
     *   where: {
     *     // ... filter to delete one ImportError
     *   }
     * })
     * 
     */
    delete<T extends ImportErrorDeleteArgs>(args: SelectSubset<T, ImportErrorDeleteArgs<ExtArgs>>): Prisma__ImportErrorClient<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImportError.
     * @param {ImportErrorUpdateArgs} args - Arguments to update one ImportError.
     * @example
     * // Update one ImportError
     * const importError = await prisma.importError.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportErrorUpdateArgs>(args: SelectSubset<T, ImportErrorUpdateArgs<ExtArgs>>): Prisma__ImportErrorClient<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImportErrors.
     * @param {ImportErrorDeleteManyArgs} args - Arguments to filter ImportErrors to delete.
     * @example
     * // Delete a few ImportErrors
     * const { count } = await prisma.importError.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportErrorDeleteManyArgs>(args?: SelectSubset<T, ImportErrorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportErrors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportErrorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportErrors
     * const importError = await prisma.importError.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportErrorUpdateManyArgs>(args: SelectSubset<T, ImportErrorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportErrors and returns the data updated in the database.
     * @param {ImportErrorUpdateManyAndReturnArgs} args - Arguments to update many ImportErrors.
     * @example
     * // Update many ImportErrors
     * const importError = await prisma.importError.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImportErrors and only return the `id`
     * const importErrorWithIdOnly = await prisma.importError.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImportErrorUpdateManyAndReturnArgs>(args: SelectSubset<T, ImportErrorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImportError.
     * @param {ImportErrorUpsertArgs} args - Arguments to update or create a ImportError.
     * @example
     * // Update or create a ImportError
     * const importError = await prisma.importError.upsert({
     *   create: {
     *     // ... data to create a ImportError
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportError we want to update
     *   }
     * })
     */
    upsert<T extends ImportErrorUpsertArgs>(args: SelectSubset<T, ImportErrorUpsertArgs<ExtArgs>>): Prisma__ImportErrorClient<$Result.GetResult<Prisma.$ImportErrorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImportErrors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportErrorCountArgs} args - Arguments to filter ImportErrors to count.
     * @example
     * // Count the number of ImportErrors
     * const count = await prisma.importError.count({
     *   where: {
     *     // ... the filter for the ImportErrors we want to count
     *   }
     * })
    **/
    count<T extends ImportErrorCountArgs>(
      args?: Subset<T, ImportErrorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportErrorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportError.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportErrorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportErrorAggregateArgs>(args: Subset<T, ImportErrorAggregateArgs>): Prisma.PrismaPromise<GetImportErrorAggregateType<T>>

    /**
     * Group by ImportError.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportErrorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportErrorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportErrorGroupByArgs['orderBy'] }
        : { orderBy?: ImportErrorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportErrorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportErrorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportError model
   */
  readonly fields: ImportErrorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportError.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportErrorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    importJob<T extends ImportJobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ImportJobDefaultArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportError model
   */
  interface ImportErrorFieldRefs {
    readonly id: FieldRef<"ImportError", 'String'>
    readonly importJobId: FieldRef<"ImportError", 'String'>
    readonly rowNumber: FieldRef<"ImportError", 'Int'>
    readonly fieldName: FieldRef<"ImportError", 'String'>
    readonly errorType: FieldRef<"ImportError", 'String'>
    readonly errorMessage: FieldRef<"ImportError", 'String'>
    readonly rawData: FieldRef<"ImportError", 'Json'>
    readonly createdAt: FieldRef<"ImportError", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportError findUnique
   */
  export type ImportErrorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
    /**
     * Filter, which ImportError to fetch.
     */
    where: ImportErrorWhereUniqueInput
  }

  /**
   * ImportError findUniqueOrThrow
   */
  export type ImportErrorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
    /**
     * Filter, which ImportError to fetch.
     */
    where: ImportErrorWhereUniqueInput
  }

  /**
   * ImportError findFirst
   */
  export type ImportErrorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
    /**
     * Filter, which ImportError to fetch.
     */
    where?: ImportErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportErrors to fetch.
     */
    orderBy?: ImportErrorOrderByWithRelationInput | ImportErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportErrors.
     */
    cursor?: ImportErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportErrors.
     */
    distinct?: ImportErrorScalarFieldEnum | ImportErrorScalarFieldEnum[]
  }

  /**
   * ImportError findFirstOrThrow
   */
  export type ImportErrorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
    /**
     * Filter, which ImportError to fetch.
     */
    where?: ImportErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportErrors to fetch.
     */
    orderBy?: ImportErrorOrderByWithRelationInput | ImportErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportErrors.
     */
    cursor?: ImportErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportErrors.
     */
    distinct?: ImportErrorScalarFieldEnum | ImportErrorScalarFieldEnum[]
  }

  /**
   * ImportError findMany
   */
  export type ImportErrorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
    /**
     * Filter, which ImportErrors to fetch.
     */
    where?: ImportErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportErrors to fetch.
     */
    orderBy?: ImportErrorOrderByWithRelationInput | ImportErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportErrors.
     */
    cursor?: ImportErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportErrors.
     */
    skip?: number
    distinct?: ImportErrorScalarFieldEnum | ImportErrorScalarFieldEnum[]
  }

  /**
   * ImportError create
   */
  export type ImportErrorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportError.
     */
    data: XOR<ImportErrorCreateInput, ImportErrorUncheckedCreateInput>
  }

  /**
   * ImportError createMany
   */
  export type ImportErrorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportErrors.
     */
    data: ImportErrorCreateManyInput | ImportErrorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportError createManyAndReturn
   */
  export type ImportErrorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * The data used to create many ImportErrors.
     */
    data: ImportErrorCreateManyInput | ImportErrorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportError update
   */
  export type ImportErrorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportError.
     */
    data: XOR<ImportErrorUpdateInput, ImportErrorUncheckedUpdateInput>
    /**
     * Choose, which ImportError to update.
     */
    where: ImportErrorWhereUniqueInput
  }

  /**
   * ImportError updateMany
   */
  export type ImportErrorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportErrors.
     */
    data: XOR<ImportErrorUpdateManyMutationInput, ImportErrorUncheckedUpdateManyInput>
    /**
     * Filter which ImportErrors to update
     */
    where?: ImportErrorWhereInput
    /**
     * Limit how many ImportErrors to update.
     */
    limit?: number
  }

  /**
   * ImportError updateManyAndReturn
   */
  export type ImportErrorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * The data used to update ImportErrors.
     */
    data: XOR<ImportErrorUpdateManyMutationInput, ImportErrorUncheckedUpdateManyInput>
    /**
     * Filter which ImportErrors to update
     */
    where?: ImportErrorWhereInput
    /**
     * Limit how many ImportErrors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportError upsert
   */
  export type ImportErrorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportError to update in case it exists.
     */
    where: ImportErrorWhereUniqueInput
    /**
     * In case the ImportError found by the `where` argument doesn't exist, create a new ImportError with this data.
     */
    create: XOR<ImportErrorCreateInput, ImportErrorUncheckedCreateInput>
    /**
     * In case the ImportError was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportErrorUpdateInput, ImportErrorUncheckedUpdateInput>
  }

  /**
   * ImportError delete
   */
  export type ImportErrorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
    /**
     * Filter which ImportError to delete.
     */
    where: ImportErrorWhereUniqueInput
  }

  /**
   * ImportError deleteMany
   */
  export type ImportErrorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportErrors to delete
     */
    where?: ImportErrorWhereInput
    /**
     * Limit how many ImportErrors to delete.
     */
    limit?: number
  }

  /**
   * ImportError without action
   */
  export type ImportErrorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportError
     */
    select?: ImportErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportError
     */
    omit?: ImportErrorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportErrorInclude<ExtArgs> | null
  }


  /**
   * Model UpgradeRecommendation
   */

  export type AggregateUpgradeRecommendation = {
    _count: UpgradeRecommendationCountAggregateOutputType | null
    _avg: UpgradeRecommendationAvgAggregateOutputType | null
    _sum: UpgradeRecommendationSumAggregateOutputType | null
    _min: UpgradeRecommendationMinAggregateOutputType | null
    _max: UpgradeRecommendationMaxAggregateOutputType | null
  }

  export type UpgradeRecommendationAvgAggregateOutputType = {
    currentUsage: number | null
    limitValue: number | null
    usagePercent: number | null
    daysToLimit: number | null
    currentCost: number | null
    projectedCost: number | null
    upgradeCost: number | null
    revenueImpact: number | null
    profitImpact: number | null
    roi: number | null
    estimatedCostUsd: number | null
    estimatedSavings: number | null
    roiMonths: number | null
  }

  export type UpgradeRecommendationSumAggregateOutputType = {
    currentUsage: number | null
    limitValue: number | null
    usagePercent: number | null
    daysToLimit: number | null
    currentCost: number | null
    projectedCost: number | null
    upgradeCost: number | null
    revenueImpact: number | null
    profitImpact: number | null
    roi: number | null
    estimatedCostUsd: number | null
    estimatedSavings: number | null
    roiMonths: number | null
  }

  export type UpgradeRecommendationMinAggregateOutputType = {
    id: string | null
    service: $Enums.InfrastructureService | null
    currentPlan: string | null
    recommendedPlan: string | null
    priority: $Enums.RecommendationPriority | null
    status: $Enums.RecommendationStatus | null
    reason: string | null
    currentUsage: number | null
    limitValue: number | null
    usagePercent: number | null
    daysToLimit: number | null
    currentCost: number | null
    projectedCost: number | null
    upgradeCost: number | null
    revenueImpact: number | null
    profitImpact: number | null
    roi: number | null
    benefits: string | null
    risks: string | null
    estimatedCostUsd: number | null
    estimatedSavings: number | null
    roiMonths: number | null
    createdAt: Date | null
    updatedAt: Date | null
    acknowledgedAt: Date | null
    implementedAt: Date | null
  }

  export type UpgradeRecommendationMaxAggregateOutputType = {
    id: string | null
    service: $Enums.InfrastructureService | null
    currentPlan: string | null
    recommendedPlan: string | null
    priority: $Enums.RecommendationPriority | null
    status: $Enums.RecommendationStatus | null
    reason: string | null
    currentUsage: number | null
    limitValue: number | null
    usagePercent: number | null
    daysToLimit: number | null
    currentCost: number | null
    projectedCost: number | null
    upgradeCost: number | null
    revenueImpact: number | null
    profitImpact: number | null
    roi: number | null
    benefits: string | null
    risks: string | null
    estimatedCostUsd: number | null
    estimatedSavings: number | null
    roiMonths: number | null
    createdAt: Date | null
    updatedAt: Date | null
    acknowledgedAt: Date | null
    implementedAt: Date | null
  }

  export type UpgradeRecommendationCountAggregateOutputType = {
    id: number
    service: number
    currentPlan: number
    recommendedPlan: number
    priority: number
    status: number
    reason: number
    currentUsage: number
    limitValue: number
    usagePercent: number
    daysToLimit: number
    currentCost: number
    projectedCost: number
    upgradeCost: number
    revenueImpact: number
    profitImpact: number
    roi: number
    benefits: number
    risks: number
    estimatedCostUsd: number
    estimatedSavings: number
    roiMonths: number
    createdAt: number
    updatedAt: number
    acknowledgedAt: number
    implementedAt: number
    _all: number
  }


  export type UpgradeRecommendationAvgAggregateInputType = {
    currentUsage?: true
    limitValue?: true
    usagePercent?: true
    daysToLimit?: true
    currentCost?: true
    projectedCost?: true
    upgradeCost?: true
    revenueImpact?: true
    profitImpact?: true
    roi?: true
    estimatedCostUsd?: true
    estimatedSavings?: true
    roiMonths?: true
  }

  export type UpgradeRecommendationSumAggregateInputType = {
    currentUsage?: true
    limitValue?: true
    usagePercent?: true
    daysToLimit?: true
    currentCost?: true
    projectedCost?: true
    upgradeCost?: true
    revenueImpact?: true
    profitImpact?: true
    roi?: true
    estimatedCostUsd?: true
    estimatedSavings?: true
    roiMonths?: true
  }

  export type UpgradeRecommendationMinAggregateInputType = {
    id?: true
    service?: true
    currentPlan?: true
    recommendedPlan?: true
    priority?: true
    status?: true
    reason?: true
    currentUsage?: true
    limitValue?: true
    usagePercent?: true
    daysToLimit?: true
    currentCost?: true
    projectedCost?: true
    upgradeCost?: true
    revenueImpact?: true
    profitImpact?: true
    roi?: true
    benefits?: true
    risks?: true
    estimatedCostUsd?: true
    estimatedSavings?: true
    roiMonths?: true
    createdAt?: true
    updatedAt?: true
    acknowledgedAt?: true
    implementedAt?: true
  }

  export type UpgradeRecommendationMaxAggregateInputType = {
    id?: true
    service?: true
    currentPlan?: true
    recommendedPlan?: true
    priority?: true
    status?: true
    reason?: true
    currentUsage?: true
    limitValue?: true
    usagePercent?: true
    daysToLimit?: true
    currentCost?: true
    projectedCost?: true
    upgradeCost?: true
    revenueImpact?: true
    profitImpact?: true
    roi?: true
    benefits?: true
    risks?: true
    estimatedCostUsd?: true
    estimatedSavings?: true
    roiMonths?: true
    createdAt?: true
    updatedAt?: true
    acknowledgedAt?: true
    implementedAt?: true
  }

  export type UpgradeRecommendationCountAggregateInputType = {
    id?: true
    service?: true
    currentPlan?: true
    recommendedPlan?: true
    priority?: true
    status?: true
    reason?: true
    currentUsage?: true
    limitValue?: true
    usagePercent?: true
    daysToLimit?: true
    currentCost?: true
    projectedCost?: true
    upgradeCost?: true
    revenueImpact?: true
    profitImpact?: true
    roi?: true
    benefits?: true
    risks?: true
    estimatedCostUsd?: true
    estimatedSavings?: true
    roiMonths?: true
    createdAt?: true
    updatedAt?: true
    acknowledgedAt?: true
    implementedAt?: true
    _all?: true
  }

  export type UpgradeRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UpgradeRecommendation to aggregate.
     */
    where?: UpgradeRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpgradeRecommendations to fetch.
     */
    orderBy?: UpgradeRecommendationOrderByWithRelationInput | UpgradeRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UpgradeRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpgradeRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpgradeRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UpgradeRecommendations
    **/
    _count?: true | UpgradeRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UpgradeRecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UpgradeRecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UpgradeRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UpgradeRecommendationMaxAggregateInputType
  }

  export type GetUpgradeRecommendationAggregateType<T extends UpgradeRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateUpgradeRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpgradeRecommendation[P]>
      : GetScalarType<T[P], AggregateUpgradeRecommendation[P]>
  }




  export type UpgradeRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpgradeRecommendationWhereInput
    orderBy?: UpgradeRecommendationOrderByWithAggregationInput | UpgradeRecommendationOrderByWithAggregationInput[]
    by: UpgradeRecommendationScalarFieldEnum[] | UpgradeRecommendationScalarFieldEnum
    having?: UpgradeRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UpgradeRecommendationCountAggregateInputType | true
    _avg?: UpgradeRecommendationAvgAggregateInputType
    _sum?: UpgradeRecommendationSumAggregateInputType
    _min?: UpgradeRecommendationMinAggregateInputType
    _max?: UpgradeRecommendationMaxAggregateInputType
  }

  export type UpgradeRecommendationGroupByOutputType = {
    id: string
    service: $Enums.InfrastructureService
    currentPlan: string
    recommendedPlan: string
    priority: $Enums.RecommendationPriority
    status: $Enums.RecommendationStatus
    reason: string
    currentUsage: number | null
    limitValue: number | null
    usagePercent: number | null
    daysToLimit: number | null
    currentCost: number | null
    projectedCost: number | null
    upgradeCost: number | null
    revenueImpact: number | null
    profitImpact: number | null
    roi: number | null
    benefits: string | null
    risks: string | null
    estimatedCostUsd: number | null
    estimatedSavings: number | null
    roiMonths: number | null
    createdAt: Date
    updatedAt: Date
    acknowledgedAt: Date | null
    implementedAt: Date | null
    _count: UpgradeRecommendationCountAggregateOutputType | null
    _avg: UpgradeRecommendationAvgAggregateOutputType | null
    _sum: UpgradeRecommendationSumAggregateOutputType | null
    _min: UpgradeRecommendationMinAggregateOutputType | null
    _max: UpgradeRecommendationMaxAggregateOutputType | null
  }

  type GetUpgradeRecommendationGroupByPayload<T extends UpgradeRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UpgradeRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UpgradeRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UpgradeRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], UpgradeRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type UpgradeRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    currentPlan?: boolean
    recommendedPlan?: boolean
    priority?: boolean
    status?: boolean
    reason?: boolean
    currentUsage?: boolean
    limitValue?: boolean
    usagePercent?: boolean
    daysToLimit?: boolean
    currentCost?: boolean
    projectedCost?: boolean
    upgradeCost?: boolean
    revenueImpact?: boolean
    profitImpact?: boolean
    roi?: boolean
    benefits?: boolean
    risks?: boolean
    estimatedCostUsd?: boolean
    estimatedSavings?: boolean
    roiMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acknowledgedAt?: boolean
    implementedAt?: boolean
  }, ExtArgs["result"]["upgradeRecommendation"]>

  export type UpgradeRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    currentPlan?: boolean
    recommendedPlan?: boolean
    priority?: boolean
    status?: boolean
    reason?: boolean
    currentUsage?: boolean
    limitValue?: boolean
    usagePercent?: boolean
    daysToLimit?: boolean
    currentCost?: boolean
    projectedCost?: boolean
    upgradeCost?: boolean
    revenueImpact?: boolean
    profitImpact?: boolean
    roi?: boolean
    benefits?: boolean
    risks?: boolean
    estimatedCostUsd?: boolean
    estimatedSavings?: boolean
    roiMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acknowledgedAt?: boolean
    implementedAt?: boolean
  }, ExtArgs["result"]["upgradeRecommendation"]>

  export type UpgradeRecommendationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    currentPlan?: boolean
    recommendedPlan?: boolean
    priority?: boolean
    status?: boolean
    reason?: boolean
    currentUsage?: boolean
    limitValue?: boolean
    usagePercent?: boolean
    daysToLimit?: boolean
    currentCost?: boolean
    projectedCost?: boolean
    upgradeCost?: boolean
    revenueImpact?: boolean
    profitImpact?: boolean
    roi?: boolean
    benefits?: boolean
    risks?: boolean
    estimatedCostUsd?: boolean
    estimatedSavings?: boolean
    roiMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acknowledgedAt?: boolean
    implementedAt?: boolean
  }, ExtArgs["result"]["upgradeRecommendation"]>

  export type UpgradeRecommendationSelectScalar = {
    id?: boolean
    service?: boolean
    currentPlan?: boolean
    recommendedPlan?: boolean
    priority?: boolean
    status?: boolean
    reason?: boolean
    currentUsage?: boolean
    limitValue?: boolean
    usagePercent?: boolean
    daysToLimit?: boolean
    currentCost?: boolean
    projectedCost?: boolean
    upgradeCost?: boolean
    revenueImpact?: boolean
    profitImpact?: boolean
    roi?: boolean
    benefits?: boolean
    risks?: boolean
    estimatedCostUsd?: boolean
    estimatedSavings?: boolean
    roiMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acknowledgedAt?: boolean
    implementedAt?: boolean
  }

  export type UpgradeRecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service" | "currentPlan" | "recommendedPlan" | "priority" | "status" | "reason" | "currentUsage" | "limitValue" | "usagePercent" | "daysToLimit" | "currentCost" | "projectedCost" | "upgradeCost" | "revenueImpact" | "profitImpact" | "roi" | "benefits" | "risks" | "estimatedCostUsd" | "estimatedSavings" | "roiMonths" | "createdAt" | "updatedAt" | "acknowledgedAt" | "implementedAt", ExtArgs["result"]["upgradeRecommendation"]>

  export type $UpgradeRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UpgradeRecommendation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service: $Enums.InfrastructureService
      currentPlan: string
      recommendedPlan: string
      priority: $Enums.RecommendationPriority
      status: $Enums.RecommendationStatus
      reason: string
      currentUsage: number | null
      limitValue: number | null
      usagePercent: number | null
      daysToLimit: number | null
      currentCost: number | null
      projectedCost: number | null
      upgradeCost: number | null
      revenueImpact: number | null
      profitImpact: number | null
      roi: number | null
      benefits: string | null
      risks: string | null
      estimatedCostUsd: number | null
      estimatedSavings: number | null
      roiMonths: number | null
      createdAt: Date
      updatedAt: Date
      acknowledgedAt: Date | null
      implementedAt: Date | null
    }, ExtArgs["result"]["upgradeRecommendation"]>
    composites: {}
  }

  type UpgradeRecommendationGetPayload<S extends boolean | null | undefined | UpgradeRecommendationDefaultArgs> = $Result.GetResult<Prisma.$UpgradeRecommendationPayload, S>

  type UpgradeRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UpgradeRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UpgradeRecommendationCountAggregateInputType | true
    }

  export interface UpgradeRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UpgradeRecommendation'], meta: { name: 'UpgradeRecommendation' } }
    /**
     * Find zero or one UpgradeRecommendation that matches the filter.
     * @param {UpgradeRecommendationFindUniqueArgs} args - Arguments to find a UpgradeRecommendation
     * @example
     * // Get one UpgradeRecommendation
     * const upgradeRecommendation = await prisma.upgradeRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UpgradeRecommendationFindUniqueArgs>(args: SelectSubset<T, UpgradeRecommendationFindUniqueArgs<ExtArgs>>): Prisma__UpgradeRecommendationClient<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UpgradeRecommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UpgradeRecommendationFindUniqueOrThrowArgs} args - Arguments to find a UpgradeRecommendation
     * @example
     * // Get one UpgradeRecommendation
     * const upgradeRecommendation = await prisma.upgradeRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UpgradeRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, UpgradeRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UpgradeRecommendationClient<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UpgradeRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpgradeRecommendationFindFirstArgs} args - Arguments to find a UpgradeRecommendation
     * @example
     * // Get one UpgradeRecommendation
     * const upgradeRecommendation = await prisma.upgradeRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UpgradeRecommendationFindFirstArgs>(args?: SelectSubset<T, UpgradeRecommendationFindFirstArgs<ExtArgs>>): Prisma__UpgradeRecommendationClient<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UpgradeRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpgradeRecommendationFindFirstOrThrowArgs} args - Arguments to find a UpgradeRecommendation
     * @example
     * // Get one UpgradeRecommendation
     * const upgradeRecommendation = await prisma.upgradeRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UpgradeRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, UpgradeRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UpgradeRecommendationClient<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UpgradeRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpgradeRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UpgradeRecommendations
     * const upgradeRecommendations = await prisma.upgradeRecommendation.findMany()
     * 
     * // Get first 10 UpgradeRecommendations
     * const upgradeRecommendations = await prisma.upgradeRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const upgradeRecommendationWithIdOnly = await prisma.upgradeRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UpgradeRecommendationFindManyArgs>(args?: SelectSubset<T, UpgradeRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UpgradeRecommendation.
     * @param {UpgradeRecommendationCreateArgs} args - Arguments to create a UpgradeRecommendation.
     * @example
     * // Create one UpgradeRecommendation
     * const UpgradeRecommendation = await prisma.upgradeRecommendation.create({
     *   data: {
     *     // ... data to create a UpgradeRecommendation
     *   }
     * })
     * 
     */
    create<T extends UpgradeRecommendationCreateArgs>(args: SelectSubset<T, UpgradeRecommendationCreateArgs<ExtArgs>>): Prisma__UpgradeRecommendationClient<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UpgradeRecommendations.
     * @param {UpgradeRecommendationCreateManyArgs} args - Arguments to create many UpgradeRecommendations.
     * @example
     * // Create many UpgradeRecommendations
     * const upgradeRecommendation = await prisma.upgradeRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UpgradeRecommendationCreateManyArgs>(args?: SelectSubset<T, UpgradeRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UpgradeRecommendations and returns the data saved in the database.
     * @param {UpgradeRecommendationCreateManyAndReturnArgs} args - Arguments to create many UpgradeRecommendations.
     * @example
     * // Create many UpgradeRecommendations
     * const upgradeRecommendation = await prisma.upgradeRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UpgradeRecommendations and only return the `id`
     * const upgradeRecommendationWithIdOnly = await prisma.upgradeRecommendation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UpgradeRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, UpgradeRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UpgradeRecommendation.
     * @param {UpgradeRecommendationDeleteArgs} args - Arguments to delete one UpgradeRecommendation.
     * @example
     * // Delete one UpgradeRecommendation
     * const UpgradeRecommendation = await prisma.upgradeRecommendation.delete({
     *   where: {
     *     // ... filter to delete one UpgradeRecommendation
     *   }
     * })
     * 
     */
    delete<T extends UpgradeRecommendationDeleteArgs>(args: SelectSubset<T, UpgradeRecommendationDeleteArgs<ExtArgs>>): Prisma__UpgradeRecommendationClient<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UpgradeRecommendation.
     * @param {UpgradeRecommendationUpdateArgs} args - Arguments to update one UpgradeRecommendation.
     * @example
     * // Update one UpgradeRecommendation
     * const upgradeRecommendation = await prisma.upgradeRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UpgradeRecommendationUpdateArgs>(args: SelectSubset<T, UpgradeRecommendationUpdateArgs<ExtArgs>>): Prisma__UpgradeRecommendationClient<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UpgradeRecommendations.
     * @param {UpgradeRecommendationDeleteManyArgs} args - Arguments to filter UpgradeRecommendations to delete.
     * @example
     * // Delete a few UpgradeRecommendations
     * const { count } = await prisma.upgradeRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UpgradeRecommendationDeleteManyArgs>(args?: SelectSubset<T, UpgradeRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UpgradeRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpgradeRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UpgradeRecommendations
     * const upgradeRecommendation = await prisma.upgradeRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UpgradeRecommendationUpdateManyArgs>(args: SelectSubset<T, UpgradeRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UpgradeRecommendations and returns the data updated in the database.
     * @param {UpgradeRecommendationUpdateManyAndReturnArgs} args - Arguments to update many UpgradeRecommendations.
     * @example
     * // Update many UpgradeRecommendations
     * const upgradeRecommendation = await prisma.upgradeRecommendation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UpgradeRecommendations and only return the `id`
     * const upgradeRecommendationWithIdOnly = await prisma.upgradeRecommendation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UpgradeRecommendationUpdateManyAndReturnArgs>(args: SelectSubset<T, UpgradeRecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UpgradeRecommendation.
     * @param {UpgradeRecommendationUpsertArgs} args - Arguments to update or create a UpgradeRecommendation.
     * @example
     * // Update or create a UpgradeRecommendation
     * const upgradeRecommendation = await prisma.upgradeRecommendation.upsert({
     *   create: {
     *     // ... data to create a UpgradeRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UpgradeRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends UpgradeRecommendationUpsertArgs>(args: SelectSubset<T, UpgradeRecommendationUpsertArgs<ExtArgs>>): Prisma__UpgradeRecommendationClient<$Result.GetResult<Prisma.$UpgradeRecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UpgradeRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpgradeRecommendationCountArgs} args - Arguments to filter UpgradeRecommendations to count.
     * @example
     * // Count the number of UpgradeRecommendations
     * const count = await prisma.upgradeRecommendation.count({
     *   where: {
     *     // ... the filter for the UpgradeRecommendations we want to count
     *   }
     * })
    **/
    count<T extends UpgradeRecommendationCountArgs>(
      args?: Subset<T, UpgradeRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UpgradeRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UpgradeRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpgradeRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UpgradeRecommendationAggregateArgs>(args: Subset<T, UpgradeRecommendationAggregateArgs>): Prisma.PrismaPromise<GetUpgradeRecommendationAggregateType<T>>

    /**
     * Group by UpgradeRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpgradeRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UpgradeRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UpgradeRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: UpgradeRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UpgradeRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpgradeRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UpgradeRecommendation model
   */
  readonly fields: UpgradeRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UpgradeRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UpgradeRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UpgradeRecommendation model
   */
  interface UpgradeRecommendationFieldRefs {
    readonly id: FieldRef<"UpgradeRecommendation", 'String'>
    readonly service: FieldRef<"UpgradeRecommendation", 'InfrastructureService'>
    readonly currentPlan: FieldRef<"UpgradeRecommendation", 'String'>
    readonly recommendedPlan: FieldRef<"UpgradeRecommendation", 'String'>
    readonly priority: FieldRef<"UpgradeRecommendation", 'RecommendationPriority'>
    readonly status: FieldRef<"UpgradeRecommendation", 'RecommendationStatus'>
    readonly reason: FieldRef<"UpgradeRecommendation", 'String'>
    readonly currentUsage: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly limitValue: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly usagePercent: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly daysToLimit: FieldRef<"UpgradeRecommendation", 'Int'>
    readonly currentCost: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly projectedCost: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly upgradeCost: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly revenueImpact: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly profitImpact: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly roi: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly benefits: FieldRef<"UpgradeRecommendation", 'String'>
    readonly risks: FieldRef<"UpgradeRecommendation", 'String'>
    readonly estimatedCostUsd: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly estimatedSavings: FieldRef<"UpgradeRecommendation", 'Float'>
    readonly roiMonths: FieldRef<"UpgradeRecommendation", 'Int'>
    readonly createdAt: FieldRef<"UpgradeRecommendation", 'DateTime'>
    readonly updatedAt: FieldRef<"UpgradeRecommendation", 'DateTime'>
    readonly acknowledgedAt: FieldRef<"UpgradeRecommendation", 'DateTime'>
    readonly implementedAt: FieldRef<"UpgradeRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UpgradeRecommendation findUnique
   */
  export type UpgradeRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * Filter, which UpgradeRecommendation to fetch.
     */
    where: UpgradeRecommendationWhereUniqueInput
  }

  /**
   * UpgradeRecommendation findUniqueOrThrow
   */
  export type UpgradeRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * Filter, which UpgradeRecommendation to fetch.
     */
    where: UpgradeRecommendationWhereUniqueInput
  }

  /**
   * UpgradeRecommendation findFirst
   */
  export type UpgradeRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * Filter, which UpgradeRecommendation to fetch.
     */
    where?: UpgradeRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpgradeRecommendations to fetch.
     */
    orderBy?: UpgradeRecommendationOrderByWithRelationInput | UpgradeRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UpgradeRecommendations.
     */
    cursor?: UpgradeRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpgradeRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpgradeRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UpgradeRecommendations.
     */
    distinct?: UpgradeRecommendationScalarFieldEnum | UpgradeRecommendationScalarFieldEnum[]
  }

  /**
   * UpgradeRecommendation findFirstOrThrow
   */
  export type UpgradeRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * Filter, which UpgradeRecommendation to fetch.
     */
    where?: UpgradeRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpgradeRecommendations to fetch.
     */
    orderBy?: UpgradeRecommendationOrderByWithRelationInput | UpgradeRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UpgradeRecommendations.
     */
    cursor?: UpgradeRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpgradeRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpgradeRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UpgradeRecommendations.
     */
    distinct?: UpgradeRecommendationScalarFieldEnum | UpgradeRecommendationScalarFieldEnum[]
  }

  /**
   * UpgradeRecommendation findMany
   */
  export type UpgradeRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * Filter, which UpgradeRecommendations to fetch.
     */
    where?: UpgradeRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpgradeRecommendations to fetch.
     */
    orderBy?: UpgradeRecommendationOrderByWithRelationInput | UpgradeRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UpgradeRecommendations.
     */
    cursor?: UpgradeRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpgradeRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpgradeRecommendations.
     */
    skip?: number
    distinct?: UpgradeRecommendationScalarFieldEnum | UpgradeRecommendationScalarFieldEnum[]
  }

  /**
   * UpgradeRecommendation create
   */
  export type UpgradeRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * The data needed to create a UpgradeRecommendation.
     */
    data: XOR<UpgradeRecommendationCreateInput, UpgradeRecommendationUncheckedCreateInput>
  }

  /**
   * UpgradeRecommendation createMany
   */
  export type UpgradeRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UpgradeRecommendations.
     */
    data: UpgradeRecommendationCreateManyInput | UpgradeRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UpgradeRecommendation createManyAndReturn
   */
  export type UpgradeRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * The data used to create many UpgradeRecommendations.
     */
    data: UpgradeRecommendationCreateManyInput | UpgradeRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UpgradeRecommendation update
   */
  export type UpgradeRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * The data needed to update a UpgradeRecommendation.
     */
    data: XOR<UpgradeRecommendationUpdateInput, UpgradeRecommendationUncheckedUpdateInput>
    /**
     * Choose, which UpgradeRecommendation to update.
     */
    where: UpgradeRecommendationWhereUniqueInput
  }

  /**
   * UpgradeRecommendation updateMany
   */
  export type UpgradeRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UpgradeRecommendations.
     */
    data: XOR<UpgradeRecommendationUpdateManyMutationInput, UpgradeRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which UpgradeRecommendations to update
     */
    where?: UpgradeRecommendationWhereInput
    /**
     * Limit how many UpgradeRecommendations to update.
     */
    limit?: number
  }

  /**
   * UpgradeRecommendation updateManyAndReturn
   */
  export type UpgradeRecommendationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * The data used to update UpgradeRecommendations.
     */
    data: XOR<UpgradeRecommendationUpdateManyMutationInput, UpgradeRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which UpgradeRecommendations to update
     */
    where?: UpgradeRecommendationWhereInput
    /**
     * Limit how many UpgradeRecommendations to update.
     */
    limit?: number
  }

  /**
   * UpgradeRecommendation upsert
   */
  export type UpgradeRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * The filter to search for the UpgradeRecommendation to update in case it exists.
     */
    where: UpgradeRecommendationWhereUniqueInput
    /**
     * In case the UpgradeRecommendation found by the `where` argument doesn't exist, create a new UpgradeRecommendation with this data.
     */
    create: XOR<UpgradeRecommendationCreateInput, UpgradeRecommendationUncheckedCreateInput>
    /**
     * In case the UpgradeRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UpgradeRecommendationUpdateInput, UpgradeRecommendationUncheckedUpdateInput>
  }

  /**
   * UpgradeRecommendation delete
   */
  export type UpgradeRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
    /**
     * Filter which UpgradeRecommendation to delete.
     */
    where: UpgradeRecommendationWhereUniqueInput
  }

  /**
   * UpgradeRecommendation deleteMany
   */
  export type UpgradeRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UpgradeRecommendations to delete
     */
    where?: UpgradeRecommendationWhereInput
    /**
     * Limit how many UpgradeRecommendations to delete.
     */
    limit?: number
  }

  /**
   * UpgradeRecommendation without action
   */
  export type UpgradeRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpgradeRecommendation
     */
    select?: UpgradeRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpgradeRecommendation
     */
    omit?: UpgradeRecommendationOmit<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    email: string | null
    role: string | null
    expiresAt: Date | null
    revoked: boolean | null
    revokedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    email: string | null
    role: string | null
    expiresAt: Date | null
    revoked: boolean | null
    revokedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    email: number
    role: number
    expiresAt: number
    revoked: number
    revokedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    email?: true
    role?: true
    expiresAt?: true
    revoked?: true
    revokedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    email?: true
    role?: true
    expiresAt?: true
    revoked?: true
    revokedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    email?: true
    role?: true
    expiresAt?: true
    revoked?: true
    revokedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    email: string
    role: string
    expiresAt: Date
    revoked: boolean
    revokedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    email?: boolean
    role?: boolean
    expiresAt?: boolean
    revoked?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    email?: boolean
    role?: boolean
    expiresAt?: boolean
    revoked?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    email?: boolean
    role?: boolean
    expiresAt?: boolean
    revoked?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    email?: boolean
    role?: boolean
    expiresAt?: boolean
    revoked?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "email" | "role" | "expiresAt" | "revoked" | "revokedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["refreshToken"]>

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      email: string
      role: string
      expiresAt: Date
      revoked: boolean
      revokedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly sessionId: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly email: FieldRef<"RefreshToken", 'String'>
    readonly role: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrgScalarFieldEnum: {
    id: 'id',
    name: 'name',
    featureFlags: 'featureFlags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    aiMonthlyBudgetCents: 'aiMonthlyBudgetCents',
    aiCreditBalance: 'aiCreditBalance',
    aiPlan: 'aiPlan',
    aiAlerts: 'aiAlerts',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    subscriptionStatus: 'subscriptionStatus',
    subscriptionStartDate: 'subscriptionStartDate',
    subscriptionEndDate: 'subscriptionEndDate',
    brandConfig: 'brandConfig',
    settingsJson: 'settingsJson'
  };

  export type OrgScalarFieldEnum = (typeof OrgScalarFieldEnum)[keyof typeof OrgScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    email: 'email',
    name: 'name',
    role: 'role',
    passwordHash: 'passwordHash',
    mustChangePassword: 'mustChangePassword',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive',
    isLocked: 'isLocked',
    lockedUntil: 'lockedUntil',
    failedLoginAttempts: 'failedLoginAttempts',
    lastFailedLogin: 'lastFailedLogin',
    lastSuccessfulLogin: 'lastSuccessfulLogin',
    lastPasswordChange: 'lastPasswordChange',
    totpSecret: 'totpSecret',
    totpEnabled: 'totpEnabled',
    backupCodesHash: 'backupCodesHash'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserRecoveryCodeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    codeHash: 'codeHash',
    usedAt: 'usedAt',
    usedFrom: 'usedFrom',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type UserRecoveryCodeScalarFieldEnum = (typeof UserRecoveryCodeScalarFieldEnum)[keyof typeof UserRecoveryCodeScalarFieldEnum]


  export const UserSecurityQuestionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    question: 'question',
    answerHash: 'answerHash',
    createdAt: 'createdAt'
  };

  export type UserSecurityQuestionScalarFieldEnum = (typeof UserSecurityQuestionScalarFieldEnum)[keyof typeof UserSecurityQuestionScalarFieldEnum]


  export const UserBreakglassAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orgId: 'orgId',
    encryptedEmail: 'encryptedEmail',
    encryptedPasswordHash: 'encryptedPasswordHash',
    encryptionIV: 'encryptionIV',
    createdAt: 'createdAt',
    lastActivatedAt: 'lastActivatedAt',
    activationCount: 'activationCount',
    isEnabled: 'isEnabled',
    canAutoActivate: 'canAutoActivate',
    minDelayMinutes: 'minDelayMinutes'
  };

  export type UserBreakglassAccountScalarFieldEnum = (typeof UserBreakglassAccountScalarFieldEnum)[keyof typeof UserBreakglassAccountScalarFieldEnum]


  export const UserDeviceFingerprintScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fingerprint: 'fingerprint',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    isTrusted: 'isTrusted',
    trustScore: 'trustScore',
    firstSeenAt: 'firstSeenAt',
    lastSeenAt: 'lastSeenAt',
    loginCount: 'loginCount'
  };

  export type UserDeviceFingerprintScalarFieldEnum = (typeof UserDeviceFingerprintScalarFieldEnum)[keyof typeof UserDeviceFingerprintScalarFieldEnum]


  export const UserLoginHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    success: 'success',
    method: 'method',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceFingerprint: 'deviceFingerprint',
    riskScore: 'riskScore',
    riskFactors: 'riskFactors',
    country: 'country',
    city: 'city',
    timestamp: 'timestamp'
  };

  export type UserLoginHistoryScalarFieldEnum = (typeof UserLoginHistoryScalarFieldEnum)[keyof typeof UserLoginHistoryScalarFieldEnum]


  export const BreakglassActivationLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orgId: 'orgId',
    reason: 'reason',
    method: 'method',
    riskScore: 'riskScore',
    riskFactors: 'riskFactors',
    delayMinutes: 'delayMinutes',
    verificationSteps: 'verificationSteps',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    success: 'success',
    errorMessage: 'errorMessage',
    notifiedAdmins: 'notifiedAdmins',
    timestamp: 'timestamp'
  };

  export type BreakglassActivationLogScalarFieldEnum = (typeof BreakglassActivationLogScalarFieldEnum)[keyof typeof BreakglassActivationLogScalarFieldEnum]


  export const RecoveryRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orgId: 'orgId',
    type: 'type',
    status: 'status',
    verificationToken: 'verificationToken',
    verificationCode: 'verificationCode',
    codeExpiresAt: 'codeExpiresAt',
    codeAttempts: 'codeAttempts',
    riskScore: 'riskScore',
    delayUntil: 'delayUntil',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    completedAt: 'completedAt'
  };

  export type RecoveryRequestScalarFieldEnum = (typeof RecoveryRequestScalarFieldEnum)[keyof typeof RecoveryRequestScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    publicId: 'publicId',
    sourceType: 'sourceType',
    identityHash: 'identityHash',
    company: 'company',
    contactName: 'contactName',
    email: 'email',
    phoneE164: 'phoneE164',
    website: 'website',
    serviceCode: 'serviceCode',
    zip: 'zip',
    enrichmentJson: 'enrichmentJson',
    aiScore: 'aiScore',
    scoreFactors: 'scoreFactors',
    systemGenerated: 'systemGenerated',
    convertedAt: 'convertedAt',
    rfp: 'rfp',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    city: 'city',
    notes: 'notes',
    sourceDetail: 'sourceDetail',
    state: 'state',
    postalCode: 'postalCode',
    address: 'address',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    country: 'country'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    publicId: 'publicId',
    company: 'company',
    primaryName: 'primaryName',
    primaryEmail: 'primaryEmail',
    primaryPhone: 'primaryPhone',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const OpportunityScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    customerId: 'customerId',
    valueType: 'valueType',
    estValue: 'estValue',
    stage: 'stage',
    ownerId: 'ownerId',
    sourceLeadId: 'sourceLeadId',
    classification: 'classification',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OpportunityScalarFieldEnum = (typeof OpportunityScalarFieldEnum)[keyof typeof OpportunityScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    customerId: 'customerId',
    amount: 'amount',
    status: 'status',
    issuedAt: 'issuedAt',
    items: 'items'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    invoiceId: 'invoiceId',
    amount: 'amount',
    method: 'method',
    receivedAt: 'receivedAt',
    reference: 'reference',
    status: 'status',
    stripePaymentIntentId: 'stripePaymentIntentId',
    stripeChargeId: 'stripeChargeId',
    failureReason: 'failureReason',
    retryCount: 'retryCount',
    lastRetryAt: 'lastRetryAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const RfpScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    publicId: 'publicId',
    sourceSite: 'sourceSite',
    title: 'title',
    dueDate: 'dueDate',
    docs: 'docs',
    aiBidFit: 'aiBidFit',
    aiPriceHint: 'aiPriceHint',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RfpScalarFieldEnum = (typeof RfpScalarFieldEnum)[keyof typeof RfpScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    customerId: 'customerId',
    rfpId: 'rfpId',
    status: 'status',
    schedule: 'schedule',
    assignedTo: 'assignedTo',
    checklist: 'checklist',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    employeeId: 'employeeId',
    referredName: 'referredName',
    referredEmail: 'referredEmail',
    referredPhone: 'referredPhone',
    status: 'status',
    convertedAt: 'convertedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const BillingLedgerScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    type: 'type',
    amount: 'amount',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type BillingLedgerScalarFieldEnum = (typeof BillingLedgerScalarFieldEnum)[keyof typeof BillingLedgerScalarFieldEnum]


  export const LeadInvoiceScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    number: 'number',
    periodFrom: 'periodFrom',
    periodTo: 'periodTo',
    status: 'status',
    subtotalCents: 'subtotalCents',
    taxCents: 'taxCents',
    totalCents: 'totalCents',
    currency: 'currency',
    stripeInvoiceId: 'stripeInvoiceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    leadCount: 'leadCount'
  };

  export type LeadInvoiceScalarFieldEnum = (typeof LeadInvoiceScalarFieldEnum)[keyof typeof LeadInvoiceScalarFieldEnum]


  export const LeadInvoiceLineScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    leadId: 'leadId',
    description: 'description',
    quantity: 'quantity',
    unitPriceCents: 'unitPriceCents',
    amountCents: 'amountCents',
    source: 'source',
    createdAt: 'createdAt'
  };

  export type LeadInvoiceLineScalarFieldEnum = (typeof LeadInvoiceLineScalarFieldEnum)[keyof typeof LeadInvoiceLineScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    actorUserId: 'actorUserId',
    entity: 'entity',
    entityId: 'entityId',
    field: 'field',
    oldValue: 'oldValue',
    newValue: 'newValue',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const RbacPermissionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type RbacPermissionScalarFieldEnum = (typeof RbacPermissionScalarFieldEnum)[keyof typeof RbacPermissionScalarFieldEnum]


  export const RbacRoleScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    name: 'name',
    slug: 'slug',
    isSystem: 'isSystem',
    createdAt: 'createdAt'
  };

  export type RbacRoleScalarFieldEnum = (typeof RbacRoleScalarFieldEnum)[keyof typeof RbacRoleScalarFieldEnum]


  export const RbacRolePermissionScalarFieldEnum: {
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type RbacRolePermissionScalarFieldEnum = (typeof RbacRolePermissionScalarFieldEnum)[keyof typeof RbacRolePermissionScalarFieldEnum]


  export const RbacUserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orgId: 'orgId',
    roleId: 'roleId'
  };

  export type RbacUserRoleScalarFieldEnum = (typeof RbacUserRoleScalarFieldEnum)[keyof typeof RbacUserRoleScalarFieldEnum]


  export const ProviderConfigScalarFieldEnum: {
    id: 'id',
    samApiKey: 'samApiKey',
    stripeSecretKey: 'stripeSecretKey',
    otherConfig: 'otherConfig',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProviderConfigScalarFieldEnum = (typeof ProviderConfigScalarFieldEnum)[keyof typeof ProviderConfigScalarFieldEnum]


  export const PricingPlanScalarFieldEnum: {
    orgId: 'orgId',
    model: 'model',
    currency: 'currency',
    unitAmount: 'unitAmount',
    tiersJson: 'tiersJson',
    includedUnits: 'includedUnits'
  };

  export type PricingPlanScalarFieldEnum = (typeof PricingPlanScalarFieldEnum)[keyof typeof PricingPlanScalarFieldEnum]


  export const AiUsageEventScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    userId: 'userId',
    feature: 'feature',
    model: 'model',
    tokensIn: 'tokensIn',
    tokensOut: 'tokensOut',
    costUsd: 'costUsd',
    creditsUsed: 'creditsUsed',
    requestId: 'requestId',
    createdAt: 'createdAt'
  };

  export type AiUsageEventScalarFieldEnum = (typeof AiUsageEventScalarFieldEnum)[keyof typeof AiUsageEventScalarFieldEnum]


  export const AiMonthlySummaryScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    monthKey: 'monthKey',
    tokensIn: 'tokensIn',
    tokensOut: 'tokensOut',
    costUsd: 'costUsd',
    creditsUsed: 'creditsUsed',
    callCount: 'callCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiMonthlySummaryScalarFieldEnum = (typeof AiMonthlySummaryScalarFieldEnum)[keyof typeof AiMonthlySummaryScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    actorType: 'actorType',
    actorId: 'actorId',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    plan: 'plan',
    status: 'status',
    startedAt: 'startedAt',
    canceledAt: 'canceledAt',
    renewsAt: 'renewsAt',
    priceCents: 'priceCents',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const UsageMeterScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    meter: 'meter',
    quantity: 'quantity',
    windowStart: 'windowStart',
    windowEnd: 'windowEnd',
    createdAt: 'createdAt'
  };

  export type UsageMeterScalarFieldEnum = (typeof UsageMeterScalarFieldEnum)[keyof typeof UsageMeterScalarFieldEnum]


  export const AddonPurchaseScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    sku: 'sku',
    amount: 'amount',
    status: 'status',
    purchasedAt: 'purchasedAt',
    refundedAt: 'refundedAt',
    meta: 'meta'
  };

  export type AddonPurchaseScalarFieldEnum = (typeof AddonPurchaseScalarFieldEnum)[keyof typeof AddonPurchaseScalarFieldEnum]


  export const FederationKeyScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    keyId: 'keyId',
    secretHash: 'secretHash',
    scope: 'scope',
    createdAt: 'createdAt',
    disabledAt: 'disabledAt',
    rotatedAt: 'rotatedAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type FederationKeyScalarFieldEnum = (typeof FederationKeyScalarFieldEnum)[keyof typeof FederationKeyScalarFieldEnum]


  export const OIDCConfigScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    issuerUrl: 'issuerUrl',
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    scopes: 'scopes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastTestedAt: 'lastTestedAt'
  };

  export type OIDCConfigScalarFieldEnum = (typeof OIDCConfigScalarFieldEnum)[keyof typeof OIDCConfigScalarFieldEnum]


  export const ProviderIntegrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    config: 'config',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastSyncAt: 'lastSyncAt'
  };

  export type ProviderIntegrationScalarFieldEnum = (typeof ProviderIntegrationScalarFieldEnum)[keyof typeof ProviderIntegrationScalarFieldEnum]


  export const AuditEventScalarFieldEnum: {
    id: 'id',
    actorType: 'actorType',
    actorId: 'actorId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditEventScalarFieldEnum = (typeof AuditEventScalarFieldEnum)[keyof typeof AuditEventScalarFieldEnum]


  export const AnalyticsSnapshotScalarFieldEnum: {
    id: 'id',
    snapshotDate: 'snapshotDate',
    mrrCents: 'mrrCents',
    arrCents: 'arrCents',
    activeClients: 'activeClients',
    newClients: 'newClients',
    churnedClients: 'churnedClients',
    totalRevenue: 'totalRevenue',
    metricsJson: 'metricsJson',
    createdAt: 'createdAt'
  };

  export type AnalyticsSnapshotScalarFieldEnum = (typeof AnalyticsSnapshotScalarFieldEnum)[keyof typeof AnalyticsSnapshotScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    severity: 'severity',
    status: 'status',
    title: 'title',
    description: 'description',
    assigneeUserId: 'assigneeUserId',
    slaResponseDeadline: 'slaResponseDeadline',
    slaResolveDeadline: 'slaResolveDeadline',
    acknowledgedAt: 'acknowledgedAt',
    resolvedAt: 'resolvedAt',
    closedAt: 'closedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const InvoiceLineScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    lineType: 'lineType',
    quantity: 'quantity',
    unitPriceCents: 'unitPriceCents',
    amountCents: 'amountCents',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    createdAt: 'createdAt'
  };

  export type InvoiceLineScalarFieldEnum = (typeof InvoiceLineScalarFieldEnum)[keyof typeof InvoiceLineScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    audience: 'audience',
    type: 'type',
    title: 'title',
    body: 'body',
    severity: 'severity',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PricePlanScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    description: 'description',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PricePlanScalarFieldEnum = (typeof PricePlanScalarFieldEnum)[keyof typeof PricePlanScalarFieldEnum]


  export const PlanPriceScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    currency: 'currency',
    unitAmountCents: 'unitAmountCents',
    cadence: 'cadence',
    trialDays: 'trialDays',
    active: 'active',
    stripePriceId: 'stripePriceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanPriceScalarFieldEnum = (typeof PlanPriceScalarFieldEnum)[keyof typeof PlanPriceScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    name: 'name',
    percentOff: 'percentOff',
    amountOffCents: 'amountOffCents',
    duration: 'duration',
    durationMonths: 'durationMonths',
    appliesToPlanId: 'appliesToPlanId',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    percentOff: 'percentOff',
    amountOffCents: 'amountOffCents',
    duration: 'duration',
    durationMonths: 'durationMonths',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    maxRedemptions: 'maxRedemptions',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const TenantPriceOverrideScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    planId: 'planId',
    priceId: 'priceId',
    type: 'type',
    percentOff: 'percentOff',
    amountOffCents: 'amountOffCents',
    priceCents: 'priceCents',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantPriceOverrideScalarFieldEnum = (typeof TenantPriceOverrideScalarFieldEnum)[keyof typeof TenantPriceOverrideScalarFieldEnum]


  export const GlobalMonetizationConfigScalarFieldEnum: {
    id: 'id',
    defaultPlanId: 'defaultPlanId',
    defaultPriceId: 'defaultPriceId',
    defaultTrialDays: 'defaultTrialDays',
    publicOnboarding: 'publicOnboarding',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GlobalMonetizationConfigScalarFieldEnum = (typeof GlobalMonetizationConfigScalarFieldEnum)[keyof typeof GlobalMonetizationConfigScalarFieldEnum]


  export const OnboardingInviteScalarFieldEnum: {
    id: 'id',
    token: 'token',
    email: 'email',
    planId: 'planId',
    priceId: 'priceId',
    offerId: 'offerId',
    couponId: 'couponId',
    trialDays: 'trialDays',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type OnboardingInviteScalarFieldEnum = (typeof OnboardingInviteScalarFieldEnum)[keyof typeof OnboardingInviteScalarFieldEnum]


  export const InfrastructureMetricScalarFieldEnum: {
    id: 'id',
    service: 'service',
    metric: 'metric',
    value: 'value',
    timestamp: 'timestamp',
    metadata: 'metadata'
  };

  export type InfrastructureMetricScalarFieldEnum = (typeof InfrastructureMetricScalarFieldEnum)[keyof typeof InfrastructureMetricScalarFieldEnum]


  export const InfrastructureLimitScalarFieldEnum: {
    id: 'id',
    service: 'service',
    metric: 'metric',
    currentPlan: 'currentPlan',
    limitValue: 'limitValue',
    warningPercent: 'warningPercent',
    criticalPercent: 'criticalPercent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InfrastructureLimitScalarFieldEnum = (typeof InfrastructureLimitScalarFieldEnum)[keyof typeof InfrastructureLimitScalarFieldEnum]


  export const ImportJobScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    userId: 'userId',
    entityType: 'entityType',
    status: 'status',
    fileName: 'fileName',
    fileSize: 'fileSize',
    totalRecords: 'totalRecords',
    processedRecords: 'processedRecords',
    successCount: 'successCount',
    errorCount: 'errorCount',
    skipCount: 'skipCount',
    mappingId: 'mappingId',
    sampleData: 'sampleData',
    fieldMappings: 'fieldMappings',
    transformRules: 'transformRules',
    validationRules: 'validationRules',
    progressPercent: 'progressPercent',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorSummary: 'errorSummary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImportJobScalarFieldEnum = (typeof ImportJobScalarFieldEnum)[keyof typeof ImportJobScalarFieldEnum]


  export const ImportMappingScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    name: 'name',
    entityType: 'entityType',
    sourceFormat: 'sourceFormat',
    fieldMappings: 'fieldMappings',
    transformRules: 'transformRules',
    validationRules: 'validationRules',
    isTemplate: 'isTemplate',
    useCount: 'useCount',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImportMappingScalarFieldEnum = (typeof ImportMappingScalarFieldEnum)[keyof typeof ImportMappingScalarFieldEnum]


  export const ImportErrorScalarFieldEnum: {
    id: 'id',
    importJobId: 'importJobId',
    rowNumber: 'rowNumber',
    fieldName: 'fieldName',
    errorType: 'errorType',
    errorMessage: 'errorMessage',
    rawData: 'rawData',
    createdAt: 'createdAt'
  };

  export type ImportErrorScalarFieldEnum = (typeof ImportErrorScalarFieldEnum)[keyof typeof ImportErrorScalarFieldEnum]


  export const UpgradeRecommendationScalarFieldEnum: {
    id: 'id',
    service: 'service',
    currentPlan: 'currentPlan',
    recommendedPlan: 'recommendedPlan',
    priority: 'priority',
    status: 'status',
    reason: 'reason',
    currentUsage: 'currentUsage',
    limitValue: 'limitValue',
    usagePercent: 'usagePercent',
    daysToLimit: 'daysToLimit',
    currentCost: 'currentCost',
    projectedCost: 'projectedCost',
    upgradeCost: 'upgradeCost',
    revenueImpact: 'revenueImpact',
    profitImpact: 'profitImpact',
    roi: 'roi',
    benefits: 'benefits',
    risks: 'risks',
    estimatedCostUsd: 'estimatedCostUsd',
    estimatedSavings: 'estimatedSavings',
    roiMonths: 'roiMonths',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    acknowledgedAt: 'acknowledgedAt',
    implementedAt: 'implementedAt'
  };

  export type UpgradeRecommendationScalarFieldEnum = (typeof UpgradeRecommendationScalarFieldEnum)[keyof typeof UpgradeRecommendationScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    email: 'email',
    role: 'role',
    expiresAt: 'expiresAt',
    revoked: 'revoked',
    revokedAt: 'revokedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AiPlan'
   */
  export type EnumAiPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiPlan'>
    


  /**
   * Reference to a field of type 'AiPlan[]'
   */
  export type ListEnumAiPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiPlan[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'LeadSource'
   */
  export type EnumLeadSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadSource'>
    


  /**
   * Reference to a field of type 'LeadSource[]'
   */
  export type ListEnumLeadSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadSource[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'ValueType'
   */
  export type EnumValueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ValueType'>
    


  /**
   * Reference to a field of type 'ValueType[]'
   */
  export type ListEnumValueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ValueType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'LedgerType'
   */
  export type EnumLedgerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerType'>
    


  /**
   * Reference to a field of type 'LedgerType[]'
   */
  export type ListEnumLedgerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerType[]'>
    


  /**
   * Reference to a field of type 'PricingModel'
   */
  export type EnumPricingModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingModel'>
    


  /**
   * Reference to a field of type 'PricingModel[]'
   */
  export type ListEnumPricingModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingModel[]'>
    


  /**
   * Reference to a field of type 'IncidentSeverity'
   */
  export type EnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity'>
    


  /**
   * Reference to a field of type 'IncidentSeverity[]'
   */
  export type ListEnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity[]'>
    


  /**
   * Reference to a field of type 'IncidentStatus'
   */
  export type EnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus'>
    


  /**
   * Reference to a field of type 'IncidentStatus[]'
   */
  export type ListEnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceLineType'
   */
  export type EnumInvoiceLineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceLineType'>
    


  /**
   * Reference to a field of type 'InvoiceLineType[]'
   */
  export type ListEnumInvoiceLineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceLineType[]'>
    


  /**
   * Reference to a field of type 'BillingCadence'
   */
  export type EnumBillingCadenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCadence'>
    


  /**
   * Reference to a field of type 'BillingCadence[]'
   */
  export type ListEnumBillingCadenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCadence[]'>
    


  /**
   * Reference to a field of type 'OverrideType'
   */
  export type EnumOverrideTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OverrideType'>
    


  /**
   * Reference to a field of type 'OverrideType[]'
   */
  export type ListEnumOverrideTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OverrideType[]'>
    


  /**
   * Reference to a field of type 'InfrastructureService'
   */
  export type EnumInfrastructureServiceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InfrastructureService'>
    


  /**
   * Reference to a field of type 'InfrastructureService[]'
   */
  export type ListEnumInfrastructureServiceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InfrastructureService[]'>
    


  /**
   * Reference to a field of type 'MetricType'
   */
  export type EnumMetricTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetricType'>
    


  /**
   * Reference to a field of type 'MetricType[]'
   */
  export type ListEnumMetricTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetricType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ImportEntityType'
   */
  export type EnumImportEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportEntityType'>
    


  /**
   * Reference to a field of type 'ImportEntityType[]'
   */
  export type ListEnumImportEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportEntityType[]'>
    


  /**
   * Reference to a field of type 'ImportStatus'
   */
  export type EnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus'>
    


  /**
   * Reference to a field of type 'ImportStatus[]'
   */
  export type ListEnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus[]'>
    


  /**
   * Reference to a field of type 'RecommendationPriority'
   */
  export type EnumRecommendationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationPriority'>
    


  /**
   * Reference to a field of type 'RecommendationPriority[]'
   */
  export type ListEnumRecommendationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationPriority[]'>
    


  /**
   * Reference to a field of type 'RecommendationStatus'
   */
  export type EnumRecommendationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationStatus'>
    


  /**
   * Reference to a field of type 'RecommendationStatus[]'
   */
  export type ListEnumRecommendationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type OrgWhereInput = {
    AND?: OrgWhereInput | OrgWhereInput[]
    OR?: OrgWhereInput[]
    NOT?: OrgWhereInput | OrgWhereInput[]
    id?: StringFilter<"Org"> | string
    name?: StringFilter<"Org"> | string
    featureFlags?: JsonFilter<"Org">
    createdAt?: DateTimeFilter<"Org"> | Date | string
    updatedAt?: DateTimeFilter<"Org"> | Date | string
    aiMonthlyBudgetCents?: IntFilter<"Org"> | number
    aiCreditBalance?: IntFilter<"Org"> | number
    aiPlan?: EnumAiPlanFilter<"Org"> | $Enums.AiPlan
    aiAlerts?: JsonFilter<"Org">
    stripeCustomerId?: StringNullableFilter<"Org"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Org"> | string | null
    subscriptionStatus?: StringNullableFilter<"Org"> | string | null
    subscriptionStartDate?: DateTimeNullableFilter<"Org"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableFilter<"Org"> | Date | string | null
    brandConfig?: JsonNullableFilter<"Org">
    settingsJson?: JsonNullableFilter<"Org">
    auditLogs?: AuditLogListRelationFilter
    ledger?: BillingLedgerListRelationFilter
    customers?: CustomerListRelationFilter
    invoices?: InvoiceListRelationFilter
    jobs?: JobListRelationFilter
    leads?: LeadListRelationFilter
    opportunities?: OpportunityListRelationFilter
    payments?: PaymentListRelationFilter
    referrals?: ReferralListRelationFilter
    rfps?: RfpListRelationFilter
    users?: UserListRelationFilter
    rbacRoles?: RbacRoleListRelationFilter
    rbacUserRoles?: RbacUserRoleListRelationFilter
    leadInvoices?: LeadInvoiceListRelationFilter
    pricingPlan?: XOR<PricingPlanNullableScalarRelationFilter, PricingPlanWhereInput> | null
    aiUsageEvents?: AiUsageEventListRelationFilter
    aiMonthlySummaries?: AiMonthlySummaryListRelationFilter
    activities?: ActivityListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    usageMeters?: UsageMeterListRelationFilter
    addonPurchases?: AddonPurchaseListRelationFilter
    tenantOverrides?: TenantPriceOverrideListRelationFilter
    incidents?: IncidentListRelationFilter
    notifications?: NotificationListRelationFilter
    importJobs?: ImportJobListRelationFilter
    importMappings?: ImportMappingListRelationFilter
  }

  export type OrgOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    featureFlags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiMonthlyBudgetCents?: SortOrder
    aiCreditBalance?: SortOrder
    aiPlan?: SortOrder
    aiAlerts?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    subscriptionStartDate?: SortOrderInput | SortOrder
    subscriptionEndDate?: SortOrderInput | SortOrder
    brandConfig?: SortOrderInput | SortOrder
    settingsJson?: SortOrderInput | SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
    ledger?: BillingLedgerOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    jobs?: JobOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    opportunities?: OpportunityOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    referrals?: ReferralOrderByRelationAggregateInput
    rfps?: RfpOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    rbacRoles?: RbacRoleOrderByRelationAggregateInput
    rbacUserRoles?: RbacUserRoleOrderByRelationAggregateInput
    leadInvoices?: LeadInvoiceOrderByRelationAggregateInput
    pricingPlan?: PricingPlanOrderByWithRelationInput
    aiUsageEvents?: AiUsageEventOrderByRelationAggregateInput
    aiMonthlySummaries?: AiMonthlySummaryOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    usageMeters?: UsageMeterOrderByRelationAggregateInput
    addonPurchases?: AddonPurchaseOrderByRelationAggregateInput
    tenantOverrides?: TenantPriceOverrideOrderByRelationAggregateInput
    incidents?: IncidentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    importJobs?: ImportJobOrderByRelationAggregateInput
    importMappings?: ImportMappingOrderByRelationAggregateInput
  }

  export type OrgWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrgWhereInput | OrgWhereInput[]
    OR?: OrgWhereInput[]
    NOT?: OrgWhereInput | OrgWhereInput[]
    name?: StringFilter<"Org"> | string
    featureFlags?: JsonFilter<"Org">
    createdAt?: DateTimeFilter<"Org"> | Date | string
    updatedAt?: DateTimeFilter<"Org"> | Date | string
    aiMonthlyBudgetCents?: IntFilter<"Org"> | number
    aiCreditBalance?: IntFilter<"Org"> | number
    aiPlan?: EnumAiPlanFilter<"Org"> | $Enums.AiPlan
    aiAlerts?: JsonFilter<"Org">
    stripeCustomerId?: StringNullableFilter<"Org"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Org"> | string | null
    subscriptionStatus?: StringNullableFilter<"Org"> | string | null
    subscriptionStartDate?: DateTimeNullableFilter<"Org"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableFilter<"Org"> | Date | string | null
    brandConfig?: JsonNullableFilter<"Org">
    settingsJson?: JsonNullableFilter<"Org">
    auditLogs?: AuditLogListRelationFilter
    ledger?: BillingLedgerListRelationFilter
    customers?: CustomerListRelationFilter
    invoices?: InvoiceListRelationFilter
    jobs?: JobListRelationFilter
    leads?: LeadListRelationFilter
    opportunities?: OpportunityListRelationFilter
    payments?: PaymentListRelationFilter
    referrals?: ReferralListRelationFilter
    rfps?: RfpListRelationFilter
    users?: UserListRelationFilter
    rbacRoles?: RbacRoleListRelationFilter
    rbacUserRoles?: RbacUserRoleListRelationFilter
    leadInvoices?: LeadInvoiceListRelationFilter
    pricingPlan?: XOR<PricingPlanNullableScalarRelationFilter, PricingPlanWhereInput> | null
    aiUsageEvents?: AiUsageEventListRelationFilter
    aiMonthlySummaries?: AiMonthlySummaryListRelationFilter
    activities?: ActivityListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    usageMeters?: UsageMeterListRelationFilter
    addonPurchases?: AddonPurchaseListRelationFilter
    tenantOverrides?: TenantPriceOverrideListRelationFilter
    incidents?: IncidentListRelationFilter
    notifications?: NotificationListRelationFilter
    importJobs?: ImportJobListRelationFilter
    importMappings?: ImportMappingListRelationFilter
  }, "id">

  export type OrgOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    featureFlags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiMonthlyBudgetCents?: SortOrder
    aiCreditBalance?: SortOrder
    aiPlan?: SortOrder
    aiAlerts?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    subscriptionStartDate?: SortOrderInput | SortOrder
    subscriptionEndDate?: SortOrderInput | SortOrder
    brandConfig?: SortOrderInput | SortOrder
    settingsJson?: SortOrderInput | SortOrder
    _count?: OrgCountOrderByAggregateInput
    _avg?: OrgAvgOrderByAggregateInput
    _max?: OrgMaxOrderByAggregateInput
    _min?: OrgMinOrderByAggregateInput
    _sum?: OrgSumOrderByAggregateInput
  }

  export type OrgScalarWhereWithAggregatesInput = {
    AND?: OrgScalarWhereWithAggregatesInput | OrgScalarWhereWithAggregatesInput[]
    OR?: OrgScalarWhereWithAggregatesInput[]
    NOT?: OrgScalarWhereWithAggregatesInput | OrgScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Org"> | string
    name?: StringWithAggregatesFilter<"Org"> | string
    featureFlags?: JsonWithAggregatesFilter<"Org">
    createdAt?: DateTimeWithAggregatesFilter<"Org"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Org"> | Date | string
    aiMonthlyBudgetCents?: IntWithAggregatesFilter<"Org"> | number
    aiCreditBalance?: IntWithAggregatesFilter<"Org"> | number
    aiPlan?: EnumAiPlanWithAggregatesFilter<"Org"> | $Enums.AiPlan
    aiAlerts?: JsonWithAggregatesFilter<"Org">
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Org"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Org"> | string | null
    subscriptionStatus?: StringNullableWithAggregatesFilter<"Org"> | string | null
    subscriptionStartDate?: DateTimeNullableWithAggregatesFilter<"Org"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableWithAggregatesFilter<"Org"> | Date | string | null
    brandConfig?: JsonNullableWithAggregatesFilter<"Org">
    settingsJson?: JsonNullableWithAggregatesFilter<"Org">
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    orgId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    passwordHash?: StringNullableFilter<"User"> | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    status?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isActive?: BoolFilter<"User"> | boolean
    isLocked?: BoolFilter<"User"> | boolean
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    lastFailedLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastSuccessfulLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastPasswordChange?: DateTimeNullableFilter<"User"> | Date | string | null
    totpSecret?: StringNullableFilter<"User"> | string | null
    totpEnabled?: BoolFilter<"User"> | boolean
    backupCodesHash?: StringNullableFilter<"User"> | string | null
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    rbacUserRoles?: RbacUserRoleListRelationFilter
    recoveryCodes?: UserRecoveryCodeListRelationFilter
    breakglassAccount?: XOR<UserBreakglassAccountNullableScalarRelationFilter, UserBreakglassAccountWhereInput> | null
    securityQuestions?: UserSecurityQuestionListRelationFilter
    loginHistory?: UserLoginHistoryListRelationFilter
    deviceFingerprints?: UserDeviceFingerprintListRelationFilter
    importJobs?: ImportJobListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    mustChangePassword?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lastFailedLogin?: SortOrderInput | SortOrder
    lastSuccessfulLogin?: SortOrderInput | SortOrder
    lastPasswordChange?: SortOrderInput | SortOrder
    totpSecret?: SortOrderInput | SortOrder
    totpEnabled?: SortOrder
    backupCodesHash?: SortOrderInput | SortOrder
    org?: OrgOrderByWithRelationInput
    rbacUserRoles?: RbacUserRoleOrderByRelationAggregateInput
    recoveryCodes?: UserRecoveryCodeOrderByRelationAggregateInput
    breakglassAccount?: UserBreakglassAccountOrderByWithRelationInput
    securityQuestions?: UserSecurityQuestionOrderByRelationAggregateInput
    loginHistory?: UserLoginHistoryOrderByRelationAggregateInput
    deviceFingerprints?: UserDeviceFingerprintOrderByRelationAggregateInput
    importJobs?: ImportJobOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    orgId?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    passwordHash?: StringNullableFilter<"User"> | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    status?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isActive?: BoolFilter<"User"> | boolean
    isLocked?: BoolFilter<"User"> | boolean
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    lastFailedLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastSuccessfulLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastPasswordChange?: DateTimeNullableFilter<"User"> | Date | string | null
    totpSecret?: StringNullableFilter<"User"> | string | null
    totpEnabled?: BoolFilter<"User"> | boolean
    backupCodesHash?: StringNullableFilter<"User"> | string | null
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    rbacUserRoles?: RbacUserRoleListRelationFilter
    recoveryCodes?: UserRecoveryCodeListRelationFilter
    breakglassAccount?: XOR<UserBreakglassAccountNullableScalarRelationFilter, UserBreakglassAccountWhereInput> | null
    securityQuestions?: UserSecurityQuestionListRelationFilter
    loginHistory?: UserLoginHistoryListRelationFilter
    deviceFingerprints?: UserDeviceFingerprintListRelationFilter
    importJobs?: ImportJobListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    mustChangePassword?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lastFailedLogin?: SortOrderInput | SortOrder
    lastSuccessfulLogin?: SortOrderInput | SortOrder
    lastPasswordChange?: SortOrderInput | SortOrder
    totpSecret?: SortOrderInput | SortOrder
    totpEnabled?: SortOrder
    backupCodesHash?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    orgId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    mustChangePassword?: BoolWithAggregatesFilter<"User"> | boolean
    status?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isLocked?: BoolWithAggregatesFilter<"User"> | boolean
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntWithAggregatesFilter<"User"> | number
    lastFailedLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastSuccessfulLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastPasswordChange?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    totpSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    totpEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    backupCodesHash?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserRecoveryCodeWhereInput = {
    AND?: UserRecoveryCodeWhereInput | UserRecoveryCodeWhereInput[]
    OR?: UserRecoveryCodeWhereInput[]
    NOT?: UserRecoveryCodeWhereInput | UserRecoveryCodeWhereInput[]
    id?: StringFilter<"UserRecoveryCode"> | string
    userId?: StringFilter<"UserRecoveryCode"> | string
    codeHash?: StringFilter<"UserRecoveryCode"> | string
    usedAt?: DateTimeNullableFilter<"UserRecoveryCode"> | Date | string | null
    usedFrom?: StringNullableFilter<"UserRecoveryCode"> | string | null
    createdAt?: DateTimeFilter<"UserRecoveryCode"> | Date | string
    expiresAt?: DateTimeFilter<"UserRecoveryCode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserRecoveryCodeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    usedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserRecoveryCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserRecoveryCodeWhereInput | UserRecoveryCodeWhereInput[]
    OR?: UserRecoveryCodeWhereInput[]
    NOT?: UserRecoveryCodeWhereInput | UserRecoveryCodeWhereInput[]
    userId?: StringFilter<"UserRecoveryCode"> | string
    codeHash?: StringFilter<"UserRecoveryCode"> | string
    usedAt?: DateTimeNullableFilter<"UserRecoveryCode"> | Date | string | null
    usedFrom?: StringNullableFilter<"UserRecoveryCode"> | string | null
    createdAt?: DateTimeFilter<"UserRecoveryCode"> | Date | string
    expiresAt?: DateTimeFilter<"UserRecoveryCode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserRecoveryCodeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    usedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: UserRecoveryCodeCountOrderByAggregateInput
    _max?: UserRecoveryCodeMaxOrderByAggregateInput
    _min?: UserRecoveryCodeMinOrderByAggregateInput
  }

  export type UserRecoveryCodeScalarWhereWithAggregatesInput = {
    AND?: UserRecoveryCodeScalarWhereWithAggregatesInput | UserRecoveryCodeScalarWhereWithAggregatesInput[]
    OR?: UserRecoveryCodeScalarWhereWithAggregatesInput[]
    NOT?: UserRecoveryCodeScalarWhereWithAggregatesInput | UserRecoveryCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRecoveryCode"> | string
    userId?: StringWithAggregatesFilter<"UserRecoveryCode"> | string
    codeHash?: StringWithAggregatesFilter<"UserRecoveryCode"> | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"UserRecoveryCode"> | Date | string | null
    usedFrom?: StringNullableWithAggregatesFilter<"UserRecoveryCode"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserRecoveryCode"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserRecoveryCode"> | Date | string
  }

  export type UserSecurityQuestionWhereInput = {
    AND?: UserSecurityQuestionWhereInput | UserSecurityQuestionWhereInput[]
    OR?: UserSecurityQuestionWhereInput[]
    NOT?: UserSecurityQuestionWhereInput | UserSecurityQuestionWhereInput[]
    id?: StringFilter<"UserSecurityQuestion"> | string
    userId?: StringFilter<"UserSecurityQuestion"> | string
    question?: StringFilter<"UserSecurityQuestion"> | string
    answerHash?: StringFilter<"UserSecurityQuestion"> | string
    createdAt?: DateTimeFilter<"UserSecurityQuestion"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSecurityQuestionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSecurityQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSecurityQuestionWhereInput | UserSecurityQuestionWhereInput[]
    OR?: UserSecurityQuestionWhereInput[]
    NOT?: UserSecurityQuestionWhereInput | UserSecurityQuestionWhereInput[]
    userId?: StringFilter<"UserSecurityQuestion"> | string
    question?: StringFilter<"UserSecurityQuestion"> | string
    answerHash?: StringFilter<"UserSecurityQuestion"> | string
    createdAt?: DateTimeFilter<"UserSecurityQuestion"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserSecurityQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    _count?: UserSecurityQuestionCountOrderByAggregateInput
    _max?: UserSecurityQuestionMaxOrderByAggregateInput
    _min?: UserSecurityQuestionMinOrderByAggregateInput
  }

  export type UserSecurityQuestionScalarWhereWithAggregatesInput = {
    AND?: UserSecurityQuestionScalarWhereWithAggregatesInput | UserSecurityQuestionScalarWhereWithAggregatesInput[]
    OR?: UserSecurityQuestionScalarWhereWithAggregatesInput[]
    NOT?: UserSecurityQuestionScalarWhereWithAggregatesInput | UserSecurityQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSecurityQuestion"> | string
    userId?: StringWithAggregatesFilter<"UserSecurityQuestion"> | string
    question?: StringWithAggregatesFilter<"UserSecurityQuestion"> | string
    answerHash?: StringWithAggregatesFilter<"UserSecurityQuestion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSecurityQuestion"> | Date | string
  }

  export type UserBreakglassAccountWhereInput = {
    AND?: UserBreakglassAccountWhereInput | UserBreakglassAccountWhereInput[]
    OR?: UserBreakglassAccountWhereInput[]
    NOT?: UserBreakglassAccountWhereInput | UserBreakglassAccountWhereInput[]
    id?: StringFilter<"UserBreakglassAccount"> | string
    userId?: StringFilter<"UserBreakglassAccount"> | string
    orgId?: StringFilter<"UserBreakglassAccount"> | string
    encryptedEmail?: StringFilter<"UserBreakglassAccount"> | string
    encryptedPasswordHash?: StringFilter<"UserBreakglassAccount"> | string
    encryptionIV?: StringFilter<"UserBreakglassAccount"> | string
    createdAt?: DateTimeFilter<"UserBreakglassAccount"> | Date | string
    lastActivatedAt?: DateTimeNullableFilter<"UserBreakglassAccount"> | Date | string | null
    activationCount?: IntFilter<"UserBreakglassAccount"> | number
    isEnabled?: BoolFilter<"UserBreakglassAccount"> | boolean
    canAutoActivate?: BoolFilter<"UserBreakglassAccount"> | boolean
    minDelayMinutes?: IntFilter<"UserBreakglassAccount"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserBreakglassAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    encryptedEmail?: SortOrder
    encryptedPasswordHash?: SortOrder
    encryptionIV?: SortOrder
    createdAt?: SortOrder
    lastActivatedAt?: SortOrderInput | SortOrder
    activationCount?: SortOrder
    isEnabled?: SortOrder
    canAutoActivate?: SortOrder
    minDelayMinutes?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserBreakglassAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserBreakglassAccountWhereInput | UserBreakglassAccountWhereInput[]
    OR?: UserBreakglassAccountWhereInput[]
    NOT?: UserBreakglassAccountWhereInput | UserBreakglassAccountWhereInput[]
    orgId?: StringFilter<"UserBreakglassAccount"> | string
    encryptedEmail?: StringFilter<"UserBreakglassAccount"> | string
    encryptedPasswordHash?: StringFilter<"UserBreakglassAccount"> | string
    encryptionIV?: StringFilter<"UserBreakglassAccount"> | string
    createdAt?: DateTimeFilter<"UserBreakglassAccount"> | Date | string
    lastActivatedAt?: DateTimeNullableFilter<"UserBreakglassAccount"> | Date | string | null
    activationCount?: IntFilter<"UserBreakglassAccount"> | number
    isEnabled?: BoolFilter<"UserBreakglassAccount"> | boolean
    canAutoActivate?: BoolFilter<"UserBreakglassAccount"> | boolean
    minDelayMinutes?: IntFilter<"UserBreakglassAccount"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserBreakglassAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    encryptedEmail?: SortOrder
    encryptedPasswordHash?: SortOrder
    encryptionIV?: SortOrder
    createdAt?: SortOrder
    lastActivatedAt?: SortOrderInput | SortOrder
    activationCount?: SortOrder
    isEnabled?: SortOrder
    canAutoActivate?: SortOrder
    minDelayMinutes?: SortOrder
    _count?: UserBreakglassAccountCountOrderByAggregateInput
    _avg?: UserBreakglassAccountAvgOrderByAggregateInput
    _max?: UserBreakglassAccountMaxOrderByAggregateInput
    _min?: UserBreakglassAccountMinOrderByAggregateInput
    _sum?: UserBreakglassAccountSumOrderByAggregateInput
  }

  export type UserBreakglassAccountScalarWhereWithAggregatesInput = {
    AND?: UserBreakglassAccountScalarWhereWithAggregatesInput | UserBreakglassAccountScalarWhereWithAggregatesInput[]
    OR?: UserBreakglassAccountScalarWhereWithAggregatesInput[]
    NOT?: UserBreakglassAccountScalarWhereWithAggregatesInput | UserBreakglassAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBreakglassAccount"> | string
    userId?: StringWithAggregatesFilter<"UserBreakglassAccount"> | string
    orgId?: StringWithAggregatesFilter<"UserBreakglassAccount"> | string
    encryptedEmail?: StringWithAggregatesFilter<"UserBreakglassAccount"> | string
    encryptedPasswordHash?: StringWithAggregatesFilter<"UserBreakglassAccount"> | string
    encryptionIV?: StringWithAggregatesFilter<"UserBreakglassAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserBreakglassAccount"> | Date | string
    lastActivatedAt?: DateTimeNullableWithAggregatesFilter<"UserBreakglassAccount"> | Date | string | null
    activationCount?: IntWithAggregatesFilter<"UserBreakglassAccount"> | number
    isEnabled?: BoolWithAggregatesFilter<"UserBreakglassAccount"> | boolean
    canAutoActivate?: BoolWithAggregatesFilter<"UserBreakglassAccount"> | boolean
    minDelayMinutes?: IntWithAggregatesFilter<"UserBreakglassAccount"> | number
  }

  export type UserDeviceFingerprintWhereInput = {
    AND?: UserDeviceFingerprintWhereInput | UserDeviceFingerprintWhereInput[]
    OR?: UserDeviceFingerprintWhereInput[]
    NOT?: UserDeviceFingerprintWhereInput | UserDeviceFingerprintWhereInput[]
    id?: StringFilter<"UserDeviceFingerprint"> | string
    userId?: StringFilter<"UserDeviceFingerprint"> | string
    fingerprint?: StringFilter<"UserDeviceFingerprint"> | string
    ipAddress?: StringFilter<"UserDeviceFingerprint"> | string
    userAgent?: StringFilter<"UserDeviceFingerprint"> | string
    isTrusted?: BoolFilter<"UserDeviceFingerprint"> | boolean
    trustScore?: IntFilter<"UserDeviceFingerprint"> | number
    firstSeenAt?: DateTimeFilter<"UserDeviceFingerprint"> | Date | string
    lastSeenAt?: DateTimeFilter<"UserDeviceFingerprint"> | Date | string
    loginCount?: IntFilter<"UserDeviceFingerprint"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserDeviceFingerprintOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fingerprint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isTrusted?: SortOrder
    trustScore?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    loginCount?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserDeviceFingerprintWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_fingerprint?: UserDeviceFingerprintUserIdFingerprintCompoundUniqueInput
    AND?: UserDeviceFingerprintWhereInput | UserDeviceFingerprintWhereInput[]
    OR?: UserDeviceFingerprintWhereInput[]
    NOT?: UserDeviceFingerprintWhereInput | UserDeviceFingerprintWhereInput[]
    userId?: StringFilter<"UserDeviceFingerprint"> | string
    fingerprint?: StringFilter<"UserDeviceFingerprint"> | string
    ipAddress?: StringFilter<"UserDeviceFingerprint"> | string
    userAgent?: StringFilter<"UserDeviceFingerprint"> | string
    isTrusted?: BoolFilter<"UserDeviceFingerprint"> | boolean
    trustScore?: IntFilter<"UserDeviceFingerprint"> | number
    firstSeenAt?: DateTimeFilter<"UserDeviceFingerprint"> | Date | string
    lastSeenAt?: DateTimeFilter<"UserDeviceFingerprint"> | Date | string
    loginCount?: IntFilter<"UserDeviceFingerprint"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_fingerprint">

  export type UserDeviceFingerprintOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fingerprint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isTrusted?: SortOrder
    trustScore?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    loginCount?: SortOrder
    _count?: UserDeviceFingerprintCountOrderByAggregateInput
    _avg?: UserDeviceFingerprintAvgOrderByAggregateInput
    _max?: UserDeviceFingerprintMaxOrderByAggregateInput
    _min?: UserDeviceFingerprintMinOrderByAggregateInput
    _sum?: UserDeviceFingerprintSumOrderByAggregateInput
  }

  export type UserDeviceFingerprintScalarWhereWithAggregatesInput = {
    AND?: UserDeviceFingerprintScalarWhereWithAggregatesInput | UserDeviceFingerprintScalarWhereWithAggregatesInput[]
    OR?: UserDeviceFingerprintScalarWhereWithAggregatesInput[]
    NOT?: UserDeviceFingerprintScalarWhereWithAggregatesInput | UserDeviceFingerprintScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserDeviceFingerprint"> | string
    userId?: StringWithAggregatesFilter<"UserDeviceFingerprint"> | string
    fingerprint?: StringWithAggregatesFilter<"UserDeviceFingerprint"> | string
    ipAddress?: StringWithAggregatesFilter<"UserDeviceFingerprint"> | string
    userAgent?: StringWithAggregatesFilter<"UserDeviceFingerprint"> | string
    isTrusted?: BoolWithAggregatesFilter<"UserDeviceFingerprint"> | boolean
    trustScore?: IntWithAggregatesFilter<"UserDeviceFingerprint"> | number
    firstSeenAt?: DateTimeWithAggregatesFilter<"UserDeviceFingerprint"> | Date | string
    lastSeenAt?: DateTimeWithAggregatesFilter<"UserDeviceFingerprint"> | Date | string
    loginCount?: IntWithAggregatesFilter<"UserDeviceFingerprint"> | number
  }

  export type UserLoginHistoryWhereInput = {
    AND?: UserLoginHistoryWhereInput | UserLoginHistoryWhereInput[]
    OR?: UserLoginHistoryWhereInput[]
    NOT?: UserLoginHistoryWhereInput | UserLoginHistoryWhereInput[]
    id?: StringFilter<"UserLoginHistory"> | string
    userId?: StringFilter<"UserLoginHistory"> | string
    success?: BoolFilter<"UserLoginHistory"> | boolean
    method?: StringFilter<"UserLoginHistory"> | string
    ipAddress?: StringFilter<"UserLoginHistory"> | string
    userAgent?: StringFilter<"UserLoginHistory"> | string
    deviceFingerprint?: StringNullableFilter<"UserLoginHistory"> | string | null
    riskScore?: IntFilter<"UserLoginHistory"> | number
    riskFactors?: StringNullableFilter<"UserLoginHistory"> | string | null
    country?: StringNullableFilter<"UserLoginHistory"> | string | null
    city?: StringNullableFilter<"UserLoginHistory"> | string | null
    timestamp?: DateTimeFilter<"UserLoginHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserLoginHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    success?: SortOrder
    method?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserLoginHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserLoginHistoryWhereInput | UserLoginHistoryWhereInput[]
    OR?: UserLoginHistoryWhereInput[]
    NOT?: UserLoginHistoryWhereInput | UserLoginHistoryWhereInput[]
    userId?: StringFilter<"UserLoginHistory"> | string
    success?: BoolFilter<"UserLoginHistory"> | boolean
    method?: StringFilter<"UserLoginHistory"> | string
    ipAddress?: StringFilter<"UserLoginHistory"> | string
    userAgent?: StringFilter<"UserLoginHistory"> | string
    deviceFingerprint?: StringNullableFilter<"UserLoginHistory"> | string | null
    riskScore?: IntFilter<"UserLoginHistory"> | number
    riskFactors?: StringNullableFilter<"UserLoginHistory"> | string | null
    country?: StringNullableFilter<"UserLoginHistory"> | string | null
    city?: StringNullableFilter<"UserLoginHistory"> | string | null
    timestamp?: DateTimeFilter<"UserLoginHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserLoginHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    success?: SortOrder
    method?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: UserLoginHistoryCountOrderByAggregateInput
    _avg?: UserLoginHistoryAvgOrderByAggregateInput
    _max?: UserLoginHistoryMaxOrderByAggregateInput
    _min?: UserLoginHistoryMinOrderByAggregateInput
    _sum?: UserLoginHistorySumOrderByAggregateInput
  }

  export type UserLoginHistoryScalarWhereWithAggregatesInput = {
    AND?: UserLoginHistoryScalarWhereWithAggregatesInput | UserLoginHistoryScalarWhereWithAggregatesInput[]
    OR?: UserLoginHistoryScalarWhereWithAggregatesInput[]
    NOT?: UserLoginHistoryScalarWhereWithAggregatesInput | UserLoginHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLoginHistory"> | string
    userId?: StringWithAggregatesFilter<"UserLoginHistory"> | string
    success?: BoolWithAggregatesFilter<"UserLoginHistory"> | boolean
    method?: StringWithAggregatesFilter<"UserLoginHistory"> | string
    ipAddress?: StringWithAggregatesFilter<"UserLoginHistory"> | string
    userAgent?: StringWithAggregatesFilter<"UserLoginHistory"> | string
    deviceFingerprint?: StringNullableWithAggregatesFilter<"UserLoginHistory"> | string | null
    riskScore?: IntWithAggregatesFilter<"UserLoginHistory"> | number
    riskFactors?: StringNullableWithAggregatesFilter<"UserLoginHistory"> | string | null
    country?: StringNullableWithAggregatesFilter<"UserLoginHistory"> | string | null
    city?: StringNullableWithAggregatesFilter<"UserLoginHistory"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"UserLoginHistory"> | Date | string
  }

  export type BreakglassActivationLogWhereInput = {
    AND?: BreakglassActivationLogWhereInput | BreakglassActivationLogWhereInput[]
    OR?: BreakglassActivationLogWhereInput[]
    NOT?: BreakglassActivationLogWhereInput | BreakglassActivationLogWhereInput[]
    id?: StringFilter<"BreakglassActivationLog"> | string
    userId?: StringFilter<"BreakglassActivationLog"> | string
    orgId?: StringFilter<"BreakglassActivationLog"> | string
    reason?: StringFilter<"BreakglassActivationLog"> | string
    method?: StringFilter<"BreakglassActivationLog"> | string
    riskScore?: IntFilter<"BreakglassActivationLog"> | number
    riskFactors?: StringFilter<"BreakglassActivationLog"> | string
    delayMinutes?: IntFilter<"BreakglassActivationLog"> | number
    verificationSteps?: StringFilter<"BreakglassActivationLog"> | string
    ipAddress?: StringFilter<"BreakglassActivationLog"> | string
    userAgent?: StringFilter<"BreakglassActivationLog"> | string
    success?: BoolFilter<"BreakglassActivationLog"> | boolean
    errorMessage?: StringNullableFilter<"BreakglassActivationLog"> | string | null
    notifiedAdmins?: StringFilter<"BreakglassActivationLog"> | string
    timestamp?: DateTimeFilter<"BreakglassActivationLog"> | Date | string
  }

  export type BreakglassActivationLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    reason?: SortOrder
    method?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    delayMinutes?: SortOrder
    verificationSteps?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    notifiedAdmins?: SortOrder
    timestamp?: SortOrder
  }

  export type BreakglassActivationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreakglassActivationLogWhereInput | BreakglassActivationLogWhereInput[]
    OR?: BreakglassActivationLogWhereInput[]
    NOT?: BreakglassActivationLogWhereInput | BreakglassActivationLogWhereInput[]
    userId?: StringFilter<"BreakglassActivationLog"> | string
    orgId?: StringFilter<"BreakglassActivationLog"> | string
    reason?: StringFilter<"BreakglassActivationLog"> | string
    method?: StringFilter<"BreakglassActivationLog"> | string
    riskScore?: IntFilter<"BreakglassActivationLog"> | number
    riskFactors?: StringFilter<"BreakglassActivationLog"> | string
    delayMinutes?: IntFilter<"BreakglassActivationLog"> | number
    verificationSteps?: StringFilter<"BreakglassActivationLog"> | string
    ipAddress?: StringFilter<"BreakglassActivationLog"> | string
    userAgent?: StringFilter<"BreakglassActivationLog"> | string
    success?: BoolFilter<"BreakglassActivationLog"> | boolean
    errorMessage?: StringNullableFilter<"BreakglassActivationLog"> | string | null
    notifiedAdmins?: StringFilter<"BreakglassActivationLog"> | string
    timestamp?: DateTimeFilter<"BreakglassActivationLog"> | Date | string
  }, "id">

  export type BreakglassActivationLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    reason?: SortOrder
    method?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    delayMinutes?: SortOrder
    verificationSteps?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    notifiedAdmins?: SortOrder
    timestamp?: SortOrder
    _count?: BreakglassActivationLogCountOrderByAggregateInput
    _avg?: BreakglassActivationLogAvgOrderByAggregateInput
    _max?: BreakglassActivationLogMaxOrderByAggregateInput
    _min?: BreakglassActivationLogMinOrderByAggregateInput
    _sum?: BreakglassActivationLogSumOrderByAggregateInput
  }

  export type BreakglassActivationLogScalarWhereWithAggregatesInput = {
    AND?: BreakglassActivationLogScalarWhereWithAggregatesInput | BreakglassActivationLogScalarWhereWithAggregatesInput[]
    OR?: BreakglassActivationLogScalarWhereWithAggregatesInput[]
    NOT?: BreakglassActivationLogScalarWhereWithAggregatesInput | BreakglassActivationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreakglassActivationLog"> | string
    userId?: StringWithAggregatesFilter<"BreakglassActivationLog"> | string
    orgId?: StringWithAggregatesFilter<"BreakglassActivationLog"> | string
    reason?: StringWithAggregatesFilter<"BreakglassActivationLog"> | string
    method?: StringWithAggregatesFilter<"BreakglassActivationLog"> | string
    riskScore?: IntWithAggregatesFilter<"BreakglassActivationLog"> | number
    riskFactors?: StringWithAggregatesFilter<"BreakglassActivationLog"> | string
    delayMinutes?: IntWithAggregatesFilter<"BreakglassActivationLog"> | number
    verificationSteps?: StringWithAggregatesFilter<"BreakglassActivationLog"> | string
    ipAddress?: StringWithAggregatesFilter<"BreakglassActivationLog"> | string
    userAgent?: StringWithAggregatesFilter<"BreakglassActivationLog"> | string
    success?: BoolWithAggregatesFilter<"BreakglassActivationLog"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"BreakglassActivationLog"> | string | null
    notifiedAdmins?: StringWithAggregatesFilter<"BreakglassActivationLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"BreakglassActivationLog"> | Date | string
  }

  export type RecoveryRequestWhereInput = {
    AND?: RecoveryRequestWhereInput | RecoveryRequestWhereInput[]
    OR?: RecoveryRequestWhereInput[]
    NOT?: RecoveryRequestWhereInput | RecoveryRequestWhereInput[]
    id?: StringFilter<"RecoveryRequest"> | string
    userId?: StringFilter<"RecoveryRequest"> | string
    orgId?: StringFilter<"RecoveryRequest"> | string
    type?: StringFilter<"RecoveryRequest"> | string
    status?: StringFilter<"RecoveryRequest"> | string
    verificationToken?: StringFilter<"RecoveryRequest"> | string
    verificationCode?: StringNullableFilter<"RecoveryRequest"> | string | null
    codeExpiresAt?: DateTimeNullableFilter<"RecoveryRequest"> | Date | string | null
    codeAttempts?: IntFilter<"RecoveryRequest"> | number
    riskScore?: IntFilter<"RecoveryRequest"> | number
    delayUntil?: DateTimeFilter<"RecoveryRequest"> | Date | string
    ipAddress?: StringFilter<"RecoveryRequest"> | string
    userAgent?: StringFilter<"RecoveryRequest"> | string
    createdAt?: DateTimeFilter<"RecoveryRequest"> | Date | string
    expiresAt?: DateTimeFilter<"RecoveryRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"RecoveryRequest"> | Date | string | null
  }

  export type RecoveryRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    verificationToken?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    codeExpiresAt?: SortOrderInput | SortOrder
    codeAttempts?: SortOrder
    riskScore?: SortOrder
    delayUntil?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type RecoveryRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    verificationToken?: string
    AND?: RecoveryRequestWhereInput | RecoveryRequestWhereInput[]
    OR?: RecoveryRequestWhereInput[]
    NOT?: RecoveryRequestWhereInput | RecoveryRequestWhereInput[]
    userId?: StringFilter<"RecoveryRequest"> | string
    orgId?: StringFilter<"RecoveryRequest"> | string
    type?: StringFilter<"RecoveryRequest"> | string
    status?: StringFilter<"RecoveryRequest"> | string
    verificationCode?: StringNullableFilter<"RecoveryRequest"> | string | null
    codeExpiresAt?: DateTimeNullableFilter<"RecoveryRequest"> | Date | string | null
    codeAttempts?: IntFilter<"RecoveryRequest"> | number
    riskScore?: IntFilter<"RecoveryRequest"> | number
    delayUntil?: DateTimeFilter<"RecoveryRequest"> | Date | string
    ipAddress?: StringFilter<"RecoveryRequest"> | string
    userAgent?: StringFilter<"RecoveryRequest"> | string
    createdAt?: DateTimeFilter<"RecoveryRequest"> | Date | string
    expiresAt?: DateTimeFilter<"RecoveryRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"RecoveryRequest"> | Date | string | null
  }, "id" | "verificationToken">

  export type RecoveryRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    verificationToken?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    codeExpiresAt?: SortOrderInput | SortOrder
    codeAttempts?: SortOrder
    riskScore?: SortOrder
    delayUntil?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: RecoveryRequestCountOrderByAggregateInput
    _avg?: RecoveryRequestAvgOrderByAggregateInput
    _max?: RecoveryRequestMaxOrderByAggregateInput
    _min?: RecoveryRequestMinOrderByAggregateInput
    _sum?: RecoveryRequestSumOrderByAggregateInput
  }

  export type RecoveryRequestScalarWhereWithAggregatesInput = {
    AND?: RecoveryRequestScalarWhereWithAggregatesInput | RecoveryRequestScalarWhereWithAggregatesInput[]
    OR?: RecoveryRequestScalarWhereWithAggregatesInput[]
    NOT?: RecoveryRequestScalarWhereWithAggregatesInput | RecoveryRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecoveryRequest"> | string
    userId?: StringWithAggregatesFilter<"RecoveryRequest"> | string
    orgId?: StringWithAggregatesFilter<"RecoveryRequest"> | string
    type?: StringWithAggregatesFilter<"RecoveryRequest"> | string
    status?: StringWithAggregatesFilter<"RecoveryRequest"> | string
    verificationToken?: StringWithAggregatesFilter<"RecoveryRequest"> | string
    verificationCode?: StringNullableWithAggregatesFilter<"RecoveryRequest"> | string | null
    codeExpiresAt?: DateTimeNullableWithAggregatesFilter<"RecoveryRequest"> | Date | string | null
    codeAttempts?: IntWithAggregatesFilter<"RecoveryRequest"> | number
    riskScore?: IntWithAggregatesFilter<"RecoveryRequest"> | number
    delayUntil?: DateTimeWithAggregatesFilter<"RecoveryRequest"> | Date | string
    ipAddress?: StringWithAggregatesFilter<"RecoveryRequest"> | string
    userAgent?: StringWithAggregatesFilter<"RecoveryRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RecoveryRequest"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"RecoveryRequest"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"RecoveryRequest"> | Date | string | null
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    orgId?: StringFilter<"Lead"> | string
    publicId?: StringFilter<"Lead"> | string
    sourceType?: EnumLeadSourceFilter<"Lead"> | $Enums.LeadSource
    identityHash?: StringFilter<"Lead"> | string
    company?: StringNullableFilter<"Lead"> | string | null
    contactName?: StringNullableFilter<"Lead"> | string | null
    email?: StringNullableFilter<"Lead"> | string | null
    phoneE164?: StringNullableFilter<"Lead"> | string | null
    website?: StringNullableFilter<"Lead"> | string | null
    serviceCode?: StringNullableFilter<"Lead"> | string | null
    zip?: StringNullableFilter<"Lead"> | string | null
    enrichmentJson?: JsonFilter<"Lead">
    aiScore?: IntFilter<"Lead"> | number
    scoreFactors?: JsonFilter<"Lead">
    systemGenerated?: BoolFilter<"Lead"> | boolean
    convertedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    rfp?: JsonNullableFilter<"Lead">
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    city?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    sourceDetail?: StringNullableFilter<"Lead"> | string | null
    state?: StringNullableFilter<"Lead"> | string | null
    postalCode?: StringNullableFilter<"Lead"> | string | null
    address?: StringNullableFilter<"Lead"> | string | null
    addressLine1?: StringNullableFilter<"Lead"> | string | null
    addressLine2?: StringNullableFilter<"Lead"> | string | null
    country?: StringNullableFilter<"Lead"> | string | null
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    LeadInvoiceLine?: LeadInvoiceLineListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    sourceType?: SortOrder
    identityHash?: SortOrder
    company?: SortOrderInput | SortOrder
    contactName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phoneE164?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    serviceCode?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    enrichmentJson?: SortOrder
    aiScore?: SortOrder
    scoreFactors?: SortOrder
    systemGenerated?: SortOrder
    convertedAt?: SortOrderInput | SortOrder
    rfp?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    sourceDetail?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    org?: OrgOrderByWithRelationInput
    LeadInvoiceLine?: LeadInvoiceLineOrderByRelationAggregateInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    publicId?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    orgId?: StringFilter<"Lead"> | string
    sourceType?: EnumLeadSourceFilter<"Lead"> | $Enums.LeadSource
    identityHash?: StringFilter<"Lead"> | string
    company?: StringNullableFilter<"Lead"> | string | null
    contactName?: StringNullableFilter<"Lead"> | string | null
    email?: StringNullableFilter<"Lead"> | string | null
    phoneE164?: StringNullableFilter<"Lead"> | string | null
    website?: StringNullableFilter<"Lead"> | string | null
    serviceCode?: StringNullableFilter<"Lead"> | string | null
    zip?: StringNullableFilter<"Lead"> | string | null
    enrichmentJson?: JsonFilter<"Lead">
    aiScore?: IntFilter<"Lead"> | number
    scoreFactors?: JsonFilter<"Lead">
    systemGenerated?: BoolFilter<"Lead"> | boolean
    convertedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    rfp?: JsonNullableFilter<"Lead">
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    city?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    sourceDetail?: StringNullableFilter<"Lead"> | string | null
    state?: StringNullableFilter<"Lead"> | string | null
    postalCode?: StringNullableFilter<"Lead"> | string | null
    address?: StringNullableFilter<"Lead"> | string | null
    addressLine1?: StringNullableFilter<"Lead"> | string | null
    addressLine2?: StringNullableFilter<"Lead"> | string | null
    country?: StringNullableFilter<"Lead"> | string | null
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    LeadInvoiceLine?: LeadInvoiceLineListRelationFilter
  }, "id" | "publicId">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    sourceType?: SortOrder
    identityHash?: SortOrder
    company?: SortOrderInput | SortOrder
    contactName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phoneE164?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    serviceCode?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    enrichmentJson?: SortOrder
    aiScore?: SortOrder
    scoreFactors?: SortOrder
    systemGenerated?: SortOrder
    convertedAt?: SortOrderInput | SortOrder
    rfp?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    sourceDetail?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    orgId?: StringWithAggregatesFilter<"Lead"> | string
    publicId?: StringWithAggregatesFilter<"Lead"> | string
    sourceType?: EnumLeadSourceWithAggregatesFilter<"Lead"> | $Enums.LeadSource
    identityHash?: StringWithAggregatesFilter<"Lead"> | string
    company?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    contactName?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    email?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    phoneE164?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    website?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    serviceCode?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    zip?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    enrichmentJson?: JsonWithAggregatesFilter<"Lead">
    aiScore?: IntWithAggregatesFilter<"Lead"> | number
    scoreFactors?: JsonWithAggregatesFilter<"Lead">
    systemGenerated?: BoolWithAggregatesFilter<"Lead"> | boolean
    convertedAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    rfp?: JsonNullableWithAggregatesFilter<"Lead">
    status?: EnumLeadStatusWithAggregatesFilter<"Lead"> | $Enums.LeadStatus
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    city?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    sourceDetail?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    state?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    address?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    country?: StringNullableWithAggregatesFilter<"Lead"> | string | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    orgId?: StringFilter<"Customer"> | string
    publicId?: StringFilter<"Customer"> | string
    company?: StringNullableFilter<"Customer"> | string | null
    primaryName?: StringNullableFilter<"Customer"> | string | null
    primaryEmail?: StringNullableFilter<"Customer"> | string | null
    primaryPhone?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    invoices?: InvoiceListRelationFilter
    jobs?: JobListRelationFilter
    opportunities?: OpportunityListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    company?: SortOrderInput | SortOrder
    primaryName?: SortOrderInput | SortOrder
    primaryEmail?: SortOrderInput | SortOrder
    primaryPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    org?: OrgOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    jobs?: JobOrderByRelationAggregateInput
    opportunities?: OpportunityOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    publicId?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    orgId?: StringFilter<"Customer"> | string
    company?: StringNullableFilter<"Customer"> | string | null
    primaryName?: StringNullableFilter<"Customer"> | string | null
    primaryEmail?: StringNullableFilter<"Customer"> | string | null
    primaryPhone?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    invoices?: InvoiceListRelationFilter
    jobs?: JobListRelationFilter
    opportunities?: OpportunityListRelationFilter
  }, "id" | "publicId">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    company?: SortOrderInput | SortOrder
    primaryName?: SortOrderInput | SortOrder
    primaryEmail?: SortOrderInput | SortOrder
    primaryPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    orgId?: StringWithAggregatesFilter<"Customer"> | string
    publicId?: StringWithAggregatesFilter<"Customer"> | string
    company?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    primaryName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    primaryEmail?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    primaryPhone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type OpportunityWhereInput = {
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    orgId?: StringFilter<"Opportunity"> | string
    customerId?: StringFilter<"Opportunity"> | string
    valueType?: EnumValueTypeFilter<"Opportunity"> | $Enums.ValueType
    estValue?: DecimalNullableFilter<"Opportunity"> | Decimal | DecimalJsLike | number | string | null
    stage?: StringFilter<"Opportunity"> | string
    ownerId?: StringNullableFilter<"Opportunity"> | string | null
    sourceLeadId?: StringNullableFilter<"Opportunity"> | string | null
    classification?: JsonFilter<"Opportunity">
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type OpportunityOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    valueType?: SortOrder
    estValue?: SortOrderInput | SortOrder
    stage?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    sourceLeadId?: SortOrderInput | SortOrder
    classification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    org?: OrgOrderByWithRelationInput
  }

  export type OpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    orgId?: StringFilter<"Opportunity"> | string
    customerId?: StringFilter<"Opportunity"> | string
    valueType?: EnumValueTypeFilter<"Opportunity"> | $Enums.ValueType
    estValue?: DecimalNullableFilter<"Opportunity"> | Decimal | DecimalJsLike | number | string | null
    stage?: StringFilter<"Opportunity"> | string
    ownerId?: StringNullableFilter<"Opportunity"> | string | null
    sourceLeadId?: StringNullableFilter<"Opportunity"> | string | null
    classification?: JsonFilter<"Opportunity">
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type OpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    valueType?: SortOrder
    estValue?: SortOrderInput | SortOrder
    stage?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    sourceLeadId?: SortOrderInput | SortOrder
    classification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OpportunityCountOrderByAggregateInput
    _avg?: OpportunityAvgOrderByAggregateInput
    _max?: OpportunityMaxOrderByAggregateInput
    _min?: OpportunityMinOrderByAggregateInput
    _sum?: OpportunitySumOrderByAggregateInput
  }

  export type OpportunityScalarWhereWithAggregatesInput = {
    AND?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    OR?: OpportunityScalarWhereWithAggregatesInput[]
    NOT?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Opportunity"> | string
    orgId?: StringWithAggregatesFilter<"Opportunity"> | string
    customerId?: StringWithAggregatesFilter<"Opportunity"> | string
    valueType?: EnumValueTypeWithAggregatesFilter<"Opportunity"> | $Enums.ValueType
    estValue?: DecimalNullableWithAggregatesFilter<"Opportunity"> | Decimal | DecimalJsLike | number | string | null
    stage?: StringWithAggregatesFilter<"Opportunity"> | string
    ownerId?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    sourceLeadId?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    classification?: JsonWithAggregatesFilter<"Opportunity">
    createdAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    orgId?: StringFilter<"Invoice"> | string
    customerId?: StringNullableFilter<"Invoice"> | string | null
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    issuedAt?: DateTimeFilter<"Invoice"> | Date | string
    items?: JsonFilter<"Invoice">
    lineItems?: InvoiceLineListRelationFilter
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    items?: SortOrder
    lineItems?: InvoiceLineOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    org?: OrgOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    orgId?: StringFilter<"Invoice"> | string
    customerId?: StringNullableFilter<"Invoice"> | string | null
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    issuedAt?: DateTimeFilter<"Invoice"> | Date | string
    items?: JsonFilter<"Invoice">
    lineItems?: InvoiceLineListRelationFilter
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    payments?: PaymentListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    items?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    orgId?: StringWithAggregatesFilter<"Invoice"> | string
    customerId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    amount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    items?: JsonWithAggregatesFilter<"Invoice">
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    orgId?: StringFilter<"Payment"> | string
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    receivedAt?: DateTimeFilter<"Payment"> | Date | string
    reference?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    retryCount?: IntFilter<"Payment"> | number
    lastRetryAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    receivedAt?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeChargeId?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    lastRetryAt?: SortOrderInput | SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    org?: OrgOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    orgId?: StringFilter<"Payment"> | string
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    receivedAt?: DateTimeFilter<"Payment"> | Date | string
    reference?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    retryCount?: IntFilter<"Payment"> | number
    lastRetryAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    receivedAt?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeChargeId?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    lastRetryAt?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    orgId?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringWithAggregatesFilter<"Payment"> | string
    receivedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: StringWithAggregatesFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    failureReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    retryCount?: IntWithAggregatesFilter<"Payment"> | number
    lastRetryAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
  }

  export type RfpWhereInput = {
    AND?: RfpWhereInput | RfpWhereInput[]
    OR?: RfpWhereInput[]
    NOT?: RfpWhereInput | RfpWhereInput[]
    id?: StringFilter<"Rfp"> | string
    orgId?: StringFilter<"Rfp"> | string
    publicId?: StringFilter<"Rfp"> | string
    sourceSite?: StringFilter<"Rfp"> | string
    title?: StringFilter<"Rfp"> | string
    dueDate?: DateTimeNullableFilter<"Rfp"> | Date | string | null
    docs?: JsonFilter<"Rfp">
    aiBidFit?: IntNullableFilter<"Rfp"> | number | null
    aiPriceHint?: JsonFilter<"Rfp">
    createdAt?: DateTimeFilter<"Rfp"> | Date | string
    updatedAt?: DateTimeFilter<"Rfp"> | Date | string
    jobs?: JobListRelationFilter
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type RfpOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    sourceSite?: SortOrder
    title?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    docs?: SortOrder
    aiBidFit?: SortOrderInput | SortOrder
    aiPriceHint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jobs?: JobOrderByRelationAggregateInput
    org?: OrgOrderByWithRelationInput
  }

  export type RfpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    publicId?: string
    AND?: RfpWhereInput | RfpWhereInput[]
    OR?: RfpWhereInput[]
    NOT?: RfpWhereInput | RfpWhereInput[]
    orgId?: StringFilter<"Rfp"> | string
    sourceSite?: StringFilter<"Rfp"> | string
    title?: StringFilter<"Rfp"> | string
    dueDate?: DateTimeNullableFilter<"Rfp"> | Date | string | null
    docs?: JsonFilter<"Rfp">
    aiBidFit?: IntNullableFilter<"Rfp"> | number | null
    aiPriceHint?: JsonFilter<"Rfp">
    createdAt?: DateTimeFilter<"Rfp"> | Date | string
    updatedAt?: DateTimeFilter<"Rfp"> | Date | string
    jobs?: JobListRelationFilter
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id" | "publicId">

  export type RfpOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    sourceSite?: SortOrder
    title?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    docs?: SortOrder
    aiBidFit?: SortOrderInput | SortOrder
    aiPriceHint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RfpCountOrderByAggregateInput
    _avg?: RfpAvgOrderByAggregateInput
    _max?: RfpMaxOrderByAggregateInput
    _min?: RfpMinOrderByAggregateInput
    _sum?: RfpSumOrderByAggregateInput
  }

  export type RfpScalarWhereWithAggregatesInput = {
    AND?: RfpScalarWhereWithAggregatesInput | RfpScalarWhereWithAggregatesInput[]
    OR?: RfpScalarWhereWithAggregatesInput[]
    NOT?: RfpScalarWhereWithAggregatesInput | RfpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rfp"> | string
    orgId?: StringWithAggregatesFilter<"Rfp"> | string
    publicId?: StringWithAggregatesFilter<"Rfp"> | string
    sourceSite?: StringWithAggregatesFilter<"Rfp"> | string
    title?: StringWithAggregatesFilter<"Rfp"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Rfp"> | Date | string | null
    docs?: JsonWithAggregatesFilter<"Rfp">
    aiBidFit?: IntNullableWithAggregatesFilter<"Rfp"> | number | null
    aiPriceHint?: JsonWithAggregatesFilter<"Rfp">
    createdAt?: DateTimeWithAggregatesFilter<"Rfp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Rfp"> | Date | string
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: StringFilter<"Job"> | string
    orgId?: StringFilter<"Job"> | string
    customerId?: StringNullableFilter<"Job"> | string | null
    rfpId?: StringNullableFilter<"Job"> | string | null
    status?: StringFilter<"Job"> | string
    schedule?: JsonFilter<"Job">
    assignedTo?: StringNullableFilter<"Job"> | string | null
    checklist?: JsonFilter<"Job">
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    rfp?: XOR<RfpNullableScalarRelationFilter, RfpWhereInput> | null
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    rfpId?: SortOrderInput | SortOrder
    status?: SortOrder
    schedule?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    checklist?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    org?: OrgOrderByWithRelationInput
    rfp?: RfpOrderByWithRelationInput
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    orgId?: StringFilter<"Job"> | string
    customerId?: StringNullableFilter<"Job"> | string | null
    rfpId?: StringNullableFilter<"Job"> | string | null
    status?: StringFilter<"Job"> | string
    schedule?: JsonFilter<"Job">
    assignedTo?: StringNullableFilter<"Job"> | string | null
    checklist?: JsonFilter<"Job">
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    rfp?: XOR<RfpNullableScalarRelationFilter, RfpWhereInput> | null
  }, "id">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    rfpId?: SortOrderInput | SortOrder
    status?: SortOrder
    schedule?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    checklist?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobCountOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Job"> | string
    orgId?: StringWithAggregatesFilter<"Job"> | string
    customerId?: StringNullableWithAggregatesFilter<"Job"> | string | null
    rfpId?: StringNullableWithAggregatesFilter<"Job"> | string | null
    status?: StringWithAggregatesFilter<"Job"> | string
    schedule?: JsonWithAggregatesFilter<"Job">
    assignedTo?: StringNullableWithAggregatesFilter<"Job"> | string | null
    checklist?: JsonWithAggregatesFilter<"Job">
    createdAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    orgId?: StringFilter<"Referral"> | string
    employeeId?: StringNullableFilter<"Referral"> | string | null
    referredName?: StringFilter<"Referral"> | string
    referredEmail?: StringNullableFilter<"Referral"> | string | null
    referredPhone?: StringNullableFilter<"Referral"> | string | null
    status?: StringFilter<"Referral"> | string
    convertedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    referredName?: SortOrder
    referredEmail?: SortOrderInput | SortOrder
    referredPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    convertedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    orgId?: StringFilter<"Referral"> | string
    employeeId?: StringNullableFilter<"Referral"> | string | null
    referredName?: StringFilter<"Referral"> | string
    referredEmail?: StringNullableFilter<"Referral"> | string | null
    referredPhone?: StringNullableFilter<"Referral"> | string | null
    status?: StringFilter<"Referral"> | string
    convertedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    referredName?: SortOrder
    referredEmail?: SortOrderInput | SortOrder
    referredPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    convertedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    orgId?: StringWithAggregatesFilter<"Referral"> | string
    employeeId?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    referredName?: StringWithAggregatesFilter<"Referral"> | string
    referredEmail?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    referredPhone?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    status?: StringWithAggregatesFilter<"Referral"> | string
    convertedAt?: DateTimeNullableWithAggregatesFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type BillingLedgerWhereInput = {
    AND?: BillingLedgerWhereInput | BillingLedgerWhereInput[]
    OR?: BillingLedgerWhereInput[]
    NOT?: BillingLedgerWhereInput | BillingLedgerWhereInput[]
    id?: StringFilter<"BillingLedger"> | string
    orgId?: StringFilter<"BillingLedger"> | string
    type?: EnumLedgerTypeFilter<"BillingLedger"> | $Enums.LedgerType
    amount?: DecimalFilter<"BillingLedger"> | Decimal | DecimalJsLike | number | string
    meta?: JsonFilter<"BillingLedger">
    createdAt?: DateTimeFilter<"BillingLedger"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type BillingLedgerOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type BillingLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingLedgerWhereInput | BillingLedgerWhereInput[]
    OR?: BillingLedgerWhereInput[]
    NOT?: BillingLedgerWhereInput | BillingLedgerWhereInput[]
    orgId?: StringFilter<"BillingLedger"> | string
    type?: EnumLedgerTypeFilter<"BillingLedger"> | $Enums.LedgerType
    amount?: DecimalFilter<"BillingLedger"> | Decimal | DecimalJsLike | number | string
    meta?: JsonFilter<"BillingLedger">
    createdAt?: DateTimeFilter<"BillingLedger"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type BillingLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    _count?: BillingLedgerCountOrderByAggregateInput
    _avg?: BillingLedgerAvgOrderByAggregateInput
    _max?: BillingLedgerMaxOrderByAggregateInput
    _min?: BillingLedgerMinOrderByAggregateInput
    _sum?: BillingLedgerSumOrderByAggregateInput
  }

  export type BillingLedgerScalarWhereWithAggregatesInput = {
    AND?: BillingLedgerScalarWhereWithAggregatesInput | BillingLedgerScalarWhereWithAggregatesInput[]
    OR?: BillingLedgerScalarWhereWithAggregatesInput[]
    NOT?: BillingLedgerScalarWhereWithAggregatesInput | BillingLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingLedger"> | string
    orgId?: StringWithAggregatesFilter<"BillingLedger"> | string
    type?: EnumLedgerTypeWithAggregatesFilter<"BillingLedger"> | $Enums.LedgerType
    amount?: DecimalWithAggregatesFilter<"BillingLedger"> | Decimal | DecimalJsLike | number | string
    meta?: JsonWithAggregatesFilter<"BillingLedger">
    createdAt?: DateTimeWithAggregatesFilter<"BillingLedger"> | Date | string
  }

  export type LeadInvoiceWhereInput = {
    AND?: LeadInvoiceWhereInput | LeadInvoiceWhereInput[]
    OR?: LeadInvoiceWhereInput[]
    NOT?: LeadInvoiceWhereInput | LeadInvoiceWhereInput[]
    id?: StringFilter<"LeadInvoice"> | string
    orgId?: StringNullableFilter<"LeadInvoice"> | string | null
    number?: StringFilter<"LeadInvoice"> | string
    periodFrom?: DateTimeFilter<"LeadInvoice"> | Date | string
    periodTo?: DateTimeFilter<"LeadInvoice"> | Date | string
    status?: StringFilter<"LeadInvoice"> | string
    subtotalCents?: IntFilter<"LeadInvoice"> | number
    taxCents?: IntFilter<"LeadInvoice"> | number
    totalCents?: IntFilter<"LeadInvoice"> | number
    currency?: StringFilter<"LeadInvoice"> | string
    stripeInvoiceId?: StringNullableFilter<"LeadInvoice"> | string | null
    createdAt?: DateTimeFilter<"LeadInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"LeadInvoice"> | Date | string
    leadCount?: IntFilter<"LeadInvoice"> | number
    org?: XOR<OrgNullableScalarRelationFilter, OrgWhereInput> | null
    lines?: LeadInvoiceLineListRelationFilter
  }

  export type LeadInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrderInput | SortOrder
    number?: SortOrder
    periodFrom?: SortOrder
    periodTo?: SortOrder
    status?: SortOrder
    subtotalCents?: SortOrder
    taxCents?: SortOrder
    totalCents?: SortOrder
    currency?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leadCount?: SortOrder
    org?: OrgOrderByWithRelationInput
    lines?: LeadInvoiceLineOrderByRelationAggregateInput
  }

  export type LeadInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    AND?: LeadInvoiceWhereInput | LeadInvoiceWhereInput[]
    OR?: LeadInvoiceWhereInput[]
    NOT?: LeadInvoiceWhereInput | LeadInvoiceWhereInput[]
    orgId?: StringNullableFilter<"LeadInvoice"> | string | null
    periodFrom?: DateTimeFilter<"LeadInvoice"> | Date | string
    periodTo?: DateTimeFilter<"LeadInvoice"> | Date | string
    status?: StringFilter<"LeadInvoice"> | string
    subtotalCents?: IntFilter<"LeadInvoice"> | number
    taxCents?: IntFilter<"LeadInvoice"> | number
    totalCents?: IntFilter<"LeadInvoice"> | number
    currency?: StringFilter<"LeadInvoice"> | string
    stripeInvoiceId?: StringNullableFilter<"LeadInvoice"> | string | null
    createdAt?: DateTimeFilter<"LeadInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"LeadInvoice"> | Date | string
    leadCount?: IntFilter<"LeadInvoice"> | number
    org?: XOR<OrgNullableScalarRelationFilter, OrgWhereInput> | null
    lines?: LeadInvoiceLineListRelationFilter
  }, "id" | "number">

  export type LeadInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrderInput | SortOrder
    number?: SortOrder
    periodFrom?: SortOrder
    periodTo?: SortOrder
    status?: SortOrder
    subtotalCents?: SortOrder
    taxCents?: SortOrder
    totalCents?: SortOrder
    currency?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leadCount?: SortOrder
    _count?: LeadInvoiceCountOrderByAggregateInput
    _avg?: LeadInvoiceAvgOrderByAggregateInput
    _max?: LeadInvoiceMaxOrderByAggregateInput
    _min?: LeadInvoiceMinOrderByAggregateInput
    _sum?: LeadInvoiceSumOrderByAggregateInput
  }

  export type LeadInvoiceScalarWhereWithAggregatesInput = {
    AND?: LeadInvoiceScalarWhereWithAggregatesInput | LeadInvoiceScalarWhereWithAggregatesInput[]
    OR?: LeadInvoiceScalarWhereWithAggregatesInput[]
    NOT?: LeadInvoiceScalarWhereWithAggregatesInput | LeadInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadInvoice"> | string
    orgId?: StringNullableWithAggregatesFilter<"LeadInvoice"> | string | null
    number?: StringWithAggregatesFilter<"LeadInvoice"> | string
    periodFrom?: DateTimeWithAggregatesFilter<"LeadInvoice"> | Date | string
    periodTo?: DateTimeWithAggregatesFilter<"LeadInvoice"> | Date | string
    status?: StringWithAggregatesFilter<"LeadInvoice"> | string
    subtotalCents?: IntWithAggregatesFilter<"LeadInvoice"> | number
    taxCents?: IntWithAggregatesFilter<"LeadInvoice"> | number
    totalCents?: IntWithAggregatesFilter<"LeadInvoice"> | number
    currency?: StringWithAggregatesFilter<"LeadInvoice"> | string
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"LeadInvoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LeadInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeadInvoice"> | Date | string
    leadCount?: IntWithAggregatesFilter<"LeadInvoice"> | number
  }

  export type LeadInvoiceLineWhereInput = {
    AND?: LeadInvoiceLineWhereInput | LeadInvoiceLineWhereInput[]
    OR?: LeadInvoiceLineWhereInput[]
    NOT?: LeadInvoiceLineWhereInput | LeadInvoiceLineWhereInput[]
    id?: StringFilter<"LeadInvoiceLine"> | string
    invoiceId?: StringFilter<"LeadInvoiceLine"> | string
    leadId?: StringNullableFilter<"LeadInvoiceLine"> | string | null
    description?: StringFilter<"LeadInvoiceLine"> | string
    quantity?: IntFilter<"LeadInvoiceLine"> | number
    unitPriceCents?: IntFilter<"LeadInvoiceLine"> | number
    amountCents?: IntFilter<"LeadInvoiceLine"> | number
    source?: StringNullableFilter<"LeadInvoiceLine"> | string | null
    createdAt?: DateTimeFilter<"LeadInvoiceLine"> | Date | string
    invoice?: XOR<LeadInvoiceScalarRelationFilter, LeadInvoiceWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
  }

  export type LeadInvoiceLineOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    invoice?: LeadInvoiceOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
  }

  export type LeadInvoiceLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadInvoiceLineWhereInput | LeadInvoiceLineWhereInput[]
    OR?: LeadInvoiceLineWhereInput[]
    NOT?: LeadInvoiceLineWhereInput | LeadInvoiceLineWhereInput[]
    invoiceId?: StringFilter<"LeadInvoiceLine"> | string
    leadId?: StringNullableFilter<"LeadInvoiceLine"> | string | null
    description?: StringFilter<"LeadInvoiceLine"> | string
    quantity?: IntFilter<"LeadInvoiceLine"> | number
    unitPriceCents?: IntFilter<"LeadInvoiceLine"> | number
    amountCents?: IntFilter<"LeadInvoiceLine"> | number
    source?: StringNullableFilter<"LeadInvoiceLine"> | string | null
    createdAt?: DateTimeFilter<"LeadInvoiceLine"> | Date | string
    invoice?: XOR<LeadInvoiceScalarRelationFilter, LeadInvoiceWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
  }, "id">

  export type LeadInvoiceLineOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LeadInvoiceLineCountOrderByAggregateInput
    _avg?: LeadInvoiceLineAvgOrderByAggregateInput
    _max?: LeadInvoiceLineMaxOrderByAggregateInput
    _min?: LeadInvoiceLineMinOrderByAggregateInput
    _sum?: LeadInvoiceLineSumOrderByAggregateInput
  }

  export type LeadInvoiceLineScalarWhereWithAggregatesInput = {
    AND?: LeadInvoiceLineScalarWhereWithAggregatesInput | LeadInvoiceLineScalarWhereWithAggregatesInput[]
    OR?: LeadInvoiceLineScalarWhereWithAggregatesInput[]
    NOT?: LeadInvoiceLineScalarWhereWithAggregatesInput | LeadInvoiceLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadInvoiceLine"> | string
    invoiceId?: StringWithAggregatesFilter<"LeadInvoiceLine"> | string
    leadId?: StringNullableWithAggregatesFilter<"LeadInvoiceLine"> | string | null
    description?: StringWithAggregatesFilter<"LeadInvoiceLine"> | string
    quantity?: IntWithAggregatesFilter<"LeadInvoiceLine"> | number
    unitPriceCents?: IntWithAggregatesFilter<"LeadInvoiceLine"> | number
    amountCents?: IntWithAggregatesFilter<"LeadInvoiceLine"> | number
    source?: StringNullableWithAggregatesFilter<"LeadInvoiceLine"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LeadInvoiceLine"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    orgId?: StringFilter<"AuditLog"> | string
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    field?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    reason?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    actorUserId?: SortOrderInput | SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    field?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    orgId?: StringFilter<"AuditLog"> | string
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    field?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    reason?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    actorUserId?: SortOrderInput | SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    field?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    orgId?: StringWithAggregatesFilter<"AuditLog"> | string
    actorUserId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    field?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    reason?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type RbacPermissionWhereInput = {
    AND?: RbacPermissionWhereInput | RbacPermissionWhereInput[]
    OR?: RbacPermissionWhereInput[]
    NOT?: RbacPermissionWhereInput | RbacPermissionWhereInput[]
    id?: StringFilter<"RbacPermission"> | string
    code?: StringFilter<"RbacPermission"> | string
    description?: StringNullableFilter<"RbacPermission"> | string | null
    createdAt?: DateTimeFilter<"RbacPermission"> | Date | string
    rolePerms?: RbacRolePermissionListRelationFilter
  }

  export type RbacPermissionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    rolePerms?: RbacRolePermissionOrderByRelationAggregateInput
  }

  export type RbacPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: RbacPermissionWhereInput | RbacPermissionWhereInput[]
    OR?: RbacPermissionWhereInput[]
    NOT?: RbacPermissionWhereInput | RbacPermissionWhereInput[]
    description?: StringNullableFilter<"RbacPermission"> | string | null
    createdAt?: DateTimeFilter<"RbacPermission"> | Date | string
    rolePerms?: RbacRolePermissionListRelationFilter
  }, "id" | "code">

  export type RbacPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RbacPermissionCountOrderByAggregateInput
    _max?: RbacPermissionMaxOrderByAggregateInput
    _min?: RbacPermissionMinOrderByAggregateInput
  }

  export type RbacPermissionScalarWhereWithAggregatesInput = {
    AND?: RbacPermissionScalarWhereWithAggregatesInput | RbacPermissionScalarWhereWithAggregatesInput[]
    OR?: RbacPermissionScalarWhereWithAggregatesInput[]
    NOT?: RbacPermissionScalarWhereWithAggregatesInput | RbacPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RbacPermission"> | string
    code?: StringWithAggregatesFilter<"RbacPermission"> | string
    description?: StringNullableWithAggregatesFilter<"RbacPermission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RbacPermission"> | Date | string
  }

  export type RbacRoleWhereInput = {
    AND?: RbacRoleWhereInput | RbacRoleWhereInput[]
    OR?: RbacRoleWhereInput[]
    NOT?: RbacRoleWhereInput | RbacRoleWhereInput[]
    id?: StringFilter<"RbacRole"> | string
    orgId?: StringNullableFilter<"RbacRole"> | string | null
    name?: StringFilter<"RbacRole"> | string
    slug?: StringFilter<"RbacRole"> | string
    isSystem?: BoolFilter<"RbacRole"> | boolean
    createdAt?: DateTimeFilter<"RbacRole"> | Date | string
    org?: XOR<OrgNullableScalarRelationFilter, OrgWhereInput> | null
    rolePerms?: RbacRolePermissionListRelationFilter
    userRoles?: RbacUserRoleListRelationFilter
  }

  export type RbacRoleOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrderInput | SortOrder
    name?: SortOrder
    slug?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    org?: OrgOrderByWithRelationInput
    rolePerms?: RbacRolePermissionOrderByRelationAggregateInput
    userRoles?: RbacUserRoleOrderByRelationAggregateInput
  }

  export type RbacRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orgId_slug?: RbacRoleOrgIdSlugCompoundUniqueInput
    AND?: RbacRoleWhereInput | RbacRoleWhereInput[]
    OR?: RbacRoleWhereInput[]
    NOT?: RbacRoleWhereInput | RbacRoleWhereInput[]
    orgId?: StringNullableFilter<"RbacRole"> | string | null
    name?: StringFilter<"RbacRole"> | string
    slug?: StringFilter<"RbacRole"> | string
    isSystem?: BoolFilter<"RbacRole"> | boolean
    createdAt?: DateTimeFilter<"RbacRole"> | Date | string
    org?: XOR<OrgNullableScalarRelationFilter, OrgWhereInput> | null
    rolePerms?: RbacRolePermissionListRelationFilter
    userRoles?: RbacUserRoleListRelationFilter
  }, "id" | "orgId_slug">

  export type RbacRoleOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrderInput | SortOrder
    name?: SortOrder
    slug?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    _count?: RbacRoleCountOrderByAggregateInput
    _max?: RbacRoleMaxOrderByAggregateInput
    _min?: RbacRoleMinOrderByAggregateInput
  }

  export type RbacRoleScalarWhereWithAggregatesInput = {
    AND?: RbacRoleScalarWhereWithAggregatesInput | RbacRoleScalarWhereWithAggregatesInput[]
    OR?: RbacRoleScalarWhereWithAggregatesInput[]
    NOT?: RbacRoleScalarWhereWithAggregatesInput | RbacRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RbacRole"> | string
    orgId?: StringNullableWithAggregatesFilter<"RbacRole"> | string | null
    name?: StringWithAggregatesFilter<"RbacRole"> | string
    slug?: StringWithAggregatesFilter<"RbacRole"> | string
    isSystem?: BoolWithAggregatesFilter<"RbacRole"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RbacRole"> | Date | string
  }

  export type RbacRolePermissionWhereInput = {
    AND?: RbacRolePermissionWhereInput | RbacRolePermissionWhereInput[]
    OR?: RbacRolePermissionWhereInput[]
    NOT?: RbacRolePermissionWhereInput | RbacRolePermissionWhereInput[]
    roleId?: StringFilter<"RbacRolePermission"> | string
    permissionId?: StringFilter<"RbacRolePermission"> | string
    role?: XOR<RbacRoleScalarRelationFilter, RbacRoleWhereInput>
    permission?: XOR<RbacPermissionScalarRelationFilter, RbacPermissionWhereInput>
  }

  export type RbacRolePermissionOrderByWithRelationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    role?: RbacRoleOrderByWithRelationInput
    permission?: RbacPermissionOrderByWithRelationInput
  }

  export type RbacRolePermissionWhereUniqueInput = Prisma.AtLeast<{
    roleId_permissionId?: RbacRolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RbacRolePermissionWhereInput | RbacRolePermissionWhereInput[]
    OR?: RbacRolePermissionWhereInput[]
    NOT?: RbacRolePermissionWhereInput | RbacRolePermissionWhereInput[]
    roleId?: StringFilter<"RbacRolePermission"> | string
    permissionId?: StringFilter<"RbacRolePermission"> | string
    role?: XOR<RbacRoleScalarRelationFilter, RbacRoleWhereInput>
    permission?: XOR<RbacPermissionScalarRelationFilter, RbacPermissionWhereInput>
  }, "roleId_permissionId">

  export type RbacRolePermissionOrderByWithAggregationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    _count?: RbacRolePermissionCountOrderByAggregateInput
    _max?: RbacRolePermissionMaxOrderByAggregateInput
    _min?: RbacRolePermissionMinOrderByAggregateInput
  }

  export type RbacRolePermissionScalarWhereWithAggregatesInput = {
    AND?: RbacRolePermissionScalarWhereWithAggregatesInput | RbacRolePermissionScalarWhereWithAggregatesInput[]
    OR?: RbacRolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RbacRolePermissionScalarWhereWithAggregatesInput | RbacRolePermissionScalarWhereWithAggregatesInput[]
    roleId?: StringWithAggregatesFilter<"RbacRolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RbacRolePermission"> | string
  }

  export type RbacUserRoleWhereInput = {
    AND?: RbacUserRoleWhereInput | RbacUserRoleWhereInput[]
    OR?: RbacUserRoleWhereInput[]
    NOT?: RbacUserRoleWhereInput | RbacUserRoleWhereInput[]
    id?: StringFilter<"RbacUserRole"> | string
    userId?: StringFilter<"RbacUserRole"> | string
    orgId?: StringNullableFilter<"RbacUserRole"> | string | null
    roleId?: StringFilter<"RbacUserRole"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    org?: XOR<OrgNullableScalarRelationFilter, OrgWhereInput> | null
    role?: XOR<RbacRoleScalarRelationFilter, RbacRoleWhereInput>
  }

  export type RbacUserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrderInput | SortOrder
    roleId?: SortOrder
    user?: UserOrderByWithRelationInput
    org?: OrgOrderByWithRelationInput
    role?: RbacRoleOrderByWithRelationInput
  }

  export type RbacUserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId_orgId?: RbacUserRoleUserIdRoleIdOrgIdCompoundUniqueInput
    AND?: RbacUserRoleWhereInput | RbacUserRoleWhereInput[]
    OR?: RbacUserRoleWhereInput[]
    NOT?: RbacUserRoleWhereInput | RbacUserRoleWhereInput[]
    userId?: StringFilter<"RbacUserRole"> | string
    orgId?: StringNullableFilter<"RbacUserRole"> | string | null
    roleId?: StringFilter<"RbacUserRole"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    org?: XOR<OrgNullableScalarRelationFilter, OrgWhereInput> | null
    role?: XOR<RbacRoleScalarRelationFilter, RbacRoleWhereInput>
  }, "id" | "userId_roleId_orgId">

  export type RbacUserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrderInput | SortOrder
    roleId?: SortOrder
    _count?: RbacUserRoleCountOrderByAggregateInput
    _max?: RbacUserRoleMaxOrderByAggregateInput
    _min?: RbacUserRoleMinOrderByAggregateInput
  }

  export type RbacUserRoleScalarWhereWithAggregatesInput = {
    AND?: RbacUserRoleScalarWhereWithAggregatesInput | RbacUserRoleScalarWhereWithAggregatesInput[]
    OR?: RbacUserRoleScalarWhereWithAggregatesInput[]
    NOT?: RbacUserRoleScalarWhereWithAggregatesInput | RbacUserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RbacUserRole"> | string
    userId?: StringWithAggregatesFilter<"RbacUserRole"> | string
    orgId?: StringNullableWithAggregatesFilter<"RbacUserRole"> | string | null
    roleId?: StringWithAggregatesFilter<"RbacUserRole"> | string
  }

  export type ProviderConfigWhereInput = {
    AND?: ProviderConfigWhereInput | ProviderConfigWhereInput[]
    OR?: ProviderConfigWhereInput[]
    NOT?: ProviderConfigWhereInput | ProviderConfigWhereInput[]
    id?: StringFilter<"ProviderConfig"> | string
    samApiKey?: StringNullableFilter<"ProviderConfig"> | string | null
    stripeSecretKey?: StringNullableFilter<"ProviderConfig"> | string | null
    otherConfig?: JsonNullableFilter<"ProviderConfig">
    createdAt?: DateTimeFilter<"ProviderConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ProviderConfig"> | Date | string
  }

  export type ProviderConfigOrderByWithRelationInput = {
    id?: SortOrder
    samApiKey?: SortOrderInput | SortOrder
    stripeSecretKey?: SortOrderInput | SortOrder
    otherConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProviderConfigWhereInput | ProviderConfigWhereInput[]
    OR?: ProviderConfigWhereInput[]
    NOT?: ProviderConfigWhereInput | ProviderConfigWhereInput[]
    samApiKey?: StringNullableFilter<"ProviderConfig"> | string | null
    stripeSecretKey?: StringNullableFilter<"ProviderConfig"> | string | null
    otherConfig?: JsonNullableFilter<"ProviderConfig">
    createdAt?: DateTimeFilter<"ProviderConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ProviderConfig"> | Date | string
  }, "id">

  export type ProviderConfigOrderByWithAggregationInput = {
    id?: SortOrder
    samApiKey?: SortOrderInput | SortOrder
    stripeSecretKey?: SortOrderInput | SortOrder
    otherConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProviderConfigCountOrderByAggregateInput
    _max?: ProviderConfigMaxOrderByAggregateInput
    _min?: ProviderConfigMinOrderByAggregateInput
  }

  export type ProviderConfigScalarWhereWithAggregatesInput = {
    AND?: ProviderConfigScalarWhereWithAggregatesInput | ProviderConfigScalarWhereWithAggregatesInput[]
    OR?: ProviderConfigScalarWhereWithAggregatesInput[]
    NOT?: ProviderConfigScalarWhereWithAggregatesInput | ProviderConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProviderConfig"> | string
    samApiKey?: StringNullableWithAggregatesFilter<"ProviderConfig"> | string | null
    stripeSecretKey?: StringNullableWithAggregatesFilter<"ProviderConfig"> | string | null
    otherConfig?: JsonNullableWithAggregatesFilter<"ProviderConfig">
    createdAt?: DateTimeWithAggregatesFilter<"ProviderConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProviderConfig"> | Date | string
  }

  export type PricingPlanWhereInput = {
    AND?: PricingPlanWhereInput | PricingPlanWhereInput[]
    OR?: PricingPlanWhereInput[]
    NOT?: PricingPlanWhereInput | PricingPlanWhereInput[]
    orgId?: StringFilter<"PricingPlan"> | string
    model?: EnumPricingModelFilter<"PricingPlan"> | $Enums.PricingModel
    currency?: StringFilter<"PricingPlan"> | string
    unitAmount?: IntFilter<"PricingPlan"> | number
    tiersJson?: JsonNullableFilter<"PricingPlan">
    includedUnits?: IntFilter<"PricingPlan"> | number
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type PricingPlanOrderByWithRelationInput = {
    orgId?: SortOrder
    model?: SortOrder
    currency?: SortOrder
    unitAmount?: SortOrder
    tiersJson?: SortOrderInput | SortOrder
    includedUnits?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type PricingPlanWhereUniqueInput = Prisma.AtLeast<{
    orgId?: string
    AND?: PricingPlanWhereInput | PricingPlanWhereInput[]
    OR?: PricingPlanWhereInput[]
    NOT?: PricingPlanWhereInput | PricingPlanWhereInput[]
    model?: EnumPricingModelFilter<"PricingPlan"> | $Enums.PricingModel
    currency?: StringFilter<"PricingPlan"> | string
    unitAmount?: IntFilter<"PricingPlan"> | number
    tiersJson?: JsonNullableFilter<"PricingPlan">
    includedUnits?: IntFilter<"PricingPlan"> | number
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "orgId">

  export type PricingPlanOrderByWithAggregationInput = {
    orgId?: SortOrder
    model?: SortOrder
    currency?: SortOrder
    unitAmount?: SortOrder
    tiersJson?: SortOrderInput | SortOrder
    includedUnits?: SortOrder
    _count?: PricingPlanCountOrderByAggregateInput
    _avg?: PricingPlanAvgOrderByAggregateInput
    _max?: PricingPlanMaxOrderByAggregateInput
    _min?: PricingPlanMinOrderByAggregateInput
    _sum?: PricingPlanSumOrderByAggregateInput
  }

  export type PricingPlanScalarWhereWithAggregatesInput = {
    AND?: PricingPlanScalarWhereWithAggregatesInput | PricingPlanScalarWhereWithAggregatesInput[]
    OR?: PricingPlanScalarWhereWithAggregatesInput[]
    NOT?: PricingPlanScalarWhereWithAggregatesInput | PricingPlanScalarWhereWithAggregatesInput[]
    orgId?: StringWithAggregatesFilter<"PricingPlan"> | string
    model?: EnumPricingModelWithAggregatesFilter<"PricingPlan"> | $Enums.PricingModel
    currency?: StringWithAggregatesFilter<"PricingPlan"> | string
    unitAmount?: IntWithAggregatesFilter<"PricingPlan"> | number
    tiersJson?: JsonNullableWithAggregatesFilter<"PricingPlan">
    includedUnits?: IntWithAggregatesFilter<"PricingPlan"> | number
  }

  export type AiUsageEventWhereInput = {
    AND?: AiUsageEventWhereInput | AiUsageEventWhereInput[]
    OR?: AiUsageEventWhereInput[]
    NOT?: AiUsageEventWhereInput | AiUsageEventWhereInput[]
    id?: StringFilter<"AiUsageEvent"> | string
    orgId?: StringFilter<"AiUsageEvent"> | string
    userId?: StringNullableFilter<"AiUsageEvent"> | string | null
    feature?: StringFilter<"AiUsageEvent"> | string
    model?: StringFilter<"AiUsageEvent"> | string
    tokensIn?: IntFilter<"AiUsageEvent"> | number
    tokensOut?: IntFilter<"AiUsageEvent"> | number
    costUsd?: DecimalFilter<"AiUsageEvent"> | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFilter<"AiUsageEvent"> | number
    requestId?: StringNullableFilter<"AiUsageEvent"> | string | null
    createdAt?: DateTimeFilter<"AiUsageEvent"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type AiUsageEventOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrderInput | SortOrder
    feature?: SortOrder
    model?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    requestId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type AiUsageEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiUsageEventWhereInput | AiUsageEventWhereInput[]
    OR?: AiUsageEventWhereInput[]
    NOT?: AiUsageEventWhereInput | AiUsageEventWhereInput[]
    orgId?: StringFilter<"AiUsageEvent"> | string
    userId?: StringNullableFilter<"AiUsageEvent"> | string | null
    feature?: StringFilter<"AiUsageEvent"> | string
    model?: StringFilter<"AiUsageEvent"> | string
    tokensIn?: IntFilter<"AiUsageEvent"> | number
    tokensOut?: IntFilter<"AiUsageEvent"> | number
    costUsd?: DecimalFilter<"AiUsageEvent"> | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFilter<"AiUsageEvent"> | number
    requestId?: StringNullableFilter<"AiUsageEvent"> | string | null
    createdAt?: DateTimeFilter<"AiUsageEvent"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type AiUsageEventOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrderInput | SortOrder
    feature?: SortOrder
    model?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    requestId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AiUsageEventCountOrderByAggregateInput
    _avg?: AiUsageEventAvgOrderByAggregateInput
    _max?: AiUsageEventMaxOrderByAggregateInput
    _min?: AiUsageEventMinOrderByAggregateInput
    _sum?: AiUsageEventSumOrderByAggregateInput
  }

  export type AiUsageEventScalarWhereWithAggregatesInput = {
    AND?: AiUsageEventScalarWhereWithAggregatesInput | AiUsageEventScalarWhereWithAggregatesInput[]
    OR?: AiUsageEventScalarWhereWithAggregatesInput[]
    NOT?: AiUsageEventScalarWhereWithAggregatesInput | AiUsageEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiUsageEvent"> | string
    orgId?: StringWithAggregatesFilter<"AiUsageEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"AiUsageEvent"> | string | null
    feature?: StringWithAggregatesFilter<"AiUsageEvent"> | string
    model?: StringWithAggregatesFilter<"AiUsageEvent"> | string
    tokensIn?: IntWithAggregatesFilter<"AiUsageEvent"> | number
    tokensOut?: IntWithAggregatesFilter<"AiUsageEvent"> | number
    costUsd?: DecimalWithAggregatesFilter<"AiUsageEvent"> | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntWithAggregatesFilter<"AiUsageEvent"> | number
    requestId?: StringNullableWithAggregatesFilter<"AiUsageEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AiUsageEvent"> | Date | string
  }

  export type AiMonthlySummaryWhereInput = {
    AND?: AiMonthlySummaryWhereInput | AiMonthlySummaryWhereInput[]
    OR?: AiMonthlySummaryWhereInput[]
    NOT?: AiMonthlySummaryWhereInput | AiMonthlySummaryWhereInput[]
    id?: StringFilter<"AiMonthlySummary"> | string
    orgId?: StringFilter<"AiMonthlySummary"> | string
    monthKey?: StringFilter<"AiMonthlySummary"> | string
    tokensIn?: IntFilter<"AiMonthlySummary"> | number
    tokensOut?: IntFilter<"AiMonthlySummary"> | number
    costUsd?: DecimalFilter<"AiMonthlySummary"> | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFilter<"AiMonthlySummary"> | number
    callCount?: IntFilter<"AiMonthlySummary"> | number
    createdAt?: DateTimeFilter<"AiMonthlySummary"> | Date | string
    updatedAt?: DateTimeFilter<"AiMonthlySummary"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type AiMonthlySummaryOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    monthKey?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    callCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type AiMonthlySummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orgId_monthKey?: AiMonthlySummaryOrgIdMonthKeyCompoundUniqueInput
    AND?: AiMonthlySummaryWhereInput | AiMonthlySummaryWhereInput[]
    OR?: AiMonthlySummaryWhereInput[]
    NOT?: AiMonthlySummaryWhereInput | AiMonthlySummaryWhereInput[]
    orgId?: StringFilter<"AiMonthlySummary"> | string
    monthKey?: StringFilter<"AiMonthlySummary"> | string
    tokensIn?: IntFilter<"AiMonthlySummary"> | number
    tokensOut?: IntFilter<"AiMonthlySummary"> | number
    costUsd?: DecimalFilter<"AiMonthlySummary"> | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFilter<"AiMonthlySummary"> | number
    callCount?: IntFilter<"AiMonthlySummary"> | number
    createdAt?: DateTimeFilter<"AiMonthlySummary"> | Date | string
    updatedAt?: DateTimeFilter<"AiMonthlySummary"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id" | "orgId_monthKey">

  export type AiMonthlySummaryOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    monthKey?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    callCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiMonthlySummaryCountOrderByAggregateInput
    _avg?: AiMonthlySummaryAvgOrderByAggregateInput
    _max?: AiMonthlySummaryMaxOrderByAggregateInput
    _min?: AiMonthlySummaryMinOrderByAggregateInput
    _sum?: AiMonthlySummarySumOrderByAggregateInput
  }

  export type AiMonthlySummaryScalarWhereWithAggregatesInput = {
    AND?: AiMonthlySummaryScalarWhereWithAggregatesInput | AiMonthlySummaryScalarWhereWithAggregatesInput[]
    OR?: AiMonthlySummaryScalarWhereWithAggregatesInput[]
    NOT?: AiMonthlySummaryScalarWhereWithAggregatesInput | AiMonthlySummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiMonthlySummary"> | string
    orgId?: StringWithAggregatesFilter<"AiMonthlySummary"> | string
    monthKey?: StringWithAggregatesFilter<"AiMonthlySummary"> | string
    tokensIn?: IntWithAggregatesFilter<"AiMonthlySummary"> | number
    tokensOut?: IntWithAggregatesFilter<"AiMonthlySummary"> | number
    costUsd?: DecimalWithAggregatesFilter<"AiMonthlySummary"> | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntWithAggregatesFilter<"AiMonthlySummary"> | number
    callCount?: IntWithAggregatesFilter<"AiMonthlySummary"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AiMonthlySummary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiMonthlySummary"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    orgId?: StringFilter<"Activity"> | string
    actorType?: StringFilter<"Activity"> | string
    actorId?: StringNullableFilter<"Activity"> | string | null
    entityType?: StringFilter<"Activity"> | string
    entityId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    meta?: JsonFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrderInput | SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    orgId?: StringFilter<"Activity"> | string
    actorType?: StringFilter<"Activity"> | string
    actorId?: StringNullableFilter<"Activity"> | string | null
    entityType?: StringFilter<"Activity"> | string
    entityId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    meta?: JsonFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrderInput | SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    orgId?: StringWithAggregatesFilter<"Activity"> | string
    actorType?: StringWithAggregatesFilter<"Activity"> | string
    actorId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    entityType?: StringWithAggregatesFilter<"Activity"> | string
    entityId?: StringWithAggregatesFilter<"Activity"> | string
    action?: StringWithAggregatesFilter<"Activity"> | string
    meta?: JsonWithAggregatesFilter<"Activity">
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    orgId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    startedAt?: DateTimeFilter<"Subscription"> | Date | string
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    renewsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    priceCents?: IntFilter<"Subscription"> | number
    meta?: JsonFilter<"Subscription">
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    renewsAt?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    orgId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    startedAt?: DateTimeFilter<"Subscription"> | Date | string
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    renewsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    priceCents?: IntFilter<"Subscription"> | number
    meta?: JsonFilter<"Subscription">
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    renewsAt?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    orgId?: StringWithAggregatesFilter<"Subscription"> | string
    plan?: StringWithAggregatesFilter<"Subscription"> | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    startedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    renewsAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    priceCents?: IntWithAggregatesFilter<"Subscription"> | number
    meta?: JsonWithAggregatesFilter<"Subscription">
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type UsageMeterWhereInput = {
    AND?: UsageMeterWhereInput | UsageMeterWhereInput[]
    OR?: UsageMeterWhereInput[]
    NOT?: UsageMeterWhereInput | UsageMeterWhereInput[]
    id?: StringFilter<"UsageMeter"> | string
    orgId?: StringFilter<"UsageMeter"> | string
    meter?: StringFilter<"UsageMeter"> | string
    quantity?: IntFilter<"UsageMeter"> | number
    windowStart?: DateTimeFilter<"UsageMeter"> | Date | string
    windowEnd?: DateTimeFilter<"UsageMeter"> | Date | string
    createdAt?: DateTimeFilter<"UsageMeter"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type UsageMeterOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    meter?: SortOrder
    quantity?: SortOrder
    windowStart?: SortOrder
    windowEnd?: SortOrder
    createdAt?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type UsageMeterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageMeterWhereInput | UsageMeterWhereInput[]
    OR?: UsageMeterWhereInput[]
    NOT?: UsageMeterWhereInput | UsageMeterWhereInput[]
    orgId?: StringFilter<"UsageMeter"> | string
    meter?: StringFilter<"UsageMeter"> | string
    quantity?: IntFilter<"UsageMeter"> | number
    windowStart?: DateTimeFilter<"UsageMeter"> | Date | string
    windowEnd?: DateTimeFilter<"UsageMeter"> | Date | string
    createdAt?: DateTimeFilter<"UsageMeter"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type UsageMeterOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    meter?: SortOrder
    quantity?: SortOrder
    windowStart?: SortOrder
    windowEnd?: SortOrder
    createdAt?: SortOrder
    _count?: UsageMeterCountOrderByAggregateInput
    _avg?: UsageMeterAvgOrderByAggregateInput
    _max?: UsageMeterMaxOrderByAggregateInput
    _min?: UsageMeterMinOrderByAggregateInput
    _sum?: UsageMeterSumOrderByAggregateInput
  }

  export type UsageMeterScalarWhereWithAggregatesInput = {
    AND?: UsageMeterScalarWhereWithAggregatesInput | UsageMeterScalarWhereWithAggregatesInput[]
    OR?: UsageMeterScalarWhereWithAggregatesInput[]
    NOT?: UsageMeterScalarWhereWithAggregatesInput | UsageMeterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageMeter"> | string
    orgId?: StringWithAggregatesFilter<"UsageMeter"> | string
    meter?: StringWithAggregatesFilter<"UsageMeter"> | string
    quantity?: IntWithAggregatesFilter<"UsageMeter"> | number
    windowStart?: DateTimeWithAggregatesFilter<"UsageMeter"> | Date | string
    windowEnd?: DateTimeWithAggregatesFilter<"UsageMeter"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UsageMeter"> | Date | string
  }

  export type AddonPurchaseWhereInput = {
    AND?: AddonPurchaseWhereInput | AddonPurchaseWhereInput[]
    OR?: AddonPurchaseWhereInput[]
    NOT?: AddonPurchaseWhereInput | AddonPurchaseWhereInput[]
    id?: StringFilter<"AddonPurchase"> | string
    orgId?: StringFilter<"AddonPurchase"> | string
    sku?: StringFilter<"AddonPurchase"> | string
    amount?: DecimalFilter<"AddonPurchase"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"AddonPurchase"> | string
    purchasedAt?: DateTimeFilter<"AddonPurchase"> | Date | string
    refundedAt?: DateTimeNullableFilter<"AddonPurchase"> | Date | string | null
    meta?: JsonFilter<"AddonPurchase">
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type AddonPurchaseOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    sku?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    refundedAt?: SortOrderInput | SortOrder
    meta?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type AddonPurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddonPurchaseWhereInput | AddonPurchaseWhereInput[]
    OR?: AddonPurchaseWhereInput[]
    NOT?: AddonPurchaseWhereInput | AddonPurchaseWhereInput[]
    orgId?: StringFilter<"AddonPurchase"> | string
    sku?: StringFilter<"AddonPurchase"> | string
    amount?: DecimalFilter<"AddonPurchase"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"AddonPurchase"> | string
    purchasedAt?: DateTimeFilter<"AddonPurchase"> | Date | string
    refundedAt?: DateTimeNullableFilter<"AddonPurchase"> | Date | string | null
    meta?: JsonFilter<"AddonPurchase">
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type AddonPurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    sku?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    refundedAt?: SortOrderInput | SortOrder
    meta?: SortOrder
    _count?: AddonPurchaseCountOrderByAggregateInput
    _avg?: AddonPurchaseAvgOrderByAggregateInput
    _max?: AddonPurchaseMaxOrderByAggregateInput
    _min?: AddonPurchaseMinOrderByAggregateInput
    _sum?: AddonPurchaseSumOrderByAggregateInput
  }

  export type AddonPurchaseScalarWhereWithAggregatesInput = {
    AND?: AddonPurchaseScalarWhereWithAggregatesInput | AddonPurchaseScalarWhereWithAggregatesInput[]
    OR?: AddonPurchaseScalarWhereWithAggregatesInput[]
    NOT?: AddonPurchaseScalarWhereWithAggregatesInput | AddonPurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AddonPurchase"> | string
    orgId?: StringWithAggregatesFilter<"AddonPurchase"> | string
    sku?: StringWithAggregatesFilter<"AddonPurchase"> | string
    amount?: DecimalWithAggregatesFilter<"AddonPurchase"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"AddonPurchase"> | string
    purchasedAt?: DateTimeWithAggregatesFilter<"AddonPurchase"> | Date | string
    refundedAt?: DateTimeNullableWithAggregatesFilter<"AddonPurchase"> | Date | string | null
    meta?: JsonWithAggregatesFilter<"AddonPurchase">
  }

  export type FederationKeyWhereInput = {
    AND?: FederationKeyWhereInput | FederationKeyWhereInput[]
    OR?: FederationKeyWhereInput[]
    NOT?: FederationKeyWhereInput | FederationKeyWhereInput[]
    id?: StringFilter<"FederationKey"> | string
    tenantId?: StringFilter<"FederationKey"> | string
    keyId?: StringFilter<"FederationKey"> | string
    secretHash?: StringFilter<"FederationKey"> | string
    scope?: StringFilter<"FederationKey"> | string
    createdAt?: DateTimeFilter<"FederationKey"> | Date | string
    disabledAt?: DateTimeNullableFilter<"FederationKey"> | Date | string | null
    rotatedAt?: DateTimeNullableFilter<"FederationKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"FederationKey"> | Date | string | null
  }

  export type FederationKeyOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    keyId?: SortOrder
    secretHash?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    disabledAt?: SortOrderInput | SortOrder
    rotatedAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
  }

  export type FederationKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyId?: string
    AND?: FederationKeyWhereInput | FederationKeyWhereInput[]
    OR?: FederationKeyWhereInput[]
    NOT?: FederationKeyWhereInput | FederationKeyWhereInput[]
    tenantId?: StringFilter<"FederationKey"> | string
    secretHash?: StringFilter<"FederationKey"> | string
    scope?: StringFilter<"FederationKey"> | string
    createdAt?: DateTimeFilter<"FederationKey"> | Date | string
    disabledAt?: DateTimeNullableFilter<"FederationKey"> | Date | string | null
    rotatedAt?: DateTimeNullableFilter<"FederationKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"FederationKey"> | Date | string | null
  }, "id" | "keyId">

  export type FederationKeyOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    keyId?: SortOrder
    secretHash?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    disabledAt?: SortOrderInput | SortOrder
    rotatedAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: FederationKeyCountOrderByAggregateInput
    _max?: FederationKeyMaxOrderByAggregateInput
    _min?: FederationKeyMinOrderByAggregateInput
  }

  export type FederationKeyScalarWhereWithAggregatesInput = {
    AND?: FederationKeyScalarWhereWithAggregatesInput | FederationKeyScalarWhereWithAggregatesInput[]
    OR?: FederationKeyScalarWhereWithAggregatesInput[]
    NOT?: FederationKeyScalarWhereWithAggregatesInput | FederationKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FederationKey"> | string
    tenantId?: StringWithAggregatesFilter<"FederationKey"> | string
    keyId?: StringWithAggregatesFilter<"FederationKey"> | string
    secretHash?: StringWithAggregatesFilter<"FederationKey"> | string
    scope?: StringWithAggregatesFilter<"FederationKey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FederationKey"> | Date | string
    disabledAt?: DateTimeNullableWithAggregatesFilter<"FederationKey"> | Date | string | null
    rotatedAt?: DateTimeNullableWithAggregatesFilter<"FederationKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"FederationKey"> | Date | string | null
  }

  export type OIDCConfigWhereInput = {
    AND?: OIDCConfigWhereInput | OIDCConfigWhereInput[]
    OR?: OIDCConfigWhereInput[]
    NOT?: OIDCConfigWhereInput | OIDCConfigWhereInput[]
    id?: StringFilter<"OIDCConfig"> | string
    enabled?: BoolFilter<"OIDCConfig"> | boolean
    issuerUrl?: StringFilter<"OIDCConfig"> | string
    clientId?: StringFilter<"OIDCConfig"> | string
    clientSecret?: StringFilter<"OIDCConfig"> | string
    scopes?: StringFilter<"OIDCConfig"> | string
    createdAt?: DateTimeFilter<"OIDCConfig"> | Date | string
    updatedAt?: DateTimeFilter<"OIDCConfig"> | Date | string
    lastTestedAt?: DateTimeNullableFilter<"OIDCConfig"> | Date | string | null
  }

  export type OIDCConfigOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    issuerUrl?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastTestedAt?: SortOrderInput | SortOrder
  }

  export type OIDCConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OIDCConfigWhereInput | OIDCConfigWhereInput[]
    OR?: OIDCConfigWhereInput[]
    NOT?: OIDCConfigWhereInput | OIDCConfigWhereInput[]
    enabled?: BoolFilter<"OIDCConfig"> | boolean
    issuerUrl?: StringFilter<"OIDCConfig"> | string
    clientId?: StringFilter<"OIDCConfig"> | string
    clientSecret?: StringFilter<"OIDCConfig"> | string
    scopes?: StringFilter<"OIDCConfig"> | string
    createdAt?: DateTimeFilter<"OIDCConfig"> | Date | string
    updatedAt?: DateTimeFilter<"OIDCConfig"> | Date | string
    lastTestedAt?: DateTimeNullableFilter<"OIDCConfig"> | Date | string | null
  }, "id">

  export type OIDCConfigOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    issuerUrl?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastTestedAt?: SortOrderInput | SortOrder
    _count?: OIDCConfigCountOrderByAggregateInput
    _max?: OIDCConfigMaxOrderByAggregateInput
    _min?: OIDCConfigMinOrderByAggregateInput
  }

  export type OIDCConfigScalarWhereWithAggregatesInput = {
    AND?: OIDCConfigScalarWhereWithAggregatesInput | OIDCConfigScalarWhereWithAggregatesInput[]
    OR?: OIDCConfigScalarWhereWithAggregatesInput[]
    NOT?: OIDCConfigScalarWhereWithAggregatesInput | OIDCConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OIDCConfig"> | string
    enabled?: BoolWithAggregatesFilter<"OIDCConfig"> | boolean
    issuerUrl?: StringWithAggregatesFilter<"OIDCConfig"> | string
    clientId?: StringWithAggregatesFilter<"OIDCConfig"> | string
    clientSecret?: StringWithAggregatesFilter<"OIDCConfig"> | string
    scopes?: StringWithAggregatesFilter<"OIDCConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OIDCConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OIDCConfig"> | Date | string
    lastTestedAt?: DateTimeNullableWithAggregatesFilter<"OIDCConfig"> | Date | string | null
  }

  export type ProviderIntegrationWhereInput = {
    AND?: ProviderIntegrationWhereInput | ProviderIntegrationWhereInput[]
    OR?: ProviderIntegrationWhereInput[]
    NOT?: ProviderIntegrationWhereInput | ProviderIntegrationWhereInput[]
    id?: StringFilter<"ProviderIntegration"> | string
    name?: StringFilter<"ProviderIntegration"> | string
    type?: StringFilter<"ProviderIntegration"> | string
    config?: JsonFilter<"ProviderIntegration">
    enabled?: BoolFilter<"ProviderIntegration"> | boolean
    createdAt?: DateTimeFilter<"ProviderIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"ProviderIntegration"> | Date | string
    lastSyncAt?: DateTimeNullableFilter<"ProviderIntegration"> | Date | string | null
  }

  export type ProviderIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
  }

  export type ProviderIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProviderIntegrationWhereInput | ProviderIntegrationWhereInput[]
    OR?: ProviderIntegrationWhereInput[]
    NOT?: ProviderIntegrationWhereInput | ProviderIntegrationWhereInput[]
    name?: StringFilter<"ProviderIntegration"> | string
    type?: StringFilter<"ProviderIntegration"> | string
    config?: JsonFilter<"ProviderIntegration">
    enabled?: BoolFilter<"ProviderIntegration"> | boolean
    createdAt?: DateTimeFilter<"ProviderIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"ProviderIntegration"> | Date | string
    lastSyncAt?: DateTimeNullableFilter<"ProviderIntegration"> | Date | string | null
  }, "id">

  export type ProviderIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    _count?: ProviderIntegrationCountOrderByAggregateInput
    _max?: ProviderIntegrationMaxOrderByAggregateInput
    _min?: ProviderIntegrationMinOrderByAggregateInput
  }

  export type ProviderIntegrationScalarWhereWithAggregatesInput = {
    AND?: ProviderIntegrationScalarWhereWithAggregatesInput | ProviderIntegrationScalarWhereWithAggregatesInput[]
    OR?: ProviderIntegrationScalarWhereWithAggregatesInput[]
    NOT?: ProviderIntegrationScalarWhereWithAggregatesInput | ProviderIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProviderIntegration"> | string
    name?: StringWithAggregatesFilter<"ProviderIntegration"> | string
    type?: StringWithAggregatesFilter<"ProviderIntegration"> | string
    config?: JsonWithAggregatesFilter<"ProviderIntegration">
    enabled?: BoolWithAggregatesFilter<"ProviderIntegration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProviderIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProviderIntegration"> | Date | string
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"ProviderIntegration"> | Date | string | null
  }

  export type AuditEventWhereInput = {
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    id?: StringFilter<"AuditEvent"> | string
    actorType?: StringFilter<"AuditEvent"> | string
    actorId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    entityType?: StringFilter<"AuditEvent"> | string
    entityId?: StringNullableFilter<"AuditEvent"> | string | null
    metadata?: JsonFilter<"AuditEvent">
    ipAddress?: StringNullableFilter<"AuditEvent"> | string | null
    userAgent?: StringNullableFilter<"AuditEvent"> | string | null
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
  }

  export type AuditEventOrderByWithRelationInput = {
    id?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    actorType?: StringFilter<"AuditEvent"> | string
    actorId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    entityType?: StringFilter<"AuditEvent"> | string
    entityId?: StringNullableFilter<"AuditEvent"> | string | null
    metadata?: JsonFilter<"AuditEvent">
    ipAddress?: StringNullableFilter<"AuditEvent"> | string | null
    userAgent?: StringNullableFilter<"AuditEvent"> | string | null
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
  }, "id">

  export type AuditEventOrderByWithAggregationInput = {
    id?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditEventCountOrderByAggregateInput
    _max?: AuditEventMaxOrderByAggregateInput
    _min?: AuditEventMinOrderByAggregateInput
  }

  export type AuditEventScalarWhereWithAggregatesInput = {
    AND?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    OR?: AuditEventScalarWhereWithAggregatesInput[]
    NOT?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditEvent"> | string
    actorType?: StringWithAggregatesFilter<"AuditEvent"> | string
    actorId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    action?: StringWithAggregatesFilter<"AuditEvent"> | string
    entityType?: StringWithAggregatesFilter<"AuditEvent"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    metadata?: JsonWithAggregatesFilter<"AuditEvent">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditEvent"> | Date | string
  }

  export type AnalyticsSnapshotWhereInput = {
    AND?: AnalyticsSnapshotWhereInput | AnalyticsSnapshotWhereInput[]
    OR?: AnalyticsSnapshotWhereInput[]
    NOT?: AnalyticsSnapshotWhereInput | AnalyticsSnapshotWhereInput[]
    id?: StringFilter<"AnalyticsSnapshot"> | string
    snapshotDate?: DateTimeFilter<"AnalyticsSnapshot"> | Date | string
    mrrCents?: IntFilter<"AnalyticsSnapshot"> | number
    arrCents?: IntFilter<"AnalyticsSnapshot"> | number
    activeClients?: IntFilter<"AnalyticsSnapshot"> | number
    newClients?: IntFilter<"AnalyticsSnapshot"> | number
    churnedClients?: IntFilter<"AnalyticsSnapshot"> | number
    totalRevenue?: IntFilter<"AnalyticsSnapshot"> | number
    metricsJson?: JsonFilter<"AnalyticsSnapshot">
    createdAt?: DateTimeFilter<"AnalyticsSnapshot"> | Date | string
  }

  export type AnalyticsSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    snapshotDate?: SortOrder
    mrrCents?: SortOrder
    arrCents?: SortOrder
    activeClients?: SortOrder
    newClients?: SortOrder
    churnedClients?: SortOrder
    totalRevenue?: SortOrder
    metricsJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    snapshotDate?: Date | string
    AND?: AnalyticsSnapshotWhereInput | AnalyticsSnapshotWhereInput[]
    OR?: AnalyticsSnapshotWhereInput[]
    NOT?: AnalyticsSnapshotWhereInput | AnalyticsSnapshotWhereInput[]
    mrrCents?: IntFilter<"AnalyticsSnapshot"> | number
    arrCents?: IntFilter<"AnalyticsSnapshot"> | number
    activeClients?: IntFilter<"AnalyticsSnapshot"> | number
    newClients?: IntFilter<"AnalyticsSnapshot"> | number
    churnedClients?: IntFilter<"AnalyticsSnapshot"> | number
    totalRevenue?: IntFilter<"AnalyticsSnapshot"> | number
    metricsJson?: JsonFilter<"AnalyticsSnapshot">
    createdAt?: DateTimeFilter<"AnalyticsSnapshot"> | Date | string
  }, "id" | "snapshotDate">

  export type AnalyticsSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    snapshotDate?: SortOrder
    mrrCents?: SortOrder
    arrCents?: SortOrder
    activeClients?: SortOrder
    newClients?: SortOrder
    churnedClients?: SortOrder
    totalRevenue?: SortOrder
    metricsJson?: SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsSnapshotCountOrderByAggregateInput
    _avg?: AnalyticsSnapshotAvgOrderByAggregateInput
    _max?: AnalyticsSnapshotMaxOrderByAggregateInput
    _min?: AnalyticsSnapshotMinOrderByAggregateInput
    _sum?: AnalyticsSnapshotSumOrderByAggregateInput
  }

  export type AnalyticsSnapshotScalarWhereWithAggregatesInput = {
    AND?: AnalyticsSnapshotScalarWhereWithAggregatesInput | AnalyticsSnapshotScalarWhereWithAggregatesInput[]
    OR?: AnalyticsSnapshotScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsSnapshotScalarWhereWithAggregatesInput | AnalyticsSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsSnapshot"> | string
    snapshotDate?: DateTimeWithAggregatesFilter<"AnalyticsSnapshot"> | Date | string
    mrrCents?: IntWithAggregatesFilter<"AnalyticsSnapshot"> | number
    arrCents?: IntWithAggregatesFilter<"AnalyticsSnapshot"> | number
    activeClients?: IntWithAggregatesFilter<"AnalyticsSnapshot"> | number
    newClients?: IntWithAggregatesFilter<"AnalyticsSnapshot"> | number
    churnedClients?: IntWithAggregatesFilter<"AnalyticsSnapshot"> | number
    totalRevenue?: IntWithAggregatesFilter<"AnalyticsSnapshot"> | number
    metricsJson?: JsonWithAggregatesFilter<"AnalyticsSnapshot">
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsSnapshot"> | Date | string
  }

  export type IncidentWhereInput = {
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    id?: StringFilter<"Incident"> | string
    orgId?: StringFilter<"Incident"> | string
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    title?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    assigneeUserId?: StringNullableFilter<"Incident"> | string | null
    slaResponseDeadline?: DateTimeNullableFilter<"Incident"> | Date | string | null
    slaResolveDeadline?: DateTimeNullableFilter<"Incident"> | Date | string | null
    acknowledgedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assigneeUserId?: SortOrderInput | SortOrder
    slaResponseDeadline?: SortOrderInput | SortOrder
    slaResolveDeadline?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type IncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    orgId?: StringFilter<"Incident"> | string
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    title?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    assigneeUserId?: StringNullableFilter<"Incident"> | string | null
    slaResponseDeadline?: DateTimeNullableFilter<"Incident"> | Date | string | null
    slaResolveDeadline?: DateTimeNullableFilter<"Incident"> | Date | string | null
    acknowledgedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
  }, "id">

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assigneeUserId?: SortOrderInput | SortOrder
    slaResponseDeadline?: SortOrderInput | SortOrder
    slaResolveDeadline?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    OR?: IncidentScalarWhereWithAggregatesInput[]
    NOT?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incident"> | string
    orgId?: StringWithAggregatesFilter<"Incident"> | string
    severity?: EnumIncidentSeverityWithAggregatesFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusWithAggregatesFilter<"Incident"> | $Enums.IncidentStatus
    title?: StringWithAggregatesFilter<"Incident"> | string
    description?: StringWithAggregatesFilter<"Incident"> | string
    assigneeUserId?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    slaResponseDeadline?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    slaResolveDeadline?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
  }

  export type InvoiceLineWhereInput = {
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    id?: StringFilter<"InvoiceLine"> | string
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    lineType?: EnumInvoiceLineTypeFilter<"InvoiceLine"> | $Enums.InvoiceLineType
    quantity?: IntFilter<"InvoiceLine"> | number
    unitPriceCents?: IntFilter<"InvoiceLine"> | number
    amountCents?: IntFilter<"InvoiceLine"> | number
    sourceType?: StringNullableFilter<"InvoiceLine"> | string | null
    sourceId?: StringNullableFilter<"InvoiceLine"> | string | null
    createdAt?: DateTimeFilter<"InvoiceLine"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceLineOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    lineType?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
    sourceType?: SortOrderInput | SortOrder
    sourceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    lineType?: EnumInvoiceLineTypeFilter<"InvoiceLine"> | $Enums.InvoiceLineType
    quantity?: IntFilter<"InvoiceLine"> | number
    unitPriceCents?: IntFilter<"InvoiceLine"> | number
    amountCents?: IntFilter<"InvoiceLine"> | number
    sourceType?: StringNullableFilter<"InvoiceLine"> | string | null
    sourceId?: StringNullableFilter<"InvoiceLine"> | string | null
    createdAt?: DateTimeFilter<"InvoiceLine"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceLineOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    lineType?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
    sourceType?: SortOrderInput | SortOrder
    sourceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InvoiceLineCountOrderByAggregateInput
    _avg?: InvoiceLineAvgOrderByAggregateInput
    _max?: InvoiceLineMaxOrderByAggregateInput
    _min?: InvoiceLineMinOrderByAggregateInput
    _sum?: InvoiceLineSumOrderByAggregateInput
  }

  export type InvoiceLineScalarWhereWithAggregatesInput = {
    AND?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    OR?: InvoiceLineScalarWhereWithAggregatesInput[]
    NOT?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceLine"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceLine"> | string
    description?: StringWithAggregatesFilter<"InvoiceLine"> | string
    lineType?: EnumInvoiceLineTypeWithAggregatesFilter<"InvoiceLine"> | $Enums.InvoiceLineType
    quantity?: IntWithAggregatesFilter<"InvoiceLine"> | number
    unitPriceCents?: IntWithAggregatesFilter<"InvoiceLine"> | number
    amountCents?: IntWithAggregatesFilter<"InvoiceLine"> | number
    sourceType?: StringNullableWithAggregatesFilter<"InvoiceLine"> | string | null
    sourceId?: StringNullableWithAggregatesFilter<"InvoiceLine"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceLine"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    orgId?: StringNullableFilter<"Notification"> | string | null
    audience?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    severity?: StringFilter<"Notification"> | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    org?: XOR<OrgNullableScalarRelationFilter, OrgWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrderInput | SortOrder
    audience?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    severity?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    org?: OrgOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    orgId?: StringNullableFilter<"Notification"> | string | null
    audience?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    severity?: StringFilter<"Notification"> | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    org?: XOR<OrgNullableScalarRelationFilter, OrgWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrderInput | SortOrder
    audience?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    severity?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    orgId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    audience?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    severity?: StringWithAggregatesFilter<"Notification"> | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PricePlanWhereInput = {
    AND?: PricePlanWhereInput | PricePlanWhereInput[]
    OR?: PricePlanWhereInput[]
    NOT?: PricePlanWhereInput | PricePlanWhereInput[]
    id?: StringFilter<"PricePlan"> | string
    key?: StringFilter<"PricePlan"> | string
    name?: StringFilter<"PricePlan"> | string
    description?: StringNullableFilter<"PricePlan"> | string | null
    active?: BoolFilter<"PricePlan"> | boolean
    createdAt?: DateTimeFilter<"PricePlan"> | Date | string
    updatedAt?: DateTimeFilter<"PricePlan"> | Date | string
    prices?: PlanPriceListRelationFilter
    offers?: OfferListRelationFilter
    overrides?: TenantPriceOverrideListRelationFilter
    asDefaultFor?: GlobalMonetizationConfigListRelationFilter
    invites?: OnboardingInviteListRelationFilter
  }

  export type PricePlanOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prices?: PlanPriceOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
    overrides?: TenantPriceOverrideOrderByRelationAggregateInput
    asDefaultFor?: GlobalMonetizationConfigOrderByRelationAggregateInput
    invites?: OnboardingInviteOrderByRelationAggregateInput
  }

  export type PricePlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: PricePlanWhereInput | PricePlanWhereInput[]
    OR?: PricePlanWhereInput[]
    NOT?: PricePlanWhereInput | PricePlanWhereInput[]
    name?: StringFilter<"PricePlan"> | string
    description?: StringNullableFilter<"PricePlan"> | string | null
    active?: BoolFilter<"PricePlan"> | boolean
    createdAt?: DateTimeFilter<"PricePlan"> | Date | string
    updatedAt?: DateTimeFilter<"PricePlan"> | Date | string
    prices?: PlanPriceListRelationFilter
    offers?: OfferListRelationFilter
    overrides?: TenantPriceOverrideListRelationFilter
    asDefaultFor?: GlobalMonetizationConfigListRelationFilter
    invites?: OnboardingInviteListRelationFilter
  }, "id" | "key">

  export type PricePlanOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PricePlanCountOrderByAggregateInput
    _max?: PricePlanMaxOrderByAggregateInput
    _min?: PricePlanMinOrderByAggregateInput
  }

  export type PricePlanScalarWhereWithAggregatesInput = {
    AND?: PricePlanScalarWhereWithAggregatesInput | PricePlanScalarWhereWithAggregatesInput[]
    OR?: PricePlanScalarWhereWithAggregatesInput[]
    NOT?: PricePlanScalarWhereWithAggregatesInput | PricePlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PricePlan"> | string
    key?: StringWithAggregatesFilter<"PricePlan"> | string
    name?: StringWithAggregatesFilter<"PricePlan"> | string
    description?: StringNullableWithAggregatesFilter<"PricePlan"> | string | null
    active?: BoolWithAggregatesFilter<"PricePlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PricePlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PricePlan"> | Date | string
  }

  export type PlanPriceWhereInput = {
    AND?: PlanPriceWhereInput | PlanPriceWhereInput[]
    OR?: PlanPriceWhereInput[]
    NOT?: PlanPriceWhereInput | PlanPriceWhereInput[]
    id?: StringFilter<"PlanPrice"> | string
    planId?: StringFilter<"PlanPrice"> | string
    currency?: StringFilter<"PlanPrice"> | string
    unitAmountCents?: IntFilter<"PlanPrice"> | number
    cadence?: EnumBillingCadenceFilter<"PlanPrice"> | $Enums.BillingCadence
    trialDays?: IntNullableFilter<"PlanPrice"> | number | null
    active?: BoolFilter<"PlanPrice"> | boolean
    stripePriceId?: StringNullableFilter<"PlanPrice"> | string | null
    createdAt?: DateTimeFilter<"PlanPrice"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPrice"> | Date | string
    overrides?: TenantPriceOverrideListRelationFilter
    asDefaultFor?: GlobalMonetizationConfigListRelationFilter
    invites?: OnboardingInviteListRelationFilter
    plan?: XOR<PricePlanScalarRelationFilter, PricePlanWhereInput>
  }

  export type PlanPriceOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    unitAmountCents?: SortOrder
    cadence?: SortOrder
    trialDays?: SortOrderInput | SortOrder
    active?: SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    overrides?: TenantPriceOverrideOrderByRelationAggregateInput
    asDefaultFor?: GlobalMonetizationConfigOrderByRelationAggregateInput
    invites?: OnboardingInviteOrderByRelationAggregateInput
    plan?: PricePlanOrderByWithRelationInput
  }

  export type PlanPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanPriceWhereInput | PlanPriceWhereInput[]
    OR?: PlanPriceWhereInput[]
    NOT?: PlanPriceWhereInput | PlanPriceWhereInput[]
    planId?: StringFilter<"PlanPrice"> | string
    currency?: StringFilter<"PlanPrice"> | string
    unitAmountCents?: IntFilter<"PlanPrice"> | number
    cadence?: EnumBillingCadenceFilter<"PlanPrice"> | $Enums.BillingCadence
    trialDays?: IntNullableFilter<"PlanPrice"> | number | null
    active?: BoolFilter<"PlanPrice"> | boolean
    stripePriceId?: StringNullableFilter<"PlanPrice"> | string | null
    createdAt?: DateTimeFilter<"PlanPrice"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPrice"> | Date | string
    overrides?: TenantPriceOverrideListRelationFilter
    asDefaultFor?: GlobalMonetizationConfigListRelationFilter
    invites?: OnboardingInviteListRelationFilter
    plan?: XOR<PricePlanScalarRelationFilter, PricePlanWhereInput>
  }, "id">

  export type PlanPriceOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    unitAmountCents?: SortOrder
    cadence?: SortOrder
    trialDays?: SortOrderInput | SortOrder
    active?: SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanPriceCountOrderByAggregateInput
    _avg?: PlanPriceAvgOrderByAggregateInput
    _max?: PlanPriceMaxOrderByAggregateInput
    _min?: PlanPriceMinOrderByAggregateInput
    _sum?: PlanPriceSumOrderByAggregateInput
  }

  export type PlanPriceScalarWhereWithAggregatesInput = {
    AND?: PlanPriceScalarWhereWithAggregatesInput | PlanPriceScalarWhereWithAggregatesInput[]
    OR?: PlanPriceScalarWhereWithAggregatesInput[]
    NOT?: PlanPriceScalarWhereWithAggregatesInput | PlanPriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanPrice"> | string
    planId?: StringWithAggregatesFilter<"PlanPrice"> | string
    currency?: StringWithAggregatesFilter<"PlanPrice"> | string
    unitAmountCents?: IntWithAggregatesFilter<"PlanPrice"> | number
    cadence?: EnumBillingCadenceWithAggregatesFilter<"PlanPrice"> | $Enums.BillingCadence
    trialDays?: IntNullableWithAggregatesFilter<"PlanPrice"> | number | null
    active?: BoolWithAggregatesFilter<"PlanPrice"> | boolean
    stripePriceId?: StringNullableWithAggregatesFilter<"PlanPrice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlanPrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanPrice"> | Date | string
  }

  export type OfferWhereInput = {
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    id?: StringFilter<"Offer"> | string
    name?: StringFilter<"Offer"> | string
    percentOff?: IntNullableFilter<"Offer"> | number | null
    amountOffCents?: IntNullableFilter<"Offer"> | number | null
    duration?: StringNullableFilter<"Offer"> | string | null
    durationMonths?: IntNullableFilter<"Offer"> | number | null
    appliesToPlanId?: StringNullableFilter<"Offer"> | string | null
    startsAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    active?: BoolFilter<"Offer"> | boolean
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    appliesToPlan?: XOR<PricePlanNullableScalarRelationFilter, PricePlanWhereInput> | null
    invites?: OnboardingInviteListRelationFilter
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    percentOff?: SortOrderInput | SortOrder
    amountOffCents?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    durationMonths?: SortOrderInput | SortOrder
    appliesToPlanId?: SortOrderInput | SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appliesToPlan?: PricePlanOrderByWithRelationInput
    invites?: OnboardingInviteOrderByRelationAggregateInput
  }

  export type OfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    name?: StringFilter<"Offer"> | string
    percentOff?: IntNullableFilter<"Offer"> | number | null
    amountOffCents?: IntNullableFilter<"Offer"> | number | null
    duration?: StringNullableFilter<"Offer"> | string | null
    durationMonths?: IntNullableFilter<"Offer"> | number | null
    appliesToPlanId?: StringNullableFilter<"Offer"> | string | null
    startsAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    active?: BoolFilter<"Offer"> | boolean
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    appliesToPlan?: XOR<PricePlanNullableScalarRelationFilter, PricePlanWhereInput> | null
    invites?: OnboardingInviteListRelationFilter
  }, "id">

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    percentOff?: SortOrderInput | SortOrder
    amountOffCents?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    durationMonths?: SortOrderInput | SortOrder
    appliesToPlanId?: SortOrderInput | SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    OR?: OfferScalarWhereWithAggregatesInput[]
    NOT?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Offer"> | string
    name?: StringWithAggregatesFilter<"Offer"> | string
    percentOff?: IntNullableWithAggregatesFilter<"Offer"> | number | null
    amountOffCents?: IntNullableWithAggregatesFilter<"Offer"> | number | null
    duration?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    durationMonths?: IntNullableWithAggregatesFilter<"Offer"> | number | null
    appliesToPlanId?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    startsAt?: DateTimeNullableWithAggregatesFilter<"Offer"> | Date | string | null
    endsAt?: DateTimeNullableWithAggregatesFilter<"Offer"> | Date | string | null
    active?: BoolWithAggregatesFilter<"Offer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    name?: StringNullableFilter<"Coupon"> | string | null
    percentOff?: IntNullableFilter<"Coupon"> | number | null
    amountOffCents?: IntNullableFilter<"Coupon"> | number | null
    duration?: StringNullableFilter<"Coupon"> | string | null
    durationMonths?: IntNullableFilter<"Coupon"> | number | null
    startsAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    maxRedemptions?: IntNullableFilter<"Coupon"> | number | null
    active?: BoolFilter<"Coupon"> | boolean
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    invites?: OnboardingInviteListRelationFilter
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    percentOff?: SortOrderInput | SortOrder
    amountOffCents?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    durationMonths?: SortOrderInput | SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    maxRedemptions?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invites?: OnboardingInviteOrderByRelationAggregateInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    name?: StringNullableFilter<"Coupon"> | string | null
    percentOff?: IntNullableFilter<"Coupon"> | number | null
    amountOffCents?: IntNullableFilter<"Coupon"> | number | null
    duration?: StringNullableFilter<"Coupon"> | string | null
    durationMonths?: IntNullableFilter<"Coupon"> | number | null
    startsAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    maxRedemptions?: IntNullableFilter<"Coupon"> | number | null
    active?: BoolFilter<"Coupon"> | boolean
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    invites?: OnboardingInviteListRelationFilter
  }, "id" | "code">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    percentOff?: SortOrderInput | SortOrder
    amountOffCents?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    durationMonths?: SortOrderInput | SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    maxRedemptions?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coupon"> | string
    code?: StringWithAggregatesFilter<"Coupon"> | string
    name?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    percentOff?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    amountOffCents?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    duration?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    durationMonths?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    startsAt?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    endsAt?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    maxRedemptions?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    active?: BoolWithAggregatesFilter<"Coupon"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type TenantPriceOverrideWhereInput = {
    AND?: TenantPriceOverrideWhereInput | TenantPriceOverrideWhereInput[]
    OR?: TenantPriceOverrideWhereInput[]
    NOT?: TenantPriceOverrideWhereInput | TenantPriceOverrideWhereInput[]
    id?: StringFilter<"TenantPriceOverride"> | string
    orgId?: StringFilter<"TenantPriceOverride"> | string
    planId?: StringNullableFilter<"TenantPriceOverride"> | string | null
    priceId?: StringNullableFilter<"TenantPriceOverride"> | string | null
    type?: EnumOverrideTypeFilter<"TenantPriceOverride"> | $Enums.OverrideType
    percentOff?: IntNullableFilter<"TenantPriceOverride"> | number | null
    amountOffCents?: IntNullableFilter<"TenantPriceOverride"> | number | null
    priceCents?: IntNullableFilter<"TenantPriceOverride"> | number | null
    startsAt?: DateTimeNullableFilter<"TenantPriceOverride"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"TenantPriceOverride"> | Date | string | null
    reason?: StringNullableFilter<"TenantPriceOverride"> | string | null
    createdAt?: DateTimeFilter<"TenantPriceOverride"> | Date | string
    updatedAt?: DateTimeFilter<"TenantPriceOverride"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    plan?: XOR<PricePlanNullableScalarRelationFilter, PricePlanWhereInput> | null
    price?: XOR<PlanPriceNullableScalarRelationFilter, PlanPriceWhereInput> | null
  }

  export type TenantPriceOverrideOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    planId?: SortOrderInput | SortOrder
    priceId?: SortOrderInput | SortOrder
    type?: SortOrder
    percentOff?: SortOrderInput | SortOrder
    amountOffCents?: SortOrderInput | SortOrder
    priceCents?: SortOrderInput | SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    org?: OrgOrderByWithRelationInput
    plan?: PricePlanOrderByWithRelationInput
    price?: PlanPriceOrderByWithRelationInput
  }

  export type TenantPriceOverrideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantPriceOverrideWhereInput | TenantPriceOverrideWhereInput[]
    OR?: TenantPriceOverrideWhereInput[]
    NOT?: TenantPriceOverrideWhereInput | TenantPriceOverrideWhereInput[]
    orgId?: StringFilter<"TenantPriceOverride"> | string
    planId?: StringNullableFilter<"TenantPriceOverride"> | string | null
    priceId?: StringNullableFilter<"TenantPriceOverride"> | string | null
    type?: EnumOverrideTypeFilter<"TenantPriceOverride"> | $Enums.OverrideType
    percentOff?: IntNullableFilter<"TenantPriceOverride"> | number | null
    amountOffCents?: IntNullableFilter<"TenantPriceOverride"> | number | null
    priceCents?: IntNullableFilter<"TenantPriceOverride"> | number | null
    startsAt?: DateTimeNullableFilter<"TenantPriceOverride"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"TenantPriceOverride"> | Date | string | null
    reason?: StringNullableFilter<"TenantPriceOverride"> | string | null
    createdAt?: DateTimeFilter<"TenantPriceOverride"> | Date | string
    updatedAt?: DateTimeFilter<"TenantPriceOverride"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    plan?: XOR<PricePlanNullableScalarRelationFilter, PricePlanWhereInput> | null
    price?: XOR<PlanPriceNullableScalarRelationFilter, PlanPriceWhereInput> | null
  }, "id">

  export type TenantPriceOverrideOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    planId?: SortOrderInput | SortOrder
    priceId?: SortOrderInput | SortOrder
    type?: SortOrder
    percentOff?: SortOrderInput | SortOrder
    amountOffCents?: SortOrderInput | SortOrder
    priceCents?: SortOrderInput | SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantPriceOverrideCountOrderByAggregateInput
    _avg?: TenantPriceOverrideAvgOrderByAggregateInput
    _max?: TenantPriceOverrideMaxOrderByAggregateInput
    _min?: TenantPriceOverrideMinOrderByAggregateInput
    _sum?: TenantPriceOverrideSumOrderByAggregateInput
  }

  export type TenantPriceOverrideScalarWhereWithAggregatesInput = {
    AND?: TenantPriceOverrideScalarWhereWithAggregatesInput | TenantPriceOverrideScalarWhereWithAggregatesInput[]
    OR?: TenantPriceOverrideScalarWhereWithAggregatesInput[]
    NOT?: TenantPriceOverrideScalarWhereWithAggregatesInput | TenantPriceOverrideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantPriceOverride"> | string
    orgId?: StringWithAggregatesFilter<"TenantPriceOverride"> | string
    planId?: StringNullableWithAggregatesFilter<"TenantPriceOverride"> | string | null
    priceId?: StringNullableWithAggregatesFilter<"TenantPriceOverride"> | string | null
    type?: EnumOverrideTypeWithAggregatesFilter<"TenantPriceOverride"> | $Enums.OverrideType
    percentOff?: IntNullableWithAggregatesFilter<"TenantPriceOverride"> | number | null
    amountOffCents?: IntNullableWithAggregatesFilter<"TenantPriceOverride"> | number | null
    priceCents?: IntNullableWithAggregatesFilter<"TenantPriceOverride"> | number | null
    startsAt?: DateTimeNullableWithAggregatesFilter<"TenantPriceOverride"> | Date | string | null
    endsAt?: DateTimeNullableWithAggregatesFilter<"TenantPriceOverride"> | Date | string | null
    reason?: StringNullableWithAggregatesFilter<"TenantPriceOverride"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantPriceOverride"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantPriceOverride"> | Date | string
  }

  export type GlobalMonetizationConfigWhereInput = {
    AND?: GlobalMonetizationConfigWhereInput | GlobalMonetizationConfigWhereInput[]
    OR?: GlobalMonetizationConfigWhereInput[]
    NOT?: GlobalMonetizationConfigWhereInput | GlobalMonetizationConfigWhereInput[]
    id?: StringFilter<"GlobalMonetizationConfig"> | string
    defaultPlanId?: StringNullableFilter<"GlobalMonetizationConfig"> | string | null
    defaultPriceId?: StringNullableFilter<"GlobalMonetizationConfig"> | string | null
    defaultTrialDays?: IntNullableFilter<"GlobalMonetizationConfig"> | number | null
    publicOnboarding?: BoolFilter<"GlobalMonetizationConfig"> | boolean
    createdAt?: DateTimeFilter<"GlobalMonetizationConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalMonetizationConfig"> | Date | string
    defaultPlan?: XOR<PricePlanNullableScalarRelationFilter, PricePlanWhereInput> | null
    defaultPrice?: XOR<PlanPriceNullableScalarRelationFilter, PlanPriceWhereInput> | null
  }

  export type GlobalMonetizationConfigOrderByWithRelationInput = {
    id?: SortOrder
    defaultPlanId?: SortOrderInput | SortOrder
    defaultPriceId?: SortOrderInput | SortOrder
    defaultTrialDays?: SortOrderInput | SortOrder
    publicOnboarding?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaultPlan?: PricePlanOrderByWithRelationInput
    defaultPrice?: PlanPriceOrderByWithRelationInput
  }

  export type GlobalMonetizationConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GlobalMonetizationConfigWhereInput | GlobalMonetizationConfigWhereInput[]
    OR?: GlobalMonetizationConfigWhereInput[]
    NOT?: GlobalMonetizationConfigWhereInput | GlobalMonetizationConfigWhereInput[]
    defaultPlanId?: StringNullableFilter<"GlobalMonetizationConfig"> | string | null
    defaultPriceId?: StringNullableFilter<"GlobalMonetizationConfig"> | string | null
    defaultTrialDays?: IntNullableFilter<"GlobalMonetizationConfig"> | number | null
    publicOnboarding?: BoolFilter<"GlobalMonetizationConfig"> | boolean
    createdAt?: DateTimeFilter<"GlobalMonetizationConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalMonetizationConfig"> | Date | string
    defaultPlan?: XOR<PricePlanNullableScalarRelationFilter, PricePlanWhereInput> | null
    defaultPrice?: XOR<PlanPriceNullableScalarRelationFilter, PlanPriceWhereInput> | null
  }, "id">

  export type GlobalMonetizationConfigOrderByWithAggregationInput = {
    id?: SortOrder
    defaultPlanId?: SortOrderInput | SortOrder
    defaultPriceId?: SortOrderInput | SortOrder
    defaultTrialDays?: SortOrderInput | SortOrder
    publicOnboarding?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GlobalMonetizationConfigCountOrderByAggregateInput
    _avg?: GlobalMonetizationConfigAvgOrderByAggregateInput
    _max?: GlobalMonetizationConfigMaxOrderByAggregateInput
    _min?: GlobalMonetizationConfigMinOrderByAggregateInput
    _sum?: GlobalMonetizationConfigSumOrderByAggregateInput
  }

  export type GlobalMonetizationConfigScalarWhereWithAggregatesInput = {
    AND?: GlobalMonetizationConfigScalarWhereWithAggregatesInput | GlobalMonetizationConfigScalarWhereWithAggregatesInput[]
    OR?: GlobalMonetizationConfigScalarWhereWithAggregatesInput[]
    NOT?: GlobalMonetizationConfigScalarWhereWithAggregatesInput | GlobalMonetizationConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GlobalMonetizationConfig"> | string
    defaultPlanId?: StringNullableWithAggregatesFilter<"GlobalMonetizationConfig"> | string | null
    defaultPriceId?: StringNullableWithAggregatesFilter<"GlobalMonetizationConfig"> | string | null
    defaultTrialDays?: IntNullableWithAggregatesFilter<"GlobalMonetizationConfig"> | number | null
    publicOnboarding?: BoolWithAggregatesFilter<"GlobalMonetizationConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GlobalMonetizationConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GlobalMonetizationConfig"> | Date | string
  }

  export type OnboardingInviteWhereInput = {
    AND?: OnboardingInviteWhereInput | OnboardingInviteWhereInput[]
    OR?: OnboardingInviteWhereInput[]
    NOT?: OnboardingInviteWhereInput | OnboardingInviteWhereInput[]
    id?: StringFilter<"OnboardingInvite"> | string
    token?: StringFilter<"OnboardingInvite"> | string
    email?: StringNullableFilter<"OnboardingInvite"> | string | null
    planId?: StringNullableFilter<"OnboardingInvite"> | string | null
    priceId?: StringNullableFilter<"OnboardingInvite"> | string | null
    offerId?: StringNullableFilter<"OnboardingInvite"> | string | null
    couponId?: StringNullableFilter<"OnboardingInvite"> | string | null
    trialDays?: IntNullableFilter<"OnboardingInvite"> | number | null
    expiresAt?: DateTimeFilter<"OnboardingInvite"> | Date | string
    usedAt?: DateTimeNullableFilter<"OnboardingInvite"> | Date | string | null
    note?: StringNullableFilter<"OnboardingInvite"> | string | null
    createdAt?: DateTimeFilter<"OnboardingInvite"> | Date | string
    plan?: XOR<PricePlanNullableScalarRelationFilter, PricePlanWhereInput> | null
    price?: XOR<PlanPriceNullableScalarRelationFilter, PlanPriceWhereInput> | null
    offer?: XOR<OfferNullableScalarRelationFilter, OfferWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null
  }

  export type OnboardingInviteOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    priceId?: SortOrderInput | SortOrder
    offerId?: SortOrderInput | SortOrder
    couponId?: SortOrderInput | SortOrder
    trialDays?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    plan?: PricePlanOrderByWithRelationInput
    price?: PlanPriceOrderByWithRelationInput
    offer?: OfferOrderByWithRelationInput
    coupon?: CouponOrderByWithRelationInput
  }

  export type OnboardingInviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: OnboardingInviteWhereInput | OnboardingInviteWhereInput[]
    OR?: OnboardingInviteWhereInput[]
    NOT?: OnboardingInviteWhereInput | OnboardingInviteWhereInput[]
    email?: StringNullableFilter<"OnboardingInvite"> | string | null
    planId?: StringNullableFilter<"OnboardingInvite"> | string | null
    priceId?: StringNullableFilter<"OnboardingInvite"> | string | null
    offerId?: StringNullableFilter<"OnboardingInvite"> | string | null
    couponId?: StringNullableFilter<"OnboardingInvite"> | string | null
    trialDays?: IntNullableFilter<"OnboardingInvite"> | number | null
    expiresAt?: DateTimeFilter<"OnboardingInvite"> | Date | string
    usedAt?: DateTimeNullableFilter<"OnboardingInvite"> | Date | string | null
    note?: StringNullableFilter<"OnboardingInvite"> | string | null
    createdAt?: DateTimeFilter<"OnboardingInvite"> | Date | string
    plan?: XOR<PricePlanNullableScalarRelationFilter, PricePlanWhereInput> | null
    price?: XOR<PlanPriceNullableScalarRelationFilter, PlanPriceWhereInput> | null
    offer?: XOR<OfferNullableScalarRelationFilter, OfferWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null
  }, "id" | "token">

  export type OnboardingInviteOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    priceId?: SortOrderInput | SortOrder
    offerId?: SortOrderInput | SortOrder
    couponId?: SortOrderInput | SortOrder
    trialDays?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OnboardingInviteCountOrderByAggregateInput
    _avg?: OnboardingInviteAvgOrderByAggregateInput
    _max?: OnboardingInviteMaxOrderByAggregateInput
    _min?: OnboardingInviteMinOrderByAggregateInput
    _sum?: OnboardingInviteSumOrderByAggregateInput
  }

  export type OnboardingInviteScalarWhereWithAggregatesInput = {
    AND?: OnboardingInviteScalarWhereWithAggregatesInput | OnboardingInviteScalarWhereWithAggregatesInput[]
    OR?: OnboardingInviteScalarWhereWithAggregatesInput[]
    NOT?: OnboardingInviteScalarWhereWithAggregatesInput | OnboardingInviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OnboardingInvite"> | string
    token?: StringWithAggregatesFilter<"OnboardingInvite"> | string
    email?: StringNullableWithAggregatesFilter<"OnboardingInvite"> | string | null
    planId?: StringNullableWithAggregatesFilter<"OnboardingInvite"> | string | null
    priceId?: StringNullableWithAggregatesFilter<"OnboardingInvite"> | string | null
    offerId?: StringNullableWithAggregatesFilter<"OnboardingInvite"> | string | null
    couponId?: StringNullableWithAggregatesFilter<"OnboardingInvite"> | string | null
    trialDays?: IntNullableWithAggregatesFilter<"OnboardingInvite"> | number | null
    expiresAt?: DateTimeWithAggregatesFilter<"OnboardingInvite"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"OnboardingInvite"> | Date | string | null
    note?: StringNullableWithAggregatesFilter<"OnboardingInvite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OnboardingInvite"> | Date | string
  }

  export type InfrastructureMetricWhereInput = {
    AND?: InfrastructureMetricWhereInput | InfrastructureMetricWhereInput[]
    OR?: InfrastructureMetricWhereInput[]
    NOT?: InfrastructureMetricWhereInput | InfrastructureMetricWhereInput[]
    id?: StringFilter<"InfrastructureMetric"> | string
    service?: EnumInfrastructureServiceFilter<"InfrastructureMetric"> | $Enums.InfrastructureService
    metric?: EnumMetricTypeFilter<"InfrastructureMetric"> | $Enums.MetricType
    value?: FloatFilter<"InfrastructureMetric"> | number
    timestamp?: DateTimeFilter<"InfrastructureMetric"> | Date | string
    metadata?: JsonNullableFilter<"InfrastructureMetric">
  }

  export type InfrastructureMetricOrderByWithRelationInput = {
    id?: SortOrder
    service?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type InfrastructureMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InfrastructureMetricWhereInput | InfrastructureMetricWhereInput[]
    OR?: InfrastructureMetricWhereInput[]
    NOT?: InfrastructureMetricWhereInput | InfrastructureMetricWhereInput[]
    service?: EnumInfrastructureServiceFilter<"InfrastructureMetric"> | $Enums.InfrastructureService
    metric?: EnumMetricTypeFilter<"InfrastructureMetric"> | $Enums.MetricType
    value?: FloatFilter<"InfrastructureMetric"> | number
    timestamp?: DateTimeFilter<"InfrastructureMetric"> | Date | string
    metadata?: JsonNullableFilter<"InfrastructureMetric">
  }, "id">

  export type InfrastructureMetricOrderByWithAggregationInput = {
    id?: SortOrder
    service?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: InfrastructureMetricCountOrderByAggregateInput
    _avg?: InfrastructureMetricAvgOrderByAggregateInput
    _max?: InfrastructureMetricMaxOrderByAggregateInput
    _min?: InfrastructureMetricMinOrderByAggregateInput
    _sum?: InfrastructureMetricSumOrderByAggregateInput
  }

  export type InfrastructureMetricScalarWhereWithAggregatesInput = {
    AND?: InfrastructureMetricScalarWhereWithAggregatesInput | InfrastructureMetricScalarWhereWithAggregatesInput[]
    OR?: InfrastructureMetricScalarWhereWithAggregatesInput[]
    NOT?: InfrastructureMetricScalarWhereWithAggregatesInput | InfrastructureMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InfrastructureMetric"> | string
    service?: EnumInfrastructureServiceWithAggregatesFilter<"InfrastructureMetric"> | $Enums.InfrastructureService
    metric?: EnumMetricTypeWithAggregatesFilter<"InfrastructureMetric"> | $Enums.MetricType
    value?: FloatWithAggregatesFilter<"InfrastructureMetric"> | number
    timestamp?: DateTimeWithAggregatesFilter<"InfrastructureMetric"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"InfrastructureMetric">
  }

  export type InfrastructureLimitWhereInput = {
    AND?: InfrastructureLimitWhereInput | InfrastructureLimitWhereInput[]
    OR?: InfrastructureLimitWhereInput[]
    NOT?: InfrastructureLimitWhereInput | InfrastructureLimitWhereInput[]
    id?: StringFilter<"InfrastructureLimit"> | string
    service?: EnumInfrastructureServiceFilter<"InfrastructureLimit"> | $Enums.InfrastructureService
    metric?: EnumMetricTypeFilter<"InfrastructureLimit"> | $Enums.MetricType
    currentPlan?: StringFilter<"InfrastructureLimit"> | string
    limitValue?: FloatFilter<"InfrastructureLimit"> | number
    warningPercent?: FloatFilter<"InfrastructureLimit"> | number
    criticalPercent?: FloatFilter<"InfrastructureLimit"> | number
    createdAt?: DateTimeFilter<"InfrastructureLimit"> | Date | string
    updatedAt?: DateTimeFilter<"InfrastructureLimit"> | Date | string
  }

  export type InfrastructureLimitOrderByWithRelationInput = {
    id?: SortOrder
    service?: SortOrder
    metric?: SortOrder
    currentPlan?: SortOrder
    limitValue?: SortOrder
    warningPercent?: SortOrder
    criticalPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfrastructureLimitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    service_metric_currentPlan?: InfrastructureLimitServiceMetricCurrentPlanCompoundUniqueInput
    AND?: InfrastructureLimitWhereInput | InfrastructureLimitWhereInput[]
    OR?: InfrastructureLimitWhereInput[]
    NOT?: InfrastructureLimitWhereInput | InfrastructureLimitWhereInput[]
    service?: EnumInfrastructureServiceFilter<"InfrastructureLimit"> | $Enums.InfrastructureService
    metric?: EnumMetricTypeFilter<"InfrastructureLimit"> | $Enums.MetricType
    currentPlan?: StringFilter<"InfrastructureLimit"> | string
    limitValue?: FloatFilter<"InfrastructureLimit"> | number
    warningPercent?: FloatFilter<"InfrastructureLimit"> | number
    criticalPercent?: FloatFilter<"InfrastructureLimit"> | number
    createdAt?: DateTimeFilter<"InfrastructureLimit"> | Date | string
    updatedAt?: DateTimeFilter<"InfrastructureLimit"> | Date | string
  }, "id" | "service_metric_currentPlan">

  export type InfrastructureLimitOrderByWithAggregationInput = {
    id?: SortOrder
    service?: SortOrder
    metric?: SortOrder
    currentPlan?: SortOrder
    limitValue?: SortOrder
    warningPercent?: SortOrder
    criticalPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InfrastructureLimitCountOrderByAggregateInput
    _avg?: InfrastructureLimitAvgOrderByAggregateInput
    _max?: InfrastructureLimitMaxOrderByAggregateInput
    _min?: InfrastructureLimitMinOrderByAggregateInput
    _sum?: InfrastructureLimitSumOrderByAggregateInput
  }

  export type InfrastructureLimitScalarWhereWithAggregatesInput = {
    AND?: InfrastructureLimitScalarWhereWithAggregatesInput | InfrastructureLimitScalarWhereWithAggregatesInput[]
    OR?: InfrastructureLimitScalarWhereWithAggregatesInput[]
    NOT?: InfrastructureLimitScalarWhereWithAggregatesInput | InfrastructureLimitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InfrastructureLimit"> | string
    service?: EnumInfrastructureServiceWithAggregatesFilter<"InfrastructureLimit"> | $Enums.InfrastructureService
    metric?: EnumMetricTypeWithAggregatesFilter<"InfrastructureLimit"> | $Enums.MetricType
    currentPlan?: StringWithAggregatesFilter<"InfrastructureLimit"> | string
    limitValue?: FloatWithAggregatesFilter<"InfrastructureLimit"> | number
    warningPercent?: FloatWithAggregatesFilter<"InfrastructureLimit"> | number
    criticalPercent?: FloatWithAggregatesFilter<"InfrastructureLimit"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InfrastructureLimit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InfrastructureLimit"> | Date | string
  }

  export type ImportJobWhereInput = {
    AND?: ImportJobWhereInput | ImportJobWhereInput[]
    OR?: ImportJobWhereInput[]
    NOT?: ImportJobWhereInput | ImportJobWhereInput[]
    id?: StringFilter<"ImportJob"> | string
    orgId?: StringFilter<"ImportJob"> | string
    userId?: StringFilter<"ImportJob"> | string
    entityType?: EnumImportEntityTypeFilter<"ImportJob"> | $Enums.ImportEntityType
    status?: EnumImportStatusFilter<"ImportJob"> | $Enums.ImportStatus
    fileName?: StringFilter<"ImportJob"> | string
    fileSize?: IntFilter<"ImportJob"> | number
    totalRecords?: IntFilter<"ImportJob"> | number
    processedRecords?: IntFilter<"ImportJob"> | number
    successCount?: IntFilter<"ImportJob"> | number
    errorCount?: IntFilter<"ImportJob"> | number
    skipCount?: IntFilter<"ImportJob"> | number
    mappingId?: StringNullableFilter<"ImportJob"> | string | null
    sampleData?: JsonNullableFilter<"ImportJob">
    fieldMappings?: JsonNullableFilter<"ImportJob">
    transformRules?: JsonNullableFilter<"ImportJob">
    validationRules?: JsonNullableFilter<"ImportJob">
    progressPercent?: IntFilter<"ImportJob"> | number
    startedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    errorSummary?: StringNullableFilter<"ImportJob"> | string | null
    createdAt?: DateTimeFilter<"ImportJob"> | Date | string
    updatedAt?: DateTimeFilter<"ImportJob"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    mapping?: XOR<ImportMappingNullableScalarRelationFilter, ImportMappingWhereInput> | null
    errors?: ImportErrorListRelationFilter
  }

  export type ImportJobOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    totalRecords?: SortOrder
    processedRecords?: SortOrder
    successCount?: SortOrder
    errorCount?: SortOrder
    skipCount?: SortOrder
    mappingId?: SortOrderInput | SortOrder
    sampleData?: SortOrderInput | SortOrder
    fieldMappings?: SortOrderInput | SortOrder
    transformRules?: SortOrderInput | SortOrder
    validationRules?: SortOrderInput | SortOrder
    progressPercent?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorSummary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    org?: OrgOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    mapping?: ImportMappingOrderByWithRelationInput
    errors?: ImportErrorOrderByRelationAggregateInput
  }

  export type ImportJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportJobWhereInput | ImportJobWhereInput[]
    OR?: ImportJobWhereInput[]
    NOT?: ImportJobWhereInput | ImportJobWhereInput[]
    orgId?: StringFilter<"ImportJob"> | string
    userId?: StringFilter<"ImportJob"> | string
    entityType?: EnumImportEntityTypeFilter<"ImportJob"> | $Enums.ImportEntityType
    status?: EnumImportStatusFilter<"ImportJob"> | $Enums.ImportStatus
    fileName?: StringFilter<"ImportJob"> | string
    fileSize?: IntFilter<"ImportJob"> | number
    totalRecords?: IntFilter<"ImportJob"> | number
    processedRecords?: IntFilter<"ImportJob"> | number
    successCount?: IntFilter<"ImportJob"> | number
    errorCount?: IntFilter<"ImportJob"> | number
    skipCount?: IntFilter<"ImportJob"> | number
    mappingId?: StringNullableFilter<"ImportJob"> | string | null
    sampleData?: JsonNullableFilter<"ImportJob">
    fieldMappings?: JsonNullableFilter<"ImportJob">
    transformRules?: JsonNullableFilter<"ImportJob">
    validationRules?: JsonNullableFilter<"ImportJob">
    progressPercent?: IntFilter<"ImportJob"> | number
    startedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    errorSummary?: StringNullableFilter<"ImportJob"> | string | null
    createdAt?: DateTimeFilter<"ImportJob"> | Date | string
    updatedAt?: DateTimeFilter<"ImportJob"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    mapping?: XOR<ImportMappingNullableScalarRelationFilter, ImportMappingWhereInput> | null
    errors?: ImportErrorListRelationFilter
  }, "id">

  export type ImportJobOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    totalRecords?: SortOrder
    processedRecords?: SortOrder
    successCount?: SortOrder
    errorCount?: SortOrder
    skipCount?: SortOrder
    mappingId?: SortOrderInput | SortOrder
    sampleData?: SortOrderInput | SortOrder
    fieldMappings?: SortOrderInput | SortOrder
    transformRules?: SortOrderInput | SortOrder
    validationRules?: SortOrderInput | SortOrder
    progressPercent?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorSummary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImportJobCountOrderByAggregateInput
    _avg?: ImportJobAvgOrderByAggregateInput
    _max?: ImportJobMaxOrderByAggregateInput
    _min?: ImportJobMinOrderByAggregateInput
    _sum?: ImportJobSumOrderByAggregateInput
  }

  export type ImportJobScalarWhereWithAggregatesInput = {
    AND?: ImportJobScalarWhereWithAggregatesInput | ImportJobScalarWhereWithAggregatesInput[]
    OR?: ImportJobScalarWhereWithAggregatesInput[]
    NOT?: ImportJobScalarWhereWithAggregatesInput | ImportJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportJob"> | string
    orgId?: StringWithAggregatesFilter<"ImportJob"> | string
    userId?: StringWithAggregatesFilter<"ImportJob"> | string
    entityType?: EnumImportEntityTypeWithAggregatesFilter<"ImportJob"> | $Enums.ImportEntityType
    status?: EnumImportStatusWithAggregatesFilter<"ImportJob"> | $Enums.ImportStatus
    fileName?: StringWithAggregatesFilter<"ImportJob"> | string
    fileSize?: IntWithAggregatesFilter<"ImportJob"> | number
    totalRecords?: IntWithAggregatesFilter<"ImportJob"> | number
    processedRecords?: IntWithAggregatesFilter<"ImportJob"> | number
    successCount?: IntWithAggregatesFilter<"ImportJob"> | number
    errorCount?: IntWithAggregatesFilter<"ImportJob"> | number
    skipCount?: IntWithAggregatesFilter<"ImportJob"> | number
    mappingId?: StringNullableWithAggregatesFilter<"ImportJob"> | string | null
    sampleData?: JsonNullableWithAggregatesFilter<"ImportJob">
    fieldMappings?: JsonNullableWithAggregatesFilter<"ImportJob">
    transformRules?: JsonNullableWithAggregatesFilter<"ImportJob">
    validationRules?: JsonNullableWithAggregatesFilter<"ImportJob">
    progressPercent?: IntWithAggregatesFilter<"ImportJob"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ImportJob"> | Date | string | null
    errorSummary?: StringNullableWithAggregatesFilter<"ImportJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ImportJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImportJob"> | Date | string
  }

  export type ImportMappingWhereInput = {
    AND?: ImportMappingWhereInput | ImportMappingWhereInput[]
    OR?: ImportMappingWhereInput[]
    NOT?: ImportMappingWhereInput | ImportMappingWhereInput[]
    id?: StringFilter<"ImportMapping"> | string
    orgId?: StringFilter<"ImportMapping"> | string
    name?: StringFilter<"ImportMapping"> | string
    entityType?: EnumImportEntityTypeFilter<"ImportMapping"> | $Enums.ImportEntityType
    sourceFormat?: StringFilter<"ImportMapping"> | string
    fieldMappings?: JsonFilter<"ImportMapping">
    transformRules?: JsonFilter<"ImportMapping">
    validationRules?: JsonFilter<"ImportMapping">
    isTemplate?: BoolFilter<"ImportMapping"> | boolean
    useCount?: IntFilter<"ImportMapping"> | number
    lastUsedAt?: DateTimeNullableFilter<"ImportMapping"> | Date | string | null
    createdAt?: DateTimeFilter<"ImportMapping"> | Date | string
    updatedAt?: DateTimeFilter<"ImportMapping"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    jobs?: ImportJobListRelationFilter
  }

  export type ImportMappingOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    entityType?: SortOrder
    sourceFormat?: SortOrder
    fieldMappings?: SortOrder
    transformRules?: SortOrder
    validationRules?: SortOrder
    isTemplate?: SortOrder
    useCount?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    org?: OrgOrderByWithRelationInput
    jobs?: ImportJobOrderByRelationAggregateInput
  }

  export type ImportMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportMappingWhereInput | ImportMappingWhereInput[]
    OR?: ImportMappingWhereInput[]
    NOT?: ImportMappingWhereInput | ImportMappingWhereInput[]
    orgId?: StringFilter<"ImportMapping"> | string
    name?: StringFilter<"ImportMapping"> | string
    entityType?: EnumImportEntityTypeFilter<"ImportMapping"> | $Enums.ImportEntityType
    sourceFormat?: StringFilter<"ImportMapping"> | string
    fieldMappings?: JsonFilter<"ImportMapping">
    transformRules?: JsonFilter<"ImportMapping">
    validationRules?: JsonFilter<"ImportMapping">
    isTemplate?: BoolFilter<"ImportMapping"> | boolean
    useCount?: IntFilter<"ImportMapping"> | number
    lastUsedAt?: DateTimeNullableFilter<"ImportMapping"> | Date | string | null
    createdAt?: DateTimeFilter<"ImportMapping"> | Date | string
    updatedAt?: DateTimeFilter<"ImportMapping"> | Date | string
    org?: XOR<OrgScalarRelationFilter, OrgWhereInput>
    jobs?: ImportJobListRelationFilter
  }, "id">

  export type ImportMappingOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    entityType?: SortOrder
    sourceFormat?: SortOrder
    fieldMappings?: SortOrder
    transformRules?: SortOrder
    validationRules?: SortOrder
    isTemplate?: SortOrder
    useCount?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImportMappingCountOrderByAggregateInput
    _avg?: ImportMappingAvgOrderByAggregateInput
    _max?: ImportMappingMaxOrderByAggregateInput
    _min?: ImportMappingMinOrderByAggregateInput
    _sum?: ImportMappingSumOrderByAggregateInput
  }

  export type ImportMappingScalarWhereWithAggregatesInput = {
    AND?: ImportMappingScalarWhereWithAggregatesInput | ImportMappingScalarWhereWithAggregatesInput[]
    OR?: ImportMappingScalarWhereWithAggregatesInput[]
    NOT?: ImportMappingScalarWhereWithAggregatesInput | ImportMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportMapping"> | string
    orgId?: StringWithAggregatesFilter<"ImportMapping"> | string
    name?: StringWithAggregatesFilter<"ImportMapping"> | string
    entityType?: EnumImportEntityTypeWithAggregatesFilter<"ImportMapping"> | $Enums.ImportEntityType
    sourceFormat?: StringWithAggregatesFilter<"ImportMapping"> | string
    fieldMappings?: JsonWithAggregatesFilter<"ImportMapping">
    transformRules?: JsonWithAggregatesFilter<"ImportMapping">
    validationRules?: JsonWithAggregatesFilter<"ImportMapping">
    isTemplate?: BoolWithAggregatesFilter<"ImportMapping"> | boolean
    useCount?: IntWithAggregatesFilter<"ImportMapping"> | number
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ImportMapping"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ImportMapping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImportMapping"> | Date | string
  }

  export type ImportErrorWhereInput = {
    AND?: ImportErrorWhereInput | ImportErrorWhereInput[]
    OR?: ImportErrorWhereInput[]
    NOT?: ImportErrorWhereInput | ImportErrorWhereInput[]
    id?: StringFilter<"ImportError"> | string
    importJobId?: StringFilter<"ImportError"> | string
    rowNumber?: IntFilter<"ImportError"> | number
    fieldName?: StringNullableFilter<"ImportError"> | string | null
    errorType?: StringFilter<"ImportError"> | string
    errorMessage?: StringFilter<"ImportError"> | string
    rawData?: JsonNullableFilter<"ImportError">
    createdAt?: DateTimeFilter<"ImportError"> | Date | string
    importJob?: XOR<ImportJobScalarRelationFilter, ImportJobWhereInput>
  }

  export type ImportErrorOrderByWithRelationInput = {
    id?: SortOrder
    importJobId?: SortOrder
    rowNumber?: SortOrder
    fieldName?: SortOrderInput | SortOrder
    errorType?: SortOrder
    errorMessage?: SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    importJob?: ImportJobOrderByWithRelationInput
  }

  export type ImportErrorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportErrorWhereInput | ImportErrorWhereInput[]
    OR?: ImportErrorWhereInput[]
    NOT?: ImportErrorWhereInput | ImportErrorWhereInput[]
    importJobId?: StringFilter<"ImportError"> | string
    rowNumber?: IntFilter<"ImportError"> | number
    fieldName?: StringNullableFilter<"ImportError"> | string | null
    errorType?: StringFilter<"ImportError"> | string
    errorMessage?: StringFilter<"ImportError"> | string
    rawData?: JsonNullableFilter<"ImportError">
    createdAt?: DateTimeFilter<"ImportError"> | Date | string
    importJob?: XOR<ImportJobScalarRelationFilter, ImportJobWhereInput>
  }, "id">

  export type ImportErrorOrderByWithAggregationInput = {
    id?: SortOrder
    importJobId?: SortOrder
    rowNumber?: SortOrder
    fieldName?: SortOrderInput | SortOrder
    errorType?: SortOrder
    errorMessage?: SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ImportErrorCountOrderByAggregateInput
    _avg?: ImportErrorAvgOrderByAggregateInput
    _max?: ImportErrorMaxOrderByAggregateInput
    _min?: ImportErrorMinOrderByAggregateInput
    _sum?: ImportErrorSumOrderByAggregateInput
  }

  export type ImportErrorScalarWhereWithAggregatesInput = {
    AND?: ImportErrorScalarWhereWithAggregatesInput | ImportErrorScalarWhereWithAggregatesInput[]
    OR?: ImportErrorScalarWhereWithAggregatesInput[]
    NOT?: ImportErrorScalarWhereWithAggregatesInput | ImportErrorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportError"> | string
    importJobId?: StringWithAggregatesFilter<"ImportError"> | string
    rowNumber?: IntWithAggregatesFilter<"ImportError"> | number
    fieldName?: StringNullableWithAggregatesFilter<"ImportError"> | string | null
    errorType?: StringWithAggregatesFilter<"ImportError"> | string
    errorMessage?: StringWithAggregatesFilter<"ImportError"> | string
    rawData?: JsonNullableWithAggregatesFilter<"ImportError">
    createdAt?: DateTimeWithAggregatesFilter<"ImportError"> | Date | string
  }

  export type UpgradeRecommendationWhereInput = {
    AND?: UpgradeRecommendationWhereInput | UpgradeRecommendationWhereInput[]
    OR?: UpgradeRecommendationWhereInput[]
    NOT?: UpgradeRecommendationWhereInput | UpgradeRecommendationWhereInput[]
    id?: StringFilter<"UpgradeRecommendation"> | string
    service?: EnumInfrastructureServiceFilter<"UpgradeRecommendation"> | $Enums.InfrastructureService
    currentPlan?: StringFilter<"UpgradeRecommendation"> | string
    recommendedPlan?: StringFilter<"UpgradeRecommendation"> | string
    priority?: EnumRecommendationPriorityFilter<"UpgradeRecommendation"> | $Enums.RecommendationPriority
    status?: EnumRecommendationStatusFilter<"UpgradeRecommendation"> | $Enums.RecommendationStatus
    reason?: StringFilter<"UpgradeRecommendation"> | string
    currentUsage?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    limitValue?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    usagePercent?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    daysToLimit?: IntNullableFilter<"UpgradeRecommendation"> | number | null
    currentCost?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    projectedCost?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    upgradeCost?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    revenueImpact?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    profitImpact?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    roi?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    benefits?: StringNullableFilter<"UpgradeRecommendation"> | string | null
    risks?: StringNullableFilter<"UpgradeRecommendation"> | string | null
    estimatedCostUsd?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    estimatedSavings?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    roiMonths?: IntNullableFilter<"UpgradeRecommendation"> | number | null
    createdAt?: DateTimeFilter<"UpgradeRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"UpgradeRecommendation"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"UpgradeRecommendation"> | Date | string | null
    implementedAt?: DateTimeNullableFilter<"UpgradeRecommendation"> | Date | string | null
  }

  export type UpgradeRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    service?: SortOrder
    currentPlan?: SortOrder
    recommendedPlan?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    currentUsage?: SortOrderInput | SortOrder
    limitValue?: SortOrderInput | SortOrder
    usagePercent?: SortOrderInput | SortOrder
    daysToLimit?: SortOrderInput | SortOrder
    currentCost?: SortOrderInput | SortOrder
    projectedCost?: SortOrderInput | SortOrder
    upgradeCost?: SortOrderInput | SortOrder
    revenueImpact?: SortOrderInput | SortOrder
    profitImpact?: SortOrderInput | SortOrder
    roi?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    risks?: SortOrderInput | SortOrder
    estimatedCostUsd?: SortOrderInput | SortOrder
    estimatedSavings?: SortOrderInput | SortOrder
    roiMonths?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    implementedAt?: SortOrderInput | SortOrder
  }

  export type UpgradeRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UpgradeRecommendationWhereInput | UpgradeRecommendationWhereInput[]
    OR?: UpgradeRecommendationWhereInput[]
    NOT?: UpgradeRecommendationWhereInput | UpgradeRecommendationWhereInput[]
    service?: EnumInfrastructureServiceFilter<"UpgradeRecommendation"> | $Enums.InfrastructureService
    currentPlan?: StringFilter<"UpgradeRecommendation"> | string
    recommendedPlan?: StringFilter<"UpgradeRecommendation"> | string
    priority?: EnumRecommendationPriorityFilter<"UpgradeRecommendation"> | $Enums.RecommendationPriority
    status?: EnumRecommendationStatusFilter<"UpgradeRecommendation"> | $Enums.RecommendationStatus
    reason?: StringFilter<"UpgradeRecommendation"> | string
    currentUsage?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    limitValue?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    usagePercent?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    daysToLimit?: IntNullableFilter<"UpgradeRecommendation"> | number | null
    currentCost?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    projectedCost?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    upgradeCost?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    revenueImpact?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    profitImpact?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    roi?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    benefits?: StringNullableFilter<"UpgradeRecommendation"> | string | null
    risks?: StringNullableFilter<"UpgradeRecommendation"> | string | null
    estimatedCostUsd?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    estimatedSavings?: FloatNullableFilter<"UpgradeRecommendation"> | number | null
    roiMonths?: IntNullableFilter<"UpgradeRecommendation"> | number | null
    createdAt?: DateTimeFilter<"UpgradeRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"UpgradeRecommendation"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"UpgradeRecommendation"> | Date | string | null
    implementedAt?: DateTimeNullableFilter<"UpgradeRecommendation"> | Date | string | null
  }, "id">

  export type UpgradeRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    service?: SortOrder
    currentPlan?: SortOrder
    recommendedPlan?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    currentUsage?: SortOrderInput | SortOrder
    limitValue?: SortOrderInput | SortOrder
    usagePercent?: SortOrderInput | SortOrder
    daysToLimit?: SortOrderInput | SortOrder
    currentCost?: SortOrderInput | SortOrder
    projectedCost?: SortOrderInput | SortOrder
    upgradeCost?: SortOrderInput | SortOrder
    revenueImpact?: SortOrderInput | SortOrder
    profitImpact?: SortOrderInput | SortOrder
    roi?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    risks?: SortOrderInput | SortOrder
    estimatedCostUsd?: SortOrderInput | SortOrder
    estimatedSavings?: SortOrderInput | SortOrder
    roiMonths?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    implementedAt?: SortOrderInput | SortOrder
    _count?: UpgradeRecommendationCountOrderByAggregateInput
    _avg?: UpgradeRecommendationAvgOrderByAggregateInput
    _max?: UpgradeRecommendationMaxOrderByAggregateInput
    _min?: UpgradeRecommendationMinOrderByAggregateInput
    _sum?: UpgradeRecommendationSumOrderByAggregateInput
  }

  export type UpgradeRecommendationScalarWhereWithAggregatesInput = {
    AND?: UpgradeRecommendationScalarWhereWithAggregatesInput | UpgradeRecommendationScalarWhereWithAggregatesInput[]
    OR?: UpgradeRecommendationScalarWhereWithAggregatesInput[]
    NOT?: UpgradeRecommendationScalarWhereWithAggregatesInput | UpgradeRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UpgradeRecommendation"> | string
    service?: EnumInfrastructureServiceWithAggregatesFilter<"UpgradeRecommendation"> | $Enums.InfrastructureService
    currentPlan?: StringWithAggregatesFilter<"UpgradeRecommendation"> | string
    recommendedPlan?: StringWithAggregatesFilter<"UpgradeRecommendation"> | string
    priority?: EnumRecommendationPriorityWithAggregatesFilter<"UpgradeRecommendation"> | $Enums.RecommendationPriority
    status?: EnumRecommendationStatusWithAggregatesFilter<"UpgradeRecommendation"> | $Enums.RecommendationStatus
    reason?: StringWithAggregatesFilter<"UpgradeRecommendation"> | string
    currentUsage?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    limitValue?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    usagePercent?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    daysToLimit?: IntNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    currentCost?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    projectedCost?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    upgradeCost?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    revenueImpact?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    profitImpact?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    roi?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    benefits?: StringNullableWithAggregatesFilter<"UpgradeRecommendation"> | string | null
    risks?: StringNullableWithAggregatesFilter<"UpgradeRecommendation"> | string | null
    estimatedCostUsd?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    estimatedSavings?: FloatNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    roiMonths?: IntNullableWithAggregatesFilter<"UpgradeRecommendation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"UpgradeRecommendation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UpgradeRecommendation"> | Date | string
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"UpgradeRecommendation"> | Date | string | null
    implementedAt?: DateTimeNullableWithAggregatesFilter<"UpgradeRecommendation"> | Date | string | null
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    sessionId?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    email?: StringFilter<"RefreshToken"> | string
    role?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    email?: StringFilter<"RefreshToken"> | string
    role?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }, "id" | "sessionId">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    sessionId?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    email?: StringWithAggregatesFilter<"RefreshToken"> | string
    role?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type OrgCreateInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrgCreateManyInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrgUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrgUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    org: OrgCreateNestedOneWithoutUsersInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintCreateNestedManyWithoutUserInput
    importJobs?: ImportJobCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    orgId: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountUncheckedCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryUncheckedCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedCreateNestedManyWithoutUserInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrgUpdateOneRequiredWithoutUsersNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUncheckedUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    orgId: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRecoveryCodeCreateInput = {
    id?: string
    codeHash: string
    usedAt?: Date | string | null
    usedFrom?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutRecoveryCodesInput
  }

  export type UserRecoveryCodeUncheckedCreateInput = {
    id?: string
    userId: string
    codeHash: string
    usedAt?: Date | string | null
    usedFrom?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type UserRecoveryCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecoveryCodesNestedInput
  }

  export type UserRecoveryCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRecoveryCodeCreateManyInput = {
    id?: string
    userId: string
    codeHash: string
    usedAt?: Date | string | null
    usedFrom?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type UserRecoveryCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRecoveryCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSecurityQuestionCreateInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSecurityQuestionsInput
  }

  export type UserSecurityQuestionUncheckedCreateInput = {
    id?: string
    userId: string
    question: string
    answerHash: string
    createdAt?: Date | string
  }

  export type UserSecurityQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSecurityQuestionsNestedInput
  }

  export type UserSecurityQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSecurityQuestionCreateManyInput = {
    id?: string
    userId: string
    question: string
    answerHash: string
    createdAt?: Date | string
  }

  export type UserSecurityQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSecurityQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBreakglassAccountCreateInput = {
    id?: string
    orgId: string
    encryptedEmail: string
    encryptedPasswordHash: string
    encryptionIV: string
    createdAt?: Date | string
    lastActivatedAt?: Date | string | null
    activationCount?: number
    isEnabled?: boolean
    canAutoActivate?: boolean
    minDelayMinutes?: number
    user: UserCreateNestedOneWithoutBreakglassAccountInput
  }

  export type UserBreakglassAccountUncheckedCreateInput = {
    id?: string
    userId: string
    orgId: string
    encryptedEmail: string
    encryptedPasswordHash: string
    encryptionIV: string
    createdAt?: Date | string
    lastActivatedAt?: Date | string | null
    activationCount?: number
    isEnabled?: boolean
    canAutoActivate?: boolean
    minDelayMinutes?: number
  }

  export type UserBreakglassAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    encryptedEmail?: StringFieldUpdateOperationsInput | string
    encryptedPasswordHash?: StringFieldUpdateOperationsInput | string
    encryptionIV?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationCount?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    canAutoActivate?: BoolFieldUpdateOperationsInput | boolean
    minDelayMinutes?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutBreakglassAccountNestedInput
  }

  export type UserBreakglassAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    encryptedEmail?: StringFieldUpdateOperationsInput | string
    encryptedPasswordHash?: StringFieldUpdateOperationsInput | string
    encryptionIV?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationCount?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    canAutoActivate?: BoolFieldUpdateOperationsInput | boolean
    minDelayMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type UserBreakglassAccountCreateManyInput = {
    id?: string
    userId: string
    orgId: string
    encryptedEmail: string
    encryptedPasswordHash: string
    encryptionIV: string
    createdAt?: Date | string
    lastActivatedAt?: Date | string | null
    activationCount?: number
    isEnabled?: boolean
    canAutoActivate?: boolean
    minDelayMinutes?: number
  }

  export type UserBreakglassAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    encryptedEmail?: StringFieldUpdateOperationsInput | string
    encryptedPasswordHash?: StringFieldUpdateOperationsInput | string
    encryptionIV?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationCount?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    canAutoActivate?: BoolFieldUpdateOperationsInput | boolean
    minDelayMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type UserBreakglassAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    encryptedEmail?: StringFieldUpdateOperationsInput | string
    encryptedPasswordHash?: StringFieldUpdateOperationsInput | string
    encryptionIV?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationCount?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    canAutoActivate?: BoolFieldUpdateOperationsInput | boolean
    minDelayMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type UserDeviceFingerprintCreateInput = {
    id?: string
    fingerprint: string
    ipAddress: string
    userAgent: string
    isTrusted?: boolean
    trustScore?: number
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    loginCount?: number
    user: UserCreateNestedOneWithoutDeviceFingerprintsInput
  }

  export type UserDeviceFingerprintUncheckedCreateInput = {
    id?: string
    userId: string
    fingerprint: string
    ipAddress: string
    userAgent: string
    isTrusted?: boolean
    trustScore?: number
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    loginCount?: number
  }

  export type UserDeviceFingerprintUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginCount?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutDeviceFingerprintsNestedInput
  }

  export type UserDeviceFingerprintUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserDeviceFingerprintCreateManyInput = {
    id?: string
    userId: string
    fingerprint: string
    ipAddress: string
    userAgent: string
    isTrusted?: boolean
    trustScore?: number
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    loginCount?: number
  }

  export type UserDeviceFingerprintUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserDeviceFingerprintUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserLoginHistoryCreateInput = {
    id?: string
    success: boolean
    method: string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    riskScore?: number
    riskFactors?: string | null
    country?: string | null
    city?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutLoginHistoryInput
  }

  export type UserLoginHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    success: boolean
    method: string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    riskScore?: number
    riskFactors?: string | null
    country?: string | null
    city?: string | null
    timestamp?: Date | string
  }

  export type UserLoginHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLoginHistoryNestedInput
  }

  export type UserLoginHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginHistoryCreateManyInput = {
    id?: string
    userId: string
    success: boolean
    method: string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    riskScore?: number
    riskFactors?: string | null
    country?: string | null
    city?: string | null
    timestamp?: Date | string
  }

  export type UserLoginHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakglassActivationLogCreateInput = {
    id?: string
    userId: string
    orgId: string
    reason: string
    method: string
    riskScore: number
    riskFactors: string
    delayMinutes: number
    verificationSteps: string
    ipAddress: string
    userAgent: string
    success: boolean
    errorMessage?: string | null
    notifiedAdmins: string
    timestamp?: Date | string
  }

  export type BreakglassActivationLogUncheckedCreateInput = {
    id?: string
    userId: string
    orgId: string
    reason: string
    method: string
    riskScore: number
    riskFactors: string
    delayMinutes: number
    verificationSteps: string
    ipAddress: string
    userAgent: string
    success: boolean
    errorMessage?: string | null
    notifiedAdmins: string
    timestamp?: Date | string
  }

  export type BreakglassActivationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: StringFieldUpdateOperationsInput | string
    delayMinutes?: IntFieldUpdateOperationsInput | number
    verificationSteps?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedAdmins?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakglassActivationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: StringFieldUpdateOperationsInput | string
    delayMinutes?: IntFieldUpdateOperationsInput | number
    verificationSteps?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedAdmins?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakglassActivationLogCreateManyInput = {
    id?: string
    userId: string
    orgId: string
    reason: string
    method: string
    riskScore: number
    riskFactors: string
    delayMinutes: number
    verificationSteps: string
    ipAddress: string
    userAgent: string
    success: boolean
    errorMessage?: string | null
    notifiedAdmins: string
    timestamp?: Date | string
  }

  export type BreakglassActivationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: StringFieldUpdateOperationsInput | string
    delayMinutes?: IntFieldUpdateOperationsInput | number
    verificationSteps?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedAdmins?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakglassActivationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: StringFieldUpdateOperationsInput | string
    delayMinutes?: IntFieldUpdateOperationsInput | number
    verificationSteps?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedAdmins?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryRequestCreateInput = {
    id?: string
    userId: string
    orgId: string
    type: string
    status: string
    verificationToken: string
    verificationCode?: string | null
    codeExpiresAt?: Date | string | null
    codeAttempts?: number
    riskScore: number
    delayUntil: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    expiresAt: Date | string
    completedAt?: Date | string | null
  }

  export type RecoveryRequestUncheckedCreateInput = {
    id?: string
    userId: string
    orgId: string
    type: string
    status: string
    verificationToken: string
    verificationCode?: string | null
    codeExpiresAt?: Date | string | null
    codeAttempts?: number
    riskScore: number
    delayUntil: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    expiresAt: Date | string
    completedAt?: Date | string | null
  }

  export type RecoveryRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    codeAttempts?: IntFieldUpdateOperationsInput | number
    riskScore?: IntFieldUpdateOperationsInput | number
    delayUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecoveryRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    codeAttempts?: IntFieldUpdateOperationsInput | number
    riskScore?: IntFieldUpdateOperationsInput | number
    delayUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecoveryRequestCreateManyInput = {
    id?: string
    userId: string
    orgId: string
    type: string
    status: string
    verificationToken: string
    verificationCode?: string | null
    codeExpiresAt?: Date | string | null
    codeAttempts?: number
    riskScore: number
    delayUntil: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    expiresAt: Date | string
    completedAt?: Date | string | null
  }

  export type RecoveryRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    codeAttempts?: IntFieldUpdateOperationsInput | number
    riskScore?: IntFieldUpdateOperationsInput | number
    delayUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecoveryRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationToken?: StringFieldUpdateOperationsInput | string
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    codeAttempts?: IntFieldUpdateOperationsInput | number
    riskScore?: IntFieldUpdateOperationsInput | number
    delayUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeadCreateInput = {
    id?: string
    publicId: string
    sourceType: $Enums.LeadSource
    identityHash: string
    company?: string | null
    contactName?: string | null
    email?: string | null
    phoneE164?: string | null
    website?: string | null
    serviceCode?: string | null
    zip?: string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: boolean
    convertedAt?: Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    notes?: string | null
    sourceDetail?: string | null
    state?: string | null
    postalCode?: string | null
    address?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    country?: string | null
    org: OrgCreateNestedOneWithoutLeadsInput
    LeadInvoiceLine?: LeadInvoiceLineCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    orgId: string
    publicId: string
    sourceType: $Enums.LeadSource
    identityHash: string
    company?: string | null
    contactName?: string | null
    email?: string | null
    phoneE164?: string | null
    website?: string | null
    serviceCode?: string | null
    zip?: string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: boolean
    convertedAt?: Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    notes?: string | null
    sourceDetail?: string | null
    state?: string | null
    postalCode?: string | null
    address?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    country?: string | null
    LeadInvoiceLine?: LeadInvoiceLineUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    identityHash?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneE164?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: IntFieldUpdateOperationsInput | number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: BoolFieldUpdateOperationsInput | boolean
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDetail?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrgUpdateOneRequiredWithoutLeadsNestedInput
    LeadInvoiceLine?: LeadInvoiceLineUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    identityHash?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneE164?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: IntFieldUpdateOperationsInput | number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: BoolFieldUpdateOperationsInput | boolean
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDetail?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    LeadInvoiceLine?: LeadInvoiceLineUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    orgId: string
    publicId: string
    sourceType: $Enums.LeadSource
    identityHash: string
    company?: string | null
    contactName?: string | null
    email?: string | null
    phoneE164?: string | null
    website?: string | null
    serviceCode?: string | null
    zip?: string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: boolean
    convertedAt?: Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    notes?: string | null
    sourceDetail?: string | null
    state?: string | null
    postalCode?: string | null
    address?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    country?: string | null
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    identityHash?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneE164?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: IntFieldUpdateOperationsInput | number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: BoolFieldUpdateOperationsInput | boolean
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDetail?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    identityHash?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneE164?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: IntFieldUpdateOperationsInput | number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: BoolFieldUpdateOperationsInput | boolean
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDetail?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutCustomersInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    opportunities?: OpportunityCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    orgId: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutCustomersNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    opportunities?: OpportunityUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    orgId: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityCreateInput = {
    id?: string
    valueType?: $Enums.ValueType
    estValue?: Decimal | DecimalJsLike | number | string | null
    stage?: string
    ownerId?: string | null
    sourceLeadId?: string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOpportunitiesInput
    org: OrgCreateNestedOneWithoutOpportunitiesInput
  }

  export type OpportunityUncheckedCreateInput = {
    id?: string
    orgId: string
    customerId: string
    valueType?: $Enums.ValueType
    estValue?: Decimal | DecimalJsLike | number | string | null
    stage?: string
    ownerId?: string | null
    sourceLeadId?: string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    estValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput
    org?: OrgUpdateOneRequiredWithoutOpportunitiesNestedInput
  }

  export type OpportunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    estValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityCreateManyInput = {
    id?: string
    orgId: string
    customerId: string
    valueType?: $Enums.ValueType
    estValue?: Decimal | DecimalJsLike | number | string | null
    stage?: string
    ownerId?: string | null
    sourceLeadId?: string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    estValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    estValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    org: OrgCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    orgId: string
    customerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    org?: OrgUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    orgId: string
    customerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method?: string
    receivedAt?: Date | string
    reference?: string | null
    status?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    failureReason?: string | null
    retryCount?: number
    lastRetryAt?: Date | string | null
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
    org: OrgCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    orgId: string
    invoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: string
    receivedAt?: Date | string
    reference?: string | null
    status?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    failureReason?: string | null
    retryCount?: number
    lastRetryAt?: Date | string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
    org?: OrgUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    orgId: string
    invoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: string
    receivedAt?: Date | string
    reference?: string | null
    status?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    failureReason?: string | null
    retryCount?: number
    lastRetryAt?: Date | string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RfpCreateInput = {
    id?: string
    publicId: string
    sourceSite: string
    title: string
    dueDate?: Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobCreateNestedManyWithoutRfpInput
    org: OrgCreateNestedOneWithoutRfpsInput
  }

  export type RfpUncheckedCreateInput = {
    id?: string
    orgId: string
    publicId: string
    sourceSite: string
    title: string
    dueDate?: Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutRfpInput
  }

  export type RfpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceSite?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: NullableIntFieldUpdateOperationsInput | number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutRfpNestedInput
    org?: OrgUpdateOneRequiredWithoutRfpsNestedInput
  }

  export type RfpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceSite?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: NullableIntFieldUpdateOperationsInput | number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutRfpNestedInput
  }

  export type RfpCreateManyInput = {
    id?: string
    orgId: string
    publicId: string
    sourceSite: string
    title: string
    dueDate?: Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RfpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceSite?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: NullableIntFieldUpdateOperationsInput | number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RfpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceSite?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: NullableIntFieldUpdateOperationsInput | number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateInput = {
    id?: string
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutJobsInput
    org: OrgCreateNestedOneWithoutJobsInput
    rfp?: RfpCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateInput = {
    id?: string
    orgId: string
    customerId?: string | null
    rfpId?: string | null
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutJobsNestedInput
    org?: OrgUpdateOneRequiredWithoutJobsNestedInput
    rfp?: RfpUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    rfpId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateManyInput = {
    id?: string
    orgId: string
    customerId?: string | null
    rfpId?: string | null
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    rfpId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    employeeId?: string | null
    referredName: string
    referredEmail?: string | null
    referredPhone?: string | null
    status?: string
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    orgId: string
    employeeId?: string | null
    referredName: string
    referredEmail?: string | null
    referredPhone?: string | null
    status?: string
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    referredName?: StringFieldUpdateOperationsInput | string
    referredEmail?: NullableStringFieldUpdateOperationsInput | string | null
    referredPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    referredName?: StringFieldUpdateOperationsInput | string
    referredEmail?: NullableStringFieldUpdateOperationsInput | string | null
    referredPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    orgId: string
    employeeId?: string | null
    referredName: string
    referredEmail?: string | null
    referredPhone?: string | null
    status?: string
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    referredName?: StringFieldUpdateOperationsInput | string
    referredEmail?: NullableStringFieldUpdateOperationsInput | string | null
    referredPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    referredName?: StringFieldUpdateOperationsInput | string
    referredEmail?: NullableStringFieldUpdateOperationsInput | string | null
    referredPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingLedgerCreateInput = {
    id?: string
    type: $Enums.LedgerType
    amount: Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    org: OrgCreateNestedOneWithoutLedgerInput
  }

  export type BillingLedgerUncheckedCreateInput = {
    id?: string
    orgId: string
    type: $Enums.LedgerType
    amount: Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutLedgerNestedInput
  }

  export type BillingLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingLedgerCreateManyInput = {
    id?: string
    orgId: string
    type: $Enums.LedgerType
    amount: Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadInvoiceCreateInput = {
    id?: string
    number: string
    periodFrom: Date | string
    periodTo: Date | string
    status: string
    subtotalCents: number
    taxCents?: number
    totalCents: number
    currency?: string
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadCount?: number
    org?: OrgCreateNestedOneWithoutLeadInvoicesInput
    lines?: LeadInvoiceLineCreateNestedManyWithoutInvoiceInput
  }

  export type LeadInvoiceUncheckedCreateInput = {
    id?: string
    orgId?: string | null
    number: string
    periodFrom: Date | string
    periodTo: Date | string
    status: string
    subtotalCents: number
    taxCents?: number
    totalCents: number
    currency?: string
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadCount?: number
    lines?: LeadInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type LeadInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    periodFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    periodTo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    taxCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadCount?: IntFieldUpdateOperationsInput | number
    org?: OrgUpdateOneWithoutLeadInvoicesNestedInput
    lines?: LeadInvoiceLineUpdateManyWithoutInvoiceNestedInput
  }

  export type LeadInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    periodFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    periodTo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    taxCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadCount?: IntFieldUpdateOperationsInput | number
    lines?: LeadInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type LeadInvoiceCreateManyInput = {
    id?: string
    orgId?: string | null
    number: string
    periodFrom: Date | string
    periodTo: Date | string
    status: string
    subtotalCents: number
    taxCents?: number
    totalCents: number
    currency?: string
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadCount?: number
  }

  export type LeadInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    periodFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    periodTo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    taxCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadCount?: IntFieldUpdateOperationsInput | number
  }

  export type LeadInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    periodFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    periodTo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    taxCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadCount?: IntFieldUpdateOperationsInput | number
  }

  export type LeadInvoiceLineCreateInput = {
    id?: string
    description: string
    quantity?: number
    unitPriceCents: number
    amountCents: number
    source?: string | null
    createdAt?: Date | string
    invoice: LeadInvoiceCreateNestedOneWithoutLinesInput
    lead?: LeadCreateNestedOneWithoutLeadInvoiceLineInput
  }

  export type LeadInvoiceLineUncheckedCreateInput = {
    id?: string
    invoiceId: string
    leadId?: string | null
    description: string
    quantity?: number
    unitPriceCents: number
    amountCents: number
    source?: string | null
    createdAt?: Date | string
  }

  export type LeadInvoiceLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: LeadInvoiceUpdateOneRequiredWithoutLinesNestedInput
    lead?: LeadUpdateOneWithoutLeadInvoiceLineNestedInput
  }

  export type LeadInvoiceLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadInvoiceLineCreateManyInput = {
    id?: string
    invoiceId: string
    leadId?: string | null
    description: string
    quantity?: number
    unitPriceCents: number
    amountCents: number
    source?: string | null
    createdAt?: Date | string
  }

  export type LeadInvoiceLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadInvoiceLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    actorUserId?: string | null
    entity: string
    entityId?: string | null
    field?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    createdAt?: Date | string
    org: OrgCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    orgId: string
    actorUserId?: string | null
    entity: string
    entityId?: string | null
    field?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    orgId: string
    actorUserId?: string | null
    entity: string
    entityId?: string | null
    field?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RbacPermissionCreateInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    rolePerms?: RbacRolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type RbacPermissionUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    rolePerms?: RbacRolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type RbacPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePerms?: RbacRolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type RbacPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePerms?: RbacRolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type RbacPermissionCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
  }

  export type RbacPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RbacPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RbacRoleCreateInput = {
    id?: string
    name: string
    slug: string
    isSystem?: boolean
    createdAt?: Date | string
    org?: OrgCreateNestedOneWithoutRbacRolesInput
    rolePerms?: RbacRolePermissionCreateNestedManyWithoutRoleInput
    userRoles?: RbacUserRoleCreateNestedManyWithoutRoleInput
  }

  export type RbacRoleUncheckedCreateInput = {
    id?: string
    orgId?: string | null
    name: string
    slug: string
    isSystem?: boolean
    createdAt?: Date | string
    rolePerms?: RbacRolePermissionUncheckedCreateNestedManyWithoutRoleInput
    userRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RbacRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneWithoutRbacRolesNestedInput
    rolePerms?: RbacRolePermissionUpdateManyWithoutRoleNestedInput
    userRoles?: RbacUserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RbacRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePerms?: RbacRolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    userRoles?: RbacUserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RbacRoleCreateManyInput = {
    id?: string
    orgId?: string | null
    name: string
    slug: string
    isSystem?: boolean
    createdAt?: Date | string
  }

  export type RbacRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RbacRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RbacRolePermissionCreateInput = {
    role: RbacRoleCreateNestedOneWithoutRolePermsInput
    permission: RbacPermissionCreateNestedOneWithoutRolePermsInput
  }

  export type RbacRolePermissionUncheckedCreateInput = {
    roleId: string
    permissionId: string
  }

  export type RbacRolePermissionUpdateInput = {
    role?: RbacRoleUpdateOneRequiredWithoutRolePermsNestedInput
    permission?: RbacPermissionUpdateOneRequiredWithoutRolePermsNestedInput
  }

  export type RbacRolePermissionUncheckedUpdateInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RbacRolePermissionCreateManyInput = {
    roleId: string
    permissionId: string
  }

  export type RbacRolePermissionUpdateManyMutationInput = {

  }

  export type RbacRolePermissionUncheckedUpdateManyInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RbacUserRoleCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutRbacUserRolesInput
    org?: OrgCreateNestedOneWithoutRbacUserRolesInput
    role: RbacRoleCreateNestedOneWithoutUserRolesInput
  }

  export type RbacUserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    orgId?: string | null
    roleId: string
  }

  export type RbacUserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutRbacUserRolesNestedInput
    org?: OrgUpdateOneWithoutRbacUserRolesNestedInput
    role?: RbacRoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type RbacUserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type RbacUserRoleCreateManyInput = {
    id?: string
    userId: string
    orgId?: string | null
    roleId: string
  }

  export type RbacUserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type RbacUserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderConfigCreateInput = {
    id?: string
    samApiKey?: string | null
    stripeSecretKey?: string | null
    otherConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderConfigUncheckedCreateInput = {
    id?: string
    samApiKey?: string | null
    stripeSecretKey?: string | null
    otherConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    samApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    otherConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    samApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    otherConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderConfigCreateManyInput = {
    id?: string
    samApiKey?: string | null
    stripeSecretKey?: string | null
    otherConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    samApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    otherConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    samApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    otherConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanCreateInput = {
    model?: $Enums.PricingModel
    currency?: string
    unitAmount?: number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: number
    org: OrgCreateNestedOneWithoutPricingPlanInput
  }

  export type PricingPlanUncheckedCreateInput = {
    orgId: string
    model?: $Enums.PricingModel
    currency?: string
    unitAmount?: number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: number
  }

  export type PricingPlanUpdateInput = {
    model?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    currency?: StringFieldUpdateOperationsInput | string
    unitAmount?: IntFieldUpdateOperationsInput | number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: IntFieldUpdateOperationsInput | number
    org?: OrgUpdateOneRequiredWithoutPricingPlanNestedInput
  }

  export type PricingPlanUncheckedUpdateInput = {
    orgId?: StringFieldUpdateOperationsInput | string
    model?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    currency?: StringFieldUpdateOperationsInput | string
    unitAmount?: IntFieldUpdateOperationsInput | number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: IntFieldUpdateOperationsInput | number
  }

  export type PricingPlanCreateManyInput = {
    orgId: string
    model?: $Enums.PricingModel
    currency?: string
    unitAmount?: number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: number
  }

  export type PricingPlanUpdateManyMutationInput = {
    model?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    currency?: StringFieldUpdateOperationsInput | string
    unitAmount?: IntFieldUpdateOperationsInput | number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: IntFieldUpdateOperationsInput | number
  }

  export type PricingPlanUncheckedUpdateManyInput = {
    orgId?: StringFieldUpdateOperationsInput | string
    model?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    currency?: StringFieldUpdateOperationsInput | string
    unitAmount?: IntFieldUpdateOperationsInput | number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: IntFieldUpdateOperationsInput | number
  }

  export type AiUsageEventCreateInput = {
    id?: string
    userId?: string | null
    feature: string
    model: string
    tokensIn: number
    tokensOut: number
    costUsd: Decimal | DecimalJsLike | number | string
    creditsUsed: number
    requestId?: string | null
    createdAt?: Date | string
    org: OrgCreateNestedOneWithoutAiUsageEventsInput
  }

  export type AiUsageEventUncheckedCreateInput = {
    id?: string
    orgId: string
    userId?: string | null
    feature: string
    model: string
    tokensIn: number
    tokensOut: number
    costUsd: Decimal | DecimalJsLike | number | string
    creditsUsed: number
    requestId?: string | null
    createdAt?: Date | string
  }

  export type AiUsageEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutAiUsageEventsNestedInput
  }

  export type AiUsageEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiUsageEventCreateManyInput = {
    id?: string
    orgId: string
    userId?: string | null
    feature: string
    model: string
    tokensIn: number
    tokensOut: number
    costUsd: Decimal | DecimalJsLike | number | string
    creditsUsed: number
    requestId?: string | null
    createdAt?: Date | string
  }

  export type AiUsageEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiUsageEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMonthlySummaryCreateInput = {
    id?: string
    monthKey: string
    tokensIn?: number
    tokensOut?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    creditsUsed?: number
    callCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutAiMonthlySummariesInput
  }

  export type AiMonthlySummaryUncheckedCreateInput = {
    id?: string
    orgId: string
    monthKey: string
    tokensIn?: number
    tokensOut?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    creditsUsed?: number
    callCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiMonthlySummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthKey?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    callCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutAiMonthlySummariesNestedInput
  }

  export type AiMonthlySummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    monthKey?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    callCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMonthlySummaryCreateManyInput = {
    id?: string
    orgId: string
    monthKey: string
    tokensIn?: number
    tokensOut?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    creditsUsed?: number
    callCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiMonthlySummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthKey?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    callCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMonthlySummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    monthKey?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    callCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    actorType: string
    actorId?: string | null
    entityType: string
    entityId: string
    action: string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    org: OrgCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    orgId: string
    actorType: string
    actorId?: string | null
    entityType: string
    entityId: string
    action: string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    orgId: string
    actorType: string
    actorId?: string | null
    entityType: string
    entityId: string
    action: string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    plan: string
    status: string
    startedAt: Date | string
    canceledAt?: Date | string | null
    renewsAt?: Date | string | null
    priceCents: number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    orgId: string
    plan: string
    status: string
    startedAt: Date | string
    canceledAt?: Date | string | null
    renewsAt?: Date | string | null
    priceCents: number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    orgId: string
    plan: string
    status: string
    startedAt: Date | string
    canceledAt?: Date | string | null
    renewsAt?: Date | string | null
    priceCents: number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMeterCreateInput = {
    id?: string
    meter: string
    quantity: number
    windowStart: Date | string
    windowEnd: Date | string
    createdAt?: Date | string
    org: OrgCreateNestedOneWithoutUsageMetersInput
  }

  export type UsageMeterUncheckedCreateInput = {
    id?: string
    orgId: string
    meter: string
    quantity: number
    windowStart: Date | string
    windowEnd: Date | string
    createdAt?: Date | string
  }

  export type UsageMeterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meter?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutUsageMetersNestedInput
  }

  export type UsageMeterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    meter?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMeterCreateManyInput = {
    id?: string
    orgId: string
    meter: string
    quantity: number
    windowStart: Date | string
    windowEnd: Date | string
    createdAt?: Date | string
  }

  export type UsageMeterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    meter?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMeterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    meter?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddonPurchaseCreateInput = {
    id?: string
    sku: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    purchasedAt?: Date | string
    refundedAt?: Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
    org: OrgCreateNestedOneWithoutAddonPurchasesInput
  }

  export type AddonPurchaseUncheckedCreateInput = {
    id?: string
    orgId: string
    sku: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    purchasedAt?: Date | string
    refundedAt?: Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type AddonPurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
    org?: OrgUpdateOneRequiredWithoutAddonPurchasesNestedInput
  }

  export type AddonPurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type AddonPurchaseCreateManyInput = {
    id?: string
    orgId: string
    sku: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    purchasedAt?: Date | string
    refundedAt?: Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type AddonPurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type AddonPurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type FederationKeyCreateInput = {
    id?: string
    tenantId: string
    keyId: string
    secretHash: string
    scope: string
    createdAt?: Date | string
    disabledAt?: Date | string | null
    rotatedAt?: Date | string | null
    lastUsedAt?: Date | string | null
  }

  export type FederationKeyUncheckedCreateInput = {
    id?: string
    tenantId: string
    keyId: string
    secretHash: string
    scope: string
    createdAt?: Date | string
    disabledAt?: Date | string | null
    rotatedAt?: Date | string | null
    lastUsedAt?: Date | string | null
  }

  export type FederationKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    secretHash?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FederationKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    secretHash?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FederationKeyCreateManyInput = {
    id?: string
    tenantId: string
    keyId: string
    secretHash: string
    scope: string
    createdAt?: Date | string
    disabledAt?: Date | string | null
    rotatedAt?: Date | string | null
    lastUsedAt?: Date | string | null
  }

  export type FederationKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    secretHash?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FederationKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    secretHash?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OIDCConfigCreateInput = {
    id?: string
    enabled?: boolean
    issuerUrl: string
    clientId: string
    clientSecret: string
    scopes?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastTestedAt?: Date | string | null
  }

  export type OIDCConfigUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    issuerUrl: string
    clientId: string
    clientSecret: string
    scopes?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastTestedAt?: Date | string | null
  }

  export type OIDCConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    issuerUrl?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OIDCConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    issuerUrl?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OIDCConfigCreateManyInput = {
    id?: string
    enabled?: boolean
    issuerUrl: string
    clientId: string
    clientSecret: string
    scopes?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastTestedAt?: Date | string | null
  }

  export type OIDCConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    issuerUrl?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OIDCConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    issuerUrl?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderIntegrationCreateInput = {
    id?: string
    name: string
    type: string
    config?: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
  }

  export type ProviderIntegrationUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    config?: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
  }

  export type ProviderIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderIntegrationCreateManyInput = {
    id?: string
    name: string
    type: string
    config?: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
  }

  export type ProviderIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditEventCreateInput = {
    id?: string
    actorType: string
    actorId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditEventUncheckedCreateInput = {
    id?: string
    actorType: string
    actorId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventCreateManyInput = {
    id?: string
    actorType: string
    actorId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSnapshotCreateInput = {
    id?: string
    snapshotDate: Date | string
    mrrCents?: number
    arrCents?: number
    activeClients?: number
    newClients?: number
    churnedClients?: number
    totalRevenue?: number
    metricsJson?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsSnapshotUncheckedCreateInput = {
    id?: string
    snapshotDate: Date | string
    mrrCents?: number
    arrCents?: number
    activeClients?: number
    newClients?: number
    churnedClients?: number
    totalRevenue?: number
    metricsJson?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mrrCents?: IntFieldUpdateOperationsInput | number
    arrCents?: IntFieldUpdateOperationsInput | number
    activeClients?: IntFieldUpdateOperationsInput | number
    newClients?: IntFieldUpdateOperationsInput | number
    churnedClients?: IntFieldUpdateOperationsInput | number
    totalRevenue?: IntFieldUpdateOperationsInput | number
    metricsJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mrrCents?: IntFieldUpdateOperationsInput | number
    arrCents?: IntFieldUpdateOperationsInput | number
    activeClients?: IntFieldUpdateOperationsInput | number
    newClients?: IntFieldUpdateOperationsInput | number
    churnedClients?: IntFieldUpdateOperationsInput | number
    totalRevenue?: IntFieldUpdateOperationsInput | number
    metricsJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSnapshotCreateManyInput = {
    id?: string
    snapshotDate: Date | string
    mrrCents?: number
    arrCents?: number
    activeClients?: number
    newClients?: number
    churnedClients?: number
    totalRevenue?: number
    metricsJson?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mrrCents?: IntFieldUpdateOperationsInput | number
    arrCents?: IntFieldUpdateOperationsInput | number
    activeClients?: IntFieldUpdateOperationsInput | number
    newClients?: IntFieldUpdateOperationsInput | number
    churnedClients?: IntFieldUpdateOperationsInput | number
    totalRevenue?: IntFieldUpdateOperationsInput | number
    metricsJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mrrCents?: IntFieldUpdateOperationsInput | number
    arrCents?: IntFieldUpdateOperationsInput | number
    activeClients?: IntFieldUpdateOperationsInput | number
    newClients?: IntFieldUpdateOperationsInput | number
    churnedClients?: IntFieldUpdateOperationsInput | number
    totalRevenue?: IntFieldUpdateOperationsInput | number
    metricsJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateInput = {
    id?: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    assigneeUserId?: string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: string
    orgId: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    assigneeUserId?: string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assigneeUserId?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assigneeUserId?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateManyInput = {
    id?: string
    orgId: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    assigneeUserId?: string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assigneeUserId?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assigneeUserId?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineCreateInput = {
    id?: string
    description: string
    lineType: $Enums.InvoiceLineType
    quantity?: number
    unitPriceCents: number
    amountCents: number
    sourceType?: string | null
    sourceId?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutLineItemsInput
  }

  export type InvoiceLineUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    lineType: $Enums.InvoiceLineType
    quantity?: number
    unitPriceCents: number
    amountCents: number
    sourceType?: string | null
    sourceId?: string | null
    createdAt?: Date | string
  }

  export type InvoiceLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lineType?: EnumInvoiceLineTypeFieldUpdateOperationsInput | $Enums.InvoiceLineType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutLineItemsNestedInput
  }

  export type InvoiceLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lineType?: EnumInvoiceLineTypeFieldUpdateOperationsInput | $Enums.InvoiceLineType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    lineType: $Enums.InvoiceLineType
    quantity?: number
    unitPriceCents: number
    amountCents: number
    sourceType?: string | null
    sourceId?: string | null
    createdAt?: Date | string
  }

  export type InvoiceLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lineType?: EnumInvoiceLineTypeFieldUpdateOperationsInput | $Enums.InvoiceLineType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lineType?: EnumInvoiceLineTypeFieldUpdateOperationsInput | $Enums.InvoiceLineType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    audience: string
    type: string
    title: string
    body: string
    severity: string
    readAt?: Date | string | null
    createdAt?: Date | string
    org?: OrgCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    orgId?: string | null
    audience: string
    type: string
    title: string
    body: string
    severity: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    audience?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    orgId?: string | null
    audience: string
    type: string
    title: string
    body: string
    severity: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    audience?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricePlanCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PlanPriceCreateNestedManyWithoutPlanInput
    offers?: OfferCreateNestedManyWithoutAppliesToPlanInput
    overrides?: TenantPriceOverrideCreateNestedManyWithoutPlanInput
    asDefaultFor?: GlobalMonetizationConfigCreateNestedManyWithoutDefaultPlanInput
    invites?: OnboardingInviteCreateNestedManyWithoutPlanInput
  }

  export type PricePlanUncheckedCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PlanPriceUncheckedCreateNestedManyWithoutPlanInput
    offers?: OfferUncheckedCreateNestedManyWithoutAppliesToPlanInput
    overrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutPlanInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPlanInput
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PricePlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PlanPriceUpdateManyWithoutPlanNestedInput
    offers?: OfferUpdateManyWithoutAppliesToPlanNestedInput
    overrides?: TenantPriceOverrideUpdateManyWithoutPlanNestedInput
    asDefaultFor?: GlobalMonetizationConfigUpdateManyWithoutDefaultPlanNestedInput
    invites?: OnboardingInviteUpdateManyWithoutPlanNestedInput
  }

  export type PricePlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PlanPriceUncheckedUpdateManyWithoutPlanNestedInput
    offers?: OfferUncheckedUpdateManyWithoutAppliesToPlanNestedInput
    overrides?: TenantPriceOverrideUncheckedUpdateManyWithoutPlanNestedInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPlanNestedInput
    invites?: OnboardingInviteUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PricePlanCreateManyInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricePlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricePlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPriceCreateInput = {
    id?: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: TenantPriceOverrideCreateNestedManyWithoutPriceInput
    asDefaultFor?: GlobalMonetizationConfigCreateNestedManyWithoutDefaultPriceInput
    invites?: OnboardingInviteCreateNestedManyWithoutPriceInput
    plan: PricePlanCreateNestedOneWithoutPricesInput
  }

  export type PlanPriceUncheckedCreateInput = {
    id?: string
    planId: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutPriceInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPriceInput
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PlanPriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: TenantPriceOverrideUpdateManyWithoutPriceNestedInput
    asDefaultFor?: GlobalMonetizationConfigUpdateManyWithoutDefaultPriceNestedInput
    invites?: OnboardingInviteUpdateManyWithoutPriceNestedInput
    plan?: PricePlanUpdateOneRequiredWithoutPricesNestedInput
  }

  export type PlanPriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: TenantPriceOverrideUncheckedUpdateManyWithoutPriceNestedInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPriceNestedInput
    invites?: OnboardingInviteUncheckedUpdateManyWithoutPriceNestedInput
  }

  export type PlanPriceCreateManyInput = {
    id?: string
    planId: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferCreateInput = {
    id?: string
    name: string
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appliesToPlan?: PricePlanCreateNestedOneWithoutOffersInput
    invites?: OnboardingInviteCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateInput = {
    id?: string
    name: string
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    appliesToPlanId?: string | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appliesToPlan?: PricePlanUpdateOneWithoutOffersNestedInput
    invites?: OnboardingInviteUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    appliesToPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: OnboardingInviteUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferCreateManyInput = {
    id?: string
    name: string
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    appliesToPlanId?: string | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    appliesToPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateInput = {
    id?: string
    code: string
    name?: string | null
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxRedemptions?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invites?: OnboardingInviteCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    code: string
    name?: string | null
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxRedemptions?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: OnboardingInviteUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: OnboardingInviteUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponCreateManyInput = {
    id?: string
    code: string
    name?: string | null
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxRedemptions?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantPriceOverrideCreateInput = {
    id?: string
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutTenantOverridesInput
    plan?: PricePlanCreateNestedOneWithoutOverridesInput
    price?: PlanPriceCreateNestedOneWithoutOverridesInput
  }

  export type TenantPriceOverrideUncheckedCreateInput = {
    id?: string
    orgId: string
    planId?: string | null
    priceId?: string | null
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantPriceOverrideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutTenantOverridesNestedInput
    plan?: PricePlanUpdateOneWithoutOverridesNestedInput
    price?: PlanPriceUpdateOneWithoutOverridesNestedInput
  }

  export type TenantPriceOverrideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantPriceOverrideCreateManyInput = {
    id?: string
    orgId: string
    planId?: string | null
    priceId?: string | null
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantPriceOverrideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantPriceOverrideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalMonetizationConfigCreateInput = {
    id?: string
    defaultTrialDays?: number | null
    publicOnboarding?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultPlan?: PricePlanCreateNestedOneWithoutAsDefaultForInput
    defaultPrice?: PlanPriceCreateNestedOneWithoutAsDefaultForInput
  }

  export type GlobalMonetizationConfigUncheckedCreateInput = {
    id?: string
    defaultPlanId?: string | null
    defaultPriceId?: string | null
    defaultTrialDays?: number | null
    publicOnboarding?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalMonetizationConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultTrialDays?: NullableIntFieldUpdateOperationsInput | number | null
    publicOnboarding?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultPlan?: PricePlanUpdateOneWithoutAsDefaultForNestedInput
    defaultPrice?: PlanPriceUpdateOneWithoutAsDefaultForNestedInput
  }

  export type GlobalMonetizationConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTrialDays?: NullableIntFieldUpdateOperationsInput | number | null
    publicOnboarding?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalMonetizationConfigCreateManyInput = {
    id?: string
    defaultPlanId?: string | null
    defaultPriceId?: string | null
    defaultTrialDays?: number | null
    publicOnboarding?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalMonetizationConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultTrialDays?: NullableIntFieldUpdateOperationsInput | number | null
    publicOnboarding?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalMonetizationConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTrialDays?: NullableIntFieldUpdateOperationsInput | number | null
    publicOnboarding?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteCreateInput = {
    id?: string
    token: string
    email?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    plan?: PricePlanCreateNestedOneWithoutInvitesInput
    price?: PlanPriceCreateNestedOneWithoutInvitesInput
    offer?: OfferCreateNestedOneWithoutInvitesInput
    coupon?: CouponCreateNestedOneWithoutInvitesInput
  }

  export type OnboardingInviteUncheckedCreateInput = {
    id?: string
    token: string
    email?: string | null
    planId?: string | null
    priceId?: string | null
    offerId?: string | null
    couponId?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type OnboardingInviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PricePlanUpdateOneWithoutInvitesNestedInput
    price?: PlanPriceUpdateOneWithoutInvitesNestedInput
    offer?: OfferUpdateOneWithoutInvitesNestedInput
    coupon?: CouponUpdateOneWithoutInvitesNestedInput
  }

  export type OnboardingInviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteCreateManyInput = {
    id?: string
    token: string
    email?: string | null
    planId?: string | null
    priceId?: string | null
    offerId?: string | null
    couponId?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type OnboardingInviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfrastructureMetricCreateInput = {
    id?: string
    service: $Enums.InfrastructureService
    metric: $Enums.MetricType
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InfrastructureMetricUncheckedCreateInput = {
    id?: string
    service: $Enums.InfrastructureService
    metric: $Enums.MetricType
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InfrastructureMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    metric?: EnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InfrastructureMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    metric?: EnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InfrastructureMetricCreateManyInput = {
    id?: string
    service: $Enums.InfrastructureService
    metric: $Enums.MetricType
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InfrastructureMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    metric?: EnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InfrastructureMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    metric?: EnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InfrastructureLimitCreateInput = {
    id?: string
    service: $Enums.InfrastructureService
    metric: $Enums.MetricType
    currentPlan: string
    limitValue: number
    warningPercent?: number
    criticalPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfrastructureLimitUncheckedCreateInput = {
    id?: string
    service: $Enums.InfrastructureService
    metric: $Enums.MetricType
    currentPlan: string
    limitValue: number
    warningPercent?: number
    criticalPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfrastructureLimitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    metric?: EnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType
    currentPlan?: StringFieldUpdateOperationsInput | string
    limitValue?: FloatFieldUpdateOperationsInput | number
    warningPercent?: FloatFieldUpdateOperationsInput | number
    criticalPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfrastructureLimitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    metric?: EnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType
    currentPlan?: StringFieldUpdateOperationsInput | string
    limitValue?: FloatFieldUpdateOperationsInput | number
    warningPercent?: FloatFieldUpdateOperationsInput | number
    criticalPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfrastructureLimitCreateManyInput = {
    id?: string
    service: $Enums.InfrastructureService
    metric: $Enums.MetricType
    currentPlan: string
    limitValue: number
    warningPercent?: number
    criticalPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfrastructureLimitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    metric?: EnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType
    currentPlan?: StringFieldUpdateOperationsInput | string
    limitValue?: FloatFieldUpdateOperationsInput | number
    warningPercent?: FloatFieldUpdateOperationsInput | number
    criticalPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfrastructureLimitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    metric?: EnumMetricTypeFieldUpdateOperationsInput | $Enums.MetricType
    currentPlan?: StringFieldUpdateOperationsInput | string
    limitValue?: FloatFieldUpdateOperationsInput | number
    warningPercent?: FloatFieldUpdateOperationsInput | number
    criticalPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobCreateInput = {
    id?: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutImportJobsInput
    user: UserCreateNestedOneWithoutImportJobsInput
    mapping?: ImportMappingCreateNestedOneWithoutJobsInput
    errors?: ImportErrorCreateNestedManyWithoutImportJobInput
  }

  export type ImportJobUncheckedCreateInput = {
    id?: string
    orgId: string
    userId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    mappingId?: string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    errors?: ImportErrorUncheckedCreateNestedManyWithoutImportJobInput
  }

  export type ImportJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutImportJobsNestedInput
    user?: UserUpdateOneRequiredWithoutImportJobsNestedInput
    mapping?: ImportMappingUpdateOneWithoutJobsNestedInput
    errors?: ImportErrorUpdateManyWithoutImportJobNestedInput
  }

  export type ImportJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    mappingId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: ImportErrorUncheckedUpdateManyWithoutImportJobNestedInput
  }

  export type ImportJobCreateManyInput = {
    id?: string
    orgId: string
    userId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    mappingId?: string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    mappingId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportMappingCreateInput = {
    id?: string
    name: string
    entityType: $Enums.ImportEntityType
    sourceFormat: string
    fieldMappings: JsonNullValueInput | InputJsonValue
    transformRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isTemplate?: boolean
    useCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutImportMappingsInput
    jobs?: ImportJobCreateNestedManyWithoutMappingInput
  }

  export type ImportMappingUncheckedCreateInput = {
    id?: string
    orgId: string
    name: string
    entityType: $Enums.ImportEntityType
    sourceFormat: string
    fieldMappings: JsonNullValueInput | InputJsonValue
    transformRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isTemplate?: boolean
    useCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: ImportJobUncheckedCreateNestedManyWithoutMappingInput
  }

  export type ImportMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    sourceFormat?: StringFieldUpdateOperationsInput | string
    fieldMappings?: JsonNullValueInput | InputJsonValue
    transformRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    useCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutImportMappingsNestedInput
    jobs?: ImportJobUpdateManyWithoutMappingNestedInput
  }

  export type ImportMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    sourceFormat?: StringFieldUpdateOperationsInput | string
    fieldMappings?: JsonNullValueInput | InputJsonValue
    transformRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    useCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: ImportJobUncheckedUpdateManyWithoutMappingNestedInput
  }

  export type ImportMappingCreateManyInput = {
    id?: string
    orgId: string
    name: string
    entityType: $Enums.ImportEntityType
    sourceFormat: string
    fieldMappings: JsonNullValueInput | InputJsonValue
    transformRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isTemplate?: boolean
    useCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    sourceFormat?: StringFieldUpdateOperationsInput | string
    fieldMappings?: JsonNullValueInput | InputJsonValue
    transformRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    useCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    sourceFormat?: StringFieldUpdateOperationsInput | string
    fieldMappings?: JsonNullValueInput | InputJsonValue
    transformRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    useCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportErrorCreateInput = {
    id?: string
    rowNumber: number
    fieldName?: string | null
    errorType: string
    errorMessage: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    importJob: ImportJobCreateNestedOneWithoutErrorsInput
  }

  export type ImportErrorUncheckedCreateInput = {
    id?: string
    importJobId: string
    rowNumber: number
    fieldName?: string | null
    errorType: string
    errorMessage: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ImportErrorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    importJob?: ImportJobUpdateOneRequiredWithoutErrorsNestedInput
  }

  export type ImportErrorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    importJobId?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportErrorCreateManyInput = {
    id?: string
    importJobId: string
    rowNumber: number
    fieldName?: string | null
    errorType: string
    errorMessage: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ImportErrorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportErrorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    importJobId?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpgradeRecommendationCreateInput = {
    id?: string
    service: $Enums.InfrastructureService
    currentPlan: string
    recommendedPlan: string
    priority: $Enums.RecommendationPriority
    status?: $Enums.RecommendationStatus
    reason: string
    currentUsage?: number | null
    limitValue?: number | null
    usagePercent?: number | null
    daysToLimit?: number | null
    currentCost?: number | null
    projectedCost?: number | null
    upgradeCost?: number | null
    revenueImpact?: number | null
    profitImpact?: number | null
    roi?: number | null
    benefits?: string | null
    risks?: string | null
    estimatedCostUsd?: number | null
    estimatedSavings?: number | null
    roiMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    acknowledgedAt?: Date | string | null
    implementedAt?: Date | string | null
  }

  export type UpgradeRecommendationUncheckedCreateInput = {
    id?: string
    service: $Enums.InfrastructureService
    currentPlan: string
    recommendedPlan: string
    priority: $Enums.RecommendationPriority
    status?: $Enums.RecommendationStatus
    reason: string
    currentUsage?: number | null
    limitValue?: number | null
    usagePercent?: number | null
    daysToLimit?: number | null
    currentCost?: number | null
    projectedCost?: number | null
    upgradeCost?: number | null
    revenueImpact?: number | null
    profitImpact?: number | null
    roi?: number | null
    benefits?: string | null
    risks?: string | null
    estimatedCostUsd?: number | null
    estimatedSavings?: number | null
    roiMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    acknowledgedAt?: Date | string | null
    implementedAt?: Date | string | null
  }

  export type UpgradeRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    currentPlan?: StringFieldUpdateOperationsInput | string
    recommendedPlan?: StringFieldUpdateOperationsInput | string
    priority?: EnumRecommendationPriorityFieldUpdateOperationsInput | $Enums.RecommendationPriority
    status?: EnumRecommendationStatusFieldUpdateOperationsInput | $Enums.RecommendationStatus
    reason?: StringFieldUpdateOperationsInput | string
    currentUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    limitValue?: NullableFloatFieldUpdateOperationsInput | number | null
    usagePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysToLimit?: NullableIntFieldUpdateOperationsInput | number | null
    currentCost?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    upgradeCost?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    profitImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedSavings?: NullableFloatFieldUpdateOperationsInput | number | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UpgradeRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    currentPlan?: StringFieldUpdateOperationsInput | string
    recommendedPlan?: StringFieldUpdateOperationsInput | string
    priority?: EnumRecommendationPriorityFieldUpdateOperationsInput | $Enums.RecommendationPriority
    status?: EnumRecommendationStatusFieldUpdateOperationsInput | $Enums.RecommendationStatus
    reason?: StringFieldUpdateOperationsInput | string
    currentUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    limitValue?: NullableFloatFieldUpdateOperationsInput | number | null
    usagePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysToLimit?: NullableIntFieldUpdateOperationsInput | number | null
    currentCost?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    upgradeCost?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    profitImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedSavings?: NullableFloatFieldUpdateOperationsInput | number | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UpgradeRecommendationCreateManyInput = {
    id?: string
    service: $Enums.InfrastructureService
    currentPlan: string
    recommendedPlan: string
    priority: $Enums.RecommendationPriority
    status?: $Enums.RecommendationStatus
    reason: string
    currentUsage?: number | null
    limitValue?: number | null
    usagePercent?: number | null
    daysToLimit?: number | null
    currentCost?: number | null
    projectedCost?: number | null
    upgradeCost?: number | null
    revenueImpact?: number | null
    profitImpact?: number | null
    roi?: number | null
    benefits?: string | null
    risks?: string | null
    estimatedCostUsd?: number | null
    estimatedSavings?: number | null
    roiMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    acknowledgedAt?: Date | string | null
    implementedAt?: Date | string | null
  }

  export type UpgradeRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    currentPlan?: StringFieldUpdateOperationsInput | string
    recommendedPlan?: StringFieldUpdateOperationsInput | string
    priority?: EnumRecommendationPriorityFieldUpdateOperationsInput | $Enums.RecommendationPriority
    status?: EnumRecommendationStatusFieldUpdateOperationsInput | $Enums.RecommendationStatus
    reason?: StringFieldUpdateOperationsInput | string
    currentUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    limitValue?: NullableFloatFieldUpdateOperationsInput | number | null
    usagePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysToLimit?: NullableIntFieldUpdateOperationsInput | number | null
    currentCost?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    upgradeCost?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    profitImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedSavings?: NullableFloatFieldUpdateOperationsInput | number | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UpgradeRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: EnumInfrastructureServiceFieldUpdateOperationsInput | $Enums.InfrastructureService
    currentPlan?: StringFieldUpdateOperationsInput | string
    recommendedPlan?: StringFieldUpdateOperationsInput | string
    priority?: EnumRecommendationPriorityFieldUpdateOperationsInput | $Enums.RecommendationPriority
    status?: EnumRecommendationStatusFieldUpdateOperationsInput | $Enums.RecommendationStatus
    reason?: StringFieldUpdateOperationsInput | string
    currentUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    limitValue?: NullableFloatFieldUpdateOperationsInput | number | null
    usagePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysToLimit?: NullableIntFieldUpdateOperationsInput | number | null
    currentCost?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    upgradeCost?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    profitImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    risks?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCostUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedSavings?: NullableFloatFieldUpdateOperationsInput | number | null
    roiMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    implementedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateInput = {
    id?: string
    sessionId: string
    userId: string
    email: string
    role: string
    expiresAt: Date | string
    revoked?: boolean
    revokedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    email: string
    role: string
    expiresAt: Date | string
    revoked?: boolean
    revokedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    email: string
    role: string
    expiresAt: Date | string
    revoked?: boolean
    revokedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumAiPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.AiPlan | EnumAiPlanFieldRefInput<$PrismaModel>
    in?: $Enums.AiPlan[] | ListEnumAiPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiPlan[] | ListEnumAiPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumAiPlanFilter<$PrismaModel> | $Enums.AiPlan
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type BillingLedgerListRelationFilter = {
    every?: BillingLedgerWhereInput
    some?: BillingLedgerWhereInput
    none?: BillingLedgerWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type OpportunityListRelationFilter = {
    every?: OpportunityWhereInput
    some?: OpportunityWhereInput
    none?: OpportunityWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type RfpListRelationFilter = {
    every?: RfpWhereInput
    some?: RfpWhereInput
    none?: RfpWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type RbacRoleListRelationFilter = {
    every?: RbacRoleWhereInput
    some?: RbacRoleWhereInput
    none?: RbacRoleWhereInput
  }

  export type RbacUserRoleListRelationFilter = {
    every?: RbacUserRoleWhereInput
    some?: RbacUserRoleWhereInput
    none?: RbacUserRoleWhereInput
  }

  export type LeadInvoiceListRelationFilter = {
    every?: LeadInvoiceWhereInput
    some?: LeadInvoiceWhereInput
    none?: LeadInvoiceWhereInput
  }

  export type PricingPlanNullableScalarRelationFilter = {
    is?: PricingPlanWhereInput | null
    isNot?: PricingPlanWhereInput | null
  }

  export type AiUsageEventListRelationFilter = {
    every?: AiUsageEventWhereInput
    some?: AiUsageEventWhereInput
    none?: AiUsageEventWhereInput
  }

  export type AiMonthlySummaryListRelationFilter = {
    every?: AiMonthlySummaryWhereInput
    some?: AiMonthlySummaryWhereInput
    none?: AiMonthlySummaryWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type UsageMeterListRelationFilter = {
    every?: UsageMeterWhereInput
    some?: UsageMeterWhereInput
    none?: UsageMeterWhereInput
  }

  export type AddonPurchaseListRelationFilter = {
    every?: AddonPurchaseWhereInput
    some?: AddonPurchaseWhereInput
    none?: AddonPurchaseWhereInput
  }

  export type TenantPriceOverrideListRelationFilter = {
    every?: TenantPriceOverrideWhereInput
    some?: TenantPriceOverrideWhereInput
    none?: TenantPriceOverrideWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ImportJobListRelationFilter = {
    every?: ImportJobWhereInput
    some?: ImportJobWhereInput
    none?: ImportJobWhereInput
  }

  export type ImportMappingListRelationFilter = {
    every?: ImportMappingWhereInput
    some?: ImportMappingWhereInput
    none?: ImportMappingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RfpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RbacRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RbacUserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiUsageEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiMonthlySummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageMeterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddonPurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantPriceOverrideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrgCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    featureFlags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiMonthlyBudgetCents?: SortOrder
    aiCreditBalance?: SortOrder
    aiPlan?: SortOrder
    aiAlerts?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrder
    subscriptionEndDate?: SortOrder
    brandConfig?: SortOrder
    settingsJson?: SortOrder
  }

  export type OrgAvgOrderByAggregateInput = {
    aiMonthlyBudgetCents?: SortOrder
    aiCreditBalance?: SortOrder
  }

  export type OrgMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiMonthlyBudgetCents?: SortOrder
    aiCreditBalance?: SortOrder
    aiPlan?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrder
    subscriptionEndDate?: SortOrder
  }

  export type OrgMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiMonthlyBudgetCents?: SortOrder
    aiCreditBalance?: SortOrder
    aiPlan?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrder
    subscriptionEndDate?: SortOrder
  }

  export type OrgSumOrderByAggregateInput = {
    aiMonthlyBudgetCents?: SortOrder
    aiCreditBalance?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumAiPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiPlan | EnumAiPlanFieldRefInput<$PrismaModel>
    in?: $Enums.AiPlan[] | ListEnumAiPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiPlan[] | ListEnumAiPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumAiPlanWithAggregatesFilter<$PrismaModel> | $Enums.AiPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiPlanFilter<$PrismaModel>
    _max?: NestedEnumAiPlanFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type OrgScalarRelationFilter = {
    is?: OrgWhereInput
    isNot?: OrgWhereInput
  }

  export type UserRecoveryCodeListRelationFilter = {
    every?: UserRecoveryCodeWhereInput
    some?: UserRecoveryCodeWhereInput
    none?: UserRecoveryCodeWhereInput
  }

  export type UserBreakglassAccountNullableScalarRelationFilter = {
    is?: UserBreakglassAccountWhereInput | null
    isNot?: UserBreakglassAccountWhereInput | null
  }

  export type UserSecurityQuestionListRelationFilter = {
    every?: UserSecurityQuestionWhereInput
    some?: UserSecurityQuestionWhereInput
    none?: UserSecurityQuestionWhereInput
  }

  export type UserLoginHistoryListRelationFilter = {
    every?: UserLoginHistoryWhereInput
    some?: UserLoginHistoryWhereInput
    none?: UserLoginHistoryWhereInput
  }

  export type UserDeviceFingerprintListRelationFilter = {
    every?: UserDeviceFingerprintWhereInput
    some?: UserDeviceFingerprintWhereInput
    none?: UserDeviceFingerprintWhereInput
  }

  export type UserRecoveryCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSecurityQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLoginHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDeviceFingerprintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    mustChangePassword?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    lockedUntil?: SortOrder
    failedLoginAttempts?: SortOrder
    lastFailedLogin?: SortOrder
    lastSuccessfulLogin?: SortOrder
    lastPasswordChange?: SortOrder
    totpSecret?: SortOrder
    totpEnabled?: SortOrder
    backupCodesHash?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    mustChangePassword?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    lockedUntil?: SortOrder
    failedLoginAttempts?: SortOrder
    lastFailedLogin?: SortOrder
    lastSuccessfulLogin?: SortOrder
    lastPasswordChange?: SortOrder
    totpSecret?: SortOrder
    totpEnabled?: SortOrder
    backupCodesHash?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    mustChangePassword?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    lockedUntil?: SortOrder
    failedLoginAttempts?: SortOrder
    lastFailedLogin?: SortOrder
    lastSuccessfulLogin?: SortOrder
    lastPasswordChange?: SortOrder
    totpSecret?: SortOrder
    totpEnabled?: SortOrder
    backupCodesHash?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserRecoveryCodeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    usedAt?: SortOrder
    usedFrom?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserRecoveryCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    usedAt?: SortOrder
    usedFrom?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserRecoveryCodeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    usedAt?: SortOrder
    usedFrom?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserSecurityQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSecurityQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSecurityQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
  }

  export type UserBreakglassAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    encryptedEmail?: SortOrder
    encryptedPasswordHash?: SortOrder
    encryptionIV?: SortOrder
    createdAt?: SortOrder
    lastActivatedAt?: SortOrder
    activationCount?: SortOrder
    isEnabled?: SortOrder
    canAutoActivate?: SortOrder
    minDelayMinutes?: SortOrder
  }

  export type UserBreakglassAccountAvgOrderByAggregateInput = {
    activationCount?: SortOrder
    minDelayMinutes?: SortOrder
  }

  export type UserBreakglassAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    encryptedEmail?: SortOrder
    encryptedPasswordHash?: SortOrder
    encryptionIV?: SortOrder
    createdAt?: SortOrder
    lastActivatedAt?: SortOrder
    activationCount?: SortOrder
    isEnabled?: SortOrder
    canAutoActivate?: SortOrder
    minDelayMinutes?: SortOrder
  }

  export type UserBreakglassAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    encryptedEmail?: SortOrder
    encryptedPasswordHash?: SortOrder
    encryptionIV?: SortOrder
    createdAt?: SortOrder
    lastActivatedAt?: SortOrder
    activationCount?: SortOrder
    isEnabled?: SortOrder
    canAutoActivate?: SortOrder
    minDelayMinutes?: SortOrder
  }

  export type UserBreakglassAccountSumOrderByAggregateInput = {
    activationCount?: SortOrder
    minDelayMinutes?: SortOrder
  }

  export type UserDeviceFingerprintUserIdFingerprintCompoundUniqueInput = {
    userId: string
    fingerprint: string
  }

  export type UserDeviceFingerprintCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fingerprint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isTrusted?: SortOrder
    trustScore?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    loginCount?: SortOrder
  }

  export type UserDeviceFingerprintAvgOrderByAggregateInput = {
    trustScore?: SortOrder
    loginCount?: SortOrder
  }

  export type UserDeviceFingerprintMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fingerprint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isTrusted?: SortOrder
    trustScore?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    loginCount?: SortOrder
  }

  export type UserDeviceFingerprintMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fingerprint?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isTrusted?: SortOrder
    trustScore?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    loginCount?: SortOrder
  }

  export type UserDeviceFingerprintSumOrderByAggregateInput = {
    trustScore?: SortOrder
    loginCount?: SortOrder
  }

  export type UserLoginHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    success?: SortOrder
    method?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    country?: SortOrder
    city?: SortOrder
    timestamp?: SortOrder
  }

  export type UserLoginHistoryAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type UserLoginHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    success?: SortOrder
    method?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    country?: SortOrder
    city?: SortOrder
    timestamp?: SortOrder
  }

  export type UserLoginHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    success?: SortOrder
    method?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceFingerprint?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    country?: SortOrder
    city?: SortOrder
    timestamp?: SortOrder
  }

  export type UserLoginHistorySumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type BreakglassActivationLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    reason?: SortOrder
    method?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    delayMinutes?: SortOrder
    verificationSteps?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    notifiedAdmins?: SortOrder
    timestamp?: SortOrder
  }

  export type BreakglassActivationLogAvgOrderByAggregateInput = {
    riskScore?: SortOrder
    delayMinutes?: SortOrder
  }

  export type BreakglassActivationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    reason?: SortOrder
    method?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    delayMinutes?: SortOrder
    verificationSteps?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    notifiedAdmins?: SortOrder
    timestamp?: SortOrder
  }

  export type BreakglassActivationLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    reason?: SortOrder
    method?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    delayMinutes?: SortOrder
    verificationSteps?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    notifiedAdmins?: SortOrder
    timestamp?: SortOrder
  }

  export type BreakglassActivationLogSumOrderByAggregateInput = {
    riskScore?: SortOrder
    delayMinutes?: SortOrder
  }

  export type RecoveryRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    verificationToken?: SortOrder
    verificationCode?: SortOrder
    codeExpiresAt?: SortOrder
    codeAttempts?: SortOrder
    riskScore?: SortOrder
    delayUntil?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    completedAt?: SortOrder
  }

  export type RecoveryRequestAvgOrderByAggregateInput = {
    codeAttempts?: SortOrder
    riskScore?: SortOrder
  }

  export type RecoveryRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    verificationToken?: SortOrder
    verificationCode?: SortOrder
    codeExpiresAt?: SortOrder
    codeAttempts?: SortOrder
    riskScore?: SortOrder
    delayUntil?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    completedAt?: SortOrder
  }

  export type RecoveryRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    verificationToken?: SortOrder
    verificationCode?: SortOrder
    codeExpiresAt?: SortOrder
    codeAttempts?: SortOrder
    riskScore?: SortOrder
    delayUntil?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    completedAt?: SortOrder
  }

  export type RecoveryRequestSumOrderByAggregateInput = {
    codeAttempts?: SortOrder
    riskScore?: SortOrder
  }

  export type EnumLeadSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadSource | EnumLeadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.LeadSource[] | ListEnumLeadSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadSource[] | ListEnumLeadSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadSourceFilter<$PrismaModel> | $Enums.LeadSource
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type LeadInvoiceLineListRelationFilter = {
    every?: LeadInvoiceLineWhereInput
    some?: LeadInvoiceLineWhereInput
    none?: LeadInvoiceLineWhereInput
  }

  export type LeadInvoiceLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    sourceType?: SortOrder
    identityHash?: SortOrder
    company?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phoneE164?: SortOrder
    website?: SortOrder
    serviceCode?: SortOrder
    zip?: SortOrder
    enrichmentJson?: SortOrder
    aiScore?: SortOrder
    scoreFactors?: SortOrder
    systemGenerated?: SortOrder
    convertedAt?: SortOrder
    rfp?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: SortOrder
    notes?: SortOrder
    sourceDetail?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    address?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    aiScore?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    sourceType?: SortOrder
    identityHash?: SortOrder
    company?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phoneE164?: SortOrder
    website?: SortOrder
    serviceCode?: SortOrder
    zip?: SortOrder
    aiScore?: SortOrder
    systemGenerated?: SortOrder
    convertedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: SortOrder
    notes?: SortOrder
    sourceDetail?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    address?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    sourceType?: SortOrder
    identityHash?: SortOrder
    company?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phoneE164?: SortOrder
    website?: SortOrder
    serviceCode?: SortOrder
    zip?: SortOrder
    aiScore?: SortOrder
    systemGenerated?: SortOrder
    convertedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: SortOrder
    notes?: SortOrder
    sourceDetail?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    address?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    aiScore?: SortOrder
  }

  export type EnumLeadSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadSource | EnumLeadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.LeadSource[] | ListEnumLeadSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadSource[] | ListEnumLeadSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadSourceWithAggregatesFilter<$PrismaModel> | $Enums.LeadSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadSourceFilter<$PrismaModel>
    _max?: NestedEnumLeadSourceFilter<$PrismaModel>
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    company?: SortOrder
    primaryName?: SortOrder
    primaryEmail?: SortOrder
    primaryPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    company?: SortOrder
    primaryName?: SortOrder
    primaryEmail?: SortOrder
    primaryPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    company?: SortOrder
    primaryName?: SortOrder
    primaryEmail?: SortOrder
    primaryPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumValueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ValueType | EnumValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ValueType[] | ListEnumValueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ValueType[] | ListEnumValueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumValueTypeFilter<$PrismaModel> | $Enums.ValueType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type OpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    valueType?: SortOrder
    estValue?: SortOrder
    stage?: SortOrder
    ownerId?: SortOrder
    sourceLeadId?: SortOrder
    classification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityAvgOrderByAggregateInput = {
    estValue?: SortOrder
  }

  export type OpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    valueType?: SortOrder
    estValue?: SortOrder
    stage?: SortOrder
    ownerId?: SortOrder
    sourceLeadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    valueType?: SortOrder
    estValue?: SortOrder
    stage?: SortOrder
    ownerId?: SortOrder
    sourceLeadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunitySumOrderByAggregateInput = {
    estValue?: SortOrder
  }

  export type EnumValueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ValueType | EnumValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ValueType[] | ListEnumValueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ValueType[] | ListEnumValueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumValueTypeWithAggregatesFilter<$PrismaModel> | $Enums.ValueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValueTypeFilter<$PrismaModel>
    _max?: NestedEnumValueTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineListRelationFilter = {
    every?: InvoiceLineWhereInput
    some?: InvoiceLineWhereInput
    none?: InvoiceLineWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type InvoiceLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    items?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    receivedAt?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    failureReason?: SortOrder
    retryCount?: SortOrder
    lastRetryAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    retryCount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    receivedAt?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    failureReason?: SortOrder
    retryCount?: SortOrder
    lastRetryAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    receivedAt?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    failureReason?: SortOrder
    retryCount?: SortOrder
    lastRetryAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    retryCount?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RfpCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    sourceSite?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    docs?: SortOrder
    aiBidFit?: SortOrder
    aiPriceHint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RfpAvgOrderByAggregateInput = {
    aiBidFit?: SortOrder
  }

  export type RfpMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    sourceSite?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    aiBidFit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RfpMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    publicId?: SortOrder
    sourceSite?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    aiBidFit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RfpSumOrderByAggregateInput = {
    aiBidFit?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type RfpNullableScalarRelationFilter = {
    is?: RfpWhereInput | null
    isNot?: RfpWhereInput | null
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    rfpId?: SortOrder
    status?: SortOrder
    schedule?: SortOrder
    assignedTo?: SortOrder
    checklist?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    rfpId?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    rfpId?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    employeeId?: SortOrder
    referredName?: SortOrder
    referredEmail?: SortOrder
    referredPhone?: SortOrder
    status?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    employeeId?: SortOrder
    referredName?: SortOrder
    referredEmail?: SortOrder
    referredPhone?: SortOrder
    status?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    employeeId?: SortOrder
    referredName?: SortOrder
    referredEmail?: SortOrder
    referredPhone?: SortOrder
    status?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLedgerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTypeFilter<$PrismaModel> | $Enums.LedgerType
  }

  export type BillingLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingLedgerAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingLedgerSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumLedgerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerTypeFilter<$PrismaModel>
  }

  export type OrgNullableScalarRelationFilter = {
    is?: OrgWhereInput | null
    isNot?: OrgWhereInput | null
  }

  export type LeadInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    number?: SortOrder
    periodFrom?: SortOrder
    periodTo?: SortOrder
    status?: SortOrder
    subtotalCents?: SortOrder
    taxCents?: SortOrder
    totalCents?: SortOrder
    currency?: SortOrder
    stripeInvoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leadCount?: SortOrder
  }

  export type LeadInvoiceAvgOrderByAggregateInput = {
    subtotalCents?: SortOrder
    taxCents?: SortOrder
    totalCents?: SortOrder
    leadCount?: SortOrder
  }

  export type LeadInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    number?: SortOrder
    periodFrom?: SortOrder
    periodTo?: SortOrder
    status?: SortOrder
    subtotalCents?: SortOrder
    taxCents?: SortOrder
    totalCents?: SortOrder
    currency?: SortOrder
    stripeInvoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leadCount?: SortOrder
  }

  export type LeadInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    number?: SortOrder
    periodFrom?: SortOrder
    periodTo?: SortOrder
    status?: SortOrder
    subtotalCents?: SortOrder
    taxCents?: SortOrder
    totalCents?: SortOrder
    currency?: SortOrder
    stripeInvoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leadCount?: SortOrder
  }

  export type LeadInvoiceSumOrderByAggregateInput = {
    subtotalCents?: SortOrder
    taxCents?: SortOrder
    totalCents?: SortOrder
    leadCount?: SortOrder
  }

  export type LeadInvoiceScalarRelationFilter = {
    is?: LeadInvoiceWhereInput
    isNot?: LeadInvoiceWhereInput
  }

  export type LeadNullableScalarRelationFilter = {
    is?: LeadWhereInput | null
    isNot?: LeadWhereInput | null
  }

  export type LeadInvoiceLineCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    leadId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadInvoiceLineAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
  }

  export type LeadInvoiceLineMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    leadId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadInvoiceLineMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    leadId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadInvoiceLineSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    actorUserId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    field?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    actorUserId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    field?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    actorUserId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    field?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type RbacRolePermissionListRelationFilter = {
    every?: RbacRolePermissionWhereInput
    some?: RbacRolePermissionWhereInput
    none?: RbacRolePermissionWhereInput
  }

  export type RbacRolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RbacPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RbacPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RbacPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RbacRoleOrgIdSlugCompoundUniqueInput = {
    orgId: string
    slug: string
  }

  export type RbacRoleCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
  }

  export type RbacRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
  }

  export type RbacRoleMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
  }

  export type RbacRoleScalarRelationFilter = {
    is?: RbacRoleWhereInput
    isNot?: RbacRoleWhereInput
  }

  export type RbacPermissionScalarRelationFilter = {
    is?: RbacPermissionWhereInput
    isNot?: RbacPermissionWhereInput
  }

  export type RbacRolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RbacRolePermissionCountOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RbacRolePermissionMaxOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RbacRolePermissionMinOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RbacUserRoleUserIdRoleIdOrgIdCompoundUniqueInput = {
    userId: string
    roleId: string
    orgId: string
  }

  export type RbacUserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    roleId?: SortOrder
  }

  export type RbacUserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    roleId?: SortOrder
  }

  export type RbacUserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    roleId?: SortOrder
  }

  export type ProviderConfigCountOrderByAggregateInput = {
    id?: SortOrder
    samApiKey?: SortOrder
    stripeSecretKey?: SortOrder
    otherConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    samApiKey?: SortOrder
    stripeSecretKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderConfigMinOrderByAggregateInput = {
    id?: SortOrder
    samApiKey?: SortOrder
    stripeSecretKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPricingModelFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelFilter<$PrismaModel> | $Enums.PricingModel
  }

  export type PricingPlanCountOrderByAggregateInput = {
    orgId?: SortOrder
    model?: SortOrder
    currency?: SortOrder
    unitAmount?: SortOrder
    tiersJson?: SortOrder
    includedUnits?: SortOrder
  }

  export type PricingPlanAvgOrderByAggregateInput = {
    unitAmount?: SortOrder
    includedUnits?: SortOrder
  }

  export type PricingPlanMaxOrderByAggregateInput = {
    orgId?: SortOrder
    model?: SortOrder
    currency?: SortOrder
    unitAmount?: SortOrder
    includedUnits?: SortOrder
  }

  export type PricingPlanMinOrderByAggregateInput = {
    orgId?: SortOrder
    model?: SortOrder
    currency?: SortOrder
    unitAmount?: SortOrder
    includedUnits?: SortOrder
  }

  export type PricingPlanSumOrderByAggregateInput = {
    unitAmount?: SortOrder
    includedUnits?: SortOrder
  }

  export type EnumPricingModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelWithAggregatesFilter<$PrismaModel> | $Enums.PricingModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingModelFilter<$PrismaModel>
    _max?: NestedEnumPricingModelFilter<$PrismaModel>
  }

  export type AiUsageEventCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    model?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
  }

  export type AiUsageEventAvgOrderByAggregateInput = {
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
  }

  export type AiUsageEventMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    model?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
  }

  export type AiUsageEventMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    model?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
  }

  export type AiUsageEventSumOrderByAggregateInput = {
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
  }

  export type AiMonthlySummaryOrgIdMonthKeyCompoundUniqueInput = {
    orgId: string
    monthKey: string
  }

  export type AiMonthlySummaryCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    monthKey?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    callCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiMonthlySummaryAvgOrderByAggregateInput = {
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    callCount?: SortOrder
  }

  export type AiMonthlySummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    monthKey?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    callCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiMonthlySummaryMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    monthKey?: SortOrder
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    callCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiMonthlySummarySumOrderByAggregateInput = {
    tokensIn?: SortOrder
    tokensOut?: SortOrder
    costUsd?: SortOrder
    creditsUsed?: SortOrder
    callCount?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    canceledAt?: SortOrder
    renewsAt?: SortOrder
    priceCents?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    priceCents?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    canceledAt?: SortOrder
    renewsAt?: SortOrder
    priceCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    canceledAt?: SortOrder
    renewsAt?: SortOrder
    priceCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    priceCents?: SortOrder
  }

  export type UsageMeterCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    meter?: SortOrder
    quantity?: SortOrder
    windowStart?: SortOrder
    windowEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageMeterAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UsageMeterMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    meter?: SortOrder
    quantity?: SortOrder
    windowStart?: SortOrder
    windowEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageMeterMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    meter?: SortOrder
    quantity?: SortOrder
    windowStart?: SortOrder
    windowEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageMeterSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type AddonPurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    sku?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    refundedAt?: SortOrder
    meta?: SortOrder
  }

  export type AddonPurchaseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AddonPurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    sku?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    refundedAt?: SortOrder
  }

  export type AddonPurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    sku?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    refundedAt?: SortOrder
  }

  export type AddonPurchaseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FederationKeyCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    keyId?: SortOrder
    secretHash?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    disabledAt?: SortOrder
    rotatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type FederationKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    keyId?: SortOrder
    secretHash?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    disabledAt?: SortOrder
    rotatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type FederationKeyMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    keyId?: SortOrder
    secretHash?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    disabledAt?: SortOrder
    rotatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type OIDCConfigCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    issuerUrl?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastTestedAt?: SortOrder
  }

  export type OIDCConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    issuerUrl?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastTestedAt?: SortOrder
  }

  export type OIDCConfigMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    issuerUrl?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastTestedAt?: SortOrder
  }

  export type ProviderIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncAt?: SortOrder
  }

  export type ProviderIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncAt?: SortOrder
  }

  export type ProviderIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncAt?: SortOrder
  }

  export type AuditEventCountOrderByAggregateInput = {
    id?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventMaxOrderByAggregateInput = {
    id?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventMinOrderByAggregateInput = {
    id?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    snapshotDate?: SortOrder
    mrrCents?: SortOrder
    arrCents?: SortOrder
    activeClients?: SortOrder
    newClients?: SortOrder
    churnedClients?: SortOrder
    totalRevenue?: SortOrder
    metricsJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsSnapshotAvgOrderByAggregateInput = {
    mrrCents?: SortOrder
    arrCents?: SortOrder
    activeClients?: SortOrder
    newClients?: SortOrder
    churnedClients?: SortOrder
    totalRevenue?: SortOrder
  }

  export type AnalyticsSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    snapshotDate?: SortOrder
    mrrCents?: SortOrder
    arrCents?: SortOrder
    activeClients?: SortOrder
    newClients?: SortOrder
    churnedClients?: SortOrder
    totalRevenue?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    snapshotDate?: SortOrder
    mrrCents?: SortOrder
    arrCents?: SortOrder
    activeClients?: SortOrder
    newClients?: SortOrder
    churnedClients?: SortOrder
    totalRevenue?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsSnapshotSumOrderByAggregateInput = {
    mrrCents?: SortOrder
    arrCents?: SortOrder
    activeClients?: SortOrder
    newClients?: SortOrder
    churnedClients?: SortOrder
    totalRevenue?: SortOrder
  }

  export type EnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type EnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assigneeUserId?: SortOrder
    slaResponseDeadline?: SortOrder
    slaResolveDeadline?: SortOrder
    acknowledgedAt?: SortOrder
    resolvedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assigneeUserId?: SortOrder
    slaResponseDeadline?: SortOrder
    slaResolveDeadline?: SortOrder
    acknowledgedAt?: SortOrder
    resolvedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assigneeUserId?: SortOrder
    slaResponseDeadline?: SortOrder
    slaResolveDeadline?: SortOrder
    acknowledgedAt?: SortOrder
    resolvedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type EnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceLineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceLineType | EnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceLineType[] | ListEnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceLineType[] | ListEnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceLineTypeFilter<$PrismaModel> | $Enums.InvoiceLineType
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceLineCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    lineType?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceLineAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
  }

  export type InvoiceLineMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    lineType?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceLineMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    lineType?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceLineSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    amountCents?: SortOrder
  }

  export type EnumInvoiceLineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceLineType | EnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceLineType[] | ListEnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceLineType[] | ListEnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceLineTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceLineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceLineTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceLineTypeFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    audience?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    severity?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    audience?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    severity?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    audience?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    severity?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanPriceListRelationFilter = {
    every?: PlanPriceWhereInput
    some?: PlanPriceWhereInput
    none?: PlanPriceWhereInput
  }

  export type OfferListRelationFilter = {
    every?: OfferWhereInput
    some?: OfferWhereInput
    none?: OfferWhereInput
  }

  export type GlobalMonetizationConfigListRelationFilter = {
    every?: GlobalMonetizationConfigWhereInput
    some?: GlobalMonetizationConfigWhereInput
    none?: GlobalMonetizationConfigWhereInput
  }

  export type OnboardingInviteListRelationFilter = {
    every?: OnboardingInviteWhereInput
    some?: OnboardingInviteWhereInput
    none?: OnboardingInviteWhereInput
  }

  export type PlanPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GlobalMonetizationConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OnboardingInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PricePlanCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricePlanMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricePlanMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBillingCadenceFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCadence | EnumBillingCadenceFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCadence[] | ListEnumBillingCadenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCadence[] | ListEnumBillingCadenceFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCadenceFilter<$PrismaModel> | $Enums.BillingCadence
  }

  export type PricePlanScalarRelationFilter = {
    is?: PricePlanWhereInput
    isNot?: PricePlanWhereInput
  }

  export type PlanPriceCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    unitAmountCents?: SortOrder
    cadence?: SortOrder
    trialDays?: SortOrder
    active?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPriceAvgOrderByAggregateInput = {
    unitAmountCents?: SortOrder
    trialDays?: SortOrder
  }

  export type PlanPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    unitAmountCents?: SortOrder
    cadence?: SortOrder
    trialDays?: SortOrder
    active?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPriceMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    currency?: SortOrder
    unitAmountCents?: SortOrder
    cadence?: SortOrder
    trialDays?: SortOrder
    active?: SortOrder
    stripePriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPriceSumOrderByAggregateInput = {
    unitAmountCents?: SortOrder
    trialDays?: SortOrder
  }

  export type EnumBillingCadenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCadence | EnumBillingCadenceFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCadence[] | ListEnumBillingCadenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCadence[] | ListEnumBillingCadenceFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCadenceWithAggregatesFilter<$PrismaModel> | $Enums.BillingCadence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingCadenceFilter<$PrismaModel>
    _max?: NestedEnumBillingCadenceFilter<$PrismaModel>
  }

  export type PricePlanNullableScalarRelationFilter = {
    is?: PricePlanWhereInput | null
    isNot?: PricePlanWhereInput | null
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrder
    appliesToPlanId?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    durationMonths?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrder
    appliesToPlanId?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrder
    appliesToPlanId?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    durationMonths?: SortOrder
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    maxRedemptions?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    durationMonths?: SortOrder
    maxRedemptions?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    maxRedemptions?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    maxRedemptions?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    durationMonths?: SortOrder
    maxRedemptions?: SortOrder
  }

  export type EnumOverrideTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OverrideType | EnumOverrideTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OverrideType[] | ListEnumOverrideTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OverrideType[] | ListEnumOverrideTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOverrideTypeFilter<$PrismaModel> | $Enums.OverrideType
  }

  export type PlanPriceNullableScalarRelationFilter = {
    is?: PlanPriceWhereInput | null
    isNot?: PlanPriceWhereInput | null
  }

  export type TenantPriceOverrideCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    planId?: SortOrder
    priceId?: SortOrder
    type?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    priceCents?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantPriceOverrideAvgOrderByAggregateInput = {
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    priceCents?: SortOrder
  }

  export type TenantPriceOverrideMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    planId?: SortOrder
    priceId?: SortOrder
    type?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    priceCents?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantPriceOverrideMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    planId?: SortOrder
    priceId?: SortOrder
    type?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    priceCents?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantPriceOverrideSumOrderByAggregateInput = {
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    priceCents?: SortOrder
  }

  export type EnumOverrideTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OverrideType | EnumOverrideTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OverrideType[] | ListEnumOverrideTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OverrideType[] | ListEnumOverrideTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOverrideTypeWithAggregatesFilter<$PrismaModel> | $Enums.OverrideType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOverrideTypeFilter<$PrismaModel>
    _max?: NestedEnumOverrideTypeFilter<$PrismaModel>
  }

  export type GlobalMonetizationConfigCountOrderByAggregateInput = {
    id?: SortOrder
    defaultPlanId?: SortOrder
    defaultPriceId?: SortOrder
    defaultTrialDays?: SortOrder
    publicOnboarding?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalMonetizationConfigAvgOrderByAggregateInput = {
    defaultTrialDays?: SortOrder
  }

  export type GlobalMonetizationConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    defaultPlanId?: SortOrder
    defaultPriceId?: SortOrder
    defaultTrialDays?: SortOrder
    publicOnboarding?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalMonetizationConfigMinOrderByAggregateInput = {
    id?: SortOrder
    defaultPlanId?: SortOrder
    defaultPriceId?: SortOrder
    defaultTrialDays?: SortOrder
    publicOnboarding?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalMonetizationConfigSumOrderByAggregateInput = {
    defaultTrialDays?: SortOrder
  }

  export type OfferNullableScalarRelationFilter = {
    is?: OfferWhereInput | null
    isNot?: OfferWhereInput | null
  }

  export type CouponNullableScalarRelationFilter = {
    is?: CouponWhereInput | null
    isNot?: CouponWhereInput | null
  }

  export type OnboardingInviteCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    planId?: SortOrder
    priceId?: SortOrder
    offerId?: SortOrder
    couponId?: SortOrder
    trialDays?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type OnboardingInviteAvgOrderByAggregateInput = {
    trialDays?: SortOrder
  }

  export type OnboardingInviteMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    planId?: SortOrder
    priceId?: SortOrder
    offerId?: SortOrder
    couponId?: SortOrder
    trialDays?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type OnboardingInviteMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    planId?: SortOrder
    priceId?: SortOrder
    offerId?: SortOrder
    couponId?: SortOrder
    trialDays?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type OnboardingInviteSumOrderByAggregateInput = {
    trialDays?: SortOrder
  }

  export type EnumInfrastructureServiceFilter<$PrismaModel = never> = {
    equals?: $Enums.InfrastructureService | EnumInfrastructureServiceFieldRefInput<$PrismaModel>
    in?: $Enums.InfrastructureService[] | ListEnumInfrastructureServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfrastructureService[] | ListEnumInfrastructureServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumInfrastructureServiceFilter<$PrismaModel> | $Enums.InfrastructureService
  }

  export type EnumMetricTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricType | EnumMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetricTypeFilter<$PrismaModel> | $Enums.MetricType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InfrastructureMetricCountOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type InfrastructureMetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type InfrastructureMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
  }

  export type InfrastructureMetricMinOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
  }

  export type InfrastructureMetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumInfrastructureServiceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InfrastructureService | EnumInfrastructureServiceFieldRefInput<$PrismaModel>
    in?: $Enums.InfrastructureService[] | ListEnumInfrastructureServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfrastructureService[] | ListEnumInfrastructureServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumInfrastructureServiceWithAggregatesFilter<$PrismaModel> | $Enums.InfrastructureService
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInfrastructureServiceFilter<$PrismaModel>
    _max?: NestedEnumInfrastructureServiceFilter<$PrismaModel>
  }

  export type EnumMetricTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricType | EnumMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetricTypeWithAggregatesFilter<$PrismaModel> | $Enums.MetricType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetricTypeFilter<$PrismaModel>
    _max?: NestedEnumMetricTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type InfrastructureLimitServiceMetricCurrentPlanCompoundUniqueInput = {
    service: $Enums.InfrastructureService
    metric: $Enums.MetricType
    currentPlan: string
  }

  export type InfrastructureLimitCountOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    metric?: SortOrder
    currentPlan?: SortOrder
    limitValue?: SortOrder
    warningPercent?: SortOrder
    criticalPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfrastructureLimitAvgOrderByAggregateInput = {
    limitValue?: SortOrder
    warningPercent?: SortOrder
    criticalPercent?: SortOrder
  }

  export type InfrastructureLimitMaxOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    metric?: SortOrder
    currentPlan?: SortOrder
    limitValue?: SortOrder
    warningPercent?: SortOrder
    criticalPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfrastructureLimitMinOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    metric?: SortOrder
    currentPlan?: SortOrder
    limitValue?: SortOrder
    warningPercent?: SortOrder
    criticalPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfrastructureLimitSumOrderByAggregateInput = {
    limitValue?: SortOrder
    warningPercent?: SortOrder
    criticalPercent?: SortOrder
  }

  export type EnumImportEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportEntityType | EnumImportEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportEntityTypeFilter<$PrismaModel> | $Enums.ImportEntityType
  }

  export type EnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type ImportMappingNullableScalarRelationFilter = {
    is?: ImportMappingWhereInput | null
    isNot?: ImportMappingWhereInput | null
  }

  export type ImportErrorListRelationFilter = {
    every?: ImportErrorWhereInput
    some?: ImportErrorWhereInput
    none?: ImportErrorWhereInput
  }

  export type ImportErrorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportJobCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    totalRecords?: SortOrder
    processedRecords?: SortOrder
    successCount?: SortOrder
    errorCount?: SortOrder
    skipCount?: SortOrder
    mappingId?: SortOrder
    sampleData?: SortOrder
    fieldMappings?: SortOrder
    transformRules?: SortOrder
    validationRules?: SortOrder
    progressPercent?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorSummary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportJobAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    totalRecords?: SortOrder
    processedRecords?: SortOrder
    successCount?: SortOrder
    errorCount?: SortOrder
    skipCount?: SortOrder
    progressPercent?: SortOrder
  }

  export type ImportJobMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    totalRecords?: SortOrder
    processedRecords?: SortOrder
    successCount?: SortOrder
    errorCount?: SortOrder
    skipCount?: SortOrder
    mappingId?: SortOrder
    progressPercent?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorSummary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportJobMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    totalRecords?: SortOrder
    processedRecords?: SortOrder
    successCount?: SortOrder
    errorCount?: SortOrder
    skipCount?: SortOrder
    mappingId?: SortOrder
    progressPercent?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorSummary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportJobSumOrderByAggregateInput = {
    fileSize?: SortOrder
    totalRecords?: SortOrder
    processedRecords?: SortOrder
    successCount?: SortOrder
    errorCount?: SortOrder
    skipCount?: SortOrder
    progressPercent?: SortOrder
  }

  export type EnumImportEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportEntityType | EnumImportEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImportEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumImportEntityTypeFilter<$PrismaModel>
  }

  export type EnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }

  export type ImportMappingCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    entityType?: SortOrder
    sourceFormat?: SortOrder
    fieldMappings?: SortOrder
    transformRules?: SortOrder
    validationRules?: SortOrder
    isTemplate?: SortOrder
    useCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportMappingAvgOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type ImportMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    entityType?: SortOrder
    sourceFormat?: SortOrder
    isTemplate?: SortOrder
    useCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportMappingMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    entityType?: SortOrder
    sourceFormat?: SortOrder
    isTemplate?: SortOrder
    useCount?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportMappingSumOrderByAggregateInput = {
    useCount?: SortOrder
  }

  export type ImportJobScalarRelationFilter = {
    is?: ImportJobWhereInput
    isNot?: ImportJobWhereInput
  }

  export type ImportErrorCountOrderByAggregateInput = {
    id?: SortOrder
    importJobId?: SortOrder
    rowNumber?: SortOrder
    fieldName?: SortOrder
    errorType?: SortOrder
    errorMessage?: SortOrder
    rawData?: SortOrder
    createdAt?: SortOrder
  }

  export type ImportErrorAvgOrderByAggregateInput = {
    rowNumber?: SortOrder
  }

  export type ImportErrorMaxOrderByAggregateInput = {
    id?: SortOrder
    importJobId?: SortOrder
    rowNumber?: SortOrder
    fieldName?: SortOrder
    errorType?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type ImportErrorMinOrderByAggregateInput = {
    id?: SortOrder
    importJobId?: SortOrder
    rowNumber?: SortOrder
    fieldName?: SortOrder
    errorType?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type ImportErrorSumOrderByAggregateInput = {
    rowNumber?: SortOrder
  }

  export type EnumRecommendationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationPriority | EnumRecommendationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendationPriority[] | ListEnumRecommendationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendationPriority[] | ListEnumRecommendationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendationPriorityFilter<$PrismaModel> | $Enums.RecommendationPriority
  }

  export type EnumRecommendationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationStatus | EnumRecommendationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendationStatus[] | ListEnumRecommendationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendationStatus[] | ListEnumRecommendationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendationStatusFilter<$PrismaModel> | $Enums.RecommendationStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UpgradeRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    currentPlan?: SortOrder
    recommendedPlan?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    currentUsage?: SortOrder
    limitValue?: SortOrder
    usagePercent?: SortOrder
    daysToLimit?: SortOrder
    currentCost?: SortOrder
    projectedCost?: SortOrder
    upgradeCost?: SortOrder
    revenueImpact?: SortOrder
    profitImpact?: SortOrder
    roi?: SortOrder
    benefits?: SortOrder
    risks?: SortOrder
    estimatedCostUsd?: SortOrder
    estimatedSavings?: SortOrder
    roiMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acknowledgedAt?: SortOrder
    implementedAt?: SortOrder
  }

  export type UpgradeRecommendationAvgOrderByAggregateInput = {
    currentUsage?: SortOrder
    limitValue?: SortOrder
    usagePercent?: SortOrder
    daysToLimit?: SortOrder
    currentCost?: SortOrder
    projectedCost?: SortOrder
    upgradeCost?: SortOrder
    revenueImpact?: SortOrder
    profitImpact?: SortOrder
    roi?: SortOrder
    estimatedCostUsd?: SortOrder
    estimatedSavings?: SortOrder
    roiMonths?: SortOrder
  }

  export type UpgradeRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    currentPlan?: SortOrder
    recommendedPlan?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    currentUsage?: SortOrder
    limitValue?: SortOrder
    usagePercent?: SortOrder
    daysToLimit?: SortOrder
    currentCost?: SortOrder
    projectedCost?: SortOrder
    upgradeCost?: SortOrder
    revenueImpact?: SortOrder
    profitImpact?: SortOrder
    roi?: SortOrder
    benefits?: SortOrder
    risks?: SortOrder
    estimatedCostUsd?: SortOrder
    estimatedSavings?: SortOrder
    roiMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acknowledgedAt?: SortOrder
    implementedAt?: SortOrder
  }

  export type UpgradeRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    currentPlan?: SortOrder
    recommendedPlan?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    currentUsage?: SortOrder
    limitValue?: SortOrder
    usagePercent?: SortOrder
    daysToLimit?: SortOrder
    currentCost?: SortOrder
    projectedCost?: SortOrder
    upgradeCost?: SortOrder
    revenueImpact?: SortOrder
    profitImpact?: SortOrder
    roi?: SortOrder
    benefits?: SortOrder
    risks?: SortOrder
    estimatedCostUsd?: SortOrder
    estimatedSavings?: SortOrder
    roiMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acknowledgedAt?: SortOrder
    implementedAt?: SortOrder
  }

  export type UpgradeRecommendationSumOrderByAggregateInput = {
    currentUsage?: SortOrder
    limitValue?: SortOrder
    usagePercent?: SortOrder
    daysToLimit?: SortOrder
    currentCost?: SortOrder
    projectedCost?: SortOrder
    upgradeCost?: SortOrder
    revenueImpact?: SortOrder
    profitImpact?: SortOrder
    roi?: SortOrder
    estimatedCostUsd?: SortOrder
    estimatedSavings?: SortOrder
    roiMonths?: SortOrder
  }

  export type EnumRecommendationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationPriority | EnumRecommendationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendationPriority[] | ListEnumRecommendationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendationPriority[] | ListEnumRecommendationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.RecommendationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecommendationPriorityFilter<$PrismaModel>
    _max?: NestedEnumRecommendationPriorityFilter<$PrismaModel>
  }

  export type EnumRecommendationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationStatus | EnumRecommendationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendationStatus[] | ListEnumRecommendationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendationStatus[] | ListEnumRecommendationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendationStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecommendationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecommendationStatusFilter<$PrismaModel>
    _max?: NestedEnumRecommendationStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditLogCreateNestedManyWithoutOrgInput = {
    create?: XOR<AuditLogCreateWithoutOrgInput, AuditLogUncheckedCreateWithoutOrgInput> | AuditLogCreateWithoutOrgInput[] | AuditLogUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOrgInput | AuditLogCreateOrConnectWithoutOrgInput[]
    createMany?: AuditLogCreateManyOrgInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BillingLedgerCreateNestedManyWithoutOrgInput = {
    create?: XOR<BillingLedgerCreateWithoutOrgInput, BillingLedgerUncheckedCreateWithoutOrgInput> | BillingLedgerCreateWithoutOrgInput[] | BillingLedgerUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: BillingLedgerCreateOrConnectWithoutOrgInput | BillingLedgerCreateOrConnectWithoutOrgInput[]
    createMany?: BillingLedgerCreateManyOrgInputEnvelope
    connect?: BillingLedgerWhereUniqueInput | BillingLedgerWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutOrgInput = {
    create?: XOR<CustomerCreateWithoutOrgInput, CustomerUncheckedCreateWithoutOrgInput> | CustomerCreateWithoutOrgInput[] | CustomerUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrgInput | CustomerCreateOrConnectWithoutOrgInput[]
    createMany?: CustomerCreateManyOrgInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutOrgInput = {
    create?: XOR<InvoiceCreateWithoutOrgInput, InvoiceUncheckedCreateWithoutOrgInput> | InvoiceCreateWithoutOrgInput[] | InvoiceUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrgInput | InvoiceCreateOrConnectWithoutOrgInput[]
    createMany?: InvoiceCreateManyOrgInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutOrgInput = {
    create?: XOR<JobCreateWithoutOrgInput, JobUncheckedCreateWithoutOrgInput> | JobCreateWithoutOrgInput[] | JobUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: JobCreateOrConnectWithoutOrgInput | JobCreateOrConnectWithoutOrgInput[]
    createMany?: JobCreateManyOrgInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutOrgInput = {
    create?: XOR<LeadCreateWithoutOrgInput, LeadUncheckedCreateWithoutOrgInput> | LeadCreateWithoutOrgInput[] | LeadUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOrgInput | LeadCreateOrConnectWithoutOrgInput[]
    createMany?: LeadCreateManyOrgInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutOrgInput = {
    create?: XOR<OpportunityCreateWithoutOrgInput, OpportunityUncheckedCreateWithoutOrgInput> | OpportunityCreateWithoutOrgInput[] | OpportunityUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutOrgInput | OpportunityCreateOrConnectWithoutOrgInput[]
    createMany?: OpportunityCreateManyOrgInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrgInput = {
    create?: XOR<PaymentCreateWithoutOrgInput, PaymentUncheckedCreateWithoutOrgInput> | PaymentCreateWithoutOrgInput[] | PaymentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrgInput | PaymentCreateOrConnectWithoutOrgInput[]
    createMany?: PaymentCreateManyOrgInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutOrgInput = {
    create?: XOR<ReferralCreateWithoutOrgInput, ReferralUncheckedCreateWithoutOrgInput> | ReferralCreateWithoutOrgInput[] | ReferralUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutOrgInput | ReferralCreateOrConnectWithoutOrgInput[]
    createMany?: ReferralCreateManyOrgInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type RfpCreateNestedManyWithoutOrgInput = {
    create?: XOR<RfpCreateWithoutOrgInput, RfpUncheckedCreateWithoutOrgInput> | RfpCreateWithoutOrgInput[] | RfpUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RfpCreateOrConnectWithoutOrgInput | RfpCreateOrConnectWithoutOrgInput[]
    createMany?: RfpCreateManyOrgInputEnvelope
    connect?: RfpWhereUniqueInput | RfpWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutOrgInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput> | UserCreateWithoutOrgInput[] | UserUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput | UserCreateOrConnectWithoutOrgInput[]
    createMany?: UserCreateManyOrgInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RbacRoleCreateNestedManyWithoutOrgInput = {
    create?: XOR<RbacRoleCreateWithoutOrgInput, RbacRoleUncheckedCreateWithoutOrgInput> | RbacRoleCreateWithoutOrgInput[] | RbacRoleUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RbacRoleCreateOrConnectWithoutOrgInput | RbacRoleCreateOrConnectWithoutOrgInput[]
    createMany?: RbacRoleCreateManyOrgInputEnvelope
    connect?: RbacRoleWhereUniqueInput | RbacRoleWhereUniqueInput[]
  }

  export type RbacUserRoleCreateNestedManyWithoutOrgInput = {
    create?: XOR<RbacUserRoleCreateWithoutOrgInput, RbacUserRoleUncheckedCreateWithoutOrgInput> | RbacUserRoleCreateWithoutOrgInput[] | RbacUserRoleUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutOrgInput | RbacUserRoleCreateOrConnectWithoutOrgInput[]
    createMany?: RbacUserRoleCreateManyOrgInputEnvelope
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
  }

  export type LeadInvoiceCreateNestedManyWithoutOrgInput = {
    create?: XOR<LeadInvoiceCreateWithoutOrgInput, LeadInvoiceUncheckedCreateWithoutOrgInput> | LeadInvoiceCreateWithoutOrgInput[] | LeadInvoiceUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: LeadInvoiceCreateOrConnectWithoutOrgInput | LeadInvoiceCreateOrConnectWithoutOrgInput[]
    createMany?: LeadInvoiceCreateManyOrgInputEnvelope
    connect?: LeadInvoiceWhereUniqueInput | LeadInvoiceWhereUniqueInput[]
  }

  export type PricingPlanCreateNestedOneWithoutOrgInput = {
    create?: XOR<PricingPlanCreateWithoutOrgInput, PricingPlanUncheckedCreateWithoutOrgInput>
    connectOrCreate?: PricingPlanCreateOrConnectWithoutOrgInput
    connect?: PricingPlanWhereUniqueInput
  }

  export type AiUsageEventCreateNestedManyWithoutOrgInput = {
    create?: XOR<AiUsageEventCreateWithoutOrgInput, AiUsageEventUncheckedCreateWithoutOrgInput> | AiUsageEventCreateWithoutOrgInput[] | AiUsageEventUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AiUsageEventCreateOrConnectWithoutOrgInput | AiUsageEventCreateOrConnectWithoutOrgInput[]
    createMany?: AiUsageEventCreateManyOrgInputEnvelope
    connect?: AiUsageEventWhereUniqueInput | AiUsageEventWhereUniqueInput[]
  }

  export type AiMonthlySummaryCreateNestedManyWithoutOrgInput = {
    create?: XOR<AiMonthlySummaryCreateWithoutOrgInput, AiMonthlySummaryUncheckedCreateWithoutOrgInput> | AiMonthlySummaryCreateWithoutOrgInput[] | AiMonthlySummaryUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AiMonthlySummaryCreateOrConnectWithoutOrgInput | AiMonthlySummaryCreateOrConnectWithoutOrgInput[]
    createMany?: AiMonthlySummaryCreateManyOrgInputEnvelope
    connect?: AiMonthlySummaryWhereUniqueInput | AiMonthlySummaryWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutOrgInput = {
    create?: XOR<ActivityCreateWithoutOrgInput, ActivityUncheckedCreateWithoutOrgInput> | ActivityCreateWithoutOrgInput[] | ActivityUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOrgInput | ActivityCreateOrConnectWithoutOrgInput[]
    createMany?: ActivityCreateManyOrgInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutOrgInput = {
    create?: XOR<SubscriptionCreateWithoutOrgInput, SubscriptionUncheckedCreateWithoutOrgInput> | SubscriptionCreateWithoutOrgInput[] | SubscriptionUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrgInput | SubscriptionCreateOrConnectWithoutOrgInput[]
    createMany?: SubscriptionCreateManyOrgInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type UsageMeterCreateNestedManyWithoutOrgInput = {
    create?: XOR<UsageMeterCreateWithoutOrgInput, UsageMeterUncheckedCreateWithoutOrgInput> | UsageMeterCreateWithoutOrgInput[] | UsageMeterUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UsageMeterCreateOrConnectWithoutOrgInput | UsageMeterCreateOrConnectWithoutOrgInput[]
    createMany?: UsageMeterCreateManyOrgInputEnvelope
    connect?: UsageMeterWhereUniqueInput | UsageMeterWhereUniqueInput[]
  }

  export type AddonPurchaseCreateNestedManyWithoutOrgInput = {
    create?: XOR<AddonPurchaseCreateWithoutOrgInput, AddonPurchaseUncheckedCreateWithoutOrgInput> | AddonPurchaseCreateWithoutOrgInput[] | AddonPurchaseUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AddonPurchaseCreateOrConnectWithoutOrgInput | AddonPurchaseCreateOrConnectWithoutOrgInput[]
    createMany?: AddonPurchaseCreateManyOrgInputEnvelope
    connect?: AddonPurchaseWhereUniqueInput | AddonPurchaseWhereUniqueInput[]
  }

  export type TenantPriceOverrideCreateNestedManyWithoutOrgInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutOrgInput, TenantPriceOverrideUncheckedCreateWithoutOrgInput> | TenantPriceOverrideCreateWithoutOrgInput[] | TenantPriceOverrideUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutOrgInput | TenantPriceOverrideCreateOrConnectWithoutOrgInput[]
    createMany?: TenantPriceOverrideCreateManyOrgInputEnvelope
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutOrgInput = {
    create?: XOR<IncidentCreateWithoutOrgInput, IncidentUncheckedCreateWithoutOrgInput> | IncidentCreateWithoutOrgInput[] | IncidentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutOrgInput | IncidentCreateOrConnectWithoutOrgInput[]
    createMany?: IncidentCreateManyOrgInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutOrgInput = {
    create?: XOR<NotificationCreateWithoutOrgInput, NotificationUncheckedCreateWithoutOrgInput> | NotificationCreateWithoutOrgInput[] | NotificationUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrgInput | NotificationCreateOrConnectWithoutOrgInput[]
    createMany?: NotificationCreateManyOrgInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ImportJobCreateNestedManyWithoutOrgInput = {
    create?: XOR<ImportJobCreateWithoutOrgInput, ImportJobUncheckedCreateWithoutOrgInput> | ImportJobCreateWithoutOrgInput[] | ImportJobUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutOrgInput | ImportJobCreateOrConnectWithoutOrgInput[]
    createMany?: ImportJobCreateManyOrgInputEnvelope
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
  }

  export type ImportMappingCreateNestedManyWithoutOrgInput = {
    create?: XOR<ImportMappingCreateWithoutOrgInput, ImportMappingUncheckedCreateWithoutOrgInput> | ImportMappingCreateWithoutOrgInput[] | ImportMappingUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ImportMappingCreateOrConnectWithoutOrgInput | ImportMappingCreateOrConnectWithoutOrgInput[]
    createMany?: ImportMappingCreateManyOrgInputEnvelope
    connect?: ImportMappingWhereUniqueInput | ImportMappingWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<AuditLogCreateWithoutOrgInput, AuditLogUncheckedCreateWithoutOrgInput> | AuditLogCreateWithoutOrgInput[] | AuditLogUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOrgInput | AuditLogCreateOrConnectWithoutOrgInput[]
    createMany?: AuditLogCreateManyOrgInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BillingLedgerUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<BillingLedgerCreateWithoutOrgInput, BillingLedgerUncheckedCreateWithoutOrgInput> | BillingLedgerCreateWithoutOrgInput[] | BillingLedgerUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: BillingLedgerCreateOrConnectWithoutOrgInput | BillingLedgerCreateOrConnectWithoutOrgInput[]
    createMany?: BillingLedgerCreateManyOrgInputEnvelope
    connect?: BillingLedgerWhereUniqueInput | BillingLedgerWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<CustomerCreateWithoutOrgInput, CustomerUncheckedCreateWithoutOrgInput> | CustomerCreateWithoutOrgInput[] | CustomerUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrgInput | CustomerCreateOrConnectWithoutOrgInput[]
    createMany?: CustomerCreateManyOrgInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<InvoiceCreateWithoutOrgInput, InvoiceUncheckedCreateWithoutOrgInput> | InvoiceCreateWithoutOrgInput[] | InvoiceUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrgInput | InvoiceCreateOrConnectWithoutOrgInput[]
    createMany?: InvoiceCreateManyOrgInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<JobCreateWithoutOrgInput, JobUncheckedCreateWithoutOrgInput> | JobCreateWithoutOrgInput[] | JobUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: JobCreateOrConnectWithoutOrgInput | JobCreateOrConnectWithoutOrgInput[]
    createMany?: JobCreateManyOrgInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<LeadCreateWithoutOrgInput, LeadUncheckedCreateWithoutOrgInput> | LeadCreateWithoutOrgInput[] | LeadUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOrgInput | LeadCreateOrConnectWithoutOrgInput[]
    createMany?: LeadCreateManyOrgInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<OpportunityCreateWithoutOrgInput, OpportunityUncheckedCreateWithoutOrgInput> | OpportunityCreateWithoutOrgInput[] | OpportunityUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutOrgInput | OpportunityCreateOrConnectWithoutOrgInput[]
    createMany?: OpportunityCreateManyOrgInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<PaymentCreateWithoutOrgInput, PaymentUncheckedCreateWithoutOrgInput> | PaymentCreateWithoutOrgInput[] | PaymentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrgInput | PaymentCreateOrConnectWithoutOrgInput[]
    createMany?: PaymentCreateManyOrgInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<ReferralCreateWithoutOrgInput, ReferralUncheckedCreateWithoutOrgInput> | ReferralCreateWithoutOrgInput[] | ReferralUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutOrgInput | ReferralCreateOrConnectWithoutOrgInput[]
    createMany?: ReferralCreateManyOrgInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type RfpUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<RfpCreateWithoutOrgInput, RfpUncheckedCreateWithoutOrgInput> | RfpCreateWithoutOrgInput[] | RfpUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RfpCreateOrConnectWithoutOrgInput | RfpCreateOrConnectWithoutOrgInput[]
    createMany?: RfpCreateManyOrgInputEnvelope
    connect?: RfpWhereUniqueInput | RfpWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput> | UserCreateWithoutOrgInput[] | UserUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput | UserCreateOrConnectWithoutOrgInput[]
    createMany?: UserCreateManyOrgInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RbacRoleUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<RbacRoleCreateWithoutOrgInput, RbacRoleUncheckedCreateWithoutOrgInput> | RbacRoleCreateWithoutOrgInput[] | RbacRoleUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RbacRoleCreateOrConnectWithoutOrgInput | RbacRoleCreateOrConnectWithoutOrgInput[]
    createMany?: RbacRoleCreateManyOrgInputEnvelope
    connect?: RbacRoleWhereUniqueInput | RbacRoleWhereUniqueInput[]
  }

  export type RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<RbacUserRoleCreateWithoutOrgInput, RbacUserRoleUncheckedCreateWithoutOrgInput> | RbacUserRoleCreateWithoutOrgInput[] | RbacUserRoleUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutOrgInput | RbacUserRoleCreateOrConnectWithoutOrgInput[]
    createMany?: RbacUserRoleCreateManyOrgInputEnvelope
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
  }

  export type LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<LeadInvoiceCreateWithoutOrgInput, LeadInvoiceUncheckedCreateWithoutOrgInput> | LeadInvoiceCreateWithoutOrgInput[] | LeadInvoiceUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: LeadInvoiceCreateOrConnectWithoutOrgInput | LeadInvoiceCreateOrConnectWithoutOrgInput[]
    createMany?: LeadInvoiceCreateManyOrgInputEnvelope
    connect?: LeadInvoiceWhereUniqueInput | LeadInvoiceWhereUniqueInput[]
  }

  export type PricingPlanUncheckedCreateNestedOneWithoutOrgInput = {
    create?: XOR<PricingPlanCreateWithoutOrgInput, PricingPlanUncheckedCreateWithoutOrgInput>
    connectOrCreate?: PricingPlanCreateOrConnectWithoutOrgInput
    connect?: PricingPlanWhereUniqueInput
  }

  export type AiUsageEventUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<AiUsageEventCreateWithoutOrgInput, AiUsageEventUncheckedCreateWithoutOrgInput> | AiUsageEventCreateWithoutOrgInput[] | AiUsageEventUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AiUsageEventCreateOrConnectWithoutOrgInput | AiUsageEventCreateOrConnectWithoutOrgInput[]
    createMany?: AiUsageEventCreateManyOrgInputEnvelope
    connect?: AiUsageEventWhereUniqueInput | AiUsageEventWhereUniqueInput[]
  }

  export type AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<AiMonthlySummaryCreateWithoutOrgInput, AiMonthlySummaryUncheckedCreateWithoutOrgInput> | AiMonthlySummaryCreateWithoutOrgInput[] | AiMonthlySummaryUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AiMonthlySummaryCreateOrConnectWithoutOrgInput | AiMonthlySummaryCreateOrConnectWithoutOrgInput[]
    createMany?: AiMonthlySummaryCreateManyOrgInputEnvelope
    connect?: AiMonthlySummaryWhereUniqueInput | AiMonthlySummaryWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<ActivityCreateWithoutOrgInput, ActivityUncheckedCreateWithoutOrgInput> | ActivityCreateWithoutOrgInput[] | ActivityUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOrgInput | ActivityCreateOrConnectWithoutOrgInput[]
    createMany?: ActivityCreateManyOrgInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<SubscriptionCreateWithoutOrgInput, SubscriptionUncheckedCreateWithoutOrgInput> | SubscriptionCreateWithoutOrgInput[] | SubscriptionUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrgInput | SubscriptionCreateOrConnectWithoutOrgInput[]
    createMany?: SubscriptionCreateManyOrgInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type UsageMeterUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<UsageMeterCreateWithoutOrgInput, UsageMeterUncheckedCreateWithoutOrgInput> | UsageMeterCreateWithoutOrgInput[] | UsageMeterUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UsageMeterCreateOrConnectWithoutOrgInput | UsageMeterCreateOrConnectWithoutOrgInput[]
    createMany?: UsageMeterCreateManyOrgInputEnvelope
    connect?: UsageMeterWhereUniqueInput | UsageMeterWhereUniqueInput[]
  }

  export type AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<AddonPurchaseCreateWithoutOrgInput, AddonPurchaseUncheckedCreateWithoutOrgInput> | AddonPurchaseCreateWithoutOrgInput[] | AddonPurchaseUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AddonPurchaseCreateOrConnectWithoutOrgInput | AddonPurchaseCreateOrConnectWithoutOrgInput[]
    createMany?: AddonPurchaseCreateManyOrgInputEnvelope
    connect?: AddonPurchaseWhereUniqueInput | AddonPurchaseWhereUniqueInput[]
  }

  export type TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutOrgInput, TenantPriceOverrideUncheckedCreateWithoutOrgInput> | TenantPriceOverrideCreateWithoutOrgInput[] | TenantPriceOverrideUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutOrgInput | TenantPriceOverrideCreateOrConnectWithoutOrgInput[]
    createMany?: TenantPriceOverrideCreateManyOrgInputEnvelope
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<IncidentCreateWithoutOrgInput, IncidentUncheckedCreateWithoutOrgInput> | IncidentCreateWithoutOrgInput[] | IncidentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutOrgInput | IncidentCreateOrConnectWithoutOrgInput[]
    createMany?: IncidentCreateManyOrgInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<NotificationCreateWithoutOrgInput, NotificationUncheckedCreateWithoutOrgInput> | NotificationCreateWithoutOrgInput[] | NotificationUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrgInput | NotificationCreateOrConnectWithoutOrgInput[]
    createMany?: NotificationCreateManyOrgInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ImportJobUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<ImportJobCreateWithoutOrgInput, ImportJobUncheckedCreateWithoutOrgInput> | ImportJobCreateWithoutOrgInput[] | ImportJobUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutOrgInput | ImportJobCreateOrConnectWithoutOrgInput[]
    createMany?: ImportJobCreateManyOrgInputEnvelope
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
  }

  export type ImportMappingUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<ImportMappingCreateWithoutOrgInput, ImportMappingUncheckedCreateWithoutOrgInput> | ImportMappingCreateWithoutOrgInput[] | ImportMappingUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ImportMappingCreateOrConnectWithoutOrgInput | ImportMappingCreateOrConnectWithoutOrgInput[]
    createMany?: ImportMappingCreateManyOrgInputEnvelope
    connect?: ImportMappingWhereUniqueInput | ImportMappingWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumAiPlanFieldUpdateOperationsInput = {
    set?: $Enums.AiPlan
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AuditLogUpdateManyWithoutOrgNestedInput = {
    create?: XOR<AuditLogCreateWithoutOrgInput, AuditLogUncheckedCreateWithoutOrgInput> | AuditLogCreateWithoutOrgInput[] | AuditLogUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOrgInput | AuditLogCreateOrConnectWithoutOrgInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutOrgInput | AuditLogUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: AuditLogCreateManyOrgInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutOrgInput | AuditLogUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutOrgInput | AuditLogUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BillingLedgerUpdateManyWithoutOrgNestedInput = {
    create?: XOR<BillingLedgerCreateWithoutOrgInput, BillingLedgerUncheckedCreateWithoutOrgInput> | BillingLedgerCreateWithoutOrgInput[] | BillingLedgerUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: BillingLedgerCreateOrConnectWithoutOrgInput | BillingLedgerCreateOrConnectWithoutOrgInput[]
    upsert?: BillingLedgerUpsertWithWhereUniqueWithoutOrgInput | BillingLedgerUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: BillingLedgerCreateManyOrgInputEnvelope
    set?: BillingLedgerWhereUniqueInput | BillingLedgerWhereUniqueInput[]
    disconnect?: BillingLedgerWhereUniqueInput | BillingLedgerWhereUniqueInput[]
    delete?: BillingLedgerWhereUniqueInput | BillingLedgerWhereUniqueInput[]
    connect?: BillingLedgerWhereUniqueInput | BillingLedgerWhereUniqueInput[]
    update?: BillingLedgerUpdateWithWhereUniqueWithoutOrgInput | BillingLedgerUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: BillingLedgerUpdateManyWithWhereWithoutOrgInput | BillingLedgerUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: BillingLedgerScalarWhereInput | BillingLedgerScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutOrgNestedInput = {
    create?: XOR<CustomerCreateWithoutOrgInput, CustomerUncheckedCreateWithoutOrgInput> | CustomerCreateWithoutOrgInput[] | CustomerUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrgInput | CustomerCreateOrConnectWithoutOrgInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutOrgInput | CustomerUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: CustomerCreateManyOrgInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutOrgInput | CustomerUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutOrgInput | CustomerUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutOrgNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrgInput, InvoiceUncheckedCreateWithoutOrgInput> | InvoiceCreateWithoutOrgInput[] | InvoiceUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrgInput | InvoiceCreateOrConnectWithoutOrgInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrgInput | InvoiceUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: InvoiceCreateManyOrgInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrgInput | InvoiceUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrgInput | InvoiceUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type JobUpdateManyWithoutOrgNestedInput = {
    create?: XOR<JobCreateWithoutOrgInput, JobUncheckedCreateWithoutOrgInput> | JobCreateWithoutOrgInput[] | JobUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: JobCreateOrConnectWithoutOrgInput | JobCreateOrConnectWithoutOrgInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutOrgInput | JobUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: JobCreateManyOrgInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutOrgInput | JobUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: JobUpdateManyWithWhereWithoutOrgInput | JobUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutOrgNestedInput = {
    create?: XOR<LeadCreateWithoutOrgInput, LeadUncheckedCreateWithoutOrgInput> | LeadCreateWithoutOrgInput[] | LeadUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOrgInput | LeadCreateOrConnectWithoutOrgInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutOrgInput | LeadUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: LeadCreateManyOrgInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutOrgInput | LeadUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutOrgInput | LeadUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutOrgNestedInput = {
    create?: XOR<OpportunityCreateWithoutOrgInput, OpportunityUncheckedCreateWithoutOrgInput> | OpportunityCreateWithoutOrgInput[] | OpportunityUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutOrgInput | OpportunityCreateOrConnectWithoutOrgInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutOrgInput | OpportunityUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: OpportunityCreateManyOrgInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutOrgInput | OpportunityUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutOrgInput | OpportunityUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrgNestedInput = {
    create?: XOR<PaymentCreateWithoutOrgInput, PaymentUncheckedCreateWithoutOrgInput> | PaymentCreateWithoutOrgInput[] | PaymentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrgInput | PaymentCreateOrConnectWithoutOrgInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrgInput | PaymentUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: PaymentCreateManyOrgInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrgInput | PaymentUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrgInput | PaymentUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ReferralCreateWithoutOrgInput, ReferralUncheckedCreateWithoutOrgInput> | ReferralCreateWithoutOrgInput[] | ReferralUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutOrgInput | ReferralCreateOrConnectWithoutOrgInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutOrgInput | ReferralUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ReferralCreateManyOrgInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutOrgInput | ReferralUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutOrgInput | ReferralUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type RfpUpdateManyWithoutOrgNestedInput = {
    create?: XOR<RfpCreateWithoutOrgInput, RfpUncheckedCreateWithoutOrgInput> | RfpCreateWithoutOrgInput[] | RfpUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RfpCreateOrConnectWithoutOrgInput | RfpCreateOrConnectWithoutOrgInput[]
    upsert?: RfpUpsertWithWhereUniqueWithoutOrgInput | RfpUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: RfpCreateManyOrgInputEnvelope
    set?: RfpWhereUniqueInput | RfpWhereUniqueInput[]
    disconnect?: RfpWhereUniqueInput | RfpWhereUniqueInput[]
    delete?: RfpWhereUniqueInput | RfpWhereUniqueInput[]
    connect?: RfpWhereUniqueInput | RfpWhereUniqueInput[]
    update?: RfpUpdateWithWhereUniqueWithoutOrgInput | RfpUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: RfpUpdateManyWithWhereWithoutOrgInput | RfpUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: RfpScalarWhereInput | RfpScalarWhereInput[]
  }

  export type UserUpdateManyWithoutOrgNestedInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput> | UserCreateWithoutOrgInput[] | UserUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput | UserCreateOrConnectWithoutOrgInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrgInput | UserUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: UserCreateManyOrgInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrgInput | UserUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrgInput | UserUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RbacRoleUpdateManyWithoutOrgNestedInput = {
    create?: XOR<RbacRoleCreateWithoutOrgInput, RbacRoleUncheckedCreateWithoutOrgInput> | RbacRoleCreateWithoutOrgInput[] | RbacRoleUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RbacRoleCreateOrConnectWithoutOrgInput | RbacRoleCreateOrConnectWithoutOrgInput[]
    upsert?: RbacRoleUpsertWithWhereUniqueWithoutOrgInput | RbacRoleUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: RbacRoleCreateManyOrgInputEnvelope
    set?: RbacRoleWhereUniqueInput | RbacRoleWhereUniqueInput[]
    disconnect?: RbacRoleWhereUniqueInput | RbacRoleWhereUniqueInput[]
    delete?: RbacRoleWhereUniqueInput | RbacRoleWhereUniqueInput[]
    connect?: RbacRoleWhereUniqueInput | RbacRoleWhereUniqueInput[]
    update?: RbacRoleUpdateWithWhereUniqueWithoutOrgInput | RbacRoleUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: RbacRoleUpdateManyWithWhereWithoutOrgInput | RbacRoleUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: RbacRoleScalarWhereInput | RbacRoleScalarWhereInput[]
  }

  export type RbacUserRoleUpdateManyWithoutOrgNestedInput = {
    create?: XOR<RbacUserRoleCreateWithoutOrgInput, RbacUserRoleUncheckedCreateWithoutOrgInput> | RbacUserRoleCreateWithoutOrgInput[] | RbacUserRoleUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutOrgInput | RbacUserRoleCreateOrConnectWithoutOrgInput[]
    upsert?: RbacUserRoleUpsertWithWhereUniqueWithoutOrgInput | RbacUserRoleUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: RbacUserRoleCreateManyOrgInputEnvelope
    set?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    disconnect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    delete?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    update?: RbacUserRoleUpdateWithWhereUniqueWithoutOrgInput | RbacUserRoleUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: RbacUserRoleUpdateManyWithWhereWithoutOrgInput | RbacUserRoleUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: RbacUserRoleScalarWhereInput | RbacUserRoleScalarWhereInput[]
  }

  export type LeadInvoiceUpdateManyWithoutOrgNestedInput = {
    create?: XOR<LeadInvoiceCreateWithoutOrgInput, LeadInvoiceUncheckedCreateWithoutOrgInput> | LeadInvoiceCreateWithoutOrgInput[] | LeadInvoiceUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: LeadInvoiceCreateOrConnectWithoutOrgInput | LeadInvoiceCreateOrConnectWithoutOrgInput[]
    upsert?: LeadInvoiceUpsertWithWhereUniqueWithoutOrgInput | LeadInvoiceUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: LeadInvoiceCreateManyOrgInputEnvelope
    set?: LeadInvoiceWhereUniqueInput | LeadInvoiceWhereUniqueInput[]
    disconnect?: LeadInvoiceWhereUniqueInput | LeadInvoiceWhereUniqueInput[]
    delete?: LeadInvoiceWhereUniqueInput | LeadInvoiceWhereUniqueInput[]
    connect?: LeadInvoiceWhereUniqueInput | LeadInvoiceWhereUniqueInput[]
    update?: LeadInvoiceUpdateWithWhereUniqueWithoutOrgInput | LeadInvoiceUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: LeadInvoiceUpdateManyWithWhereWithoutOrgInput | LeadInvoiceUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: LeadInvoiceScalarWhereInput | LeadInvoiceScalarWhereInput[]
  }

  export type PricingPlanUpdateOneWithoutOrgNestedInput = {
    create?: XOR<PricingPlanCreateWithoutOrgInput, PricingPlanUncheckedCreateWithoutOrgInput>
    connectOrCreate?: PricingPlanCreateOrConnectWithoutOrgInput
    upsert?: PricingPlanUpsertWithoutOrgInput
    disconnect?: PricingPlanWhereInput | boolean
    delete?: PricingPlanWhereInput | boolean
    connect?: PricingPlanWhereUniqueInput
    update?: XOR<XOR<PricingPlanUpdateToOneWithWhereWithoutOrgInput, PricingPlanUpdateWithoutOrgInput>, PricingPlanUncheckedUpdateWithoutOrgInput>
  }

  export type AiUsageEventUpdateManyWithoutOrgNestedInput = {
    create?: XOR<AiUsageEventCreateWithoutOrgInput, AiUsageEventUncheckedCreateWithoutOrgInput> | AiUsageEventCreateWithoutOrgInput[] | AiUsageEventUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AiUsageEventCreateOrConnectWithoutOrgInput | AiUsageEventCreateOrConnectWithoutOrgInput[]
    upsert?: AiUsageEventUpsertWithWhereUniqueWithoutOrgInput | AiUsageEventUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: AiUsageEventCreateManyOrgInputEnvelope
    set?: AiUsageEventWhereUniqueInput | AiUsageEventWhereUniqueInput[]
    disconnect?: AiUsageEventWhereUniqueInput | AiUsageEventWhereUniqueInput[]
    delete?: AiUsageEventWhereUniqueInput | AiUsageEventWhereUniqueInput[]
    connect?: AiUsageEventWhereUniqueInput | AiUsageEventWhereUniqueInput[]
    update?: AiUsageEventUpdateWithWhereUniqueWithoutOrgInput | AiUsageEventUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: AiUsageEventUpdateManyWithWhereWithoutOrgInput | AiUsageEventUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: AiUsageEventScalarWhereInput | AiUsageEventScalarWhereInput[]
  }

  export type AiMonthlySummaryUpdateManyWithoutOrgNestedInput = {
    create?: XOR<AiMonthlySummaryCreateWithoutOrgInput, AiMonthlySummaryUncheckedCreateWithoutOrgInput> | AiMonthlySummaryCreateWithoutOrgInput[] | AiMonthlySummaryUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AiMonthlySummaryCreateOrConnectWithoutOrgInput | AiMonthlySummaryCreateOrConnectWithoutOrgInput[]
    upsert?: AiMonthlySummaryUpsertWithWhereUniqueWithoutOrgInput | AiMonthlySummaryUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: AiMonthlySummaryCreateManyOrgInputEnvelope
    set?: AiMonthlySummaryWhereUniqueInput | AiMonthlySummaryWhereUniqueInput[]
    disconnect?: AiMonthlySummaryWhereUniqueInput | AiMonthlySummaryWhereUniqueInput[]
    delete?: AiMonthlySummaryWhereUniqueInput | AiMonthlySummaryWhereUniqueInput[]
    connect?: AiMonthlySummaryWhereUniqueInput | AiMonthlySummaryWhereUniqueInput[]
    update?: AiMonthlySummaryUpdateWithWhereUniqueWithoutOrgInput | AiMonthlySummaryUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: AiMonthlySummaryUpdateManyWithWhereWithoutOrgInput | AiMonthlySummaryUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: AiMonthlySummaryScalarWhereInput | AiMonthlySummaryScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ActivityCreateWithoutOrgInput, ActivityUncheckedCreateWithoutOrgInput> | ActivityCreateWithoutOrgInput[] | ActivityUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOrgInput | ActivityCreateOrConnectWithoutOrgInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOrgInput | ActivityUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ActivityCreateManyOrgInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOrgInput | ActivityUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOrgInput | ActivityUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutOrgNestedInput = {
    create?: XOR<SubscriptionCreateWithoutOrgInput, SubscriptionUncheckedCreateWithoutOrgInput> | SubscriptionCreateWithoutOrgInput[] | SubscriptionUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrgInput | SubscriptionCreateOrConnectWithoutOrgInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutOrgInput | SubscriptionUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: SubscriptionCreateManyOrgInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutOrgInput | SubscriptionUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutOrgInput | SubscriptionUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UsageMeterUpdateManyWithoutOrgNestedInput = {
    create?: XOR<UsageMeterCreateWithoutOrgInput, UsageMeterUncheckedCreateWithoutOrgInput> | UsageMeterCreateWithoutOrgInput[] | UsageMeterUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UsageMeterCreateOrConnectWithoutOrgInput | UsageMeterCreateOrConnectWithoutOrgInput[]
    upsert?: UsageMeterUpsertWithWhereUniqueWithoutOrgInput | UsageMeterUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: UsageMeterCreateManyOrgInputEnvelope
    set?: UsageMeterWhereUniqueInput | UsageMeterWhereUniqueInput[]
    disconnect?: UsageMeterWhereUniqueInput | UsageMeterWhereUniqueInput[]
    delete?: UsageMeterWhereUniqueInput | UsageMeterWhereUniqueInput[]
    connect?: UsageMeterWhereUniqueInput | UsageMeterWhereUniqueInput[]
    update?: UsageMeterUpdateWithWhereUniqueWithoutOrgInput | UsageMeterUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: UsageMeterUpdateManyWithWhereWithoutOrgInput | UsageMeterUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: UsageMeterScalarWhereInput | UsageMeterScalarWhereInput[]
  }

  export type AddonPurchaseUpdateManyWithoutOrgNestedInput = {
    create?: XOR<AddonPurchaseCreateWithoutOrgInput, AddonPurchaseUncheckedCreateWithoutOrgInput> | AddonPurchaseCreateWithoutOrgInput[] | AddonPurchaseUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AddonPurchaseCreateOrConnectWithoutOrgInput | AddonPurchaseCreateOrConnectWithoutOrgInput[]
    upsert?: AddonPurchaseUpsertWithWhereUniqueWithoutOrgInput | AddonPurchaseUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: AddonPurchaseCreateManyOrgInputEnvelope
    set?: AddonPurchaseWhereUniqueInput | AddonPurchaseWhereUniqueInput[]
    disconnect?: AddonPurchaseWhereUniqueInput | AddonPurchaseWhereUniqueInput[]
    delete?: AddonPurchaseWhereUniqueInput | AddonPurchaseWhereUniqueInput[]
    connect?: AddonPurchaseWhereUniqueInput | AddonPurchaseWhereUniqueInput[]
    update?: AddonPurchaseUpdateWithWhereUniqueWithoutOrgInput | AddonPurchaseUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: AddonPurchaseUpdateManyWithWhereWithoutOrgInput | AddonPurchaseUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: AddonPurchaseScalarWhereInput | AddonPurchaseScalarWhereInput[]
  }

  export type TenantPriceOverrideUpdateManyWithoutOrgNestedInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutOrgInput, TenantPriceOverrideUncheckedCreateWithoutOrgInput> | TenantPriceOverrideCreateWithoutOrgInput[] | TenantPriceOverrideUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutOrgInput | TenantPriceOverrideCreateOrConnectWithoutOrgInput[]
    upsert?: TenantPriceOverrideUpsertWithWhereUniqueWithoutOrgInput | TenantPriceOverrideUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: TenantPriceOverrideCreateManyOrgInputEnvelope
    set?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    disconnect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    delete?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    update?: TenantPriceOverrideUpdateWithWhereUniqueWithoutOrgInput | TenantPriceOverrideUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: TenantPriceOverrideUpdateManyWithWhereWithoutOrgInput | TenantPriceOverrideUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: TenantPriceOverrideScalarWhereInput | TenantPriceOverrideScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutOrgNestedInput = {
    create?: XOR<IncidentCreateWithoutOrgInput, IncidentUncheckedCreateWithoutOrgInput> | IncidentCreateWithoutOrgInput[] | IncidentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutOrgInput | IncidentCreateOrConnectWithoutOrgInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutOrgInput | IncidentUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: IncidentCreateManyOrgInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutOrgInput | IncidentUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutOrgInput | IncidentUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutOrgNestedInput = {
    create?: XOR<NotificationCreateWithoutOrgInput, NotificationUncheckedCreateWithoutOrgInput> | NotificationCreateWithoutOrgInput[] | NotificationUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrgInput | NotificationCreateOrConnectWithoutOrgInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOrgInput | NotificationUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: NotificationCreateManyOrgInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOrgInput | NotificationUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOrgInput | NotificationUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ImportJobUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ImportJobCreateWithoutOrgInput, ImportJobUncheckedCreateWithoutOrgInput> | ImportJobCreateWithoutOrgInput[] | ImportJobUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutOrgInput | ImportJobCreateOrConnectWithoutOrgInput[]
    upsert?: ImportJobUpsertWithWhereUniqueWithoutOrgInput | ImportJobUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ImportJobCreateManyOrgInputEnvelope
    set?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    disconnect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    delete?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    update?: ImportJobUpdateWithWhereUniqueWithoutOrgInput | ImportJobUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ImportJobUpdateManyWithWhereWithoutOrgInput | ImportJobUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
  }

  export type ImportMappingUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ImportMappingCreateWithoutOrgInput, ImportMappingUncheckedCreateWithoutOrgInput> | ImportMappingCreateWithoutOrgInput[] | ImportMappingUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ImportMappingCreateOrConnectWithoutOrgInput | ImportMappingCreateOrConnectWithoutOrgInput[]
    upsert?: ImportMappingUpsertWithWhereUniqueWithoutOrgInput | ImportMappingUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ImportMappingCreateManyOrgInputEnvelope
    set?: ImportMappingWhereUniqueInput | ImportMappingWhereUniqueInput[]
    disconnect?: ImportMappingWhereUniqueInput | ImportMappingWhereUniqueInput[]
    delete?: ImportMappingWhereUniqueInput | ImportMappingWhereUniqueInput[]
    connect?: ImportMappingWhereUniqueInput | ImportMappingWhereUniqueInput[]
    update?: ImportMappingUpdateWithWhereUniqueWithoutOrgInput | ImportMappingUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ImportMappingUpdateManyWithWhereWithoutOrgInput | ImportMappingUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ImportMappingScalarWhereInput | ImportMappingScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<AuditLogCreateWithoutOrgInput, AuditLogUncheckedCreateWithoutOrgInput> | AuditLogCreateWithoutOrgInput[] | AuditLogUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOrgInput | AuditLogCreateOrConnectWithoutOrgInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutOrgInput | AuditLogUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: AuditLogCreateManyOrgInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutOrgInput | AuditLogUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutOrgInput | AuditLogUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<BillingLedgerCreateWithoutOrgInput, BillingLedgerUncheckedCreateWithoutOrgInput> | BillingLedgerCreateWithoutOrgInput[] | BillingLedgerUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: BillingLedgerCreateOrConnectWithoutOrgInput | BillingLedgerCreateOrConnectWithoutOrgInput[]
    upsert?: BillingLedgerUpsertWithWhereUniqueWithoutOrgInput | BillingLedgerUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: BillingLedgerCreateManyOrgInputEnvelope
    set?: BillingLedgerWhereUniqueInput | BillingLedgerWhereUniqueInput[]
    disconnect?: BillingLedgerWhereUniqueInput | BillingLedgerWhereUniqueInput[]
    delete?: BillingLedgerWhereUniqueInput | BillingLedgerWhereUniqueInput[]
    connect?: BillingLedgerWhereUniqueInput | BillingLedgerWhereUniqueInput[]
    update?: BillingLedgerUpdateWithWhereUniqueWithoutOrgInput | BillingLedgerUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: BillingLedgerUpdateManyWithWhereWithoutOrgInput | BillingLedgerUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: BillingLedgerScalarWhereInput | BillingLedgerScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<CustomerCreateWithoutOrgInput, CustomerUncheckedCreateWithoutOrgInput> | CustomerCreateWithoutOrgInput[] | CustomerUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrgInput | CustomerCreateOrConnectWithoutOrgInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutOrgInput | CustomerUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: CustomerCreateManyOrgInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutOrgInput | CustomerUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutOrgInput | CustomerUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrgInput, InvoiceUncheckedCreateWithoutOrgInput> | InvoiceCreateWithoutOrgInput[] | InvoiceUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrgInput | InvoiceCreateOrConnectWithoutOrgInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrgInput | InvoiceUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: InvoiceCreateManyOrgInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrgInput | InvoiceUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrgInput | InvoiceUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<JobCreateWithoutOrgInput, JobUncheckedCreateWithoutOrgInput> | JobCreateWithoutOrgInput[] | JobUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: JobCreateOrConnectWithoutOrgInput | JobCreateOrConnectWithoutOrgInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutOrgInput | JobUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: JobCreateManyOrgInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutOrgInput | JobUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: JobUpdateManyWithWhereWithoutOrgInput | JobUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<LeadCreateWithoutOrgInput, LeadUncheckedCreateWithoutOrgInput> | LeadCreateWithoutOrgInput[] | LeadUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOrgInput | LeadCreateOrConnectWithoutOrgInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutOrgInput | LeadUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: LeadCreateManyOrgInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutOrgInput | LeadUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutOrgInput | LeadUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<OpportunityCreateWithoutOrgInput, OpportunityUncheckedCreateWithoutOrgInput> | OpportunityCreateWithoutOrgInput[] | OpportunityUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutOrgInput | OpportunityCreateOrConnectWithoutOrgInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutOrgInput | OpportunityUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: OpportunityCreateManyOrgInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutOrgInput | OpportunityUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutOrgInput | OpportunityUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<PaymentCreateWithoutOrgInput, PaymentUncheckedCreateWithoutOrgInput> | PaymentCreateWithoutOrgInput[] | PaymentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrgInput | PaymentCreateOrConnectWithoutOrgInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrgInput | PaymentUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: PaymentCreateManyOrgInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrgInput | PaymentUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrgInput | PaymentUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ReferralCreateWithoutOrgInput, ReferralUncheckedCreateWithoutOrgInput> | ReferralCreateWithoutOrgInput[] | ReferralUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutOrgInput | ReferralCreateOrConnectWithoutOrgInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutOrgInput | ReferralUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ReferralCreateManyOrgInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutOrgInput | ReferralUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutOrgInput | ReferralUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type RfpUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<RfpCreateWithoutOrgInput, RfpUncheckedCreateWithoutOrgInput> | RfpCreateWithoutOrgInput[] | RfpUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RfpCreateOrConnectWithoutOrgInput | RfpCreateOrConnectWithoutOrgInput[]
    upsert?: RfpUpsertWithWhereUniqueWithoutOrgInput | RfpUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: RfpCreateManyOrgInputEnvelope
    set?: RfpWhereUniqueInput | RfpWhereUniqueInput[]
    disconnect?: RfpWhereUniqueInput | RfpWhereUniqueInput[]
    delete?: RfpWhereUniqueInput | RfpWhereUniqueInput[]
    connect?: RfpWhereUniqueInput | RfpWhereUniqueInput[]
    update?: RfpUpdateWithWhereUniqueWithoutOrgInput | RfpUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: RfpUpdateManyWithWhereWithoutOrgInput | RfpUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: RfpScalarWhereInput | RfpScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput> | UserCreateWithoutOrgInput[] | UserUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput | UserCreateOrConnectWithoutOrgInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrgInput | UserUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: UserCreateManyOrgInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrgInput | UserUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrgInput | UserUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RbacRoleUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<RbacRoleCreateWithoutOrgInput, RbacRoleUncheckedCreateWithoutOrgInput> | RbacRoleCreateWithoutOrgInput[] | RbacRoleUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RbacRoleCreateOrConnectWithoutOrgInput | RbacRoleCreateOrConnectWithoutOrgInput[]
    upsert?: RbacRoleUpsertWithWhereUniqueWithoutOrgInput | RbacRoleUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: RbacRoleCreateManyOrgInputEnvelope
    set?: RbacRoleWhereUniqueInput | RbacRoleWhereUniqueInput[]
    disconnect?: RbacRoleWhereUniqueInput | RbacRoleWhereUniqueInput[]
    delete?: RbacRoleWhereUniqueInput | RbacRoleWhereUniqueInput[]
    connect?: RbacRoleWhereUniqueInput | RbacRoleWhereUniqueInput[]
    update?: RbacRoleUpdateWithWhereUniqueWithoutOrgInput | RbacRoleUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: RbacRoleUpdateManyWithWhereWithoutOrgInput | RbacRoleUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: RbacRoleScalarWhereInput | RbacRoleScalarWhereInput[]
  }

  export type RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<RbacUserRoleCreateWithoutOrgInput, RbacUserRoleUncheckedCreateWithoutOrgInput> | RbacUserRoleCreateWithoutOrgInput[] | RbacUserRoleUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutOrgInput | RbacUserRoleCreateOrConnectWithoutOrgInput[]
    upsert?: RbacUserRoleUpsertWithWhereUniqueWithoutOrgInput | RbacUserRoleUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: RbacUserRoleCreateManyOrgInputEnvelope
    set?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    disconnect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    delete?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    update?: RbacUserRoleUpdateWithWhereUniqueWithoutOrgInput | RbacUserRoleUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: RbacUserRoleUpdateManyWithWhereWithoutOrgInput | RbacUserRoleUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: RbacUserRoleScalarWhereInput | RbacUserRoleScalarWhereInput[]
  }

  export type LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<LeadInvoiceCreateWithoutOrgInput, LeadInvoiceUncheckedCreateWithoutOrgInput> | LeadInvoiceCreateWithoutOrgInput[] | LeadInvoiceUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: LeadInvoiceCreateOrConnectWithoutOrgInput | LeadInvoiceCreateOrConnectWithoutOrgInput[]
    upsert?: LeadInvoiceUpsertWithWhereUniqueWithoutOrgInput | LeadInvoiceUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: LeadInvoiceCreateManyOrgInputEnvelope
    set?: LeadInvoiceWhereUniqueInput | LeadInvoiceWhereUniqueInput[]
    disconnect?: LeadInvoiceWhereUniqueInput | LeadInvoiceWhereUniqueInput[]
    delete?: LeadInvoiceWhereUniqueInput | LeadInvoiceWhereUniqueInput[]
    connect?: LeadInvoiceWhereUniqueInput | LeadInvoiceWhereUniqueInput[]
    update?: LeadInvoiceUpdateWithWhereUniqueWithoutOrgInput | LeadInvoiceUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: LeadInvoiceUpdateManyWithWhereWithoutOrgInput | LeadInvoiceUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: LeadInvoiceScalarWhereInput | LeadInvoiceScalarWhereInput[]
  }

  export type PricingPlanUncheckedUpdateOneWithoutOrgNestedInput = {
    create?: XOR<PricingPlanCreateWithoutOrgInput, PricingPlanUncheckedCreateWithoutOrgInput>
    connectOrCreate?: PricingPlanCreateOrConnectWithoutOrgInput
    upsert?: PricingPlanUpsertWithoutOrgInput
    disconnect?: PricingPlanWhereInput | boolean
    delete?: PricingPlanWhereInput | boolean
    connect?: PricingPlanWhereUniqueInput
    update?: XOR<XOR<PricingPlanUpdateToOneWithWhereWithoutOrgInput, PricingPlanUpdateWithoutOrgInput>, PricingPlanUncheckedUpdateWithoutOrgInput>
  }

  export type AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<AiUsageEventCreateWithoutOrgInput, AiUsageEventUncheckedCreateWithoutOrgInput> | AiUsageEventCreateWithoutOrgInput[] | AiUsageEventUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AiUsageEventCreateOrConnectWithoutOrgInput | AiUsageEventCreateOrConnectWithoutOrgInput[]
    upsert?: AiUsageEventUpsertWithWhereUniqueWithoutOrgInput | AiUsageEventUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: AiUsageEventCreateManyOrgInputEnvelope
    set?: AiUsageEventWhereUniqueInput | AiUsageEventWhereUniqueInput[]
    disconnect?: AiUsageEventWhereUniqueInput | AiUsageEventWhereUniqueInput[]
    delete?: AiUsageEventWhereUniqueInput | AiUsageEventWhereUniqueInput[]
    connect?: AiUsageEventWhereUniqueInput | AiUsageEventWhereUniqueInput[]
    update?: AiUsageEventUpdateWithWhereUniqueWithoutOrgInput | AiUsageEventUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: AiUsageEventUpdateManyWithWhereWithoutOrgInput | AiUsageEventUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: AiUsageEventScalarWhereInput | AiUsageEventScalarWhereInput[]
  }

  export type AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<AiMonthlySummaryCreateWithoutOrgInput, AiMonthlySummaryUncheckedCreateWithoutOrgInput> | AiMonthlySummaryCreateWithoutOrgInput[] | AiMonthlySummaryUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AiMonthlySummaryCreateOrConnectWithoutOrgInput | AiMonthlySummaryCreateOrConnectWithoutOrgInput[]
    upsert?: AiMonthlySummaryUpsertWithWhereUniqueWithoutOrgInput | AiMonthlySummaryUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: AiMonthlySummaryCreateManyOrgInputEnvelope
    set?: AiMonthlySummaryWhereUniqueInput | AiMonthlySummaryWhereUniqueInput[]
    disconnect?: AiMonthlySummaryWhereUniqueInput | AiMonthlySummaryWhereUniqueInput[]
    delete?: AiMonthlySummaryWhereUniqueInput | AiMonthlySummaryWhereUniqueInput[]
    connect?: AiMonthlySummaryWhereUniqueInput | AiMonthlySummaryWhereUniqueInput[]
    update?: AiMonthlySummaryUpdateWithWhereUniqueWithoutOrgInput | AiMonthlySummaryUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: AiMonthlySummaryUpdateManyWithWhereWithoutOrgInput | AiMonthlySummaryUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: AiMonthlySummaryScalarWhereInput | AiMonthlySummaryScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ActivityCreateWithoutOrgInput, ActivityUncheckedCreateWithoutOrgInput> | ActivityCreateWithoutOrgInput[] | ActivityUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOrgInput | ActivityCreateOrConnectWithoutOrgInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOrgInput | ActivityUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ActivityCreateManyOrgInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOrgInput | ActivityUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOrgInput | ActivityUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<SubscriptionCreateWithoutOrgInput, SubscriptionUncheckedCreateWithoutOrgInput> | SubscriptionCreateWithoutOrgInput[] | SubscriptionUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrgInput | SubscriptionCreateOrConnectWithoutOrgInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutOrgInput | SubscriptionUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: SubscriptionCreateManyOrgInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutOrgInput | SubscriptionUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutOrgInput | SubscriptionUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UsageMeterUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<UsageMeterCreateWithoutOrgInput, UsageMeterUncheckedCreateWithoutOrgInput> | UsageMeterCreateWithoutOrgInput[] | UsageMeterUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UsageMeterCreateOrConnectWithoutOrgInput | UsageMeterCreateOrConnectWithoutOrgInput[]
    upsert?: UsageMeterUpsertWithWhereUniqueWithoutOrgInput | UsageMeterUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: UsageMeterCreateManyOrgInputEnvelope
    set?: UsageMeterWhereUniqueInput | UsageMeterWhereUniqueInput[]
    disconnect?: UsageMeterWhereUniqueInput | UsageMeterWhereUniqueInput[]
    delete?: UsageMeterWhereUniqueInput | UsageMeterWhereUniqueInput[]
    connect?: UsageMeterWhereUniqueInput | UsageMeterWhereUniqueInput[]
    update?: UsageMeterUpdateWithWhereUniqueWithoutOrgInput | UsageMeterUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: UsageMeterUpdateManyWithWhereWithoutOrgInput | UsageMeterUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: UsageMeterScalarWhereInput | UsageMeterScalarWhereInput[]
  }

  export type AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<AddonPurchaseCreateWithoutOrgInput, AddonPurchaseUncheckedCreateWithoutOrgInput> | AddonPurchaseCreateWithoutOrgInput[] | AddonPurchaseUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: AddonPurchaseCreateOrConnectWithoutOrgInput | AddonPurchaseCreateOrConnectWithoutOrgInput[]
    upsert?: AddonPurchaseUpsertWithWhereUniqueWithoutOrgInput | AddonPurchaseUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: AddonPurchaseCreateManyOrgInputEnvelope
    set?: AddonPurchaseWhereUniqueInput | AddonPurchaseWhereUniqueInput[]
    disconnect?: AddonPurchaseWhereUniqueInput | AddonPurchaseWhereUniqueInput[]
    delete?: AddonPurchaseWhereUniqueInput | AddonPurchaseWhereUniqueInput[]
    connect?: AddonPurchaseWhereUniqueInput | AddonPurchaseWhereUniqueInput[]
    update?: AddonPurchaseUpdateWithWhereUniqueWithoutOrgInput | AddonPurchaseUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: AddonPurchaseUpdateManyWithWhereWithoutOrgInput | AddonPurchaseUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: AddonPurchaseScalarWhereInput | AddonPurchaseScalarWhereInput[]
  }

  export type TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutOrgInput, TenantPriceOverrideUncheckedCreateWithoutOrgInput> | TenantPriceOverrideCreateWithoutOrgInput[] | TenantPriceOverrideUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutOrgInput | TenantPriceOverrideCreateOrConnectWithoutOrgInput[]
    upsert?: TenantPriceOverrideUpsertWithWhereUniqueWithoutOrgInput | TenantPriceOverrideUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: TenantPriceOverrideCreateManyOrgInputEnvelope
    set?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    disconnect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    delete?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    update?: TenantPriceOverrideUpdateWithWhereUniqueWithoutOrgInput | TenantPriceOverrideUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: TenantPriceOverrideUpdateManyWithWhereWithoutOrgInput | TenantPriceOverrideUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: TenantPriceOverrideScalarWhereInput | TenantPriceOverrideScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<IncidentCreateWithoutOrgInput, IncidentUncheckedCreateWithoutOrgInput> | IncidentCreateWithoutOrgInput[] | IncidentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutOrgInput | IncidentCreateOrConnectWithoutOrgInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutOrgInput | IncidentUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: IncidentCreateManyOrgInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutOrgInput | IncidentUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutOrgInput | IncidentUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<NotificationCreateWithoutOrgInput, NotificationUncheckedCreateWithoutOrgInput> | NotificationCreateWithoutOrgInput[] | NotificationUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrgInput | NotificationCreateOrConnectWithoutOrgInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOrgInput | NotificationUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: NotificationCreateManyOrgInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOrgInput | NotificationUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOrgInput | NotificationUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ImportJobUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ImportJobCreateWithoutOrgInput, ImportJobUncheckedCreateWithoutOrgInput> | ImportJobCreateWithoutOrgInput[] | ImportJobUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutOrgInput | ImportJobCreateOrConnectWithoutOrgInput[]
    upsert?: ImportJobUpsertWithWhereUniqueWithoutOrgInput | ImportJobUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ImportJobCreateManyOrgInputEnvelope
    set?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    disconnect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    delete?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    update?: ImportJobUpdateWithWhereUniqueWithoutOrgInput | ImportJobUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ImportJobUpdateManyWithWhereWithoutOrgInput | ImportJobUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
  }

  export type ImportMappingUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ImportMappingCreateWithoutOrgInput, ImportMappingUncheckedCreateWithoutOrgInput> | ImportMappingCreateWithoutOrgInput[] | ImportMappingUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ImportMappingCreateOrConnectWithoutOrgInput | ImportMappingCreateOrConnectWithoutOrgInput[]
    upsert?: ImportMappingUpsertWithWhereUniqueWithoutOrgInput | ImportMappingUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ImportMappingCreateManyOrgInputEnvelope
    set?: ImportMappingWhereUniqueInput | ImportMappingWhereUniqueInput[]
    disconnect?: ImportMappingWhereUniqueInput | ImportMappingWhereUniqueInput[]
    delete?: ImportMappingWhereUniqueInput | ImportMappingWhereUniqueInput[]
    connect?: ImportMappingWhereUniqueInput | ImportMappingWhereUniqueInput[]
    update?: ImportMappingUpdateWithWhereUniqueWithoutOrgInput | ImportMappingUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ImportMappingUpdateManyWithWhereWithoutOrgInput | ImportMappingUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ImportMappingScalarWhereInput | ImportMappingScalarWhereInput[]
  }

  export type OrgCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrgCreateWithoutUsersInput, OrgUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrgCreateOrConnectWithoutUsersInput
    connect?: OrgWhereUniqueInput
  }

  export type RbacUserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<RbacUserRoleCreateWithoutUserInput, RbacUserRoleUncheckedCreateWithoutUserInput> | RbacUserRoleCreateWithoutUserInput[] | RbacUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutUserInput | RbacUserRoleCreateOrConnectWithoutUserInput[]
    createMany?: RbacUserRoleCreateManyUserInputEnvelope
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
  }

  export type UserRecoveryCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRecoveryCodeCreateWithoutUserInput, UserRecoveryCodeUncheckedCreateWithoutUserInput> | UserRecoveryCodeCreateWithoutUserInput[] | UserRecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRecoveryCodeCreateOrConnectWithoutUserInput | UserRecoveryCodeCreateOrConnectWithoutUserInput[]
    createMany?: UserRecoveryCodeCreateManyUserInputEnvelope
    connect?: UserRecoveryCodeWhereUniqueInput | UserRecoveryCodeWhereUniqueInput[]
  }

  export type UserBreakglassAccountCreateNestedOneWithoutUserInput = {
    create?: XOR<UserBreakglassAccountCreateWithoutUserInput, UserBreakglassAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserBreakglassAccountCreateOrConnectWithoutUserInput
    connect?: UserBreakglassAccountWhereUniqueInput
  }

  export type UserSecurityQuestionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSecurityQuestionCreateWithoutUserInput, UserSecurityQuestionUncheckedCreateWithoutUserInput> | UserSecurityQuestionCreateWithoutUserInput[] | UserSecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSecurityQuestionCreateOrConnectWithoutUserInput | UserSecurityQuestionCreateOrConnectWithoutUserInput[]
    createMany?: UserSecurityQuestionCreateManyUserInputEnvelope
    connect?: UserSecurityQuestionWhereUniqueInput | UserSecurityQuestionWhereUniqueInput[]
  }

  export type UserLoginHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLoginHistoryCreateWithoutUserInput, UserLoginHistoryUncheckedCreateWithoutUserInput> | UserLoginHistoryCreateWithoutUserInput[] | UserLoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginHistoryCreateOrConnectWithoutUserInput | UserLoginHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserLoginHistoryCreateManyUserInputEnvelope
    connect?: UserLoginHistoryWhereUniqueInput | UserLoginHistoryWhereUniqueInput[]
  }

  export type UserDeviceFingerprintCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDeviceFingerprintCreateWithoutUserInput, UserDeviceFingerprintUncheckedCreateWithoutUserInput> | UserDeviceFingerprintCreateWithoutUserInput[] | UserDeviceFingerprintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceFingerprintCreateOrConnectWithoutUserInput | UserDeviceFingerprintCreateOrConnectWithoutUserInput[]
    createMany?: UserDeviceFingerprintCreateManyUserInputEnvelope
    connect?: UserDeviceFingerprintWhereUniqueInput | UserDeviceFingerprintWhereUniqueInput[]
  }

  export type ImportJobCreateNestedManyWithoutUserInput = {
    create?: XOR<ImportJobCreateWithoutUserInput, ImportJobUncheckedCreateWithoutUserInput> | ImportJobCreateWithoutUserInput[] | ImportJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutUserInput | ImportJobCreateOrConnectWithoutUserInput[]
    createMany?: ImportJobCreateManyUserInputEnvelope
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
  }

  export type RbacUserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RbacUserRoleCreateWithoutUserInput, RbacUserRoleUncheckedCreateWithoutUserInput> | RbacUserRoleCreateWithoutUserInput[] | RbacUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutUserInput | RbacUserRoleCreateOrConnectWithoutUserInput[]
    createMany?: RbacUserRoleCreateManyUserInputEnvelope
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
  }

  export type UserRecoveryCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRecoveryCodeCreateWithoutUserInput, UserRecoveryCodeUncheckedCreateWithoutUserInput> | UserRecoveryCodeCreateWithoutUserInput[] | UserRecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRecoveryCodeCreateOrConnectWithoutUserInput | UserRecoveryCodeCreateOrConnectWithoutUserInput[]
    createMany?: UserRecoveryCodeCreateManyUserInputEnvelope
    connect?: UserRecoveryCodeWhereUniqueInput | UserRecoveryCodeWhereUniqueInput[]
  }

  export type UserBreakglassAccountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserBreakglassAccountCreateWithoutUserInput, UserBreakglassAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserBreakglassAccountCreateOrConnectWithoutUserInput
    connect?: UserBreakglassAccountWhereUniqueInput
  }

  export type UserSecurityQuestionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSecurityQuestionCreateWithoutUserInput, UserSecurityQuestionUncheckedCreateWithoutUserInput> | UserSecurityQuestionCreateWithoutUserInput[] | UserSecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSecurityQuestionCreateOrConnectWithoutUserInput | UserSecurityQuestionCreateOrConnectWithoutUserInput[]
    createMany?: UserSecurityQuestionCreateManyUserInputEnvelope
    connect?: UserSecurityQuestionWhereUniqueInput | UserSecurityQuestionWhereUniqueInput[]
  }

  export type UserLoginHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLoginHistoryCreateWithoutUserInput, UserLoginHistoryUncheckedCreateWithoutUserInput> | UserLoginHistoryCreateWithoutUserInput[] | UserLoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginHistoryCreateOrConnectWithoutUserInput | UserLoginHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserLoginHistoryCreateManyUserInputEnvelope
    connect?: UserLoginHistoryWhereUniqueInput | UserLoginHistoryWhereUniqueInput[]
  }

  export type UserDeviceFingerprintUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDeviceFingerprintCreateWithoutUserInput, UserDeviceFingerprintUncheckedCreateWithoutUserInput> | UserDeviceFingerprintCreateWithoutUserInput[] | UserDeviceFingerprintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceFingerprintCreateOrConnectWithoutUserInput | UserDeviceFingerprintCreateOrConnectWithoutUserInput[]
    createMany?: UserDeviceFingerprintCreateManyUserInputEnvelope
    connect?: UserDeviceFingerprintWhereUniqueInput | UserDeviceFingerprintWhereUniqueInput[]
  }

  export type ImportJobUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ImportJobCreateWithoutUserInput, ImportJobUncheckedCreateWithoutUserInput> | ImportJobCreateWithoutUserInput[] | ImportJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutUserInput | ImportJobCreateOrConnectWithoutUserInput[]
    createMany?: ImportJobCreateManyUserInputEnvelope
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type OrgUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrgCreateWithoutUsersInput, OrgUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrgCreateOrConnectWithoutUsersInput
    upsert?: OrgUpsertWithoutUsersInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutUsersInput, OrgUpdateWithoutUsersInput>, OrgUncheckedUpdateWithoutUsersInput>
  }

  export type RbacUserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<RbacUserRoleCreateWithoutUserInput, RbacUserRoleUncheckedCreateWithoutUserInput> | RbacUserRoleCreateWithoutUserInput[] | RbacUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutUserInput | RbacUserRoleCreateOrConnectWithoutUserInput[]
    upsert?: RbacUserRoleUpsertWithWhereUniqueWithoutUserInput | RbacUserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RbacUserRoleCreateManyUserInputEnvelope
    set?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    disconnect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    delete?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    update?: RbacUserRoleUpdateWithWhereUniqueWithoutUserInput | RbacUserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RbacUserRoleUpdateManyWithWhereWithoutUserInput | RbacUserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RbacUserRoleScalarWhereInput | RbacUserRoleScalarWhereInput[]
  }

  export type UserRecoveryCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRecoveryCodeCreateWithoutUserInput, UserRecoveryCodeUncheckedCreateWithoutUserInput> | UserRecoveryCodeCreateWithoutUserInput[] | UserRecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRecoveryCodeCreateOrConnectWithoutUserInput | UserRecoveryCodeCreateOrConnectWithoutUserInput[]
    upsert?: UserRecoveryCodeUpsertWithWhereUniqueWithoutUserInput | UserRecoveryCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRecoveryCodeCreateManyUserInputEnvelope
    set?: UserRecoveryCodeWhereUniqueInput | UserRecoveryCodeWhereUniqueInput[]
    disconnect?: UserRecoveryCodeWhereUniqueInput | UserRecoveryCodeWhereUniqueInput[]
    delete?: UserRecoveryCodeWhereUniqueInput | UserRecoveryCodeWhereUniqueInput[]
    connect?: UserRecoveryCodeWhereUniqueInput | UserRecoveryCodeWhereUniqueInput[]
    update?: UserRecoveryCodeUpdateWithWhereUniqueWithoutUserInput | UserRecoveryCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRecoveryCodeUpdateManyWithWhereWithoutUserInput | UserRecoveryCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRecoveryCodeScalarWhereInput | UserRecoveryCodeScalarWhereInput[]
  }

  export type UserBreakglassAccountUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserBreakglassAccountCreateWithoutUserInput, UserBreakglassAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserBreakglassAccountCreateOrConnectWithoutUserInput
    upsert?: UserBreakglassAccountUpsertWithoutUserInput
    disconnect?: UserBreakglassAccountWhereInput | boolean
    delete?: UserBreakglassAccountWhereInput | boolean
    connect?: UserBreakglassAccountWhereUniqueInput
    update?: XOR<XOR<UserBreakglassAccountUpdateToOneWithWhereWithoutUserInput, UserBreakglassAccountUpdateWithoutUserInput>, UserBreakglassAccountUncheckedUpdateWithoutUserInput>
  }

  export type UserSecurityQuestionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSecurityQuestionCreateWithoutUserInput, UserSecurityQuestionUncheckedCreateWithoutUserInput> | UserSecurityQuestionCreateWithoutUserInput[] | UserSecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSecurityQuestionCreateOrConnectWithoutUserInput | UserSecurityQuestionCreateOrConnectWithoutUserInput[]
    upsert?: UserSecurityQuestionUpsertWithWhereUniqueWithoutUserInput | UserSecurityQuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSecurityQuestionCreateManyUserInputEnvelope
    set?: UserSecurityQuestionWhereUniqueInput | UserSecurityQuestionWhereUniqueInput[]
    disconnect?: UserSecurityQuestionWhereUniqueInput | UserSecurityQuestionWhereUniqueInput[]
    delete?: UserSecurityQuestionWhereUniqueInput | UserSecurityQuestionWhereUniqueInput[]
    connect?: UserSecurityQuestionWhereUniqueInput | UserSecurityQuestionWhereUniqueInput[]
    update?: UserSecurityQuestionUpdateWithWhereUniqueWithoutUserInput | UserSecurityQuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSecurityQuestionUpdateManyWithWhereWithoutUserInput | UserSecurityQuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSecurityQuestionScalarWhereInput | UserSecurityQuestionScalarWhereInput[]
  }

  export type UserLoginHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLoginHistoryCreateWithoutUserInput, UserLoginHistoryUncheckedCreateWithoutUserInput> | UserLoginHistoryCreateWithoutUserInput[] | UserLoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginHistoryCreateOrConnectWithoutUserInput | UserLoginHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserLoginHistoryUpsertWithWhereUniqueWithoutUserInput | UserLoginHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLoginHistoryCreateManyUserInputEnvelope
    set?: UserLoginHistoryWhereUniqueInput | UserLoginHistoryWhereUniqueInput[]
    disconnect?: UserLoginHistoryWhereUniqueInput | UserLoginHistoryWhereUniqueInput[]
    delete?: UserLoginHistoryWhereUniqueInput | UserLoginHistoryWhereUniqueInput[]
    connect?: UserLoginHistoryWhereUniqueInput | UserLoginHistoryWhereUniqueInput[]
    update?: UserLoginHistoryUpdateWithWhereUniqueWithoutUserInput | UserLoginHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLoginHistoryUpdateManyWithWhereWithoutUserInput | UserLoginHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLoginHistoryScalarWhereInput | UserLoginHistoryScalarWhereInput[]
  }

  export type UserDeviceFingerprintUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDeviceFingerprintCreateWithoutUserInput, UserDeviceFingerprintUncheckedCreateWithoutUserInput> | UserDeviceFingerprintCreateWithoutUserInput[] | UserDeviceFingerprintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceFingerprintCreateOrConnectWithoutUserInput | UserDeviceFingerprintCreateOrConnectWithoutUserInput[]
    upsert?: UserDeviceFingerprintUpsertWithWhereUniqueWithoutUserInput | UserDeviceFingerprintUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDeviceFingerprintCreateManyUserInputEnvelope
    set?: UserDeviceFingerprintWhereUniqueInput | UserDeviceFingerprintWhereUniqueInput[]
    disconnect?: UserDeviceFingerprintWhereUniqueInput | UserDeviceFingerprintWhereUniqueInput[]
    delete?: UserDeviceFingerprintWhereUniqueInput | UserDeviceFingerprintWhereUniqueInput[]
    connect?: UserDeviceFingerprintWhereUniqueInput | UserDeviceFingerprintWhereUniqueInput[]
    update?: UserDeviceFingerprintUpdateWithWhereUniqueWithoutUserInput | UserDeviceFingerprintUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDeviceFingerprintUpdateManyWithWhereWithoutUserInput | UserDeviceFingerprintUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDeviceFingerprintScalarWhereInput | UserDeviceFingerprintScalarWhereInput[]
  }

  export type ImportJobUpdateManyWithoutUserNestedInput = {
    create?: XOR<ImportJobCreateWithoutUserInput, ImportJobUncheckedCreateWithoutUserInput> | ImportJobCreateWithoutUserInput[] | ImportJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutUserInput | ImportJobCreateOrConnectWithoutUserInput[]
    upsert?: ImportJobUpsertWithWhereUniqueWithoutUserInput | ImportJobUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ImportJobCreateManyUserInputEnvelope
    set?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    disconnect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    delete?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    update?: ImportJobUpdateWithWhereUniqueWithoutUserInput | ImportJobUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ImportJobUpdateManyWithWhereWithoutUserInput | ImportJobUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
  }

  export type RbacUserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RbacUserRoleCreateWithoutUserInput, RbacUserRoleUncheckedCreateWithoutUserInput> | RbacUserRoleCreateWithoutUserInput[] | RbacUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutUserInput | RbacUserRoleCreateOrConnectWithoutUserInput[]
    upsert?: RbacUserRoleUpsertWithWhereUniqueWithoutUserInput | RbacUserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RbacUserRoleCreateManyUserInputEnvelope
    set?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    disconnect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    delete?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    update?: RbacUserRoleUpdateWithWhereUniqueWithoutUserInput | RbacUserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RbacUserRoleUpdateManyWithWhereWithoutUserInput | RbacUserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RbacUserRoleScalarWhereInput | RbacUserRoleScalarWhereInput[]
  }

  export type UserRecoveryCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRecoveryCodeCreateWithoutUserInput, UserRecoveryCodeUncheckedCreateWithoutUserInput> | UserRecoveryCodeCreateWithoutUserInput[] | UserRecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRecoveryCodeCreateOrConnectWithoutUserInput | UserRecoveryCodeCreateOrConnectWithoutUserInput[]
    upsert?: UserRecoveryCodeUpsertWithWhereUniqueWithoutUserInput | UserRecoveryCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRecoveryCodeCreateManyUserInputEnvelope
    set?: UserRecoveryCodeWhereUniqueInput | UserRecoveryCodeWhereUniqueInput[]
    disconnect?: UserRecoveryCodeWhereUniqueInput | UserRecoveryCodeWhereUniqueInput[]
    delete?: UserRecoveryCodeWhereUniqueInput | UserRecoveryCodeWhereUniqueInput[]
    connect?: UserRecoveryCodeWhereUniqueInput | UserRecoveryCodeWhereUniqueInput[]
    update?: UserRecoveryCodeUpdateWithWhereUniqueWithoutUserInput | UserRecoveryCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRecoveryCodeUpdateManyWithWhereWithoutUserInput | UserRecoveryCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRecoveryCodeScalarWhereInput | UserRecoveryCodeScalarWhereInput[]
  }

  export type UserBreakglassAccountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserBreakglassAccountCreateWithoutUserInput, UserBreakglassAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserBreakglassAccountCreateOrConnectWithoutUserInput
    upsert?: UserBreakglassAccountUpsertWithoutUserInput
    disconnect?: UserBreakglassAccountWhereInput | boolean
    delete?: UserBreakglassAccountWhereInput | boolean
    connect?: UserBreakglassAccountWhereUniqueInput
    update?: XOR<XOR<UserBreakglassAccountUpdateToOneWithWhereWithoutUserInput, UserBreakglassAccountUpdateWithoutUserInput>, UserBreakglassAccountUncheckedUpdateWithoutUserInput>
  }

  export type UserSecurityQuestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSecurityQuestionCreateWithoutUserInput, UserSecurityQuestionUncheckedCreateWithoutUserInput> | UserSecurityQuestionCreateWithoutUserInput[] | UserSecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSecurityQuestionCreateOrConnectWithoutUserInput | UserSecurityQuestionCreateOrConnectWithoutUserInput[]
    upsert?: UserSecurityQuestionUpsertWithWhereUniqueWithoutUserInput | UserSecurityQuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSecurityQuestionCreateManyUserInputEnvelope
    set?: UserSecurityQuestionWhereUniqueInput | UserSecurityQuestionWhereUniqueInput[]
    disconnect?: UserSecurityQuestionWhereUniqueInput | UserSecurityQuestionWhereUniqueInput[]
    delete?: UserSecurityQuestionWhereUniqueInput | UserSecurityQuestionWhereUniqueInput[]
    connect?: UserSecurityQuestionWhereUniqueInput | UserSecurityQuestionWhereUniqueInput[]
    update?: UserSecurityQuestionUpdateWithWhereUniqueWithoutUserInput | UserSecurityQuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSecurityQuestionUpdateManyWithWhereWithoutUserInput | UserSecurityQuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSecurityQuestionScalarWhereInput | UserSecurityQuestionScalarWhereInput[]
  }

  export type UserLoginHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLoginHistoryCreateWithoutUserInput, UserLoginHistoryUncheckedCreateWithoutUserInput> | UserLoginHistoryCreateWithoutUserInput[] | UserLoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginHistoryCreateOrConnectWithoutUserInput | UserLoginHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserLoginHistoryUpsertWithWhereUniqueWithoutUserInput | UserLoginHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLoginHistoryCreateManyUserInputEnvelope
    set?: UserLoginHistoryWhereUniqueInput | UserLoginHistoryWhereUniqueInput[]
    disconnect?: UserLoginHistoryWhereUniqueInput | UserLoginHistoryWhereUniqueInput[]
    delete?: UserLoginHistoryWhereUniqueInput | UserLoginHistoryWhereUniqueInput[]
    connect?: UserLoginHistoryWhereUniqueInput | UserLoginHistoryWhereUniqueInput[]
    update?: UserLoginHistoryUpdateWithWhereUniqueWithoutUserInput | UserLoginHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLoginHistoryUpdateManyWithWhereWithoutUserInput | UserLoginHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLoginHistoryScalarWhereInput | UserLoginHistoryScalarWhereInput[]
  }

  export type UserDeviceFingerprintUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDeviceFingerprintCreateWithoutUserInput, UserDeviceFingerprintUncheckedCreateWithoutUserInput> | UserDeviceFingerprintCreateWithoutUserInput[] | UserDeviceFingerprintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceFingerprintCreateOrConnectWithoutUserInput | UserDeviceFingerprintCreateOrConnectWithoutUserInput[]
    upsert?: UserDeviceFingerprintUpsertWithWhereUniqueWithoutUserInput | UserDeviceFingerprintUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDeviceFingerprintCreateManyUserInputEnvelope
    set?: UserDeviceFingerprintWhereUniqueInput | UserDeviceFingerprintWhereUniqueInput[]
    disconnect?: UserDeviceFingerprintWhereUniqueInput | UserDeviceFingerprintWhereUniqueInput[]
    delete?: UserDeviceFingerprintWhereUniqueInput | UserDeviceFingerprintWhereUniqueInput[]
    connect?: UserDeviceFingerprintWhereUniqueInput | UserDeviceFingerprintWhereUniqueInput[]
    update?: UserDeviceFingerprintUpdateWithWhereUniqueWithoutUserInput | UserDeviceFingerprintUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDeviceFingerprintUpdateManyWithWhereWithoutUserInput | UserDeviceFingerprintUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDeviceFingerprintScalarWhereInput | UserDeviceFingerprintScalarWhereInput[]
  }

  export type ImportJobUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ImportJobCreateWithoutUserInput, ImportJobUncheckedCreateWithoutUserInput> | ImportJobCreateWithoutUserInput[] | ImportJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutUserInput | ImportJobCreateOrConnectWithoutUserInput[]
    upsert?: ImportJobUpsertWithWhereUniqueWithoutUserInput | ImportJobUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ImportJobCreateManyUserInputEnvelope
    set?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    disconnect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    delete?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    update?: ImportJobUpdateWithWhereUniqueWithoutUserInput | ImportJobUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ImportJobUpdateManyWithWhereWithoutUserInput | ImportJobUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRecoveryCodesInput = {
    create?: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecoveryCodesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRecoveryCodesNestedInput = {
    create?: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecoveryCodesInput
    upsert?: UserUpsertWithoutRecoveryCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecoveryCodesInput, UserUpdateWithoutRecoveryCodesInput>, UserUncheckedUpdateWithoutRecoveryCodesInput>
  }

  export type UserCreateNestedOneWithoutSecurityQuestionsInput = {
    create?: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSecurityQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityQuestionsInput
    upsert?: UserUpsertWithoutSecurityQuestionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSecurityQuestionsInput, UserUpdateWithoutSecurityQuestionsInput>, UserUncheckedUpdateWithoutSecurityQuestionsInput>
  }

  export type UserCreateNestedOneWithoutBreakglassAccountInput = {
    create?: XOR<UserCreateWithoutBreakglassAccountInput, UserUncheckedCreateWithoutBreakglassAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutBreakglassAccountInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBreakglassAccountNestedInput = {
    create?: XOR<UserCreateWithoutBreakglassAccountInput, UserUncheckedCreateWithoutBreakglassAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutBreakglassAccountInput
    upsert?: UserUpsertWithoutBreakglassAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBreakglassAccountInput, UserUpdateWithoutBreakglassAccountInput>, UserUncheckedUpdateWithoutBreakglassAccountInput>
  }

  export type UserCreateNestedOneWithoutDeviceFingerprintsInput = {
    create?: XOR<UserCreateWithoutDeviceFingerprintsInput, UserUncheckedCreateWithoutDeviceFingerprintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceFingerprintsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeviceFingerprintsNestedInput = {
    create?: XOR<UserCreateWithoutDeviceFingerprintsInput, UserUncheckedCreateWithoutDeviceFingerprintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceFingerprintsInput
    upsert?: UserUpsertWithoutDeviceFingerprintsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeviceFingerprintsInput, UserUpdateWithoutDeviceFingerprintsInput>, UserUncheckedUpdateWithoutDeviceFingerprintsInput>
  }

  export type UserCreateNestedOneWithoutLoginHistoryInput = {
    create?: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLoginHistoryNestedInput = {
    create?: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginHistoryInput
    upsert?: UserUpsertWithoutLoginHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLoginHistoryInput, UserUpdateWithoutLoginHistoryInput>, UserUncheckedUpdateWithoutLoginHistoryInput>
  }

  export type OrgCreateNestedOneWithoutLeadsInput = {
    create?: XOR<OrgCreateWithoutLeadsInput, OrgUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutLeadsInput
    connect?: OrgWhereUniqueInput
  }

  export type LeadInvoiceLineCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadInvoiceLineCreateWithoutLeadInput, LeadInvoiceLineUncheckedCreateWithoutLeadInput> | LeadInvoiceLineCreateWithoutLeadInput[] | LeadInvoiceLineUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadInvoiceLineCreateOrConnectWithoutLeadInput | LeadInvoiceLineCreateOrConnectWithoutLeadInput[]
    createMany?: LeadInvoiceLineCreateManyLeadInputEnvelope
    connect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
  }

  export type LeadInvoiceLineUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadInvoiceLineCreateWithoutLeadInput, LeadInvoiceLineUncheckedCreateWithoutLeadInput> | LeadInvoiceLineCreateWithoutLeadInput[] | LeadInvoiceLineUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadInvoiceLineCreateOrConnectWithoutLeadInput | LeadInvoiceLineCreateOrConnectWithoutLeadInput[]
    createMany?: LeadInvoiceLineCreateManyLeadInputEnvelope
    connect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
  }

  export type EnumLeadSourceFieldUpdateOperationsInput = {
    set?: $Enums.LeadSource
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type OrgUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<OrgCreateWithoutLeadsInput, OrgUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutLeadsInput
    upsert?: OrgUpsertWithoutLeadsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutLeadsInput, OrgUpdateWithoutLeadsInput>, OrgUncheckedUpdateWithoutLeadsInput>
  }

  export type LeadInvoiceLineUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadInvoiceLineCreateWithoutLeadInput, LeadInvoiceLineUncheckedCreateWithoutLeadInput> | LeadInvoiceLineCreateWithoutLeadInput[] | LeadInvoiceLineUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadInvoiceLineCreateOrConnectWithoutLeadInput | LeadInvoiceLineCreateOrConnectWithoutLeadInput[]
    upsert?: LeadInvoiceLineUpsertWithWhereUniqueWithoutLeadInput | LeadInvoiceLineUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadInvoiceLineCreateManyLeadInputEnvelope
    set?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    disconnect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    delete?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    connect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    update?: LeadInvoiceLineUpdateWithWhereUniqueWithoutLeadInput | LeadInvoiceLineUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadInvoiceLineUpdateManyWithWhereWithoutLeadInput | LeadInvoiceLineUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadInvoiceLineScalarWhereInput | LeadInvoiceLineScalarWhereInput[]
  }

  export type LeadInvoiceLineUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadInvoiceLineCreateWithoutLeadInput, LeadInvoiceLineUncheckedCreateWithoutLeadInput> | LeadInvoiceLineCreateWithoutLeadInput[] | LeadInvoiceLineUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadInvoiceLineCreateOrConnectWithoutLeadInput | LeadInvoiceLineCreateOrConnectWithoutLeadInput[]
    upsert?: LeadInvoiceLineUpsertWithWhereUniqueWithoutLeadInput | LeadInvoiceLineUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadInvoiceLineCreateManyLeadInputEnvelope
    set?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    disconnect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    delete?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    connect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    update?: LeadInvoiceLineUpdateWithWhereUniqueWithoutLeadInput | LeadInvoiceLineUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadInvoiceLineUpdateManyWithWhereWithoutLeadInput | LeadInvoiceLineUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadInvoiceLineScalarWhereInput | LeadInvoiceLineScalarWhereInput[]
  }

  export type OrgCreateNestedOneWithoutCustomersInput = {
    create?: XOR<OrgCreateWithoutCustomersInput, OrgUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: OrgCreateOrConnectWithoutCustomersInput
    connect?: OrgWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutCustomerInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput> | OpportunityCreateWithoutCustomerInput[] | OpportunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCustomerInput | OpportunityCreateOrConnectWithoutCustomerInput[]
    createMany?: OpportunityCreateManyCustomerInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput> | OpportunityCreateWithoutCustomerInput[] | OpportunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCustomerInput | OpportunityCreateOrConnectWithoutCustomerInput[]
    createMany?: OpportunityCreateManyCustomerInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type OrgUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<OrgCreateWithoutCustomersInput, OrgUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: OrgCreateOrConnectWithoutCustomersInput
    upsert?: OrgUpsertWithoutCustomersInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutCustomersInput, OrgUpdateWithoutCustomersInput>, OrgUncheckedUpdateWithoutCustomersInput>
  }

  export type InvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type JobUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCustomerInput | JobUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCustomerInput | JobUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCustomerInput | JobUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput> | OpportunityCreateWithoutCustomerInput[] | OpportunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCustomerInput | OpportunityCreateOrConnectWithoutCustomerInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutCustomerInput | OpportunityUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OpportunityCreateManyCustomerInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutCustomerInput | OpportunityUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutCustomerInput | OpportunityUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput> | JobCreateWithoutCustomerInput[] | JobUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCustomerInput | JobCreateOrConnectWithoutCustomerInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCustomerInput | JobUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: JobCreateManyCustomerInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCustomerInput | JobUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCustomerInput | JobUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput> | OpportunityCreateWithoutCustomerInput[] | OpportunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCustomerInput | OpportunityCreateOrConnectWithoutCustomerInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutCustomerInput | OpportunityUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OpportunityCreateManyCustomerInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutCustomerInput | OpportunityUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutCustomerInput | OpportunityUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<CustomerCreateWithoutOpportunitiesInput, CustomerUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOpportunitiesInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrgCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<OrgCreateWithoutOpportunitiesInput, OrgUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutOpportunitiesInput
    connect?: OrgWhereUniqueInput
  }

  export type EnumValueTypeFieldUpdateOperationsInput = {
    set?: $Enums.ValueType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput = {
    create?: XOR<CustomerCreateWithoutOpportunitiesInput, CustomerUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOpportunitiesInput
    upsert?: CustomerUpsertWithoutOpportunitiesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOpportunitiesInput, CustomerUpdateWithoutOpportunitiesInput>, CustomerUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type OrgUpdateOneRequiredWithoutOpportunitiesNestedInput = {
    create?: XOR<OrgCreateWithoutOpportunitiesInput, OrgUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutOpportunitiesInput
    upsert?: OrgUpsertWithoutOpportunitiesInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutOpportunitiesInput, OrgUpdateWithoutOpportunitiesInput>, OrgUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type InvoiceLineCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrgCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<OrgCreateWithoutInvoicesInput, OrgUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutInvoicesInput
    connect?: OrgWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type CustomerUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    upsert?: CustomerUpsertWithoutInvoicesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutInvoicesInput, CustomerUpdateWithoutInvoicesInput>, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrgUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<OrgCreateWithoutInvoicesInput, OrgUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutInvoicesInput
    upsert?: OrgUpsertWithoutInvoicesInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutInvoicesInput, OrgUpdateWithoutInvoicesInput>, OrgUncheckedUpdateWithoutInvoicesInput>
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type OrgCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrgCreateWithoutPaymentsInput, OrgUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutPaymentsInput
    connect?: OrgWhereUniqueInput
  }

  export type InvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrgUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<OrgCreateWithoutPaymentsInput, OrgUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutPaymentsInput
    upsert?: OrgUpsertWithoutPaymentsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutPaymentsInput, OrgUpdateWithoutPaymentsInput>, OrgUncheckedUpdateWithoutPaymentsInput>
  }

  export type JobCreateNestedManyWithoutRfpInput = {
    create?: XOR<JobCreateWithoutRfpInput, JobUncheckedCreateWithoutRfpInput> | JobCreateWithoutRfpInput[] | JobUncheckedCreateWithoutRfpInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRfpInput | JobCreateOrConnectWithoutRfpInput[]
    createMany?: JobCreateManyRfpInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type OrgCreateNestedOneWithoutRfpsInput = {
    create?: XOR<OrgCreateWithoutRfpsInput, OrgUncheckedCreateWithoutRfpsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutRfpsInput
    connect?: OrgWhereUniqueInput
  }

  export type JobUncheckedCreateNestedManyWithoutRfpInput = {
    create?: XOR<JobCreateWithoutRfpInput, JobUncheckedCreateWithoutRfpInput> | JobCreateWithoutRfpInput[] | JobUncheckedCreateWithoutRfpInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRfpInput | JobCreateOrConnectWithoutRfpInput[]
    createMany?: JobCreateManyRfpInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobUpdateManyWithoutRfpNestedInput = {
    create?: XOR<JobCreateWithoutRfpInput, JobUncheckedCreateWithoutRfpInput> | JobCreateWithoutRfpInput[] | JobUncheckedCreateWithoutRfpInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRfpInput | JobCreateOrConnectWithoutRfpInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutRfpInput | JobUpsertWithWhereUniqueWithoutRfpInput[]
    createMany?: JobCreateManyRfpInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutRfpInput | JobUpdateWithWhereUniqueWithoutRfpInput[]
    updateMany?: JobUpdateManyWithWhereWithoutRfpInput | JobUpdateManyWithWhereWithoutRfpInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type OrgUpdateOneRequiredWithoutRfpsNestedInput = {
    create?: XOR<OrgCreateWithoutRfpsInput, OrgUncheckedCreateWithoutRfpsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutRfpsInput
    upsert?: OrgUpsertWithoutRfpsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutRfpsInput, OrgUpdateWithoutRfpsInput>, OrgUncheckedUpdateWithoutRfpsInput>
  }

  export type JobUncheckedUpdateManyWithoutRfpNestedInput = {
    create?: XOR<JobCreateWithoutRfpInput, JobUncheckedCreateWithoutRfpInput> | JobCreateWithoutRfpInput[] | JobUncheckedCreateWithoutRfpInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRfpInput | JobCreateOrConnectWithoutRfpInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutRfpInput | JobUpsertWithWhereUniqueWithoutRfpInput[]
    createMany?: JobCreateManyRfpInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutRfpInput | JobUpdateWithWhereUniqueWithoutRfpInput[]
    updateMany?: JobUpdateManyWithWhereWithoutRfpInput | JobUpdateManyWithWhereWithoutRfpInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutJobsInput = {
    create?: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJobsInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrgCreateNestedOneWithoutJobsInput = {
    create?: XOR<OrgCreateWithoutJobsInput, OrgUncheckedCreateWithoutJobsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutJobsInput
    connect?: OrgWhereUniqueInput
  }

  export type RfpCreateNestedOneWithoutJobsInput = {
    create?: XOR<RfpCreateWithoutJobsInput, RfpUncheckedCreateWithoutJobsInput>
    connectOrCreate?: RfpCreateOrConnectWithoutJobsInput
    connect?: RfpWhereUniqueInput
  }

  export type CustomerUpdateOneWithoutJobsNestedInput = {
    create?: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJobsInput
    upsert?: CustomerUpsertWithoutJobsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutJobsInput, CustomerUpdateWithoutJobsInput>, CustomerUncheckedUpdateWithoutJobsInput>
  }

  export type OrgUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<OrgCreateWithoutJobsInput, OrgUncheckedCreateWithoutJobsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutJobsInput
    upsert?: OrgUpsertWithoutJobsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutJobsInput, OrgUpdateWithoutJobsInput>, OrgUncheckedUpdateWithoutJobsInput>
  }

  export type RfpUpdateOneWithoutJobsNestedInput = {
    create?: XOR<RfpCreateWithoutJobsInput, RfpUncheckedCreateWithoutJobsInput>
    connectOrCreate?: RfpCreateOrConnectWithoutJobsInput
    upsert?: RfpUpsertWithoutJobsInput
    disconnect?: RfpWhereInput | boolean
    delete?: RfpWhereInput | boolean
    connect?: RfpWhereUniqueInput
    update?: XOR<XOR<RfpUpdateToOneWithWhereWithoutJobsInput, RfpUpdateWithoutJobsInput>, RfpUncheckedUpdateWithoutJobsInput>
  }

  export type OrgCreateNestedOneWithoutReferralsInput = {
    create?: XOR<OrgCreateWithoutReferralsInput, OrgUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutReferralsInput
    connect?: OrgWhereUniqueInput
  }

  export type OrgUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<OrgCreateWithoutReferralsInput, OrgUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutReferralsInput
    upsert?: OrgUpsertWithoutReferralsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutReferralsInput, OrgUpdateWithoutReferralsInput>, OrgUncheckedUpdateWithoutReferralsInput>
  }

  export type OrgCreateNestedOneWithoutLedgerInput = {
    create?: XOR<OrgCreateWithoutLedgerInput, OrgUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: OrgCreateOrConnectWithoutLedgerInput
    connect?: OrgWhereUniqueInput
  }

  export type EnumLedgerTypeFieldUpdateOperationsInput = {
    set?: $Enums.LedgerType
  }

  export type OrgUpdateOneRequiredWithoutLedgerNestedInput = {
    create?: XOR<OrgCreateWithoutLedgerInput, OrgUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: OrgCreateOrConnectWithoutLedgerInput
    upsert?: OrgUpsertWithoutLedgerInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutLedgerInput, OrgUpdateWithoutLedgerInput>, OrgUncheckedUpdateWithoutLedgerInput>
  }

  export type OrgCreateNestedOneWithoutLeadInvoicesInput = {
    create?: XOR<OrgCreateWithoutLeadInvoicesInput, OrgUncheckedCreateWithoutLeadInvoicesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutLeadInvoicesInput
    connect?: OrgWhereUniqueInput
  }

  export type LeadInvoiceLineCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<LeadInvoiceLineCreateWithoutInvoiceInput, LeadInvoiceLineUncheckedCreateWithoutInvoiceInput> | LeadInvoiceLineCreateWithoutInvoiceInput[] | LeadInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LeadInvoiceLineCreateOrConnectWithoutInvoiceInput | LeadInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: LeadInvoiceLineCreateManyInvoiceInputEnvelope
    connect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
  }

  export type LeadInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<LeadInvoiceLineCreateWithoutInvoiceInput, LeadInvoiceLineUncheckedCreateWithoutInvoiceInput> | LeadInvoiceLineCreateWithoutInvoiceInput[] | LeadInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LeadInvoiceLineCreateOrConnectWithoutInvoiceInput | LeadInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: LeadInvoiceLineCreateManyInvoiceInputEnvelope
    connect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
  }

  export type OrgUpdateOneWithoutLeadInvoicesNestedInput = {
    create?: XOR<OrgCreateWithoutLeadInvoicesInput, OrgUncheckedCreateWithoutLeadInvoicesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutLeadInvoicesInput
    upsert?: OrgUpsertWithoutLeadInvoicesInput
    disconnect?: OrgWhereInput | boolean
    delete?: OrgWhereInput | boolean
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutLeadInvoicesInput, OrgUpdateWithoutLeadInvoicesInput>, OrgUncheckedUpdateWithoutLeadInvoicesInput>
  }

  export type LeadInvoiceLineUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<LeadInvoiceLineCreateWithoutInvoiceInput, LeadInvoiceLineUncheckedCreateWithoutInvoiceInput> | LeadInvoiceLineCreateWithoutInvoiceInput[] | LeadInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LeadInvoiceLineCreateOrConnectWithoutInvoiceInput | LeadInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: LeadInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | LeadInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: LeadInvoiceLineCreateManyInvoiceInputEnvelope
    set?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    disconnect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    delete?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    connect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    update?: LeadInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | LeadInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: LeadInvoiceLineUpdateManyWithWhereWithoutInvoiceInput | LeadInvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: LeadInvoiceLineScalarWhereInput | LeadInvoiceLineScalarWhereInput[]
  }

  export type LeadInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<LeadInvoiceLineCreateWithoutInvoiceInput, LeadInvoiceLineUncheckedCreateWithoutInvoiceInput> | LeadInvoiceLineCreateWithoutInvoiceInput[] | LeadInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LeadInvoiceLineCreateOrConnectWithoutInvoiceInput | LeadInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: LeadInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | LeadInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: LeadInvoiceLineCreateManyInvoiceInputEnvelope
    set?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    disconnect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    delete?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    connect?: LeadInvoiceLineWhereUniqueInput | LeadInvoiceLineWhereUniqueInput[]
    update?: LeadInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | LeadInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: LeadInvoiceLineUpdateManyWithWhereWithoutInvoiceInput | LeadInvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: LeadInvoiceLineScalarWhereInput | LeadInvoiceLineScalarWhereInput[]
  }

  export type LeadInvoiceCreateNestedOneWithoutLinesInput = {
    create?: XOR<LeadInvoiceCreateWithoutLinesInput, LeadInvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: LeadInvoiceCreateOrConnectWithoutLinesInput
    connect?: LeadInvoiceWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutLeadInvoiceLineInput = {
    create?: XOR<LeadCreateWithoutLeadInvoiceLineInput, LeadUncheckedCreateWithoutLeadInvoiceLineInput>
    connectOrCreate?: LeadCreateOrConnectWithoutLeadInvoiceLineInput
    connect?: LeadWhereUniqueInput
  }

  export type LeadInvoiceUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<LeadInvoiceCreateWithoutLinesInput, LeadInvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: LeadInvoiceCreateOrConnectWithoutLinesInput
    upsert?: LeadInvoiceUpsertWithoutLinesInput
    connect?: LeadInvoiceWhereUniqueInput
    update?: XOR<XOR<LeadInvoiceUpdateToOneWithWhereWithoutLinesInput, LeadInvoiceUpdateWithoutLinesInput>, LeadInvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type LeadUpdateOneWithoutLeadInvoiceLineNestedInput = {
    create?: XOR<LeadCreateWithoutLeadInvoiceLineInput, LeadUncheckedCreateWithoutLeadInvoiceLineInput>
    connectOrCreate?: LeadCreateOrConnectWithoutLeadInvoiceLineInput
    upsert?: LeadUpsertWithoutLeadInvoiceLineInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutLeadInvoiceLineInput, LeadUpdateWithoutLeadInvoiceLineInput>, LeadUncheckedUpdateWithoutLeadInvoiceLineInput>
  }

  export type OrgCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<OrgCreateWithoutAuditLogsInput, OrgUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutAuditLogsInput
    connect?: OrgWhereUniqueInput
  }

  export type OrgUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<OrgCreateWithoutAuditLogsInput, OrgUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutAuditLogsInput
    upsert?: OrgUpsertWithoutAuditLogsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutAuditLogsInput, OrgUpdateWithoutAuditLogsInput>, OrgUncheckedUpdateWithoutAuditLogsInput>
  }

  export type RbacRolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RbacRolePermissionCreateWithoutPermissionInput, RbacRolePermissionUncheckedCreateWithoutPermissionInput> | RbacRolePermissionCreateWithoutPermissionInput[] | RbacRolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RbacRolePermissionCreateOrConnectWithoutPermissionInput | RbacRolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RbacRolePermissionCreateManyPermissionInputEnvelope
    connect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
  }

  export type RbacRolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RbacRolePermissionCreateWithoutPermissionInput, RbacRolePermissionUncheckedCreateWithoutPermissionInput> | RbacRolePermissionCreateWithoutPermissionInput[] | RbacRolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RbacRolePermissionCreateOrConnectWithoutPermissionInput | RbacRolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RbacRolePermissionCreateManyPermissionInputEnvelope
    connect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
  }

  export type RbacRolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RbacRolePermissionCreateWithoutPermissionInput, RbacRolePermissionUncheckedCreateWithoutPermissionInput> | RbacRolePermissionCreateWithoutPermissionInput[] | RbacRolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RbacRolePermissionCreateOrConnectWithoutPermissionInput | RbacRolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RbacRolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RbacRolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RbacRolePermissionCreateManyPermissionInputEnvelope
    set?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    disconnect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    delete?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    connect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    update?: RbacRolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RbacRolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RbacRolePermissionUpdateManyWithWhereWithoutPermissionInput | RbacRolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RbacRolePermissionScalarWhereInput | RbacRolePermissionScalarWhereInput[]
  }

  export type RbacRolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RbacRolePermissionCreateWithoutPermissionInput, RbacRolePermissionUncheckedCreateWithoutPermissionInput> | RbacRolePermissionCreateWithoutPermissionInput[] | RbacRolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RbacRolePermissionCreateOrConnectWithoutPermissionInput | RbacRolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RbacRolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RbacRolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RbacRolePermissionCreateManyPermissionInputEnvelope
    set?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    disconnect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    delete?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    connect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    update?: RbacRolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RbacRolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RbacRolePermissionUpdateManyWithWhereWithoutPermissionInput | RbacRolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RbacRolePermissionScalarWhereInput | RbacRolePermissionScalarWhereInput[]
  }

  export type OrgCreateNestedOneWithoutRbacRolesInput = {
    create?: XOR<OrgCreateWithoutRbacRolesInput, OrgUncheckedCreateWithoutRbacRolesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutRbacRolesInput
    connect?: OrgWhereUniqueInput
  }

  export type RbacRolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RbacRolePermissionCreateWithoutRoleInput, RbacRolePermissionUncheckedCreateWithoutRoleInput> | RbacRolePermissionCreateWithoutRoleInput[] | RbacRolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RbacRolePermissionCreateOrConnectWithoutRoleInput | RbacRolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RbacRolePermissionCreateManyRoleInputEnvelope
    connect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
  }

  export type RbacUserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<RbacUserRoleCreateWithoutRoleInput, RbacUserRoleUncheckedCreateWithoutRoleInput> | RbacUserRoleCreateWithoutRoleInput[] | RbacUserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutRoleInput | RbacUserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: RbacUserRoleCreateManyRoleInputEnvelope
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
  }

  export type RbacRolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RbacRolePermissionCreateWithoutRoleInput, RbacRolePermissionUncheckedCreateWithoutRoleInput> | RbacRolePermissionCreateWithoutRoleInput[] | RbacRolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RbacRolePermissionCreateOrConnectWithoutRoleInput | RbacRolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RbacRolePermissionCreateManyRoleInputEnvelope
    connect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
  }

  export type RbacUserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RbacUserRoleCreateWithoutRoleInput, RbacUserRoleUncheckedCreateWithoutRoleInput> | RbacUserRoleCreateWithoutRoleInput[] | RbacUserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutRoleInput | RbacUserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: RbacUserRoleCreateManyRoleInputEnvelope
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
  }

  export type OrgUpdateOneWithoutRbacRolesNestedInput = {
    create?: XOR<OrgCreateWithoutRbacRolesInput, OrgUncheckedCreateWithoutRbacRolesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutRbacRolesInput
    upsert?: OrgUpsertWithoutRbacRolesInput
    disconnect?: OrgWhereInput | boolean
    delete?: OrgWhereInput | boolean
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutRbacRolesInput, OrgUpdateWithoutRbacRolesInput>, OrgUncheckedUpdateWithoutRbacRolesInput>
  }

  export type RbacRolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RbacRolePermissionCreateWithoutRoleInput, RbacRolePermissionUncheckedCreateWithoutRoleInput> | RbacRolePermissionCreateWithoutRoleInput[] | RbacRolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RbacRolePermissionCreateOrConnectWithoutRoleInput | RbacRolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RbacRolePermissionUpsertWithWhereUniqueWithoutRoleInput | RbacRolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RbacRolePermissionCreateManyRoleInputEnvelope
    set?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    disconnect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    delete?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    connect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    update?: RbacRolePermissionUpdateWithWhereUniqueWithoutRoleInput | RbacRolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RbacRolePermissionUpdateManyWithWhereWithoutRoleInput | RbacRolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RbacRolePermissionScalarWhereInput | RbacRolePermissionScalarWhereInput[]
  }

  export type RbacUserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RbacUserRoleCreateWithoutRoleInput, RbacUserRoleUncheckedCreateWithoutRoleInput> | RbacUserRoleCreateWithoutRoleInput[] | RbacUserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutRoleInput | RbacUserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: RbacUserRoleUpsertWithWhereUniqueWithoutRoleInput | RbacUserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RbacUserRoleCreateManyRoleInputEnvelope
    set?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    disconnect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    delete?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    update?: RbacUserRoleUpdateWithWhereUniqueWithoutRoleInput | RbacUserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RbacUserRoleUpdateManyWithWhereWithoutRoleInput | RbacUserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RbacUserRoleScalarWhereInput | RbacUserRoleScalarWhereInput[]
  }

  export type RbacRolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RbacRolePermissionCreateWithoutRoleInput, RbacRolePermissionUncheckedCreateWithoutRoleInput> | RbacRolePermissionCreateWithoutRoleInput[] | RbacRolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RbacRolePermissionCreateOrConnectWithoutRoleInput | RbacRolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RbacRolePermissionUpsertWithWhereUniqueWithoutRoleInput | RbacRolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RbacRolePermissionCreateManyRoleInputEnvelope
    set?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    disconnect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    delete?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    connect?: RbacRolePermissionWhereUniqueInput | RbacRolePermissionWhereUniqueInput[]
    update?: RbacRolePermissionUpdateWithWhereUniqueWithoutRoleInput | RbacRolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RbacRolePermissionUpdateManyWithWhereWithoutRoleInput | RbacRolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RbacRolePermissionScalarWhereInput | RbacRolePermissionScalarWhereInput[]
  }

  export type RbacUserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RbacUserRoleCreateWithoutRoleInput, RbacUserRoleUncheckedCreateWithoutRoleInput> | RbacUserRoleCreateWithoutRoleInput[] | RbacUserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RbacUserRoleCreateOrConnectWithoutRoleInput | RbacUserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: RbacUserRoleUpsertWithWhereUniqueWithoutRoleInput | RbacUserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RbacUserRoleCreateManyRoleInputEnvelope
    set?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    disconnect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    delete?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    connect?: RbacUserRoleWhereUniqueInput | RbacUserRoleWhereUniqueInput[]
    update?: RbacUserRoleUpdateWithWhereUniqueWithoutRoleInput | RbacUserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RbacUserRoleUpdateManyWithWhereWithoutRoleInput | RbacUserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RbacUserRoleScalarWhereInput | RbacUserRoleScalarWhereInput[]
  }

  export type RbacRoleCreateNestedOneWithoutRolePermsInput = {
    create?: XOR<RbacRoleCreateWithoutRolePermsInput, RbacRoleUncheckedCreateWithoutRolePermsInput>
    connectOrCreate?: RbacRoleCreateOrConnectWithoutRolePermsInput
    connect?: RbacRoleWhereUniqueInput
  }

  export type RbacPermissionCreateNestedOneWithoutRolePermsInput = {
    create?: XOR<RbacPermissionCreateWithoutRolePermsInput, RbacPermissionUncheckedCreateWithoutRolePermsInput>
    connectOrCreate?: RbacPermissionCreateOrConnectWithoutRolePermsInput
    connect?: RbacPermissionWhereUniqueInput
  }

  export type RbacRoleUpdateOneRequiredWithoutRolePermsNestedInput = {
    create?: XOR<RbacRoleCreateWithoutRolePermsInput, RbacRoleUncheckedCreateWithoutRolePermsInput>
    connectOrCreate?: RbacRoleCreateOrConnectWithoutRolePermsInput
    upsert?: RbacRoleUpsertWithoutRolePermsInput
    connect?: RbacRoleWhereUniqueInput
    update?: XOR<XOR<RbacRoleUpdateToOneWithWhereWithoutRolePermsInput, RbacRoleUpdateWithoutRolePermsInput>, RbacRoleUncheckedUpdateWithoutRolePermsInput>
  }

  export type RbacPermissionUpdateOneRequiredWithoutRolePermsNestedInput = {
    create?: XOR<RbacPermissionCreateWithoutRolePermsInput, RbacPermissionUncheckedCreateWithoutRolePermsInput>
    connectOrCreate?: RbacPermissionCreateOrConnectWithoutRolePermsInput
    upsert?: RbacPermissionUpsertWithoutRolePermsInput
    connect?: RbacPermissionWhereUniqueInput
    update?: XOR<XOR<RbacPermissionUpdateToOneWithWhereWithoutRolePermsInput, RbacPermissionUpdateWithoutRolePermsInput>, RbacPermissionUncheckedUpdateWithoutRolePermsInput>
  }

  export type UserCreateNestedOneWithoutRbacUserRolesInput = {
    create?: XOR<UserCreateWithoutRbacUserRolesInput, UserUncheckedCreateWithoutRbacUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRbacUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type OrgCreateNestedOneWithoutRbacUserRolesInput = {
    create?: XOR<OrgCreateWithoutRbacUserRolesInput, OrgUncheckedCreateWithoutRbacUserRolesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutRbacUserRolesInput
    connect?: OrgWhereUniqueInput
  }

  export type RbacRoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RbacRoleCreateWithoutUserRolesInput, RbacRoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RbacRoleCreateOrConnectWithoutUserRolesInput
    connect?: RbacRoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRbacUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutRbacUserRolesInput, UserUncheckedCreateWithoutRbacUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRbacUserRolesInput
    upsert?: UserUpsertWithoutRbacUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRbacUserRolesInput, UserUpdateWithoutRbacUserRolesInput>, UserUncheckedUpdateWithoutRbacUserRolesInput>
  }

  export type OrgUpdateOneWithoutRbacUserRolesNestedInput = {
    create?: XOR<OrgCreateWithoutRbacUserRolesInput, OrgUncheckedCreateWithoutRbacUserRolesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutRbacUserRolesInput
    upsert?: OrgUpsertWithoutRbacUserRolesInput
    disconnect?: OrgWhereInput | boolean
    delete?: OrgWhereInput | boolean
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutRbacUserRolesInput, OrgUpdateWithoutRbacUserRolesInput>, OrgUncheckedUpdateWithoutRbacUserRolesInput>
  }

  export type RbacRoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RbacRoleCreateWithoutUserRolesInput, RbacRoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RbacRoleCreateOrConnectWithoutUserRolesInput
    upsert?: RbacRoleUpsertWithoutUserRolesInput
    connect?: RbacRoleWhereUniqueInput
    update?: XOR<XOR<RbacRoleUpdateToOneWithWhereWithoutUserRolesInput, RbacRoleUpdateWithoutUserRolesInput>, RbacRoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type OrgCreateNestedOneWithoutPricingPlanInput = {
    create?: XOR<OrgCreateWithoutPricingPlanInput, OrgUncheckedCreateWithoutPricingPlanInput>
    connectOrCreate?: OrgCreateOrConnectWithoutPricingPlanInput
    connect?: OrgWhereUniqueInput
  }

  export type EnumPricingModelFieldUpdateOperationsInput = {
    set?: $Enums.PricingModel
  }

  export type OrgUpdateOneRequiredWithoutPricingPlanNestedInput = {
    create?: XOR<OrgCreateWithoutPricingPlanInput, OrgUncheckedCreateWithoutPricingPlanInput>
    connectOrCreate?: OrgCreateOrConnectWithoutPricingPlanInput
    upsert?: OrgUpsertWithoutPricingPlanInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutPricingPlanInput, OrgUpdateWithoutPricingPlanInput>, OrgUncheckedUpdateWithoutPricingPlanInput>
  }

  export type OrgCreateNestedOneWithoutAiUsageEventsInput = {
    create?: XOR<OrgCreateWithoutAiUsageEventsInput, OrgUncheckedCreateWithoutAiUsageEventsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutAiUsageEventsInput
    connect?: OrgWhereUniqueInput
  }

  export type OrgUpdateOneRequiredWithoutAiUsageEventsNestedInput = {
    create?: XOR<OrgCreateWithoutAiUsageEventsInput, OrgUncheckedCreateWithoutAiUsageEventsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutAiUsageEventsInput
    upsert?: OrgUpsertWithoutAiUsageEventsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutAiUsageEventsInput, OrgUpdateWithoutAiUsageEventsInput>, OrgUncheckedUpdateWithoutAiUsageEventsInput>
  }

  export type OrgCreateNestedOneWithoutAiMonthlySummariesInput = {
    create?: XOR<OrgCreateWithoutAiMonthlySummariesInput, OrgUncheckedCreateWithoutAiMonthlySummariesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutAiMonthlySummariesInput
    connect?: OrgWhereUniqueInput
  }

  export type OrgUpdateOneRequiredWithoutAiMonthlySummariesNestedInput = {
    create?: XOR<OrgCreateWithoutAiMonthlySummariesInput, OrgUncheckedCreateWithoutAiMonthlySummariesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutAiMonthlySummariesInput
    upsert?: OrgUpsertWithoutAiMonthlySummariesInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutAiMonthlySummariesInput, OrgUpdateWithoutAiMonthlySummariesInput>, OrgUncheckedUpdateWithoutAiMonthlySummariesInput>
  }

  export type OrgCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<OrgCreateWithoutActivitiesInput, OrgUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutActivitiesInput
    connect?: OrgWhereUniqueInput
  }

  export type OrgUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<OrgCreateWithoutActivitiesInput, OrgUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutActivitiesInput
    upsert?: OrgUpsertWithoutActivitiesInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutActivitiesInput, OrgUpdateWithoutActivitiesInput>, OrgUncheckedUpdateWithoutActivitiesInput>
  }

  export type OrgCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<OrgCreateWithoutSubscriptionsInput, OrgUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutSubscriptionsInput
    connect?: OrgWhereUniqueInput
  }

  export type OrgUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<OrgCreateWithoutSubscriptionsInput, OrgUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutSubscriptionsInput
    upsert?: OrgUpsertWithoutSubscriptionsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutSubscriptionsInput, OrgUpdateWithoutSubscriptionsInput>, OrgUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type OrgCreateNestedOneWithoutUsageMetersInput = {
    create?: XOR<OrgCreateWithoutUsageMetersInput, OrgUncheckedCreateWithoutUsageMetersInput>
    connectOrCreate?: OrgCreateOrConnectWithoutUsageMetersInput
    connect?: OrgWhereUniqueInput
  }

  export type OrgUpdateOneRequiredWithoutUsageMetersNestedInput = {
    create?: XOR<OrgCreateWithoutUsageMetersInput, OrgUncheckedCreateWithoutUsageMetersInput>
    connectOrCreate?: OrgCreateOrConnectWithoutUsageMetersInput
    upsert?: OrgUpsertWithoutUsageMetersInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutUsageMetersInput, OrgUpdateWithoutUsageMetersInput>, OrgUncheckedUpdateWithoutUsageMetersInput>
  }

  export type OrgCreateNestedOneWithoutAddonPurchasesInput = {
    create?: XOR<OrgCreateWithoutAddonPurchasesInput, OrgUncheckedCreateWithoutAddonPurchasesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutAddonPurchasesInput
    connect?: OrgWhereUniqueInput
  }

  export type OrgUpdateOneRequiredWithoutAddonPurchasesNestedInput = {
    create?: XOR<OrgCreateWithoutAddonPurchasesInput, OrgUncheckedCreateWithoutAddonPurchasesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutAddonPurchasesInput
    upsert?: OrgUpsertWithoutAddonPurchasesInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutAddonPurchasesInput, OrgUpdateWithoutAddonPurchasesInput>, OrgUncheckedUpdateWithoutAddonPurchasesInput>
  }

  export type OrgCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<OrgCreateWithoutIncidentsInput, OrgUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutIncidentsInput
    connect?: OrgWhereUniqueInput
  }

  export type EnumIncidentSeverityFieldUpdateOperationsInput = {
    set?: $Enums.IncidentSeverity
  }

  export type EnumIncidentStatusFieldUpdateOperationsInput = {
    set?: $Enums.IncidentStatus
  }

  export type OrgUpdateOneRequiredWithoutIncidentsNestedInput = {
    create?: XOR<OrgCreateWithoutIncidentsInput, OrgUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutIncidentsInput
    upsert?: OrgUpsertWithoutIncidentsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutIncidentsInput, OrgUpdateWithoutIncidentsInput>, OrgUncheckedUpdateWithoutIncidentsInput>
  }

  export type InvoiceCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLineItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumInvoiceLineTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceLineType
  }

  export type InvoiceUpdateOneRequiredWithoutLineItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLineItemsInput
    upsert?: InvoiceUpsertWithoutLineItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLineItemsInput, InvoiceUpdateWithoutLineItemsInput>, InvoiceUncheckedUpdateWithoutLineItemsInput>
  }

  export type OrgCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<OrgCreateWithoutNotificationsInput, OrgUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutNotificationsInput
    connect?: OrgWhereUniqueInput
  }

  export type OrgUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<OrgCreateWithoutNotificationsInput, OrgUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutNotificationsInput
    upsert?: OrgUpsertWithoutNotificationsInput
    disconnect?: OrgWhereInput | boolean
    delete?: OrgWhereInput | boolean
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutNotificationsInput, OrgUpdateWithoutNotificationsInput>, OrgUncheckedUpdateWithoutNotificationsInput>
  }

  export type PlanPriceCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanPriceCreateWithoutPlanInput, PlanPriceUncheckedCreateWithoutPlanInput> | PlanPriceCreateWithoutPlanInput[] | PlanPriceUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPriceCreateOrConnectWithoutPlanInput | PlanPriceCreateOrConnectWithoutPlanInput[]
    createMany?: PlanPriceCreateManyPlanInputEnvelope
    connect?: PlanPriceWhereUniqueInput | PlanPriceWhereUniqueInput[]
  }

  export type OfferCreateNestedManyWithoutAppliesToPlanInput = {
    create?: XOR<OfferCreateWithoutAppliesToPlanInput, OfferUncheckedCreateWithoutAppliesToPlanInput> | OfferCreateWithoutAppliesToPlanInput[] | OfferUncheckedCreateWithoutAppliesToPlanInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutAppliesToPlanInput | OfferCreateOrConnectWithoutAppliesToPlanInput[]
    createMany?: OfferCreateManyAppliesToPlanInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type TenantPriceOverrideCreateNestedManyWithoutPlanInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutPlanInput, TenantPriceOverrideUncheckedCreateWithoutPlanInput> | TenantPriceOverrideCreateWithoutPlanInput[] | TenantPriceOverrideUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutPlanInput | TenantPriceOverrideCreateOrConnectWithoutPlanInput[]
    createMany?: TenantPriceOverrideCreateManyPlanInputEnvelope
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
  }

  export type GlobalMonetizationConfigCreateNestedManyWithoutDefaultPlanInput = {
    create?: XOR<GlobalMonetizationConfigCreateWithoutDefaultPlanInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput> | GlobalMonetizationConfigCreateWithoutDefaultPlanInput[] | GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput[]
    connectOrCreate?: GlobalMonetizationConfigCreateOrConnectWithoutDefaultPlanInput | GlobalMonetizationConfigCreateOrConnectWithoutDefaultPlanInput[]
    createMany?: GlobalMonetizationConfigCreateManyDefaultPlanInputEnvelope
    connect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
  }

  export type OnboardingInviteCreateNestedManyWithoutPlanInput = {
    create?: XOR<OnboardingInviteCreateWithoutPlanInput, OnboardingInviteUncheckedCreateWithoutPlanInput> | OnboardingInviteCreateWithoutPlanInput[] | OnboardingInviteUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutPlanInput | OnboardingInviteCreateOrConnectWithoutPlanInput[]
    createMany?: OnboardingInviteCreateManyPlanInputEnvelope
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
  }

  export type PlanPriceUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanPriceCreateWithoutPlanInput, PlanPriceUncheckedCreateWithoutPlanInput> | PlanPriceCreateWithoutPlanInput[] | PlanPriceUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPriceCreateOrConnectWithoutPlanInput | PlanPriceCreateOrConnectWithoutPlanInput[]
    createMany?: PlanPriceCreateManyPlanInputEnvelope
    connect?: PlanPriceWhereUniqueInput | PlanPriceWhereUniqueInput[]
  }

  export type OfferUncheckedCreateNestedManyWithoutAppliesToPlanInput = {
    create?: XOR<OfferCreateWithoutAppliesToPlanInput, OfferUncheckedCreateWithoutAppliesToPlanInput> | OfferCreateWithoutAppliesToPlanInput[] | OfferUncheckedCreateWithoutAppliesToPlanInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutAppliesToPlanInput | OfferCreateOrConnectWithoutAppliesToPlanInput[]
    createMany?: OfferCreateManyAppliesToPlanInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type TenantPriceOverrideUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutPlanInput, TenantPriceOverrideUncheckedCreateWithoutPlanInput> | TenantPriceOverrideCreateWithoutPlanInput[] | TenantPriceOverrideUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutPlanInput | TenantPriceOverrideCreateOrConnectWithoutPlanInput[]
    createMany?: TenantPriceOverrideCreateManyPlanInputEnvelope
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
  }

  export type GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPlanInput = {
    create?: XOR<GlobalMonetizationConfigCreateWithoutDefaultPlanInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput> | GlobalMonetizationConfigCreateWithoutDefaultPlanInput[] | GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput[]
    connectOrCreate?: GlobalMonetizationConfigCreateOrConnectWithoutDefaultPlanInput | GlobalMonetizationConfigCreateOrConnectWithoutDefaultPlanInput[]
    createMany?: GlobalMonetizationConfigCreateManyDefaultPlanInputEnvelope
    connect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
  }

  export type OnboardingInviteUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<OnboardingInviteCreateWithoutPlanInput, OnboardingInviteUncheckedCreateWithoutPlanInput> | OnboardingInviteCreateWithoutPlanInput[] | OnboardingInviteUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutPlanInput | OnboardingInviteCreateOrConnectWithoutPlanInput[]
    createMany?: OnboardingInviteCreateManyPlanInputEnvelope
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
  }

  export type PlanPriceUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanPriceCreateWithoutPlanInput, PlanPriceUncheckedCreateWithoutPlanInput> | PlanPriceCreateWithoutPlanInput[] | PlanPriceUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPriceCreateOrConnectWithoutPlanInput | PlanPriceCreateOrConnectWithoutPlanInput[]
    upsert?: PlanPriceUpsertWithWhereUniqueWithoutPlanInput | PlanPriceUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanPriceCreateManyPlanInputEnvelope
    set?: PlanPriceWhereUniqueInput | PlanPriceWhereUniqueInput[]
    disconnect?: PlanPriceWhereUniqueInput | PlanPriceWhereUniqueInput[]
    delete?: PlanPriceWhereUniqueInput | PlanPriceWhereUniqueInput[]
    connect?: PlanPriceWhereUniqueInput | PlanPriceWhereUniqueInput[]
    update?: PlanPriceUpdateWithWhereUniqueWithoutPlanInput | PlanPriceUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanPriceUpdateManyWithWhereWithoutPlanInput | PlanPriceUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanPriceScalarWhereInput | PlanPriceScalarWhereInput[]
  }

  export type OfferUpdateManyWithoutAppliesToPlanNestedInput = {
    create?: XOR<OfferCreateWithoutAppliesToPlanInput, OfferUncheckedCreateWithoutAppliesToPlanInput> | OfferCreateWithoutAppliesToPlanInput[] | OfferUncheckedCreateWithoutAppliesToPlanInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutAppliesToPlanInput | OfferCreateOrConnectWithoutAppliesToPlanInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutAppliesToPlanInput | OfferUpsertWithWhereUniqueWithoutAppliesToPlanInput[]
    createMany?: OfferCreateManyAppliesToPlanInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutAppliesToPlanInput | OfferUpdateWithWhereUniqueWithoutAppliesToPlanInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutAppliesToPlanInput | OfferUpdateManyWithWhereWithoutAppliesToPlanInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type TenantPriceOverrideUpdateManyWithoutPlanNestedInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutPlanInput, TenantPriceOverrideUncheckedCreateWithoutPlanInput> | TenantPriceOverrideCreateWithoutPlanInput[] | TenantPriceOverrideUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutPlanInput | TenantPriceOverrideCreateOrConnectWithoutPlanInput[]
    upsert?: TenantPriceOverrideUpsertWithWhereUniqueWithoutPlanInput | TenantPriceOverrideUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: TenantPriceOverrideCreateManyPlanInputEnvelope
    set?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    disconnect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    delete?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    update?: TenantPriceOverrideUpdateWithWhereUniqueWithoutPlanInput | TenantPriceOverrideUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: TenantPriceOverrideUpdateManyWithWhereWithoutPlanInput | TenantPriceOverrideUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: TenantPriceOverrideScalarWhereInput | TenantPriceOverrideScalarWhereInput[]
  }

  export type GlobalMonetizationConfigUpdateManyWithoutDefaultPlanNestedInput = {
    create?: XOR<GlobalMonetizationConfigCreateWithoutDefaultPlanInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput> | GlobalMonetizationConfigCreateWithoutDefaultPlanInput[] | GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput[]
    connectOrCreate?: GlobalMonetizationConfigCreateOrConnectWithoutDefaultPlanInput | GlobalMonetizationConfigCreateOrConnectWithoutDefaultPlanInput[]
    upsert?: GlobalMonetizationConfigUpsertWithWhereUniqueWithoutDefaultPlanInput | GlobalMonetizationConfigUpsertWithWhereUniqueWithoutDefaultPlanInput[]
    createMany?: GlobalMonetizationConfigCreateManyDefaultPlanInputEnvelope
    set?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    disconnect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    delete?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    connect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    update?: GlobalMonetizationConfigUpdateWithWhereUniqueWithoutDefaultPlanInput | GlobalMonetizationConfigUpdateWithWhereUniqueWithoutDefaultPlanInput[]
    updateMany?: GlobalMonetizationConfigUpdateManyWithWhereWithoutDefaultPlanInput | GlobalMonetizationConfigUpdateManyWithWhereWithoutDefaultPlanInput[]
    deleteMany?: GlobalMonetizationConfigScalarWhereInput | GlobalMonetizationConfigScalarWhereInput[]
  }

  export type OnboardingInviteUpdateManyWithoutPlanNestedInput = {
    create?: XOR<OnboardingInviteCreateWithoutPlanInput, OnboardingInviteUncheckedCreateWithoutPlanInput> | OnboardingInviteCreateWithoutPlanInput[] | OnboardingInviteUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutPlanInput | OnboardingInviteCreateOrConnectWithoutPlanInput[]
    upsert?: OnboardingInviteUpsertWithWhereUniqueWithoutPlanInput | OnboardingInviteUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: OnboardingInviteCreateManyPlanInputEnvelope
    set?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    disconnect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    delete?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    update?: OnboardingInviteUpdateWithWhereUniqueWithoutPlanInput | OnboardingInviteUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: OnboardingInviteUpdateManyWithWhereWithoutPlanInput | OnboardingInviteUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: OnboardingInviteScalarWhereInput | OnboardingInviteScalarWhereInput[]
  }

  export type PlanPriceUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanPriceCreateWithoutPlanInput, PlanPriceUncheckedCreateWithoutPlanInput> | PlanPriceCreateWithoutPlanInput[] | PlanPriceUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPriceCreateOrConnectWithoutPlanInput | PlanPriceCreateOrConnectWithoutPlanInput[]
    upsert?: PlanPriceUpsertWithWhereUniqueWithoutPlanInput | PlanPriceUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanPriceCreateManyPlanInputEnvelope
    set?: PlanPriceWhereUniqueInput | PlanPriceWhereUniqueInput[]
    disconnect?: PlanPriceWhereUniqueInput | PlanPriceWhereUniqueInput[]
    delete?: PlanPriceWhereUniqueInput | PlanPriceWhereUniqueInput[]
    connect?: PlanPriceWhereUniqueInput | PlanPriceWhereUniqueInput[]
    update?: PlanPriceUpdateWithWhereUniqueWithoutPlanInput | PlanPriceUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanPriceUpdateManyWithWhereWithoutPlanInput | PlanPriceUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanPriceScalarWhereInput | PlanPriceScalarWhereInput[]
  }

  export type OfferUncheckedUpdateManyWithoutAppliesToPlanNestedInput = {
    create?: XOR<OfferCreateWithoutAppliesToPlanInput, OfferUncheckedCreateWithoutAppliesToPlanInput> | OfferCreateWithoutAppliesToPlanInput[] | OfferUncheckedCreateWithoutAppliesToPlanInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutAppliesToPlanInput | OfferCreateOrConnectWithoutAppliesToPlanInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutAppliesToPlanInput | OfferUpsertWithWhereUniqueWithoutAppliesToPlanInput[]
    createMany?: OfferCreateManyAppliesToPlanInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutAppliesToPlanInput | OfferUpdateWithWhereUniqueWithoutAppliesToPlanInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutAppliesToPlanInput | OfferUpdateManyWithWhereWithoutAppliesToPlanInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type TenantPriceOverrideUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutPlanInput, TenantPriceOverrideUncheckedCreateWithoutPlanInput> | TenantPriceOverrideCreateWithoutPlanInput[] | TenantPriceOverrideUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutPlanInput | TenantPriceOverrideCreateOrConnectWithoutPlanInput[]
    upsert?: TenantPriceOverrideUpsertWithWhereUniqueWithoutPlanInput | TenantPriceOverrideUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: TenantPriceOverrideCreateManyPlanInputEnvelope
    set?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    disconnect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    delete?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    update?: TenantPriceOverrideUpdateWithWhereUniqueWithoutPlanInput | TenantPriceOverrideUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: TenantPriceOverrideUpdateManyWithWhereWithoutPlanInput | TenantPriceOverrideUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: TenantPriceOverrideScalarWhereInput | TenantPriceOverrideScalarWhereInput[]
  }

  export type GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPlanNestedInput = {
    create?: XOR<GlobalMonetizationConfigCreateWithoutDefaultPlanInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput> | GlobalMonetizationConfigCreateWithoutDefaultPlanInput[] | GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput[]
    connectOrCreate?: GlobalMonetizationConfigCreateOrConnectWithoutDefaultPlanInput | GlobalMonetizationConfigCreateOrConnectWithoutDefaultPlanInput[]
    upsert?: GlobalMonetizationConfigUpsertWithWhereUniqueWithoutDefaultPlanInput | GlobalMonetizationConfigUpsertWithWhereUniqueWithoutDefaultPlanInput[]
    createMany?: GlobalMonetizationConfigCreateManyDefaultPlanInputEnvelope
    set?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    disconnect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    delete?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    connect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    update?: GlobalMonetizationConfigUpdateWithWhereUniqueWithoutDefaultPlanInput | GlobalMonetizationConfigUpdateWithWhereUniqueWithoutDefaultPlanInput[]
    updateMany?: GlobalMonetizationConfigUpdateManyWithWhereWithoutDefaultPlanInput | GlobalMonetizationConfigUpdateManyWithWhereWithoutDefaultPlanInput[]
    deleteMany?: GlobalMonetizationConfigScalarWhereInput | GlobalMonetizationConfigScalarWhereInput[]
  }

  export type OnboardingInviteUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<OnboardingInviteCreateWithoutPlanInput, OnboardingInviteUncheckedCreateWithoutPlanInput> | OnboardingInviteCreateWithoutPlanInput[] | OnboardingInviteUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutPlanInput | OnboardingInviteCreateOrConnectWithoutPlanInput[]
    upsert?: OnboardingInviteUpsertWithWhereUniqueWithoutPlanInput | OnboardingInviteUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: OnboardingInviteCreateManyPlanInputEnvelope
    set?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    disconnect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    delete?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    update?: OnboardingInviteUpdateWithWhereUniqueWithoutPlanInput | OnboardingInviteUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: OnboardingInviteUpdateManyWithWhereWithoutPlanInput | OnboardingInviteUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: OnboardingInviteScalarWhereInput | OnboardingInviteScalarWhereInput[]
  }

  export type TenantPriceOverrideCreateNestedManyWithoutPriceInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutPriceInput, TenantPriceOverrideUncheckedCreateWithoutPriceInput> | TenantPriceOverrideCreateWithoutPriceInput[] | TenantPriceOverrideUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutPriceInput | TenantPriceOverrideCreateOrConnectWithoutPriceInput[]
    createMany?: TenantPriceOverrideCreateManyPriceInputEnvelope
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
  }

  export type GlobalMonetizationConfigCreateNestedManyWithoutDefaultPriceInput = {
    create?: XOR<GlobalMonetizationConfigCreateWithoutDefaultPriceInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput> | GlobalMonetizationConfigCreateWithoutDefaultPriceInput[] | GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput[]
    connectOrCreate?: GlobalMonetizationConfigCreateOrConnectWithoutDefaultPriceInput | GlobalMonetizationConfigCreateOrConnectWithoutDefaultPriceInput[]
    createMany?: GlobalMonetizationConfigCreateManyDefaultPriceInputEnvelope
    connect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
  }

  export type OnboardingInviteCreateNestedManyWithoutPriceInput = {
    create?: XOR<OnboardingInviteCreateWithoutPriceInput, OnboardingInviteUncheckedCreateWithoutPriceInput> | OnboardingInviteCreateWithoutPriceInput[] | OnboardingInviteUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutPriceInput | OnboardingInviteCreateOrConnectWithoutPriceInput[]
    createMany?: OnboardingInviteCreateManyPriceInputEnvelope
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
  }

  export type PricePlanCreateNestedOneWithoutPricesInput = {
    create?: XOR<PricePlanCreateWithoutPricesInput, PricePlanUncheckedCreateWithoutPricesInput>
    connectOrCreate?: PricePlanCreateOrConnectWithoutPricesInput
    connect?: PricePlanWhereUniqueInput
  }

  export type TenantPriceOverrideUncheckedCreateNestedManyWithoutPriceInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutPriceInput, TenantPriceOverrideUncheckedCreateWithoutPriceInput> | TenantPriceOverrideCreateWithoutPriceInput[] | TenantPriceOverrideUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutPriceInput | TenantPriceOverrideCreateOrConnectWithoutPriceInput[]
    createMany?: TenantPriceOverrideCreateManyPriceInputEnvelope
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
  }

  export type GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPriceInput = {
    create?: XOR<GlobalMonetizationConfigCreateWithoutDefaultPriceInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput> | GlobalMonetizationConfigCreateWithoutDefaultPriceInput[] | GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput[]
    connectOrCreate?: GlobalMonetizationConfigCreateOrConnectWithoutDefaultPriceInput | GlobalMonetizationConfigCreateOrConnectWithoutDefaultPriceInput[]
    createMany?: GlobalMonetizationConfigCreateManyDefaultPriceInputEnvelope
    connect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
  }

  export type OnboardingInviteUncheckedCreateNestedManyWithoutPriceInput = {
    create?: XOR<OnboardingInviteCreateWithoutPriceInput, OnboardingInviteUncheckedCreateWithoutPriceInput> | OnboardingInviteCreateWithoutPriceInput[] | OnboardingInviteUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutPriceInput | OnboardingInviteCreateOrConnectWithoutPriceInput[]
    createMany?: OnboardingInviteCreateManyPriceInputEnvelope
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
  }

  export type EnumBillingCadenceFieldUpdateOperationsInput = {
    set?: $Enums.BillingCadence
  }

  export type TenantPriceOverrideUpdateManyWithoutPriceNestedInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutPriceInput, TenantPriceOverrideUncheckedCreateWithoutPriceInput> | TenantPriceOverrideCreateWithoutPriceInput[] | TenantPriceOverrideUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutPriceInput | TenantPriceOverrideCreateOrConnectWithoutPriceInput[]
    upsert?: TenantPriceOverrideUpsertWithWhereUniqueWithoutPriceInput | TenantPriceOverrideUpsertWithWhereUniqueWithoutPriceInput[]
    createMany?: TenantPriceOverrideCreateManyPriceInputEnvelope
    set?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    disconnect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    delete?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    update?: TenantPriceOverrideUpdateWithWhereUniqueWithoutPriceInput | TenantPriceOverrideUpdateWithWhereUniqueWithoutPriceInput[]
    updateMany?: TenantPriceOverrideUpdateManyWithWhereWithoutPriceInput | TenantPriceOverrideUpdateManyWithWhereWithoutPriceInput[]
    deleteMany?: TenantPriceOverrideScalarWhereInput | TenantPriceOverrideScalarWhereInput[]
  }

  export type GlobalMonetizationConfigUpdateManyWithoutDefaultPriceNestedInput = {
    create?: XOR<GlobalMonetizationConfigCreateWithoutDefaultPriceInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput> | GlobalMonetizationConfigCreateWithoutDefaultPriceInput[] | GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput[]
    connectOrCreate?: GlobalMonetizationConfigCreateOrConnectWithoutDefaultPriceInput | GlobalMonetizationConfigCreateOrConnectWithoutDefaultPriceInput[]
    upsert?: GlobalMonetizationConfigUpsertWithWhereUniqueWithoutDefaultPriceInput | GlobalMonetizationConfigUpsertWithWhereUniqueWithoutDefaultPriceInput[]
    createMany?: GlobalMonetizationConfigCreateManyDefaultPriceInputEnvelope
    set?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    disconnect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    delete?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    connect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    update?: GlobalMonetizationConfigUpdateWithWhereUniqueWithoutDefaultPriceInput | GlobalMonetizationConfigUpdateWithWhereUniqueWithoutDefaultPriceInput[]
    updateMany?: GlobalMonetizationConfigUpdateManyWithWhereWithoutDefaultPriceInput | GlobalMonetizationConfigUpdateManyWithWhereWithoutDefaultPriceInput[]
    deleteMany?: GlobalMonetizationConfigScalarWhereInput | GlobalMonetizationConfigScalarWhereInput[]
  }

  export type OnboardingInviteUpdateManyWithoutPriceNestedInput = {
    create?: XOR<OnboardingInviteCreateWithoutPriceInput, OnboardingInviteUncheckedCreateWithoutPriceInput> | OnboardingInviteCreateWithoutPriceInput[] | OnboardingInviteUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutPriceInput | OnboardingInviteCreateOrConnectWithoutPriceInput[]
    upsert?: OnboardingInviteUpsertWithWhereUniqueWithoutPriceInput | OnboardingInviteUpsertWithWhereUniqueWithoutPriceInput[]
    createMany?: OnboardingInviteCreateManyPriceInputEnvelope
    set?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    disconnect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    delete?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    update?: OnboardingInviteUpdateWithWhereUniqueWithoutPriceInput | OnboardingInviteUpdateWithWhereUniqueWithoutPriceInput[]
    updateMany?: OnboardingInviteUpdateManyWithWhereWithoutPriceInput | OnboardingInviteUpdateManyWithWhereWithoutPriceInput[]
    deleteMany?: OnboardingInviteScalarWhereInput | OnboardingInviteScalarWhereInput[]
  }

  export type PricePlanUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<PricePlanCreateWithoutPricesInput, PricePlanUncheckedCreateWithoutPricesInput>
    connectOrCreate?: PricePlanCreateOrConnectWithoutPricesInput
    upsert?: PricePlanUpsertWithoutPricesInput
    connect?: PricePlanWhereUniqueInput
    update?: XOR<XOR<PricePlanUpdateToOneWithWhereWithoutPricesInput, PricePlanUpdateWithoutPricesInput>, PricePlanUncheckedUpdateWithoutPricesInput>
  }

  export type TenantPriceOverrideUncheckedUpdateManyWithoutPriceNestedInput = {
    create?: XOR<TenantPriceOverrideCreateWithoutPriceInput, TenantPriceOverrideUncheckedCreateWithoutPriceInput> | TenantPriceOverrideCreateWithoutPriceInput[] | TenantPriceOverrideUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: TenantPriceOverrideCreateOrConnectWithoutPriceInput | TenantPriceOverrideCreateOrConnectWithoutPriceInput[]
    upsert?: TenantPriceOverrideUpsertWithWhereUniqueWithoutPriceInput | TenantPriceOverrideUpsertWithWhereUniqueWithoutPriceInput[]
    createMany?: TenantPriceOverrideCreateManyPriceInputEnvelope
    set?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    disconnect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    delete?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    connect?: TenantPriceOverrideWhereUniqueInput | TenantPriceOverrideWhereUniqueInput[]
    update?: TenantPriceOverrideUpdateWithWhereUniqueWithoutPriceInput | TenantPriceOverrideUpdateWithWhereUniqueWithoutPriceInput[]
    updateMany?: TenantPriceOverrideUpdateManyWithWhereWithoutPriceInput | TenantPriceOverrideUpdateManyWithWhereWithoutPriceInput[]
    deleteMany?: TenantPriceOverrideScalarWhereInput | TenantPriceOverrideScalarWhereInput[]
  }

  export type GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPriceNestedInput = {
    create?: XOR<GlobalMonetizationConfigCreateWithoutDefaultPriceInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput> | GlobalMonetizationConfigCreateWithoutDefaultPriceInput[] | GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput[]
    connectOrCreate?: GlobalMonetizationConfigCreateOrConnectWithoutDefaultPriceInput | GlobalMonetizationConfigCreateOrConnectWithoutDefaultPriceInput[]
    upsert?: GlobalMonetizationConfigUpsertWithWhereUniqueWithoutDefaultPriceInput | GlobalMonetizationConfigUpsertWithWhereUniqueWithoutDefaultPriceInput[]
    createMany?: GlobalMonetizationConfigCreateManyDefaultPriceInputEnvelope
    set?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    disconnect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    delete?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    connect?: GlobalMonetizationConfigWhereUniqueInput | GlobalMonetizationConfigWhereUniqueInput[]
    update?: GlobalMonetizationConfigUpdateWithWhereUniqueWithoutDefaultPriceInput | GlobalMonetizationConfigUpdateWithWhereUniqueWithoutDefaultPriceInput[]
    updateMany?: GlobalMonetizationConfigUpdateManyWithWhereWithoutDefaultPriceInput | GlobalMonetizationConfigUpdateManyWithWhereWithoutDefaultPriceInput[]
    deleteMany?: GlobalMonetizationConfigScalarWhereInput | GlobalMonetizationConfigScalarWhereInput[]
  }

  export type OnboardingInviteUncheckedUpdateManyWithoutPriceNestedInput = {
    create?: XOR<OnboardingInviteCreateWithoutPriceInput, OnboardingInviteUncheckedCreateWithoutPriceInput> | OnboardingInviteCreateWithoutPriceInput[] | OnboardingInviteUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutPriceInput | OnboardingInviteCreateOrConnectWithoutPriceInput[]
    upsert?: OnboardingInviteUpsertWithWhereUniqueWithoutPriceInput | OnboardingInviteUpsertWithWhereUniqueWithoutPriceInput[]
    createMany?: OnboardingInviteCreateManyPriceInputEnvelope
    set?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    disconnect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    delete?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    update?: OnboardingInviteUpdateWithWhereUniqueWithoutPriceInput | OnboardingInviteUpdateWithWhereUniqueWithoutPriceInput[]
    updateMany?: OnboardingInviteUpdateManyWithWhereWithoutPriceInput | OnboardingInviteUpdateManyWithWhereWithoutPriceInput[]
    deleteMany?: OnboardingInviteScalarWhereInput | OnboardingInviteScalarWhereInput[]
  }

  export type PricePlanCreateNestedOneWithoutOffersInput = {
    create?: XOR<PricePlanCreateWithoutOffersInput, PricePlanUncheckedCreateWithoutOffersInput>
    connectOrCreate?: PricePlanCreateOrConnectWithoutOffersInput
    connect?: PricePlanWhereUniqueInput
  }

  export type OnboardingInviteCreateNestedManyWithoutOfferInput = {
    create?: XOR<OnboardingInviteCreateWithoutOfferInput, OnboardingInviteUncheckedCreateWithoutOfferInput> | OnboardingInviteCreateWithoutOfferInput[] | OnboardingInviteUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutOfferInput | OnboardingInviteCreateOrConnectWithoutOfferInput[]
    createMany?: OnboardingInviteCreateManyOfferInputEnvelope
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
  }

  export type OnboardingInviteUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<OnboardingInviteCreateWithoutOfferInput, OnboardingInviteUncheckedCreateWithoutOfferInput> | OnboardingInviteCreateWithoutOfferInput[] | OnboardingInviteUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutOfferInput | OnboardingInviteCreateOrConnectWithoutOfferInput[]
    createMany?: OnboardingInviteCreateManyOfferInputEnvelope
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
  }

  export type PricePlanUpdateOneWithoutOffersNestedInput = {
    create?: XOR<PricePlanCreateWithoutOffersInput, PricePlanUncheckedCreateWithoutOffersInput>
    connectOrCreate?: PricePlanCreateOrConnectWithoutOffersInput
    upsert?: PricePlanUpsertWithoutOffersInput
    disconnect?: PricePlanWhereInput | boolean
    delete?: PricePlanWhereInput | boolean
    connect?: PricePlanWhereUniqueInput
    update?: XOR<XOR<PricePlanUpdateToOneWithWhereWithoutOffersInput, PricePlanUpdateWithoutOffersInput>, PricePlanUncheckedUpdateWithoutOffersInput>
  }

  export type OnboardingInviteUpdateManyWithoutOfferNestedInput = {
    create?: XOR<OnboardingInviteCreateWithoutOfferInput, OnboardingInviteUncheckedCreateWithoutOfferInput> | OnboardingInviteCreateWithoutOfferInput[] | OnboardingInviteUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutOfferInput | OnboardingInviteCreateOrConnectWithoutOfferInput[]
    upsert?: OnboardingInviteUpsertWithWhereUniqueWithoutOfferInput | OnboardingInviteUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: OnboardingInviteCreateManyOfferInputEnvelope
    set?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    disconnect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    delete?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    update?: OnboardingInviteUpdateWithWhereUniqueWithoutOfferInput | OnboardingInviteUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: OnboardingInviteUpdateManyWithWhereWithoutOfferInput | OnboardingInviteUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: OnboardingInviteScalarWhereInput | OnboardingInviteScalarWhereInput[]
  }

  export type OnboardingInviteUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<OnboardingInviteCreateWithoutOfferInput, OnboardingInviteUncheckedCreateWithoutOfferInput> | OnboardingInviteCreateWithoutOfferInput[] | OnboardingInviteUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutOfferInput | OnboardingInviteCreateOrConnectWithoutOfferInput[]
    upsert?: OnboardingInviteUpsertWithWhereUniqueWithoutOfferInput | OnboardingInviteUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: OnboardingInviteCreateManyOfferInputEnvelope
    set?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    disconnect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    delete?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    update?: OnboardingInviteUpdateWithWhereUniqueWithoutOfferInput | OnboardingInviteUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: OnboardingInviteUpdateManyWithWhereWithoutOfferInput | OnboardingInviteUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: OnboardingInviteScalarWhereInput | OnboardingInviteScalarWhereInput[]
  }

  export type OnboardingInviteCreateNestedManyWithoutCouponInput = {
    create?: XOR<OnboardingInviteCreateWithoutCouponInput, OnboardingInviteUncheckedCreateWithoutCouponInput> | OnboardingInviteCreateWithoutCouponInput[] | OnboardingInviteUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutCouponInput | OnboardingInviteCreateOrConnectWithoutCouponInput[]
    createMany?: OnboardingInviteCreateManyCouponInputEnvelope
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
  }

  export type OnboardingInviteUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<OnboardingInviteCreateWithoutCouponInput, OnboardingInviteUncheckedCreateWithoutCouponInput> | OnboardingInviteCreateWithoutCouponInput[] | OnboardingInviteUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutCouponInput | OnboardingInviteCreateOrConnectWithoutCouponInput[]
    createMany?: OnboardingInviteCreateManyCouponInputEnvelope
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
  }

  export type OnboardingInviteUpdateManyWithoutCouponNestedInput = {
    create?: XOR<OnboardingInviteCreateWithoutCouponInput, OnboardingInviteUncheckedCreateWithoutCouponInput> | OnboardingInviteCreateWithoutCouponInput[] | OnboardingInviteUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutCouponInput | OnboardingInviteCreateOrConnectWithoutCouponInput[]
    upsert?: OnboardingInviteUpsertWithWhereUniqueWithoutCouponInput | OnboardingInviteUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: OnboardingInviteCreateManyCouponInputEnvelope
    set?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    disconnect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    delete?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    update?: OnboardingInviteUpdateWithWhereUniqueWithoutCouponInput | OnboardingInviteUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: OnboardingInviteUpdateManyWithWhereWithoutCouponInput | OnboardingInviteUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: OnboardingInviteScalarWhereInput | OnboardingInviteScalarWhereInput[]
  }

  export type OnboardingInviteUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<OnboardingInviteCreateWithoutCouponInput, OnboardingInviteUncheckedCreateWithoutCouponInput> | OnboardingInviteCreateWithoutCouponInput[] | OnboardingInviteUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: OnboardingInviteCreateOrConnectWithoutCouponInput | OnboardingInviteCreateOrConnectWithoutCouponInput[]
    upsert?: OnboardingInviteUpsertWithWhereUniqueWithoutCouponInput | OnboardingInviteUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: OnboardingInviteCreateManyCouponInputEnvelope
    set?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    disconnect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    delete?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    connect?: OnboardingInviteWhereUniqueInput | OnboardingInviteWhereUniqueInput[]
    update?: OnboardingInviteUpdateWithWhereUniqueWithoutCouponInput | OnboardingInviteUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: OnboardingInviteUpdateManyWithWhereWithoutCouponInput | OnboardingInviteUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: OnboardingInviteScalarWhereInput | OnboardingInviteScalarWhereInput[]
  }

  export type OrgCreateNestedOneWithoutTenantOverridesInput = {
    create?: XOR<OrgCreateWithoutTenantOverridesInput, OrgUncheckedCreateWithoutTenantOverridesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutTenantOverridesInput
    connect?: OrgWhereUniqueInput
  }

  export type PricePlanCreateNestedOneWithoutOverridesInput = {
    create?: XOR<PricePlanCreateWithoutOverridesInput, PricePlanUncheckedCreateWithoutOverridesInput>
    connectOrCreate?: PricePlanCreateOrConnectWithoutOverridesInput
    connect?: PricePlanWhereUniqueInput
  }

  export type PlanPriceCreateNestedOneWithoutOverridesInput = {
    create?: XOR<PlanPriceCreateWithoutOverridesInput, PlanPriceUncheckedCreateWithoutOverridesInput>
    connectOrCreate?: PlanPriceCreateOrConnectWithoutOverridesInput
    connect?: PlanPriceWhereUniqueInput
  }

  export type EnumOverrideTypeFieldUpdateOperationsInput = {
    set?: $Enums.OverrideType
  }

  export type OrgUpdateOneRequiredWithoutTenantOverridesNestedInput = {
    create?: XOR<OrgCreateWithoutTenantOverridesInput, OrgUncheckedCreateWithoutTenantOverridesInput>
    connectOrCreate?: OrgCreateOrConnectWithoutTenantOverridesInput
    upsert?: OrgUpsertWithoutTenantOverridesInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutTenantOverridesInput, OrgUpdateWithoutTenantOverridesInput>, OrgUncheckedUpdateWithoutTenantOverridesInput>
  }

  export type PricePlanUpdateOneWithoutOverridesNestedInput = {
    create?: XOR<PricePlanCreateWithoutOverridesInput, PricePlanUncheckedCreateWithoutOverridesInput>
    connectOrCreate?: PricePlanCreateOrConnectWithoutOverridesInput
    upsert?: PricePlanUpsertWithoutOverridesInput
    disconnect?: PricePlanWhereInput | boolean
    delete?: PricePlanWhereInput | boolean
    connect?: PricePlanWhereUniqueInput
    update?: XOR<XOR<PricePlanUpdateToOneWithWhereWithoutOverridesInput, PricePlanUpdateWithoutOverridesInput>, PricePlanUncheckedUpdateWithoutOverridesInput>
  }

  export type PlanPriceUpdateOneWithoutOverridesNestedInput = {
    create?: XOR<PlanPriceCreateWithoutOverridesInput, PlanPriceUncheckedCreateWithoutOverridesInput>
    connectOrCreate?: PlanPriceCreateOrConnectWithoutOverridesInput
    upsert?: PlanPriceUpsertWithoutOverridesInput
    disconnect?: PlanPriceWhereInput | boolean
    delete?: PlanPriceWhereInput | boolean
    connect?: PlanPriceWhereUniqueInput
    update?: XOR<XOR<PlanPriceUpdateToOneWithWhereWithoutOverridesInput, PlanPriceUpdateWithoutOverridesInput>, PlanPriceUncheckedUpdateWithoutOverridesInput>
  }

  export type PricePlanCreateNestedOneWithoutAsDefaultForInput = {
    create?: XOR<PricePlanCreateWithoutAsDefaultForInput, PricePlanUncheckedCreateWithoutAsDefaultForInput>
    connectOrCreate?: PricePlanCreateOrConnectWithoutAsDefaultForInput
    connect?: PricePlanWhereUniqueInput
  }

  export type PlanPriceCreateNestedOneWithoutAsDefaultForInput = {
    create?: XOR<PlanPriceCreateWithoutAsDefaultForInput, PlanPriceUncheckedCreateWithoutAsDefaultForInput>
    connectOrCreate?: PlanPriceCreateOrConnectWithoutAsDefaultForInput
    connect?: PlanPriceWhereUniqueInput
  }

  export type PricePlanUpdateOneWithoutAsDefaultForNestedInput = {
    create?: XOR<PricePlanCreateWithoutAsDefaultForInput, PricePlanUncheckedCreateWithoutAsDefaultForInput>
    connectOrCreate?: PricePlanCreateOrConnectWithoutAsDefaultForInput
    upsert?: PricePlanUpsertWithoutAsDefaultForInput
    disconnect?: PricePlanWhereInput | boolean
    delete?: PricePlanWhereInput | boolean
    connect?: PricePlanWhereUniqueInput
    update?: XOR<XOR<PricePlanUpdateToOneWithWhereWithoutAsDefaultForInput, PricePlanUpdateWithoutAsDefaultForInput>, PricePlanUncheckedUpdateWithoutAsDefaultForInput>
  }

  export type PlanPriceUpdateOneWithoutAsDefaultForNestedInput = {
    create?: XOR<PlanPriceCreateWithoutAsDefaultForInput, PlanPriceUncheckedCreateWithoutAsDefaultForInput>
    connectOrCreate?: PlanPriceCreateOrConnectWithoutAsDefaultForInput
    upsert?: PlanPriceUpsertWithoutAsDefaultForInput
    disconnect?: PlanPriceWhereInput | boolean
    delete?: PlanPriceWhereInput | boolean
    connect?: PlanPriceWhereUniqueInput
    update?: XOR<XOR<PlanPriceUpdateToOneWithWhereWithoutAsDefaultForInput, PlanPriceUpdateWithoutAsDefaultForInput>, PlanPriceUncheckedUpdateWithoutAsDefaultForInput>
  }

  export type PricePlanCreateNestedOneWithoutInvitesInput = {
    create?: XOR<PricePlanCreateWithoutInvitesInput, PricePlanUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: PricePlanCreateOrConnectWithoutInvitesInput
    connect?: PricePlanWhereUniqueInput
  }

  export type PlanPriceCreateNestedOneWithoutInvitesInput = {
    create?: XOR<PlanPriceCreateWithoutInvitesInput, PlanPriceUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: PlanPriceCreateOrConnectWithoutInvitesInput
    connect?: PlanPriceWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutInvitesInput = {
    create?: XOR<OfferCreateWithoutInvitesInput, OfferUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: OfferCreateOrConnectWithoutInvitesInput
    connect?: OfferWhereUniqueInput
  }

  export type CouponCreateNestedOneWithoutInvitesInput = {
    create?: XOR<CouponCreateWithoutInvitesInput, CouponUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: CouponCreateOrConnectWithoutInvitesInput
    connect?: CouponWhereUniqueInput
  }

  export type PricePlanUpdateOneWithoutInvitesNestedInput = {
    create?: XOR<PricePlanCreateWithoutInvitesInput, PricePlanUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: PricePlanCreateOrConnectWithoutInvitesInput
    upsert?: PricePlanUpsertWithoutInvitesInput
    disconnect?: PricePlanWhereInput | boolean
    delete?: PricePlanWhereInput | boolean
    connect?: PricePlanWhereUniqueInput
    update?: XOR<XOR<PricePlanUpdateToOneWithWhereWithoutInvitesInput, PricePlanUpdateWithoutInvitesInput>, PricePlanUncheckedUpdateWithoutInvitesInput>
  }

  export type PlanPriceUpdateOneWithoutInvitesNestedInput = {
    create?: XOR<PlanPriceCreateWithoutInvitesInput, PlanPriceUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: PlanPriceCreateOrConnectWithoutInvitesInput
    upsert?: PlanPriceUpsertWithoutInvitesInput
    disconnect?: PlanPriceWhereInput | boolean
    delete?: PlanPriceWhereInput | boolean
    connect?: PlanPriceWhereUniqueInput
    update?: XOR<XOR<PlanPriceUpdateToOneWithWhereWithoutInvitesInput, PlanPriceUpdateWithoutInvitesInput>, PlanPriceUncheckedUpdateWithoutInvitesInput>
  }

  export type OfferUpdateOneWithoutInvitesNestedInput = {
    create?: XOR<OfferCreateWithoutInvitesInput, OfferUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: OfferCreateOrConnectWithoutInvitesInput
    upsert?: OfferUpsertWithoutInvitesInput
    disconnect?: OfferWhereInput | boolean
    delete?: OfferWhereInput | boolean
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutInvitesInput, OfferUpdateWithoutInvitesInput>, OfferUncheckedUpdateWithoutInvitesInput>
  }

  export type CouponUpdateOneWithoutInvitesNestedInput = {
    create?: XOR<CouponCreateWithoutInvitesInput, CouponUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: CouponCreateOrConnectWithoutInvitesInput
    upsert?: CouponUpsertWithoutInvitesInput
    disconnect?: CouponWhereInput | boolean
    delete?: CouponWhereInput | boolean
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutInvitesInput, CouponUpdateWithoutInvitesInput>, CouponUncheckedUpdateWithoutInvitesInput>
  }

  export type EnumInfrastructureServiceFieldUpdateOperationsInput = {
    set?: $Enums.InfrastructureService
  }

  export type EnumMetricTypeFieldUpdateOperationsInput = {
    set?: $Enums.MetricType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrgCreateNestedOneWithoutImportJobsInput = {
    create?: XOR<OrgCreateWithoutImportJobsInput, OrgUncheckedCreateWithoutImportJobsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutImportJobsInput
    connect?: OrgWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutImportJobsInput = {
    create?: XOR<UserCreateWithoutImportJobsInput, UserUncheckedCreateWithoutImportJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutImportJobsInput
    connect?: UserWhereUniqueInput
  }

  export type ImportMappingCreateNestedOneWithoutJobsInput = {
    create?: XOR<ImportMappingCreateWithoutJobsInput, ImportMappingUncheckedCreateWithoutJobsInput>
    connectOrCreate?: ImportMappingCreateOrConnectWithoutJobsInput
    connect?: ImportMappingWhereUniqueInput
  }

  export type ImportErrorCreateNestedManyWithoutImportJobInput = {
    create?: XOR<ImportErrorCreateWithoutImportJobInput, ImportErrorUncheckedCreateWithoutImportJobInput> | ImportErrorCreateWithoutImportJobInput[] | ImportErrorUncheckedCreateWithoutImportJobInput[]
    connectOrCreate?: ImportErrorCreateOrConnectWithoutImportJobInput | ImportErrorCreateOrConnectWithoutImportJobInput[]
    createMany?: ImportErrorCreateManyImportJobInputEnvelope
    connect?: ImportErrorWhereUniqueInput | ImportErrorWhereUniqueInput[]
  }

  export type ImportErrorUncheckedCreateNestedManyWithoutImportJobInput = {
    create?: XOR<ImportErrorCreateWithoutImportJobInput, ImportErrorUncheckedCreateWithoutImportJobInput> | ImportErrorCreateWithoutImportJobInput[] | ImportErrorUncheckedCreateWithoutImportJobInput[]
    connectOrCreate?: ImportErrorCreateOrConnectWithoutImportJobInput | ImportErrorCreateOrConnectWithoutImportJobInput[]
    createMany?: ImportErrorCreateManyImportJobInputEnvelope
    connect?: ImportErrorWhereUniqueInput | ImportErrorWhereUniqueInput[]
  }

  export type EnumImportEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ImportEntityType
  }

  export type EnumImportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImportStatus
  }

  export type OrgUpdateOneRequiredWithoutImportJobsNestedInput = {
    create?: XOR<OrgCreateWithoutImportJobsInput, OrgUncheckedCreateWithoutImportJobsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutImportJobsInput
    upsert?: OrgUpsertWithoutImportJobsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutImportJobsInput, OrgUpdateWithoutImportJobsInput>, OrgUncheckedUpdateWithoutImportJobsInput>
  }

  export type UserUpdateOneRequiredWithoutImportJobsNestedInput = {
    create?: XOR<UserCreateWithoutImportJobsInput, UserUncheckedCreateWithoutImportJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutImportJobsInput
    upsert?: UserUpsertWithoutImportJobsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutImportJobsInput, UserUpdateWithoutImportJobsInput>, UserUncheckedUpdateWithoutImportJobsInput>
  }

  export type ImportMappingUpdateOneWithoutJobsNestedInput = {
    create?: XOR<ImportMappingCreateWithoutJobsInput, ImportMappingUncheckedCreateWithoutJobsInput>
    connectOrCreate?: ImportMappingCreateOrConnectWithoutJobsInput
    upsert?: ImportMappingUpsertWithoutJobsInput
    disconnect?: ImportMappingWhereInput | boolean
    delete?: ImportMappingWhereInput | boolean
    connect?: ImportMappingWhereUniqueInput
    update?: XOR<XOR<ImportMappingUpdateToOneWithWhereWithoutJobsInput, ImportMappingUpdateWithoutJobsInput>, ImportMappingUncheckedUpdateWithoutJobsInput>
  }

  export type ImportErrorUpdateManyWithoutImportJobNestedInput = {
    create?: XOR<ImportErrorCreateWithoutImportJobInput, ImportErrorUncheckedCreateWithoutImportJobInput> | ImportErrorCreateWithoutImportJobInput[] | ImportErrorUncheckedCreateWithoutImportJobInput[]
    connectOrCreate?: ImportErrorCreateOrConnectWithoutImportJobInput | ImportErrorCreateOrConnectWithoutImportJobInput[]
    upsert?: ImportErrorUpsertWithWhereUniqueWithoutImportJobInput | ImportErrorUpsertWithWhereUniqueWithoutImportJobInput[]
    createMany?: ImportErrorCreateManyImportJobInputEnvelope
    set?: ImportErrorWhereUniqueInput | ImportErrorWhereUniqueInput[]
    disconnect?: ImportErrorWhereUniqueInput | ImportErrorWhereUniqueInput[]
    delete?: ImportErrorWhereUniqueInput | ImportErrorWhereUniqueInput[]
    connect?: ImportErrorWhereUniqueInput | ImportErrorWhereUniqueInput[]
    update?: ImportErrorUpdateWithWhereUniqueWithoutImportJobInput | ImportErrorUpdateWithWhereUniqueWithoutImportJobInput[]
    updateMany?: ImportErrorUpdateManyWithWhereWithoutImportJobInput | ImportErrorUpdateManyWithWhereWithoutImportJobInput[]
    deleteMany?: ImportErrorScalarWhereInput | ImportErrorScalarWhereInput[]
  }

  export type ImportErrorUncheckedUpdateManyWithoutImportJobNestedInput = {
    create?: XOR<ImportErrorCreateWithoutImportJobInput, ImportErrorUncheckedCreateWithoutImportJobInput> | ImportErrorCreateWithoutImportJobInput[] | ImportErrorUncheckedCreateWithoutImportJobInput[]
    connectOrCreate?: ImportErrorCreateOrConnectWithoutImportJobInput | ImportErrorCreateOrConnectWithoutImportJobInput[]
    upsert?: ImportErrorUpsertWithWhereUniqueWithoutImportJobInput | ImportErrorUpsertWithWhereUniqueWithoutImportJobInput[]
    createMany?: ImportErrorCreateManyImportJobInputEnvelope
    set?: ImportErrorWhereUniqueInput | ImportErrorWhereUniqueInput[]
    disconnect?: ImportErrorWhereUniqueInput | ImportErrorWhereUniqueInput[]
    delete?: ImportErrorWhereUniqueInput | ImportErrorWhereUniqueInput[]
    connect?: ImportErrorWhereUniqueInput | ImportErrorWhereUniqueInput[]
    update?: ImportErrorUpdateWithWhereUniqueWithoutImportJobInput | ImportErrorUpdateWithWhereUniqueWithoutImportJobInput[]
    updateMany?: ImportErrorUpdateManyWithWhereWithoutImportJobInput | ImportErrorUpdateManyWithWhereWithoutImportJobInput[]
    deleteMany?: ImportErrorScalarWhereInput | ImportErrorScalarWhereInput[]
  }

  export type OrgCreateNestedOneWithoutImportMappingsInput = {
    create?: XOR<OrgCreateWithoutImportMappingsInput, OrgUncheckedCreateWithoutImportMappingsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutImportMappingsInput
    connect?: OrgWhereUniqueInput
  }

  export type ImportJobCreateNestedManyWithoutMappingInput = {
    create?: XOR<ImportJobCreateWithoutMappingInput, ImportJobUncheckedCreateWithoutMappingInput> | ImportJobCreateWithoutMappingInput[] | ImportJobUncheckedCreateWithoutMappingInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutMappingInput | ImportJobCreateOrConnectWithoutMappingInput[]
    createMany?: ImportJobCreateManyMappingInputEnvelope
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
  }

  export type ImportJobUncheckedCreateNestedManyWithoutMappingInput = {
    create?: XOR<ImportJobCreateWithoutMappingInput, ImportJobUncheckedCreateWithoutMappingInput> | ImportJobCreateWithoutMappingInput[] | ImportJobUncheckedCreateWithoutMappingInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutMappingInput | ImportJobCreateOrConnectWithoutMappingInput[]
    createMany?: ImportJobCreateManyMappingInputEnvelope
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
  }

  export type OrgUpdateOneRequiredWithoutImportMappingsNestedInput = {
    create?: XOR<OrgCreateWithoutImportMappingsInput, OrgUncheckedCreateWithoutImportMappingsInput>
    connectOrCreate?: OrgCreateOrConnectWithoutImportMappingsInput
    upsert?: OrgUpsertWithoutImportMappingsInput
    connect?: OrgWhereUniqueInput
    update?: XOR<XOR<OrgUpdateToOneWithWhereWithoutImportMappingsInput, OrgUpdateWithoutImportMappingsInput>, OrgUncheckedUpdateWithoutImportMappingsInput>
  }

  export type ImportJobUpdateManyWithoutMappingNestedInput = {
    create?: XOR<ImportJobCreateWithoutMappingInput, ImportJobUncheckedCreateWithoutMappingInput> | ImportJobCreateWithoutMappingInput[] | ImportJobUncheckedCreateWithoutMappingInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutMappingInput | ImportJobCreateOrConnectWithoutMappingInput[]
    upsert?: ImportJobUpsertWithWhereUniqueWithoutMappingInput | ImportJobUpsertWithWhereUniqueWithoutMappingInput[]
    createMany?: ImportJobCreateManyMappingInputEnvelope
    set?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    disconnect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    delete?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    update?: ImportJobUpdateWithWhereUniqueWithoutMappingInput | ImportJobUpdateWithWhereUniqueWithoutMappingInput[]
    updateMany?: ImportJobUpdateManyWithWhereWithoutMappingInput | ImportJobUpdateManyWithWhereWithoutMappingInput[]
    deleteMany?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
  }

  export type ImportJobUncheckedUpdateManyWithoutMappingNestedInput = {
    create?: XOR<ImportJobCreateWithoutMappingInput, ImportJobUncheckedCreateWithoutMappingInput> | ImportJobCreateWithoutMappingInput[] | ImportJobUncheckedCreateWithoutMappingInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutMappingInput | ImportJobCreateOrConnectWithoutMappingInput[]
    upsert?: ImportJobUpsertWithWhereUniqueWithoutMappingInput | ImportJobUpsertWithWhereUniqueWithoutMappingInput[]
    createMany?: ImportJobCreateManyMappingInputEnvelope
    set?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    disconnect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    delete?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    update?: ImportJobUpdateWithWhereUniqueWithoutMappingInput | ImportJobUpdateWithWhereUniqueWithoutMappingInput[]
    updateMany?: ImportJobUpdateManyWithWhereWithoutMappingInput | ImportJobUpdateManyWithWhereWithoutMappingInput[]
    deleteMany?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
  }

  export type ImportJobCreateNestedOneWithoutErrorsInput = {
    create?: XOR<ImportJobCreateWithoutErrorsInput, ImportJobUncheckedCreateWithoutErrorsInput>
    connectOrCreate?: ImportJobCreateOrConnectWithoutErrorsInput
    connect?: ImportJobWhereUniqueInput
  }

  export type ImportJobUpdateOneRequiredWithoutErrorsNestedInput = {
    create?: XOR<ImportJobCreateWithoutErrorsInput, ImportJobUncheckedCreateWithoutErrorsInput>
    connectOrCreate?: ImportJobCreateOrConnectWithoutErrorsInput
    upsert?: ImportJobUpsertWithoutErrorsInput
    connect?: ImportJobWhereUniqueInput
    update?: XOR<XOR<ImportJobUpdateToOneWithWhereWithoutErrorsInput, ImportJobUpdateWithoutErrorsInput>, ImportJobUncheckedUpdateWithoutErrorsInput>
  }

  export type EnumRecommendationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.RecommendationPriority
  }

  export type EnumRecommendationStatusFieldUpdateOperationsInput = {
    set?: $Enums.RecommendationStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumAiPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.AiPlan | EnumAiPlanFieldRefInput<$PrismaModel>
    in?: $Enums.AiPlan[] | ListEnumAiPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiPlan[] | ListEnumAiPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumAiPlanFilter<$PrismaModel> | $Enums.AiPlan
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAiPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiPlan | EnumAiPlanFieldRefInput<$PrismaModel>
    in?: $Enums.AiPlan[] | ListEnumAiPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiPlan[] | ListEnumAiPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumAiPlanWithAggregatesFilter<$PrismaModel> | $Enums.AiPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiPlanFilter<$PrismaModel>
    _max?: NestedEnumAiPlanFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumLeadSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadSource | EnumLeadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.LeadSource[] | ListEnumLeadSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadSource[] | ListEnumLeadSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadSourceFilter<$PrismaModel> | $Enums.LeadSource
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumLeadSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadSource | EnumLeadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.LeadSource[] | ListEnumLeadSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadSource[] | ListEnumLeadSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadSourceWithAggregatesFilter<$PrismaModel> | $Enums.LeadSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadSourceFilter<$PrismaModel>
    _max?: NestedEnumLeadSourceFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedEnumValueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ValueType | EnumValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ValueType[] | ListEnumValueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ValueType[] | ListEnumValueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumValueTypeFilter<$PrismaModel> | $Enums.ValueType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumValueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ValueType | EnumValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ValueType[] | ListEnumValueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ValueType[] | ListEnumValueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumValueTypeWithAggregatesFilter<$PrismaModel> | $Enums.ValueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValueTypeFilter<$PrismaModel>
    _max?: NestedEnumValueTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLedgerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTypeFilter<$PrismaModel> | $Enums.LedgerType
  }

  export type NestedEnumLedgerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerTypeFilter<$PrismaModel>
  }

  export type NestedEnumPricingModelFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelFilter<$PrismaModel> | $Enums.PricingModel
  }

  export type NestedEnumPricingModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelWithAggregatesFilter<$PrismaModel> | $Enums.PricingModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingModelFilter<$PrismaModel>
    _max?: NestedEnumPricingModelFilter<$PrismaModel>
  }

  export type NestedEnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type NestedEnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceLineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceLineType | EnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceLineType[] | ListEnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceLineType[] | ListEnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceLineTypeFilter<$PrismaModel> | $Enums.InvoiceLineType
  }

  export type NestedEnumInvoiceLineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceLineType | EnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceLineType[] | ListEnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceLineType[] | ListEnumInvoiceLineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceLineTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceLineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceLineTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceLineTypeFilter<$PrismaModel>
  }

  export type NestedEnumBillingCadenceFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCadence | EnumBillingCadenceFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCadence[] | ListEnumBillingCadenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCadence[] | ListEnumBillingCadenceFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCadenceFilter<$PrismaModel> | $Enums.BillingCadence
  }

  export type NestedEnumBillingCadenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCadence | EnumBillingCadenceFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCadence[] | ListEnumBillingCadenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCadence[] | ListEnumBillingCadenceFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCadenceWithAggregatesFilter<$PrismaModel> | $Enums.BillingCadence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingCadenceFilter<$PrismaModel>
    _max?: NestedEnumBillingCadenceFilter<$PrismaModel>
  }

  export type NestedEnumOverrideTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OverrideType | EnumOverrideTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OverrideType[] | ListEnumOverrideTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OverrideType[] | ListEnumOverrideTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOverrideTypeFilter<$PrismaModel> | $Enums.OverrideType
  }

  export type NestedEnumOverrideTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OverrideType | EnumOverrideTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OverrideType[] | ListEnumOverrideTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OverrideType[] | ListEnumOverrideTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOverrideTypeWithAggregatesFilter<$PrismaModel> | $Enums.OverrideType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOverrideTypeFilter<$PrismaModel>
    _max?: NestedEnumOverrideTypeFilter<$PrismaModel>
  }

  export type NestedEnumInfrastructureServiceFilter<$PrismaModel = never> = {
    equals?: $Enums.InfrastructureService | EnumInfrastructureServiceFieldRefInput<$PrismaModel>
    in?: $Enums.InfrastructureService[] | ListEnumInfrastructureServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfrastructureService[] | ListEnumInfrastructureServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumInfrastructureServiceFilter<$PrismaModel> | $Enums.InfrastructureService
  }

  export type NestedEnumMetricTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricType | EnumMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetricTypeFilter<$PrismaModel> | $Enums.MetricType
  }

  export type NestedEnumInfrastructureServiceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InfrastructureService | EnumInfrastructureServiceFieldRefInput<$PrismaModel>
    in?: $Enums.InfrastructureService[] | ListEnumInfrastructureServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfrastructureService[] | ListEnumInfrastructureServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumInfrastructureServiceWithAggregatesFilter<$PrismaModel> | $Enums.InfrastructureService
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInfrastructureServiceFilter<$PrismaModel>
    _max?: NestedEnumInfrastructureServiceFilter<$PrismaModel>
  }

  export type NestedEnumMetricTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricType | EnumMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetricType[] | ListEnumMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetricTypeWithAggregatesFilter<$PrismaModel> | $Enums.MetricType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetricTypeFilter<$PrismaModel>
    _max?: NestedEnumMetricTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumImportEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportEntityType | EnumImportEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportEntityTypeFilter<$PrismaModel> | $Enums.ImportEntityType
  }

  export type NestedEnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type NestedEnumImportEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportEntityType | EnumImportEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImportEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumImportEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }

  export type NestedEnumRecommendationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationPriority | EnumRecommendationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendationPriority[] | ListEnumRecommendationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendationPriority[] | ListEnumRecommendationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendationPriorityFilter<$PrismaModel> | $Enums.RecommendationPriority
  }

  export type NestedEnumRecommendationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationStatus | EnumRecommendationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendationStatus[] | ListEnumRecommendationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendationStatus[] | ListEnumRecommendationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendationStatusFilter<$PrismaModel> | $Enums.RecommendationStatus
  }

  export type NestedEnumRecommendationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationPriority | EnumRecommendationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendationPriority[] | ListEnumRecommendationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendationPriority[] | ListEnumRecommendationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.RecommendationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecommendationPriorityFilter<$PrismaModel>
    _max?: NestedEnumRecommendationPriorityFilter<$PrismaModel>
  }

  export type NestedEnumRecommendationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecommendationStatus | EnumRecommendationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecommendationStatus[] | ListEnumRecommendationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecommendationStatus[] | ListEnumRecommendationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecommendationStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecommendationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecommendationStatusFilter<$PrismaModel>
    _max?: NestedEnumRecommendationStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AuditLogCreateWithoutOrgInput = {
    id?: string
    actorUserId?: string | null
    entity: string
    entityId?: string | null
    field?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutOrgInput = {
    id?: string
    actorUserId?: string | null
    entity: string
    entityId?: string | null
    field?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutOrgInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutOrgInput, AuditLogUncheckedCreateWithoutOrgInput>
  }

  export type AuditLogCreateManyOrgInputEnvelope = {
    data: AuditLogCreateManyOrgInput | AuditLogCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type BillingLedgerCreateWithoutOrgInput = {
    id?: string
    type: $Enums.LedgerType
    amount: Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingLedgerUncheckedCreateWithoutOrgInput = {
    id?: string
    type: $Enums.LedgerType
    amount: Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BillingLedgerCreateOrConnectWithoutOrgInput = {
    where: BillingLedgerWhereUniqueInput
    create: XOR<BillingLedgerCreateWithoutOrgInput, BillingLedgerUncheckedCreateWithoutOrgInput>
  }

  export type BillingLedgerCreateManyOrgInputEnvelope = {
    data: BillingLedgerCreateManyOrgInput | BillingLedgerCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutOrgInput = {
    id?: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    opportunities?: OpportunityCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrgInput = {
    id?: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrgInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrgInput, CustomerUncheckedCreateWithoutOrgInput>
  }

  export type CustomerCreateManyOrgInputEnvelope = {
    data: CustomerCreateManyOrgInput | CustomerCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutOrgInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutOrgInput = {
    id?: string
    customerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutOrgInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrgInput, InvoiceUncheckedCreateWithoutOrgInput>
  }

  export type InvoiceCreateManyOrgInputEnvelope = {
    data: InvoiceCreateManyOrgInput | InvoiceCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutOrgInput = {
    id?: string
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutJobsInput
    rfp?: RfpCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutOrgInput = {
    id?: string
    customerId?: string | null
    rfpId?: string | null
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateOrConnectWithoutOrgInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutOrgInput, JobUncheckedCreateWithoutOrgInput>
  }

  export type JobCreateManyOrgInputEnvelope = {
    data: JobCreateManyOrgInput | JobCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutOrgInput = {
    id?: string
    publicId: string
    sourceType: $Enums.LeadSource
    identityHash: string
    company?: string | null
    contactName?: string | null
    email?: string | null
    phoneE164?: string | null
    website?: string | null
    serviceCode?: string | null
    zip?: string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: boolean
    convertedAt?: Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    notes?: string | null
    sourceDetail?: string | null
    state?: string | null
    postalCode?: string | null
    address?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    country?: string | null
    LeadInvoiceLine?: LeadInvoiceLineCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutOrgInput = {
    id?: string
    publicId: string
    sourceType: $Enums.LeadSource
    identityHash: string
    company?: string | null
    contactName?: string | null
    email?: string | null
    phoneE164?: string | null
    website?: string | null
    serviceCode?: string | null
    zip?: string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: boolean
    convertedAt?: Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    notes?: string | null
    sourceDetail?: string | null
    state?: string | null
    postalCode?: string | null
    address?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    country?: string | null
    LeadInvoiceLine?: LeadInvoiceLineUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutOrgInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutOrgInput, LeadUncheckedCreateWithoutOrgInput>
  }

  export type LeadCreateManyOrgInputEnvelope = {
    data: LeadCreateManyOrgInput | LeadCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutOrgInput = {
    id?: string
    valueType?: $Enums.ValueType
    estValue?: Decimal | DecimalJsLike | number | string | null
    stage?: string
    ownerId?: string | null
    sourceLeadId?: string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOpportunitiesInput
  }

  export type OpportunityUncheckedCreateWithoutOrgInput = {
    id?: string
    customerId: string
    valueType?: $Enums.ValueType
    estValue?: Decimal | DecimalJsLike | number | string | null
    stage?: string
    ownerId?: string | null
    sourceLeadId?: string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityCreateOrConnectWithoutOrgInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutOrgInput, OpportunityUncheckedCreateWithoutOrgInput>
  }

  export type OpportunityCreateManyOrgInputEnvelope = {
    data: OpportunityCreateManyOrgInput | OpportunityCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrgInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method?: string
    receivedAt?: Date | string
    reference?: string | null
    status?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    failureReason?: string | null
    retryCount?: number
    lastRetryAt?: Date | string | null
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutOrgInput = {
    id?: string
    invoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: string
    receivedAt?: Date | string
    reference?: string | null
    status?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    failureReason?: string | null
    retryCount?: number
    lastRetryAt?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutOrgInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrgInput, PaymentUncheckedCreateWithoutOrgInput>
  }

  export type PaymentCreateManyOrgInputEnvelope = {
    data: PaymentCreateManyOrgInput | PaymentCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutOrgInput = {
    id?: string
    employeeId?: string | null
    referredName: string
    referredEmail?: string | null
    referredPhone?: string | null
    status?: string
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUncheckedCreateWithoutOrgInput = {
    id?: string
    employeeId?: string | null
    referredName: string
    referredEmail?: string | null
    referredPhone?: string | null
    status?: string
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutOrgInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutOrgInput, ReferralUncheckedCreateWithoutOrgInput>
  }

  export type ReferralCreateManyOrgInputEnvelope = {
    data: ReferralCreateManyOrgInput | ReferralCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type RfpCreateWithoutOrgInput = {
    id?: string
    publicId: string
    sourceSite: string
    title: string
    dueDate?: Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobCreateNestedManyWithoutRfpInput
  }

  export type RfpUncheckedCreateWithoutOrgInput = {
    id?: string
    publicId: string
    sourceSite: string
    title: string
    dueDate?: Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutRfpInput
  }

  export type RfpCreateOrConnectWithoutOrgInput = {
    where: RfpWhereUniqueInput
    create: XOR<RfpCreateWithoutOrgInput, RfpUncheckedCreateWithoutOrgInput>
  }

  export type RfpCreateManyOrgInputEnvelope = {
    data: RfpCreateManyOrgInput | RfpCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrgInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintCreateNestedManyWithoutUserInput
    importJobs?: ImportJobCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrgInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountUncheckedCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryUncheckedCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedCreateNestedManyWithoutUserInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrgInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
  }

  export type UserCreateManyOrgInputEnvelope = {
    data: UserCreateManyOrgInput | UserCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type RbacRoleCreateWithoutOrgInput = {
    id?: string
    name: string
    slug: string
    isSystem?: boolean
    createdAt?: Date | string
    rolePerms?: RbacRolePermissionCreateNestedManyWithoutRoleInput
    userRoles?: RbacUserRoleCreateNestedManyWithoutRoleInput
  }

  export type RbacRoleUncheckedCreateWithoutOrgInput = {
    id?: string
    name: string
    slug: string
    isSystem?: boolean
    createdAt?: Date | string
    rolePerms?: RbacRolePermissionUncheckedCreateNestedManyWithoutRoleInput
    userRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RbacRoleCreateOrConnectWithoutOrgInput = {
    where: RbacRoleWhereUniqueInput
    create: XOR<RbacRoleCreateWithoutOrgInput, RbacRoleUncheckedCreateWithoutOrgInput>
  }

  export type RbacRoleCreateManyOrgInputEnvelope = {
    data: RbacRoleCreateManyOrgInput | RbacRoleCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type RbacUserRoleCreateWithoutOrgInput = {
    id?: string
    user: UserCreateNestedOneWithoutRbacUserRolesInput
    role: RbacRoleCreateNestedOneWithoutUserRolesInput
  }

  export type RbacUserRoleUncheckedCreateWithoutOrgInput = {
    id?: string
    userId: string
    roleId: string
  }

  export type RbacUserRoleCreateOrConnectWithoutOrgInput = {
    where: RbacUserRoleWhereUniqueInput
    create: XOR<RbacUserRoleCreateWithoutOrgInput, RbacUserRoleUncheckedCreateWithoutOrgInput>
  }

  export type RbacUserRoleCreateManyOrgInputEnvelope = {
    data: RbacUserRoleCreateManyOrgInput | RbacUserRoleCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type LeadInvoiceCreateWithoutOrgInput = {
    id?: string
    number: string
    periodFrom: Date | string
    periodTo: Date | string
    status: string
    subtotalCents: number
    taxCents?: number
    totalCents: number
    currency?: string
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadCount?: number
    lines?: LeadInvoiceLineCreateNestedManyWithoutInvoiceInput
  }

  export type LeadInvoiceUncheckedCreateWithoutOrgInput = {
    id?: string
    number: string
    periodFrom: Date | string
    periodTo: Date | string
    status: string
    subtotalCents: number
    taxCents?: number
    totalCents: number
    currency?: string
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadCount?: number
    lines?: LeadInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type LeadInvoiceCreateOrConnectWithoutOrgInput = {
    where: LeadInvoiceWhereUniqueInput
    create: XOR<LeadInvoiceCreateWithoutOrgInput, LeadInvoiceUncheckedCreateWithoutOrgInput>
  }

  export type LeadInvoiceCreateManyOrgInputEnvelope = {
    data: LeadInvoiceCreateManyOrgInput | LeadInvoiceCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type PricingPlanCreateWithoutOrgInput = {
    model?: $Enums.PricingModel
    currency?: string
    unitAmount?: number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: number
  }

  export type PricingPlanUncheckedCreateWithoutOrgInput = {
    model?: $Enums.PricingModel
    currency?: string
    unitAmount?: number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: number
  }

  export type PricingPlanCreateOrConnectWithoutOrgInput = {
    where: PricingPlanWhereUniqueInput
    create: XOR<PricingPlanCreateWithoutOrgInput, PricingPlanUncheckedCreateWithoutOrgInput>
  }

  export type AiUsageEventCreateWithoutOrgInput = {
    id?: string
    userId?: string | null
    feature: string
    model: string
    tokensIn: number
    tokensOut: number
    costUsd: Decimal | DecimalJsLike | number | string
    creditsUsed: number
    requestId?: string | null
    createdAt?: Date | string
  }

  export type AiUsageEventUncheckedCreateWithoutOrgInput = {
    id?: string
    userId?: string | null
    feature: string
    model: string
    tokensIn: number
    tokensOut: number
    costUsd: Decimal | DecimalJsLike | number | string
    creditsUsed: number
    requestId?: string | null
    createdAt?: Date | string
  }

  export type AiUsageEventCreateOrConnectWithoutOrgInput = {
    where: AiUsageEventWhereUniqueInput
    create: XOR<AiUsageEventCreateWithoutOrgInput, AiUsageEventUncheckedCreateWithoutOrgInput>
  }

  export type AiUsageEventCreateManyOrgInputEnvelope = {
    data: AiUsageEventCreateManyOrgInput | AiUsageEventCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type AiMonthlySummaryCreateWithoutOrgInput = {
    id?: string
    monthKey: string
    tokensIn?: number
    tokensOut?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    creditsUsed?: number
    callCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiMonthlySummaryUncheckedCreateWithoutOrgInput = {
    id?: string
    monthKey: string
    tokensIn?: number
    tokensOut?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    creditsUsed?: number
    callCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiMonthlySummaryCreateOrConnectWithoutOrgInput = {
    where: AiMonthlySummaryWhereUniqueInput
    create: XOR<AiMonthlySummaryCreateWithoutOrgInput, AiMonthlySummaryUncheckedCreateWithoutOrgInput>
  }

  export type AiMonthlySummaryCreateManyOrgInputEnvelope = {
    data: AiMonthlySummaryCreateManyOrgInput | AiMonthlySummaryCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutOrgInput = {
    id?: string
    actorType: string
    actorId?: string | null
    entityType: string
    entityId: string
    action: string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityUncheckedCreateWithoutOrgInput = {
    id?: string
    actorType: string
    actorId?: string | null
    entityType: string
    entityId: string
    action: string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutOrgInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutOrgInput, ActivityUncheckedCreateWithoutOrgInput>
  }

  export type ActivityCreateManyOrgInputEnvelope = {
    data: ActivityCreateManyOrgInput | ActivityCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutOrgInput = {
    id?: string
    plan: string
    status: string
    startedAt: Date | string
    canceledAt?: Date | string | null
    renewsAt?: Date | string | null
    priceCents: number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutOrgInput = {
    id?: string
    plan: string
    status: string
    startedAt: Date | string
    canceledAt?: Date | string | null
    renewsAt?: Date | string | null
    priceCents: number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutOrgInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutOrgInput, SubscriptionUncheckedCreateWithoutOrgInput>
  }

  export type SubscriptionCreateManyOrgInputEnvelope = {
    data: SubscriptionCreateManyOrgInput | SubscriptionCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type UsageMeterCreateWithoutOrgInput = {
    id?: string
    meter: string
    quantity: number
    windowStart: Date | string
    windowEnd: Date | string
    createdAt?: Date | string
  }

  export type UsageMeterUncheckedCreateWithoutOrgInput = {
    id?: string
    meter: string
    quantity: number
    windowStart: Date | string
    windowEnd: Date | string
    createdAt?: Date | string
  }

  export type UsageMeterCreateOrConnectWithoutOrgInput = {
    where: UsageMeterWhereUniqueInput
    create: XOR<UsageMeterCreateWithoutOrgInput, UsageMeterUncheckedCreateWithoutOrgInput>
  }

  export type UsageMeterCreateManyOrgInputEnvelope = {
    data: UsageMeterCreateManyOrgInput | UsageMeterCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type AddonPurchaseCreateWithoutOrgInput = {
    id?: string
    sku: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    purchasedAt?: Date | string
    refundedAt?: Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type AddonPurchaseUncheckedCreateWithoutOrgInput = {
    id?: string
    sku: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    purchasedAt?: Date | string
    refundedAt?: Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type AddonPurchaseCreateOrConnectWithoutOrgInput = {
    where: AddonPurchaseWhereUniqueInput
    create: XOR<AddonPurchaseCreateWithoutOrgInput, AddonPurchaseUncheckedCreateWithoutOrgInput>
  }

  export type AddonPurchaseCreateManyOrgInputEnvelope = {
    data: AddonPurchaseCreateManyOrgInput | AddonPurchaseCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type TenantPriceOverrideCreateWithoutOrgInput = {
    id?: string
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PricePlanCreateNestedOneWithoutOverridesInput
    price?: PlanPriceCreateNestedOneWithoutOverridesInput
  }

  export type TenantPriceOverrideUncheckedCreateWithoutOrgInput = {
    id?: string
    planId?: string | null
    priceId?: string | null
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantPriceOverrideCreateOrConnectWithoutOrgInput = {
    where: TenantPriceOverrideWhereUniqueInput
    create: XOR<TenantPriceOverrideCreateWithoutOrgInput, TenantPriceOverrideUncheckedCreateWithoutOrgInput>
  }

  export type TenantPriceOverrideCreateManyOrgInputEnvelope = {
    data: TenantPriceOverrideCreateManyOrgInput | TenantPriceOverrideCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutOrgInput = {
    id?: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    assigneeUserId?: string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUncheckedCreateWithoutOrgInput = {
    id?: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    assigneeUserId?: string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateOrConnectWithoutOrgInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutOrgInput, IncidentUncheckedCreateWithoutOrgInput>
  }

  export type IncidentCreateManyOrgInputEnvelope = {
    data: IncidentCreateManyOrgInput | IncidentCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutOrgInput = {
    id?: string
    audience: string
    type: string
    title: string
    body: string
    severity: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutOrgInput = {
    id?: string
    audience: string
    type: string
    title: string
    body: string
    severity: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutOrgInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutOrgInput, NotificationUncheckedCreateWithoutOrgInput>
  }

  export type NotificationCreateManyOrgInputEnvelope = {
    data: NotificationCreateManyOrgInput | NotificationCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type ImportJobCreateWithoutOrgInput = {
    id?: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutImportJobsInput
    mapping?: ImportMappingCreateNestedOneWithoutJobsInput
    errors?: ImportErrorCreateNestedManyWithoutImportJobInput
  }

  export type ImportJobUncheckedCreateWithoutOrgInput = {
    id?: string
    userId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    mappingId?: string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    errors?: ImportErrorUncheckedCreateNestedManyWithoutImportJobInput
  }

  export type ImportJobCreateOrConnectWithoutOrgInput = {
    where: ImportJobWhereUniqueInput
    create: XOR<ImportJobCreateWithoutOrgInput, ImportJobUncheckedCreateWithoutOrgInput>
  }

  export type ImportJobCreateManyOrgInputEnvelope = {
    data: ImportJobCreateManyOrgInput | ImportJobCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type ImportMappingCreateWithoutOrgInput = {
    id?: string
    name: string
    entityType: $Enums.ImportEntityType
    sourceFormat: string
    fieldMappings: JsonNullValueInput | InputJsonValue
    transformRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isTemplate?: boolean
    useCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: ImportJobCreateNestedManyWithoutMappingInput
  }

  export type ImportMappingUncheckedCreateWithoutOrgInput = {
    id?: string
    name: string
    entityType: $Enums.ImportEntityType
    sourceFormat: string
    fieldMappings: JsonNullValueInput | InputJsonValue
    transformRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isTemplate?: boolean
    useCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: ImportJobUncheckedCreateNestedManyWithoutMappingInput
  }

  export type ImportMappingCreateOrConnectWithoutOrgInput = {
    where: ImportMappingWhereUniqueInput
    create: XOR<ImportMappingCreateWithoutOrgInput, ImportMappingUncheckedCreateWithoutOrgInput>
  }

  export type ImportMappingCreateManyOrgInputEnvelope = {
    data: ImportMappingCreateManyOrgInput | ImportMappingCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutOrgInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutOrgInput, AuditLogUncheckedUpdateWithoutOrgInput>
    create: XOR<AuditLogCreateWithoutOrgInput, AuditLogUncheckedCreateWithoutOrgInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutOrgInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutOrgInput, AuditLogUncheckedUpdateWithoutOrgInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutOrgInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutOrgInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    orgId?: StringFilter<"AuditLog"> | string
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    field?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    reason?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type BillingLedgerUpsertWithWhereUniqueWithoutOrgInput = {
    where: BillingLedgerWhereUniqueInput
    update: XOR<BillingLedgerUpdateWithoutOrgInput, BillingLedgerUncheckedUpdateWithoutOrgInput>
    create: XOR<BillingLedgerCreateWithoutOrgInput, BillingLedgerUncheckedCreateWithoutOrgInput>
  }

  export type BillingLedgerUpdateWithWhereUniqueWithoutOrgInput = {
    where: BillingLedgerWhereUniqueInput
    data: XOR<BillingLedgerUpdateWithoutOrgInput, BillingLedgerUncheckedUpdateWithoutOrgInput>
  }

  export type BillingLedgerUpdateManyWithWhereWithoutOrgInput = {
    where: BillingLedgerScalarWhereInput
    data: XOR<BillingLedgerUpdateManyMutationInput, BillingLedgerUncheckedUpdateManyWithoutOrgInput>
  }

  export type BillingLedgerScalarWhereInput = {
    AND?: BillingLedgerScalarWhereInput | BillingLedgerScalarWhereInput[]
    OR?: BillingLedgerScalarWhereInput[]
    NOT?: BillingLedgerScalarWhereInput | BillingLedgerScalarWhereInput[]
    id?: StringFilter<"BillingLedger"> | string
    orgId?: StringFilter<"BillingLedger"> | string
    type?: EnumLedgerTypeFilter<"BillingLedger"> | $Enums.LedgerType
    amount?: DecimalFilter<"BillingLedger"> | Decimal | DecimalJsLike | number | string
    meta?: JsonFilter<"BillingLedger">
    createdAt?: DateTimeFilter<"BillingLedger"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutOrgInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutOrgInput, CustomerUncheckedUpdateWithoutOrgInput>
    create: XOR<CustomerCreateWithoutOrgInput, CustomerUncheckedCreateWithoutOrgInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutOrgInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutOrgInput, CustomerUncheckedUpdateWithoutOrgInput>
  }

  export type CustomerUpdateManyWithWhereWithoutOrgInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutOrgInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    orgId?: StringFilter<"Customer"> | string
    publicId?: StringFilter<"Customer"> | string
    company?: StringNullableFilter<"Customer"> | string | null
    primaryName?: StringNullableFilter<"Customer"> | string | null
    primaryEmail?: StringNullableFilter<"Customer"> | string | null
    primaryPhone?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutOrgInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutOrgInput, InvoiceUncheckedUpdateWithoutOrgInput>
    create: XOR<InvoiceCreateWithoutOrgInput, InvoiceUncheckedCreateWithoutOrgInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutOrgInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutOrgInput, InvoiceUncheckedUpdateWithoutOrgInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutOrgInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutOrgInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    orgId?: StringFilter<"Invoice"> | string
    customerId?: StringNullableFilter<"Invoice"> | string | null
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    issuedAt?: DateTimeFilter<"Invoice"> | Date | string
    items?: JsonFilter<"Invoice">
  }

  export type JobUpsertWithWhereUniqueWithoutOrgInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutOrgInput, JobUncheckedUpdateWithoutOrgInput>
    create: XOR<JobCreateWithoutOrgInput, JobUncheckedCreateWithoutOrgInput>
  }

  export type JobUpdateWithWhereUniqueWithoutOrgInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutOrgInput, JobUncheckedUpdateWithoutOrgInput>
  }

  export type JobUpdateManyWithWhereWithoutOrgInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutOrgInput>
  }

  export type JobScalarWhereInput = {
    AND?: JobScalarWhereInput | JobScalarWhereInput[]
    OR?: JobScalarWhereInput[]
    NOT?: JobScalarWhereInput | JobScalarWhereInput[]
    id?: StringFilter<"Job"> | string
    orgId?: StringFilter<"Job"> | string
    customerId?: StringNullableFilter<"Job"> | string | null
    rfpId?: StringNullableFilter<"Job"> | string | null
    status?: StringFilter<"Job"> | string
    schedule?: JsonFilter<"Job">
    assignedTo?: StringNullableFilter<"Job"> | string | null
    checklist?: JsonFilter<"Job">
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
  }

  export type LeadUpsertWithWhereUniqueWithoutOrgInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutOrgInput, LeadUncheckedUpdateWithoutOrgInput>
    create: XOR<LeadCreateWithoutOrgInput, LeadUncheckedCreateWithoutOrgInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutOrgInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutOrgInput, LeadUncheckedUpdateWithoutOrgInput>
  }

  export type LeadUpdateManyWithWhereWithoutOrgInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutOrgInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    orgId?: StringFilter<"Lead"> | string
    publicId?: StringFilter<"Lead"> | string
    sourceType?: EnumLeadSourceFilter<"Lead"> | $Enums.LeadSource
    identityHash?: StringFilter<"Lead"> | string
    company?: StringNullableFilter<"Lead"> | string | null
    contactName?: StringNullableFilter<"Lead"> | string | null
    email?: StringNullableFilter<"Lead"> | string | null
    phoneE164?: StringNullableFilter<"Lead"> | string | null
    website?: StringNullableFilter<"Lead"> | string | null
    serviceCode?: StringNullableFilter<"Lead"> | string | null
    zip?: StringNullableFilter<"Lead"> | string | null
    enrichmentJson?: JsonFilter<"Lead">
    aiScore?: IntFilter<"Lead"> | number
    scoreFactors?: JsonFilter<"Lead">
    systemGenerated?: BoolFilter<"Lead"> | boolean
    convertedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    rfp?: JsonNullableFilter<"Lead">
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    city?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    sourceDetail?: StringNullableFilter<"Lead"> | string | null
    state?: StringNullableFilter<"Lead"> | string | null
    postalCode?: StringNullableFilter<"Lead"> | string | null
    address?: StringNullableFilter<"Lead"> | string | null
    addressLine1?: StringNullableFilter<"Lead"> | string | null
    addressLine2?: StringNullableFilter<"Lead"> | string | null
    country?: StringNullableFilter<"Lead"> | string | null
  }

  export type OpportunityUpsertWithWhereUniqueWithoutOrgInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutOrgInput, OpportunityUncheckedUpdateWithoutOrgInput>
    create: XOR<OpportunityCreateWithoutOrgInput, OpportunityUncheckedCreateWithoutOrgInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutOrgInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutOrgInput, OpportunityUncheckedUpdateWithoutOrgInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutOrgInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutOrgInput>
  }

  export type OpportunityScalarWhereInput = {
    AND?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    OR?: OpportunityScalarWhereInput[]
    NOT?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    orgId?: StringFilter<"Opportunity"> | string
    customerId?: StringFilter<"Opportunity"> | string
    valueType?: EnumValueTypeFilter<"Opportunity"> | $Enums.ValueType
    estValue?: DecimalNullableFilter<"Opportunity"> | Decimal | DecimalJsLike | number | string | null
    stage?: StringFilter<"Opportunity"> | string
    ownerId?: StringNullableFilter<"Opportunity"> | string | null
    sourceLeadId?: StringNullableFilter<"Opportunity"> | string | null
    classification?: JsonFilter<"Opportunity">
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrgInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrgInput, PaymentUncheckedUpdateWithoutOrgInput>
    create: XOR<PaymentCreateWithoutOrgInput, PaymentUncheckedCreateWithoutOrgInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrgInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrgInput, PaymentUncheckedUpdateWithoutOrgInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrgInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrgInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    orgId?: StringFilter<"Payment"> | string
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    receivedAt?: DateTimeFilter<"Payment"> | Date | string
    reference?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    retryCount?: IntFilter<"Payment"> | number
    lastRetryAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
  }

  export type ReferralUpsertWithWhereUniqueWithoutOrgInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutOrgInput, ReferralUncheckedUpdateWithoutOrgInput>
    create: XOR<ReferralCreateWithoutOrgInput, ReferralUncheckedCreateWithoutOrgInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutOrgInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutOrgInput, ReferralUncheckedUpdateWithoutOrgInput>
  }

  export type ReferralUpdateManyWithWhereWithoutOrgInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutOrgInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    orgId?: StringFilter<"Referral"> | string
    employeeId?: StringNullableFilter<"Referral"> | string | null
    referredName?: StringFilter<"Referral"> | string
    referredEmail?: StringNullableFilter<"Referral"> | string | null
    referredPhone?: StringNullableFilter<"Referral"> | string | null
    status?: StringFilter<"Referral"> | string
    convertedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type RfpUpsertWithWhereUniqueWithoutOrgInput = {
    where: RfpWhereUniqueInput
    update: XOR<RfpUpdateWithoutOrgInput, RfpUncheckedUpdateWithoutOrgInput>
    create: XOR<RfpCreateWithoutOrgInput, RfpUncheckedCreateWithoutOrgInput>
  }

  export type RfpUpdateWithWhereUniqueWithoutOrgInput = {
    where: RfpWhereUniqueInput
    data: XOR<RfpUpdateWithoutOrgInput, RfpUncheckedUpdateWithoutOrgInput>
  }

  export type RfpUpdateManyWithWhereWithoutOrgInput = {
    where: RfpScalarWhereInput
    data: XOR<RfpUpdateManyMutationInput, RfpUncheckedUpdateManyWithoutOrgInput>
  }

  export type RfpScalarWhereInput = {
    AND?: RfpScalarWhereInput | RfpScalarWhereInput[]
    OR?: RfpScalarWhereInput[]
    NOT?: RfpScalarWhereInput | RfpScalarWhereInput[]
    id?: StringFilter<"Rfp"> | string
    orgId?: StringFilter<"Rfp"> | string
    publicId?: StringFilter<"Rfp"> | string
    sourceSite?: StringFilter<"Rfp"> | string
    title?: StringFilter<"Rfp"> | string
    dueDate?: DateTimeNullableFilter<"Rfp"> | Date | string | null
    docs?: JsonFilter<"Rfp">
    aiBidFit?: IntNullableFilter<"Rfp"> | number | null
    aiPriceHint?: JsonFilter<"Rfp">
    createdAt?: DateTimeFilter<"Rfp"> | Date | string
    updatedAt?: DateTimeFilter<"Rfp"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutOrgInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrgInput, UserUncheckedUpdateWithoutOrgInput>
    create: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrgInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrgInput, UserUncheckedUpdateWithoutOrgInput>
  }

  export type UserUpdateManyWithWhereWithoutOrgInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrgInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    orgId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    passwordHash?: StringNullableFilter<"User"> | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    status?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isActive?: BoolFilter<"User"> | boolean
    isLocked?: BoolFilter<"User"> | boolean
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    lastFailedLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastSuccessfulLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastPasswordChange?: DateTimeNullableFilter<"User"> | Date | string | null
    totpSecret?: StringNullableFilter<"User"> | string | null
    totpEnabled?: BoolFilter<"User"> | boolean
    backupCodesHash?: StringNullableFilter<"User"> | string | null
  }

  export type RbacRoleUpsertWithWhereUniqueWithoutOrgInput = {
    where: RbacRoleWhereUniqueInput
    update: XOR<RbacRoleUpdateWithoutOrgInput, RbacRoleUncheckedUpdateWithoutOrgInput>
    create: XOR<RbacRoleCreateWithoutOrgInput, RbacRoleUncheckedCreateWithoutOrgInput>
  }

  export type RbacRoleUpdateWithWhereUniqueWithoutOrgInput = {
    where: RbacRoleWhereUniqueInput
    data: XOR<RbacRoleUpdateWithoutOrgInput, RbacRoleUncheckedUpdateWithoutOrgInput>
  }

  export type RbacRoleUpdateManyWithWhereWithoutOrgInput = {
    where: RbacRoleScalarWhereInput
    data: XOR<RbacRoleUpdateManyMutationInput, RbacRoleUncheckedUpdateManyWithoutOrgInput>
  }

  export type RbacRoleScalarWhereInput = {
    AND?: RbacRoleScalarWhereInput | RbacRoleScalarWhereInput[]
    OR?: RbacRoleScalarWhereInput[]
    NOT?: RbacRoleScalarWhereInput | RbacRoleScalarWhereInput[]
    id?: StringFilter<"RbacRole"> | string
    orgId?: StringNullableFilter<"RbacRole"> | string | null
    name?: StringFilter<"RbacRole"> | string
    slug?: StringFilter<"RbacRole"> | string
    isSystem?: BoolFilter<"RbacRole"> | boolean
    createdAt?: DateTimeFilter<"RbacRole"> | Date | string
  }

  export type RbacUserRoleUpsertWithWhereUniqueWithoutOrgInput = {
    where: RbacUserRoleWhereUniqueInput
    update: XOR<RbacUserRoleUpdateWithoutOrgInput, RbacUserRoleUncheckedUpdateWithoutOrgInput>
    create: XOR<RbacUserRoleCreateWithoutOrgInput, RbacUserRoleUncheckedCreateWithoutOrgInput>
  }

  export type RbacUserRoleUpdateWithWhereUniqueWithoutOrgInput = {
    where: RbacUserRoleWhereUniqueInput
    data: XOR<RbacUserRoleUpdateWithoutOrgInput, RbacUserRoleUncheckedUpdateWithoutOrgInput>
  }

  export type RbacUserRoleUpdateManyWithWhereWithoutOrgInput = {
    where: RbacUserRoleScalarWhereInput
    data: XOR<RbacUserRoleUpdateManyMutationInput, RbacUserRoleUncheckedUpdateManyWithoutOrgInput>
  }

  export type RbacUserRoleScalarWhereInput = {
    AND?: RbacUserRoleScalarWhereInput | RbacUserRoleScalarWhereInput[]
    OR?: RbacUserRoleScalarWhereInput[]
    NOT?: RbacUserRoleScalarWhereInput | RbacUserRoleScalarWhereInput[]
    id?: StringFilter<"RbacUserRole"> | string
    userId?: StringFilter<"RbacUserRole"> | string
    orgId?: StringNullableFilter<"RbacUserRole"> | string | null
    roleId?: StringFilter<"RbacUserRole"> | string
  }

  export type LeadInvoiceUpsertWithWhereUniqueWithoutOrgInput = {
    where: LeadInvoiceWhereUniqueInput
    update: XOR<LeadInvoiceUpdateWithoutOrgInput, LeadInvoiceUncheckedUpdateWithoutOrgInput>
    create: XOR<LeadInvoiceCreateWithoutOrgInput, LeadInvoiceUncheckedCreateWithoutOrgInput>
  }

  export type LeadInvoiceUpdateWithWhereUniqueWithoutOrgInput = {
    where: LeadInvoiceWhereUniqueInput
    data: XOR<LeadInvoiceUpdateWithoutOrgInput, LeadInvoiceUncheckedUpdateWithoutOrgInput>
  }

  export type LeadInvoiceUpdateManyWithWhereWithoutOrgInput = {
    where: LeadInvoiceScalarWhereInput
    data: XOR<LeadInvoiceUpdateManyMutationInput, LeadInvoiceUncheckedUpdateManyWithoutOrgInput>
  }

  export type LeadInvoiceScalarWhereInput = {
    AND?: LeadInvoiceScalarWhereInput | LeadInvoiceScalarWhereInput[]
    OR?: LeadInvoiceScalarWhereInput[]
    NOT?: LeadInvoiceScalarWhereInput | LeadInvoiceScalarWhereInput[]
    id?: StringFilter<"LeadInvoice"> | string
    orgId?: StringNullableFilter<"LeadInvoice"> | string | null
    number?: StringFilter<"LeadInvoice"> | string
    periodFrom?: DateTimeFilter<"LeadInvoice"> | Date | string
    periodTo?: DateTimeFilter<"LeadInvoice"> | Date | string
    status?: StringFilter<"LeadInvoice"> | string
    subtotalCents?: IntFilter<"LeadInvoice"> | number
    taxCents?: IntFilter<"LeadInvoice"> | number
    totalCents?: IntFilter<"LeadInvoice"> | number
    currency?: StringFilter<"LeadInvoice"> | string
    stripeInvoiceId?: StringNullableFilter<"LeadInvoice"> | string | null
    createdAt?: DateTimeFilter<"LeadInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"LeadInvoice"> | Date | string
    leadCount?: IntFilter<"LeadInvoice"> | number
  }

  export type PricingPlanUpsertWithoutOrgInput = {
    update: XOR<PricingPlanUpdateWithoutOrgInput, PricingPlanUncheckedUpdateWithoutOrgInput>
    create: XOR<PricingPlanCreateWithoutOrgInput, PricingPlanUncheckedCreateWithoutOrgInput>
    where?: PricingPlanWhereInput
  }

  export type PricingPlanUpdateToOneWithWhereWithoutOrgInput = {
    where?: PricingPlanWhereInput
    data: XOR<PricingPlanUpdateWithoutOrgInput, PricingPlanUncheckedUpdateWithoutOrgInput>
  }

  export type PricingPlanUpdateWithoutOrgInput = {
    model?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    currency?: StringFieldUpdateOperationsInput | string
    unitAmount?: IntFieldUpdateOperationsInput | number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: IntFieldUpdateOperationsInput | number
  }

  export type PricingPlanUncheckedUpdateWithoutOrgInput = {
    model?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    currency?: StringFieldUpdateOperationsInput | string
    unitAmount?: IntFieldUpdateOperationsInput | number
    tiersJson?: NullableJsonNullValueInput | InputJsonValue
    includedUnits?: IntFieldUpdateOperationsInput | number
  }

  export type AiUsageEventUpsertWithWhereUniqueWithoutOrgInput = {
    where: AiUsageEventWhereUniqueInput
    update: XOR<AiUsageEventUpdateWithoutOrgInput, AiUsageEventUncheckedUpdateWithoutOrgInput>
    create: XOR<AiUsageEventCreateWithoutOrgInput, AiUsageEventUncheckedCreateWithoutOrgInput>
  }

  export type AiUsageEventUpdateWithWhereUniqueWithoutOrgInput = {
    where: AiUsageEventWhereUniqueInput
    data: XOR<AiUsageEventUpdateWithoutOrgInput, AiUsageEventUncheckedUpdateWithoutOrgInput>
  }

  export type AiUsageEventUpdateManyWithWhereWithoutOrgInput = {
    where: AiUsageEventScalarWhereInput
    data: XOR<AiUsageEventUpdateManyMutationInput, AiUsageEventUncheckedUpdateManyWithoutOrgInput>
  }

  export type AiUsageEventScalarWhereInput = {
    AND?: AiUsageEventScalarWhereInput | AiUsageEventScalarWhereInput[]
    OR?: AiUsageEventScalarWhereInput[]
    NOT?: AiUsageEventScalarWhereInput | AiUsageEventScalarWhereInput[]
    id?: StringFilter<"AiUsageEvent"> | string
    orgId?: StringFilter<"AiUsageEvent"> | string
    userId?: StringNullableFilter<"AiUsageEvent"> | string | null
    feature?: StringFilter<"AiUsageEvent"> | string
    model?: StringFilter<"AiUsageEvent"> | string
    tokensIn?: IntFilter<"AiUsageEvent"> | number
    tokensOut?: IntFilter<"AiUsageEvent"> | number
    costUsd?: DecimalFilter<"AiUsageEvent"> | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFilter<"AiUsageEvent"> | number
    requestId?: StringNullableFilter<"AiUsageEvent"> | string | null
    createdAt?: DateTimeFilter<"AiUsageEvent"> | Date | string
  }

  export type AiMonthlySummaryUpsertWithWhereUniqueWithoutOrgInput = {
    where: AiMonthlySummaryWhereUniqueInput
    update: XOR<AiMonthlySummaryUpdateWithoutOrgInput, AiMonthlySummaryUncheckedUpdateWithoutOrgInput>
    create: XOR<AiMonthlySummaryCreateWithoutOrgInput, AiMonthlySummaryUncheckedCreateWithoutOrgInput>
  }

  export type AiMonthlySummaryUpdateWithWhereUniqueWithoutOrgInput = {
    where: AiMonthlySummaryWhereUniqueInput
    data: XOR<AiMonthlySummaryUpdateWithoutOrgInput, AiMonthlySummaryUncheckedUpdateWithoutOrgInput>
  }

  export type AiMonthlySummaryUpdateManyWithWhereWithoutOrgInput = {
    where: AiMonthlySummaryScalarWhereInput
    data: XOR<AiMonthlySummaryUpdateManyMutationInput, AiMonthlySummaryUncheckedUpdateManyWithoutOrgInput>
  }

  export type AiMonthlySummaryScalarWhereInput = {
    AND?: AiMonthlySummaryScalarWhereInput | AiMonthlySummaryScalarWhereInput[]
    OR?: AiMonthlySummaryScalarWhereInput[]
    NOT?: AiMonthlySummaryScalarWhereInput | AiMonthlySummaryScalarWhereInput[]
    id?: StringFilter<"AiMonthlySummary"> | string
    orgId?: StringFilter<"AiMonthlySummary"> | string
    monthKey?: StringFilter<"AiMonthlySummary"> | string
    tokensIn?: IntFilter<"AiMonthlySummary"> | number
    tokensOut?: IntFilter<"AiMonthlySummary"> | number
    costUsd?: DecimalFilter<"AiMonthlySummary"> | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFilter<"AiMonthlySummary"> | number
    callCount?: IntFilter<"AiMonthlySummary"> | number
    createdAt?: DateTimeFilter<"AiMonthlySummary"> | Date | string
    updatedAt?: DateTimeFilter<"AiMonthlySummary"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutOrgInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutOrgInput, ActivityUncheckedUpdateWithoutOrgInput>
    create: XOR<ActivityCreateWithoutOrgInput, ActivityUncheckedCreateWithoutOrgInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutOrgInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutOrgInput, ActivityUncheckedUpdateWithoutOrgInput>
  }

  export type ActivityUpdateManyWithWhereWithoutOrgInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutOrgInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    orgId?: StringFilter<"Activity"> | string
    actorType?: StringFilter<"Activity"> | string
    actorId?: StringNullableFilter<"Activity"> | string | null
    entityType?: StringFilter<"Activity"> | string
    entityId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    meta?: JsonFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutOrgInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutOrgInput, SubscriptionUncheckedUpdateWithoutOrgInput>
    create: XOR<SubscriptionCreateWithoutOrgInput, SubscriptionUncheckedCreateWithoutOrgInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutOrgInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutOrgInput, SubscriptionUncheckedUpdateWithoutOrgInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutOrgInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutOrgInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    orgId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    startedAt?: DateTimeFilter<"Subscription"> | Date | string
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    renewsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    priceCents?: IntFilter<"Subscription"> | number
    meta?: JsonFilter<"Subscription">
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type UsageMeterUpsertWithWhereUniqueWithoutOrgInput = {
    where: UsageMeterWhereUniqueInput
    update: XOR<UsageMeterUpdateWithoutOrgInput, UsageMeterUncheckedUpdateWithoutOrgInput>
    create: XOR<UsageMeterCreateWithoutOrgInput, UsageMeterUncheckedCreateWithoutOrgInput>
  }

  export type UsageMeterUpdateWithWhereUniqueWithoutOrgInput = {
    where: UsageMeterWhereUniqueInput
    data: XOR<UsageMeterUpdateWithoutOrgInput, UsageMeterUncheckedUpdateWithoutOrgInput>
  }

  export type UsageMeterUpdateManyWithWhereWithoutOrgInput = {
    where: UsageMeterScalarWhereInput
    data: XOR<UsageMeterUpdateManyMutationInput, UsageMeterUncheckedUpdateManyWithoutOrgInput>
  }

  export type UsageMeterScalarWhereInput = {
    AND?: UsageMeterScalarWhereInput | UsageMeterScalarWhereInput[]
    OR?: UsageMeterScalarWhereInput[]
    NOT?: UsageMeterScalarWhereInput | UsageMeterScalarWhereInput[]
    id?: StringFilter<"UsageMeter"> | string
    orgId?: StringFilter<"UsageMeter"> | string
    meter?: StringFilter<"UsageMeter"> | string
    quantity?: IntFilter<"UsageMeter"> | number
    windowStart?: DateTimeFilter<"UsageMeter"> | Date | string
    windowEnd?: DateTimeFilter<"UsageMeter"> | Date | string
    createdAt?: DateTimeFilter<"UsageMeter"> | Date | string
  }

  export type AddonPurchaseUpsertWithWhereUniqueWithoutOrgInput = {
    where: AddonPurchaseWhereUniqueInput
    update: XOR<AddonPurchaseUpdateWithoutOrgInput, AddonPurchaseUncheckedUpdateWithoutOrgInput>
    create: XOR<AddonPurchaseCreateWithoutOrgInput, AddonPurchaseUncheckedCreateWithoutOrgInput>
  }

  export type AddonPurchaseUpdateWithWhereUniqueWithoutOrgInput = {
    where: AddonPurchaseWhereUniqueInput
    data: XOR<AddonPurchaseUpdateWithoutOrgInput, AddonPurchaseUncheckedUpdateWithoutOrgInput>
  }

  export type AddonPurchaseUpdateManyWithWhereWithoutOrgInput = {
    where: AddonPurchaseScalarWhereInput
    data: XOR<AddonPurchaseUpdateManyMutationInput, AddonPurchaseUncheckedUpdateManyWithoutOrgInput>
  }

  export type AddonPurchaseScalarWhereInput = {
    AND?: AddonPurchaseScalarWhereInput | AddonPurchaseScalarWhereInput[]
    OR?: AddonPurchaseScalarWhereInput[]
    NOT?: AddonPurchaseScalarWhereInput | AddonPurchaseScalarWhereInput[]
    id?: StringFilter<"AddonPurchase"> | string
    orgId?: StringFilter<"AddonPurchase"> | string
    sku?: StringFilter<"AddonPurchase"> | string
    amount?: DecimalFilter<"AddonPurchase"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"AddonPurchase"> | string
    purchasedAt?: DateTimeFilter<"AddonPurchase"> | Date | string
    refundedAt?: DateTimeNullableFilter<"AddonPurchase"> | Date | string | null
    meta?: JsonFilter<"AddonPurchase">
  }

  export type TenantPriceOverrideUpsertWithWhereUniqueWithoutOrgInput = {
    where: TenantPriceOverrideWhereUniqueInput
    update: XOR<TenantPriceOverrideUpdateWithoutOrgInput, TenantPriceOverrideUncheckedUpdateWithoutOrgInput>
    create: XOR<TenantPriceOverrideCreateWithoutOrgInput, TenantPriceOverrideUncheckedCreateWithoutOrgInput>
  }

  export type TenantPriceOverrideUpdateWithWhereUniqueWithoutOrgInput = {
    where: TenantPriceOverrideWhereUniqueInput
    data: XOR<TenantPriceOverrideUpdateWithoutOrgInput, TenantPriceOverrideUncheckedUpdateWithoutOrgInput>
  }

  export type TenantPriceOverrideUpdateManyWithWhereWithoutOrgInput = {
    where: TenantPriceOverrideScalarWhereInput
    data: XOR<TenantPriceOverrideUpdateManyMutationInput, TenantPriceOverrideUncheckedUpdateManyWithoutOrgInput>
  }

  export type TenantPriceOverrideScalarWhereInput = {
    AND?: TenantPriceOverrideScalarWhereInput | TenantPriceOverrideScalarWhereInput[]
    OR?: TenantPriceOverrideScalarWhereInput[]
    NOT?: TenantPriceOverrideScalarWhereInput | TenantPriceOverrideScalarWhereInput[]
    id?: StringFilter<"TenantPriceOverride"> | string
    orgId?: StringFilter<"TenantPriceOverride"> | string
    planId?: StringNullableFilter<"TenantPriceOverride"> | string | null
    priceId?: StringNullableFilter<"TenantPriceOverride"> | string | null
    type?: EnumOverrideTypeFilter<"TenantPriceOverride"> | $Enums.OverrideType
    percentOff?: IntNullableFilter<"TenantPriceOverride"> | number | null
    amountOffCents?: IntNullableFilter<"TenantPriceOverride"> | number | null
    priceCents?: IntNullableFilter<"TenantPriceOverride"> | number | null
    startsAt?: DateTimeNullableFilter<"TenantPriceOverride"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"TenantPriceOverride"> | Date | string | null
    reason?: StringNullableFilter<"TenantPriceOverride"> | string | null
    createdAt?: DateTimeFilter<"TenantPriceOverride"> | Date | string
    updatedAt?: DateTimeFilter<"TenantPriceOverride"> | Date | string
  }

  export type IncidentUpsertWithWhereUniqueWithoutOrgInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutOrgInput, IncidentUncheckedUpdateWithoutOrgInput>
    create: XOR<IncidentCreateWithoutOrgInput, IncidentUncheckedCreateWithoutOrgInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutOrgInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutOrgInput, IncidentUncheckedUpdateWithoutOrgInput>
  }

  export type IncidentUpdateManyWithWhereWithoutOrgInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutOrgInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    OR?: IncidentScalarWhereInput[]
    NOT?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    id?: StringFilter<"Incident"> | string
    orgId?: StringFilter<"Incident"> | string
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    title?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    assigneeUserId?: StringNullableFilter<"Incident"> | string | null
    slaResponseDeadline?: DateTimeNullableFilter<"Incident"> | Date | string | null
    slaResolveDeadline?: DateTimeNullableFilter<"Incident"> | Date | string | null
    acknowledgedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutOrgInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutOrgInput, NotificationUncheckedUpdateWithoutOrgInput>
    create: XOR<NotificationCreateWithoutOrgInput, NotificationUncheckedCreateWithoutOrgInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutOrgInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutOrgInput, NotificationUncheckedUpdateWithoutOrgInput>
  }

  export type NotificationUpdateManyWithWhereWithoutOrgInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutOrgInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    orgId?: StringNullableFilter<"Notification"> | string | null
    audience?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    severity?: StringFilter<"Notification"> | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ImportJobUpsertWithWhereUniqueWithoutOrgInput = {
    where: ImportJobWhereUniqueInput
    update: XOR<ImportJobUpdateWithoutOrgInput, ImportJobUncheckedUpdateWithoutOrgInput>
    create: XOR<ImportJobCreateWithoutOrgInput, ImportJobUncheckedCreateWithoutOrgInput>
  }

  export type ImportJobUpdateWithWhereUniqueWithoutOrgInput = {
    where: ImportJobWhereUniqueInput
    data: XOR<ImportJobUpdateWithoutOrgInput, ImportJobUncheckedUpdateWithoutOrgInput>
  }

  export type ImportJobUpdateManyWithWhereWithoutOrgInput = {
    where: ImportJobScalarWhereInput
    data: XOR<ImportJobUpdateManyMutationInput, ImportJobUncheckedUpdateManyWithoutOrgInput>
  }

  export type ImportJobScalarWhereInput = {
    AND?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
    OR?: ImportJobScalarWhereInput[]
    NOT?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
    id?: StringFilter<"ImportJob"> | string
    orgId?: StringFilter<"ImportJob"> | string
    userId?: StringFilter<"ImportJob"> | string
    entityType?: EnumImportEntityTypeFilter<"ImportJob"> | $Enums.ImportEntityType
    status?: EnumImportStatusFilter<"ImportJob"> | $Enums.ImportStatus
    fileName?: StringFilter<"ImportJob"> | string
    fileSize?: IntFilter<"ImportJob"> | number
    totalRecords?: IntFilter<"ImportJob"> | number
    processedRecords?: IntFilter<"ImportJob"> | number
    successCount?: IntFilter<"ImportJob"> | number
    errorCount?: IntFilter<"ImportJob"> | number
    skipCount?: IntFilter<"ImportJob"> | number
    mappingId?: StringNullableFilter<"ImportJob"> | string | null
    sampleData?: JsonNullableFilter<"ImportJob">
    fieldMappings?: JsonNullableFilter<"ImportJob">
    transformRules?: JsonNullableFilter<"ImportJob">
    validationRules?: JsonNullableFilter<"ImportJob">
    progressPercent?: IntFilter<"ImportJob"> | number
    startedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    errorSummary?: StringNullableFilter<"ImportJob"> | string | null
    createdAt?: DateTimeFilter<"ImportJob"> | Date | string
    updatedAt?: DateTimeFilter<"ImportJob"> | Date | string
  }

  export type ImportMappingUpsertWithWhereUniqueWithoutOrgInput = {
    where: ImportMappingWhereUniqueInput
    update: XOR<ImportMappingUpdateWithoutOrgInput, ImportMappingUncheckedUpdateWithoutOrgInput>
    create: XOR<ImportMappingCreateWithoutOrgInput, ImportMappingUncheckedCreateWithoutOrgInput>
  }

  export type ImportMappingUpdateWithWhereUniqueWithoutOrgInput = {
    where: ImportMappingWhereUniqueInput
    data: XOR<ImportMappingUpdateWithoutOrgInput, ImportMappingUncheckedUpdateWithoutOrgInput>
  }

  export type ImportMappingUpdateManyWithWhereWithoutOrgInput = {
    where: ImportMappingScalarWhereInput
    data: XOR<ImportMappingUpdateManyMutationInput, ImportMappingUncheckedUpdateManyWithoutOrgInput>
  }

  export type ImportMappingScalarWhereInput = {
    AND?: ImportMappingScalarWhereInput | ImportMappingScalarWhereInput[]
    OR?: ImportMappingScalarWhereInput[]
    NOT?: ImportMappingScalarWhereInput | ImportMappingScalarWhereInput[]
    id?: StringFilter<"ImportMapping"> | string
    orgId?: StringFilter<"ImportMapping"> | string
    name?: StringFilter<"ImportMapping"> | string
    entityType?: EnumImportEntityTypeFilter<"ImportMapping"> | $Enums.ImportEntityType
    sourceFormat?: StringFilter<"ImportMapping"> | string
    fieldMappings?: JsonFilter<"ImportMapping">
    transformRules?: JsonFilter<"ImportMapping">
    validationRules?: JsonFilter<"ImportMapping">
    isTemplate?: BoolFilter<"ImportMapping"> | boolean
    useCount?: IntFilter<"ImportMapping"> | number
    lastUsedAt?: DateTimeNullableFilter<"ImportMapping"> | Date | string | null
    createdAt?: DateTimeFilter<"ImportMapping"> | Date | string
    updatedAt?: DateTimeFilter<"ImportMapping"> | Date | string
  }

  export type OrgCreateWithoutUsersInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutUsersInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutUsersInput, OrgUncheckedCreateWithoutUsersInput>
  }

  export type RbacUserRoleCreateWithoutUserInput = {
    id?: string
    org?: OrgCreateNestedOneWithoutRbacUserRolesInput
    role: RbacRoleCreateNestedOneWithoutUserRolesInput
  }

  export type RbacUserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    orgId?: string | null
    roleId: string
  }

  export type RbacUserRoleCreateOrConnectWithoutUserInput = {
    where: RbacUserRoleWhereUniqueInput
    create: XOR<RbacUserRoleCreateWithoutUserInput, RbacUserRoleUncheckedCreateWithoutUserInput>
  }

  export type RbacUserRoleCreateManyUserInputEnvelope = {
    data: RbacUserRoleCreateManyUserInput | RbacUserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRecoveryCodeCreateWithoutUserInput = {
    id?: string
    codeHash: string
    usedAt?: Date | string | null
    usedFrom?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type UserRecoveryCodeUncheckedCreateWithoutUserInput = {
    id?: string
    codeHash: string
    usedAt?: Date | string | null
    usedFrom?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type UserRecoveryCodeCreateOrConnectWithoutUserInput = {
    where: UserRecoveryCodeWhereUniqueInput
    create: XOR<UserRecoveryCodeCreateWithoutUserInput, UserRecoveryCodeUncheckedCreateWithoutUserInput>
  }

  export type UserRecoveryCodeCreateManyUserInputEnvelope = {
    data: UserRecoveryCodeCreateManyUserInput | UserRecoveryCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBreakglassAccountCreateWithoutUserInput = {
    id?: string
    orgId: string
    encryptedEmail: string
    encryptedPasswordHash: string
    encryptionIV: string
    createdAt?: Date | string
    lastActivatedAt?: Date | string | null
    activationCount?: number
    isEnabled?: boolean
    canAutoActivate?: boolean
    minDelayMinutes?: number
  }

  export type UserBreakglassAccountUncheckedCreateWithoutUserInput = {
    id?: string
    orgId: string
    encryptedEmail: string
    encryptedPasswordHash: string
    encryptionIV: string
    createdAt?: Date | string
    lastActivatedAt?: Date | string | null
    activationCount?: number
    isEnabled?: boolean
    canAutoActivate?: boolean
    minDelayMinutes?: number
  }

  export type UserBreakglassAccountCreateOrConnectWithoutUserInput = {
    where: UserBreakglassAccountWhereUniqueInput
    create: XOR<UserBreakglassAccountCreateWithoutUserInput, UserBreakglassAccountUncheckedCreateWithoutUserInput>
  }

  export type UserSecurityQuestionCreateWithoutUserInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
  }

  export type UserSecurityQuestionUncheckedCreateWithoutUserInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
  }

  export type UserSecurityQuestionCreateOrConnectWithoutUserInput = {
    where: UserSecurityQuestionWhereUniqueInput
    create: XOR<UserSecurityQuestionCreateWithoutUserInput, UserSecurityQuestionUncheckedCreateWithoutUserInput>
  }

  export type UserSecurityQuestionCreateManyUserInputEnvelope = {
    data: UserSecurityQuestionCreateManyUserInput | UserSecurityQuestionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLoginHistoryCreateWithoutUserInput = {
    id?: string
    success: boolean
    method: string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    riskScore?: number
    riskFactors?: string | null
    country?: string | null
    city?: string | null
    timestamp?: Date | string
  }

  export type UserLoginHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    success: boolean
    method: string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    riskScore?: number
    riskFactors?: string | null
    country?: string | null
    city?: string | null
    timestamp?: Date | string
  }

  export type UserLoginHistoryCreateOrConnectWithoutUserInput = {
    where: UserLoginHistoryWhereUniqueInput
    create: XOR<UserLoginHistoryCreateWithoutUserInput, UserLoginHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserLoginHistoryCreateManyUserInputEnvelope = {
    data: UserLoginHistoryCreateManyUserInput | UserLoginHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserDeviceFingerprintCreateWithoutUserInput = {
    id?: string
    fingerprint: string
    ipAddress: string
    userAgent: string
    isTrusted?: boolean
    trustScore?: number
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    loginCount?: number
  }

  export type UserDeviceFingerprintUncheckedCreateWithoutUserInput = {
    id?: string
    fingerprint: string
    ipAddress: string
    userAgent: string
    isTrusted?: boolean
    trustScore?: number
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    loginCount?: number
  }

  export type UserDeviceFingerprintCreateOrConnectWithoutUserInput = {
    where: UserDeviceFingerprintWhereUniqueInput
    create: XOR<UserDeviceFingerprintCreateWithoutUserInput, UserDeviceFingerprintUncheckedCreateWithoutUserInput>
  }

  export type UserDeviceFingerprintCreateManyUserInputEnvelope = {
    data: UserDeviceFingerprintCreateManyUserInput | UserDeviceFingerprintCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ImportJobCreateWithoutUserInput = {
    id?: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutImportJobsInput
    mapping?: ImportMappingCreateNestedOneWithoutJobsInput
    errors?: ImportErrorCreateNestedManyWithoutImportJobInput
  }

  export type ImportJobUncheckedCreateWithoutUserInput = {
    id?: string
    orgId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    mappingId?: string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    errors?: ImportErrorUncheckedCreateNestedManyWithoutImportJobInput
  }

  export type ImportJobCreateOrConnectWithoutUserInput = {
    where: ImportJobWhereUniqueInput
    create: XOR<ImportJobCreateWithoutUserInput, ImportJobUncheckedCreateWithoutUserInput>
  }

  export type ImportJobCreateManyUserInputEnvelope = {
    data: ImportJobCreateManyUserInput | ImportJobCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrgUpsertWithoutUsersInput = {
    update: XOR<OrgUpdateWithoutUsersInput, OrgUncheckedUpdateWithoutUsersInput>
    create: XOR<OrgCreateWithoutUsersInput, OrgUncheckedCreateWithoutUsersInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutUsersInput, OrgUncheckedUpdateWithoutUsersInput>
  }

  export type OrgUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type RbacUserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: RbacUserRoleWhereUniqueInput
    update: XOR<RbacUserRoleUpdateWithoutUserInput, RbacUserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<RbacUserRoleCreateWithoutUserInput, RbacUserRoleUncheckedCreateWithoutUserInput>
  }

  export type RbacUserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: RbacUserRoleWhereUniqueInput
    data: XOR<RbacUserRoleUpdateWithoutUserInput, RbacUserRoleUncheckedUpdateWithoutUserInput>
  }

  export type RbacUserRoleUpdateManyWithWhereWithoutUserInput = {
    where: RbacUserRoleScalarWhereInput
    data: XOR<RbacUserRoleUpdateManyMutationInput, RbacUserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRecoveryCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRecoveryCodeWhereUniqueInput
    update: XOR<UserRecoveryCodeUpdateWithoutUserInput, UserRecoveryCodeUncheckedUpdateWithoutUserInput>
    create: XOR<UserRecoveryCodeCreateWithoutUserInput, UserRecoveryCodeUncheckedCreateWithoutUserInput>
  }

  export type UserRecoveryCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRecoveryCodeWhereUniqueInput
    data: XOR<UserRecoveryCodeUpdateWithoutUserInput, UserRecoveryCodeUncheckedUpdateWithoutUserInput>
  }

  export type UserRecoveryCodeUpdateManyWithWhereWithoutUserInput = {
    where: UserRecoveryCodeScalarWhereInput
    data: XOR<UserRecoveryCodeUpdateManyMutationInput, UserRecoveryCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRecoveryCodeScalarWhereInput = {
    AND?: UserRecoveryCodeScalarWhereInput | UserRecoveryCodeScalarWhereInput[]
    OR?: UserRecoveryCodeScalarWhereInput[]
    NOT?: UserRecoveryCodeScalarWhereInput | UserRecoveryCodeScalarWhereInput[]
    id?: StringFilter<"UserRecoveryCode"> | string
    userId?: StringFilter<"UserRecoveryCode"> | string
    codeHash?: StringFilter<"UserRecoveryCode"> | string
    usedAt?: DateTimeNullableFilter<"UserRecoveryCode"> | Date | string | null
    usedFrom?: StringNullableFilter<"UserRecoveryCode"> | string | null
    createdAt?: DateTimeFilter<"UserRecoveryCode"> | Date | string
    expiresAt?: DateTimeFilter<"UserRecoveryCode"> | Date | string
  }

  export type UserBreakglassAccountUpsertWithoutUserInput = {
    update: XOR<UserBreakglassAccountUpdateWithoutUserInput, UserBreakglassAccountUncheckedUpdateWithoutUserInput>
    create: XOR<UserBreakglassAccountCreateWithoutUserInput, UserBreakglassAccountUncheckedCreateWithoutUserInput>
    where?: UserBreakglassAccountWhereInput
  }

  export type UserBreakglassAccountUpdateToOneWithWhereWithoutUserInput = {
    where?: UserBreakglassAccountWhereInput
    data: XOR<UserBreakglassAccountUpdateWithoutUserInput, UserBreakglassAccountUncheckedUpdateWithoutUserInput>
  }

  export type UserBreakglassAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    encryptedEmail?: StringFieldUpdateOperationsInput | string
    encryptedPasswordHash?: StringFieldUpdateOperationsInput | string
    encryptionIV?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationCount?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    canAutoActivate?: BoolFieldUpdateOperationsInput | boolean
    minDelayMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type UserBreakglassAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    encryptedEmail?: StringFieldUpdateOperationsInput | string
    encryptedPasswordHash?: StringFieldUpdateOperationsInput | string
    encryptionIV?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationCount?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    canAutoActivate?: BoolFieldUpdateOperationsInput | boolean
    minDelayMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type UserSecurityQuestionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSecurityQuestionWhereUniqueInput
    update: XOR<UserSecurityQuestionUpdateWithoutUserInput, UserSecurityQuestionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSecurityQuestionCreateWithoutUserInput, UserSecurityQuestionUncheckedCreateWithoutUserInput>
  }

  export type UserSecurityQuestionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSecurityQuestionWhereUniqueInput
    data: XOR<UserSecurityQuestionUpdateWithoutUserInput, UserSecurityQuestionUncheckedUpdateWithoutUserInput>
  }

  export type UserSecurityQuestionUpdateManyWithWhereWithoutUserInput = {
    where: UserSecurityQuestionScalarWhereInput
    data: XOR<UserSecurityQuestionUpdateManyMutationInput, UserSecurityQuestionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSecurityQuestionScalarWhereInput = {
    AND?: UserSecurityQuestionScalarWhereInput | UserSecurityQuestionScalarWhereInput[]
    OR?: UserSecurityQuestionScalarWhereInput[]
    NOT?: UserSecurityQuestionScalarWhereInput | UserSecurityQuestionScalarWhereInput[]
    id?: StringFilter<"UserSecurityQuestion"> | string
    userId?: StringFilter<"UserSecurityQuestion"> | string
    question?: StringFilter<"UserSecurityQuestion"> | string
    answerHash?: StringFilter<"UserSecurityQuestion"> | string
    createdAt?: DateTimeFilter<"UserSecurityQuestion"> | Date | string
  }

  export type UserLoginHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLoginHistoryWhereUniqueInput
    update: XOR<UserLoginHistoryUpdateWithoutUserInput, UserLoginHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserLoginHistoryCreateWithoutUserInput, UserLoginHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserLoginHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLoginHistoryWhereUniqueInput
    data: XOR<UserLoginHistoryUpdateWithoutUserInput, UserLoginHistoryUncheckedUpdateWithoutUserInput>
  }

  export type UserLoginHistoryUpdateManyWithWhereWithoutUserInput = {
    where: UserLoginHistoryScalarWhereInput
    data: XOR<UserLoginHistoryUpdateManyMutationInput, UserLoginHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLoginHistoryScalarWhereInput = {
    AND?: UserLoginHistoryScalarWhereInput | UserLoginHistoryScalarWhereInput[]
    OR?: UserLoginHistoryScalarWhereInput[]
    NOT?: UserLoginHistoryScalarWhereInput | UserLoginHistoryScalarWhereInput[]
    id?: StringFilter<"UserLoginHistory"> | string
    userId?: StringFilter<"UserLoginHistory"> | string
    success?: BoolFilter<"UserLoginHistory"> | boolean
    method?: StringFilter<"UserLoginHistory"> | string
    ipAddress?: StringFilter<"UserLoginHistory"> | string
    userAgent?: StringFilter<"UserLoginHistory"> | string
    deviceFingerprint?: StringNullableFilter<"UserLoginHistory"> | string | null
    riskScore?: IntFilter<"UserLoginHistory"> | number
    riskFactors?: StringNullableFilter<"UserLoginHistory"> | string | null
    country?: StringNullableFilter<"UserLoginHistory"> | string | null
    city?: StringNullableFilter<"UserLoginHistory"> | string | null
    timestamp?: DateTimeFilter<"UserLoginHistory"> | Date | string
  }

  export type UserDeviceFingerprintUpsertWithWhereUniqueWithoutUserInput = {
    where: UserDeviceFingerprintWhereUniqueInput
    update: XOR<UserDeviceFingerprintUpdateWithoutUserInput, UserDeviceFingerprintUncheckedUpdateWithoutUserInput>
    create: XOR<UserDeviceFingerprintCreateWithoutUserInput, UserDeviceFingerprintUncheckedCreateWithoutUserInput>
  }

  export type UserDeviceFingerprintUpdateWithWhereUniqueWithoutUserInput = {
    where: UserDeviceFingerprintWhereUniqueInput
    data: XOR<UserDeviceFingerprintUpdateWithoutUserInput, UserDeviceFingerprintUncheckedUpdateWithoutUserInput>
  }

  export type UserDeviceFingerprintUpdateManyWithWhereWithoutUserInput = {
    where: UserDeviceFingerprintScalarWhereInput
    data: XOR<UserDeviceFingerprintUpdateManyMutationInput, UserDeviceFingerprintUncheckedUpdateManyWithoutUserInput>
  }

  export type UserDeviceFingerprintScalarWhereInput = {
    AND?: UserDeviceFingerprintScalarWhereInput | UserDeviceFingerprintScalarWhereInput[]
    OR?: UserDeviceFingerprintScalarWhereInput[]
    NOT?: UserDeviceFingerprintScalarWhereInput | UserDeviceFingerprintScalarWhereInput[]
    id?: StringFilter<"UserDeviceFingerprint"> | string
    userId?: StringFilter<"UserDeviceFingerprint"> | string
    fingerprint?: StringFilter<"UserDeviceFingerprint"> | string
    ipAddress?: StringFilter<"UserDeviceFingerprint"> | string
    userAgent?: StringFilter<"UserDeviceFingerprint"> | string
    isTrusted?: BoolFilter<"UserDeviceFingerprint"> | boolean
    trustScore?: IntFilter<"UserDeviceFingerprint"> | number
    firstSeenAt?: DateTimeFilter<"UserDeviceFingerprint"> | Date | string
    lastSeenAt?: DateTimeFilter<"UserDeviceFingerprint"> | Date | string
    loginCount?: IntFilter<"UserDeviceFingerprint"> | number
  }

  export type ImportJobUpsertWithWhereUniqueWithoutUserInput = {
    where: ImportJobWhereUniqueInput
    update: XOR<ImportJobUpdateWithoutUserInput, ImportJobUncheckedUpdateWithoutUserInput>
    create: XOR<ImportJobCreateWithoutUserInput, ImportJobUncheckedCreateWithoutUserInput>
  }

  export type ImportJobUpdateWithWhereUniqueWithoutUserInput = {
    where: ImportJobWhereUniqueInput
    data: XOR<ImportJobUpdateWithoutUserInput, ImportJobUncheckedUpdateWithoutUserInput>
  }

  export type ImportJobUpdateManyWithWhereWithoutUserInput = {
    where: ImportJobScalarWhereInput
    data: XOR<ImportJobUpdateManyMutationInput, ImportJobUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutRecoveryCodesInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    org: OrgCreateNestedOneWithoutUsersInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintCreateNestedManyWithoutUserInput
    importJobs?: ImportJobCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecoveryCodesInput = {
    id?: string
    orgId: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountUncheckedCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryUncheckedCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedCreateNestedManyWithoutUserInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecoveryCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
  }

  export type UserUpsertWithoutRecoveryCodesInput = {
    update: XOR<UserUpdateWithoutRecoveryCodesInput, UserUncheckedUpdateWithoutRecoveryCodesInput>
    create: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecoveryCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecoveryCodesInput, UserUncheckedUpdateWithoutRecoveryCodesInput>
  }

  export type UserUpdateWithoutRecoveryCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrgUpdateOneRequiredWithoutUsersNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecoveryCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUncheckedUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSecurityQuestionsInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    org: OrgCreateNestedOneWithoutUsersInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountCreateNestedOneWithoutUserInput
    loginHistory?: UserLoginHistoryCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintCreateNestedManyWithoutUserInput
    importJobs?: ImportJobCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSecurityQuestionsInput = {
    id?: string
    orgId: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountUncheckedCreateNestedOneWithoutUserInput
    loginHistory?: UserLoginHistoryUncheckedCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedCreateNestedManyWithoutUserInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSecurityQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
  }

  export type UserUpsertWithoutSecurityQuestionsInput = {
    update: XOR<UserUpdateWithoutSecurityQuestionsInput, UserUncheckedUpdateWithoutSecurityQuestionsInput>
    create: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSecurityQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSecurityQuestionsInput, UserUncheckedUpdateWithoutSecurityQuestionsInput>
  }

  export type UserUpdateWithoutSecurityQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrgUpdateOneRequiredWithoutUsersNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUpdateOneWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSecurityQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUncheckedUpdateOneWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBreakglassAccountInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    org: OrgCreateNestedOneWithoutUsersInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeCreateNestedManyWithoutUserInput
    securityQuestions?: UserSecurityQuestionCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintCreateNestedManyWithoutUserInput
    importJobs?: ImportJobCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBreakglassAccountInput = {
    id?: string
    orgId: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: UserSecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryUncheckedCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedCreateNestedManyWithoutUserInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBreakglassAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBreakglassAccountInput, UserUncheckedCreateWithoutBreakglassAccountInput>
  }

  export type UserUpsertWithoutBreakglassAccountInput = {
    update: XOR<UserUpdateWithoutBreakglassAccountInput, UserUncheckedUpdateWithoutBreakglassAccountInput>
    create: XOR<UserCreateWithoutBreakglassAccountInput, UserUncheckedCreateWithoutBreakglassAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBreakglassAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBreakglassAccountInput, UserUncheckedUpdateWithoutBreakglassAccountInput>
  }

  export type UserUpdateWithoutBreakglassAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrgUpdateOneRequiredWithoutUsersNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUpdateManyWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBreakglassAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDeviceFingerprintsInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    org: OrgCreateNestedOneWithoutUsersInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryCreateNestedManyWithoutUserInput
    importJobs?: ImportJobCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeviceFingerprintsInput = {
    id?: string
    orgId: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountUncheckedCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryUncheckedCreateNestedManyWithoutUserInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeviceFingerprintsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeviceFingerprintsInput, UserUncheckedCreateWithoutDeviceFingerprintsInput>
  }

  export type UserUpsertWithoutDeviceFingerprintsInput = {
    update: XOR<UserUpdateWithoutDeviceFingerprintsInput, UserUncheckedUpdateWithoutDeviceFingerprintsInput>
    create: XOR<UserCreateWithoutDeviceFingerprintsInput, UserUncheckedCreateWithoutDeviceFingerprintsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeviceFingerprintsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeviceFingerprintsInput, UserUncheckedUpdateWithoutDeviceFingerprintsInput>
  }

  export type UserUpdateWithoutDeviceFingerprintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrgUpdateOneRequiredWithoutUsersNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeviceFingerprintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUncheckedUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLoginHistoryInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    org: OrgCreateNestedOneWithoutUsersInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintCreateNestedManyWithoutUserInput
    importJobs?: ImportJobCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLoginHistoryInput = {
    id?: string
    orgId: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountUncheckedCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedCreateNestedManyWithoutUserInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLoginHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
  }

  export type UserUpsertWithoutLoginHistoryInput = {
    update: XOR<UserUpdateWithoutLoginHistoryInput, UserUncheckedUpdateWithoutLoginHistoryInput>
    create: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLoginHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLoginHistoryInput, UserUncheckedUpdateWithoutLoginHistoryInput>
  }

  export type UserUpdateWithoutLoginHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrgUpdateOneRequiredWithoutUsersNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLoginHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUncheckedUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrgCreateWithoutLeadsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutLeadsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutLeadsInput, OrgUncheckedCreateWithoutLeadsInput>
  }

  export type LeadInvoiceLineCreateWithoutLeadInput = {
    id?: string
    description: string
    quantity?: number
    unitPriceCents: number
    amountCents: number
    source?: string | null
    createdAt?: Date | string
    invoice: LeadInvoiceCreateNestedOneWithoutLinesInput
  }

  export type LeadInvoiceLineUncheckedCreateWithoutLeadInput = {
    id?: string
    invoiceId: string
    description: string
    quantity?: number
    unitPriceCents: number
    amountCents: number
    source?: string | null
    createdAt?: Date | string
  }

  export type LeadInvoiceLineCreateOrConnectWithoutLeadInput = {
    where: LeadInvoiceLineWhereUniqueInput
    create: XOR<LeadInvoiceLineCreateWithoutLeadInput, LeadInvoiceLineUncheckedCreateWithoutLeadInput>
  }

  export type LeadInvoiceLineCreateManyLeadInputEnvelope = {
    data: LeadInvoiceLineCreateManyLeadInput | LeadInvoiceLineCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type OrgUpsertWithoutLeadsInput = {
    update: XOR<OrgUpdateWithoutLeadsInput, OrgUncheckedUpdateWithoutLeadsInput>
    create: XOR<OrgCreateWithoutLeadsInput, OrgUncheckedCreateWithoutLeadsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutLeadsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutLeadsInput, OrgUncheckedUpdateWithoutLeadsInput>
  }

  export type OrgUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type LeadInvoiceLineUpsertWithWhereUniqueWithoutLeadInput = {
    where: LeadInvoiceLineWhereUniqueInput
    update: XOR<LeadInvoiceLineUpdateWithoutLeadInput, LeadInvoiceLineUncheckedUpdateWithoutLeadInput>
    create: XOR<LeadInvoiceLineCreateWithoutLeadInput, LeadInvoiceLineUncheckedCreateWithoutLeadInput>
  }

  export type LeadInvoiceLineUpdateWithWhereUniqueWithoutLeadInput = {
    where: LeadInvoiceLineWhereUniqueInput
    data: XOR<LeadInvoiceLineUpdateWithoutLeadInput, LeadInvoiceLineUncheckedUpdateWithoutLeadInput>
  }

  export type LeadInvoiceLineUpdateManyWithWhereWithoutLeadInput = {
    where: LeadInvoiceLineScalarWhereInput
    data: XOR<LeadInvoiceLineUpdateManyMutationInput, LeadInvoiceLineUncheckedUpdateManyWithoutLeadInput>
  }

  export type LeadInvoiceLineScalarWhereInput = {
    AND?: LeadInvoiceLineScalarWhereInput | LeadInvoiceLineScalarWhereInput[]
    OR?: LeadInvoiceLineScalarWhereInput[]
    NOT?: LeadInvoiceLineScalarWhereInput | LeadInvoiceLineScalarWhereInput[]
    id?: StringFilter<"LeadInvoiceLine"> | string
    invoiceId?: StringFilter<"LeadInvoiceLine"> | string
    leadId?: StringNullableFilter<"LeadInvoiceLine"> | string | null
    description?: StringFilter<"LeadInvoiceLine"> | string
    quantity?: IntFilter<"LeadInvoiceLine"> | number
    unitPriceCents?: IntFilter<"LeadInvoiceLine"> | number
    amountCents?: IntFilter<"LeadInvoiceLine"> | number
    source?: StringNullableFilter<"LeadInvoiceLine"> | string | null
    createdAt?: DateTimeFilter<"LeadInvoiceLine"> | Date | string
  }

  export type OrgCreateWithoutCustomersInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutCustomersInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutCustomersInput, OrgUncheckedCreateWithoutCustomersInput>
  }

  export type InvoiceCreateWithoutCustomerInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    org: OrgCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    orgId: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceCreateManyCustomerInputEnvelope = {
    data: InvoiceCreateManyCustomerInput | InvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutCustomerInput = {
    id?: string
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutJobsInput
    rfp?: RfpCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutCustomerInput = {
    id?: string
    orgId: string
    rfpId?: string | null
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateOrConnectWithoutCustomerInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput>
  }

  export type JobCreateManyCustomerInputEnvelope = {
    data: JobCreateManyCustomerInput | JobCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutCustomerInput = {
    id?: string
    valueType?: $Enums.ValueType
    estValue?: Decimal | DecimalJsLike | number | string | null
    stage?: string
    ownerId?: string | null
    sourceLeadId?: string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutOpportunitiesInput
  }

  export type OpportunityUncheckedCreateWithoutCustomerInput = {
    id?: string
    orgId: string
    valueType?: $Enums.ValueType
    estValue?: Decimal | DecimalJsLike | number | string | null
    stage?: string
    ownerId?: string | null
    sourceLeadId?: string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityCreateOrConnectWithoutCustomerInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput>
  }

  export type OpportunityCreateManyCustomerInputEnvelope = {
    data: OpportunityCreateManyCustomerInput | OpportunityCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrgUpsertWithoutCustomersInput = {
    update: XOR<OrgUpdateWithoutCustomersInput, OrgUncheckedUpdateWithoutCustomersInput>
    create: XOR<OrgCreateWithoutCustomersInput, OrgUncheckedCreateWithoutCustomersInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutCustomersInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutCustomersInput, OrgUncheckedUpdateWithoutCustomersInput>
  }

  export type OrgUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type JobUpsertWithWhereUniqueWithoutCustomerInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutCustomerInput, JobUncheckedUpdateWithoutCustomerInput>
    create: XOR<JobCreateWithoutCustomerInput, JobUncheckedCreateWithoutCustomerInput>
  }

  export type JobUpdateWithWhereUniqueWithoutCustomerInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutCustomerInput, JobUncheckedUpdateWithoutCustomerInput>
  }

  export type JobUpdateManyWithWhereWithoutCustomerInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OpportunityUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutCustomerInput, OpportunityUncheckedUpdateWithoutCustomerInput>
    create: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutCustomerInput, OpportunityUncheckedUpdateWithoutCustomerInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutCustomerInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutOpportunitiesInput = {
    id?: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutCustomersInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    orgId: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOpportunitiesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOpportunitiesInput, CustomerUncheckedCreateWithoutOpportunitiesInput>
  }

  export type OrgCreateWithoutOpportunitiesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutOpportunitiesInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutOpportunitiesInput, OrgUncheckedCreateWithoutOpportunitiesInput>
  }

  export type CustomerUpsertWithoutOpportunitiesInput = {
    update: XOR<CustomerUpdateWithoutOpportunitiesInput, CustomerUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<CustomerCreateWithoutOpportunitiesInput, CustomerUncheckedCreateWithoutOpportunitiesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOpportunitiesInput, CustomerUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type CustomerUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutCustomersNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrgUpsertWithoutOpportunitiesInput = {
    update: XOR<OrgUpdateWithoutOpportunitiesInput, OrgUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<OrgCreateWithoutOpportunitiesInput, OrgUncheckedCreateWithoutOpportunitiesInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutOpportunitiesInput, OrgUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type OrgUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type InvoiceLineCreateWithoutInvoiceInput = {
    id?: string
    description: string
    lineType: $Enums.InvoiceLineType
    quantity?: number
    unitPriceCents: number
    amountCents: number
    sourceType?: string | null
    sourceId?: string | null
    createdAt?: Date | string
  }

  export type InvoiceLineUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    lineType: $Enums.InvoiceLineType
    quantity?: number
    unitPriceCents: number
    amountCents: number
    sourceType?: string | null
    sourceId?: string | null
    createdAt?: Date | string
  }

  export type InvoiceLineCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineCreateManyInvoiceInputEnvelope = {
    data: InvoiceLineCreateManyInvoiceInput | InvoiceLineCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutInvoicesInput = {
    id?: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutCustomersInput
    jobs?: JobCreateNestedManyWithoutCustomerInput
    opportunities?: OpportunityCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutInvoicesInput = {
    id?: string
    orgId: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutCustomerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
  }

  export type OrgCreateWithoutInvoicesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutInvoicesInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutInvoicesInput, OrgUncheckedCreateWithoutInvoicesInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method?: string
    receivedAt?: Date | string
    reference?: string | null
    status?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    failureReason?: string | null
    retryCount?: number
    lastRetryAt?: Date | string | null
    org: OrgCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    orgId: string
    amount: Decimal | DecimalJsLike | number | string
    method?: string
    receivedAt?: Date | string
    reference?: string | null
    status?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    failureReason?: string | null
    retryCount?: number
    lastRetryAt?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceLineScalarWhereInput = {
    AND?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    OR?: InvoiceLineScalarWhereInput[]
    NOT?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    id?: StringFilter<"InvoiceLine"> | string
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    lineType?: EnumInvoiceLineTypeFilter<"InvoiceLine"> | $Enums.InvoiceLineType
    quantity?: IntFilter<"InvoiceLine"> | number
    unitPriceCents?: IntFilter<"InvoiceLine"> | number
    amountCents?: IntFilter<"InvoiceLine"> | number
    sourceType?: StringNullableFilter<"InvoiceLine"> | string | null
    sourceId?: StringNullableFilter<"InvoiceLine"> | string | null
    createdAt?: DateTimeFilter<"InvoiceLine"> | Date | string
  }

  export type CustomerUpsertWithoutInvoicesInput = {
    update: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutCustomersNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    opportunities?: OpportunityUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrgUpsertWithoutInvoicesInput = {
    update: XOR<OrgUpdateWithoutInvoicesInput, OrgUncheckedUpdateWithoutInvoicesInput>
    create: XOR<OrgCreateWithoutInvoicesInput, OrgUncheckedCreateWithoutInvoicesInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutInvoicesInput, OrgUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrgUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    org: OrgCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    orgId: string
    customerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type OrgCreateWithoutPaymentsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutPaymentsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutPaymentsInput, OrgUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    org?: OrgUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type OrgUpsertWithoutPaymentsInput = {
    update: XOR<OrgUpdateWithoutPaymentsInput, OrgUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrgCreateWithoutPaymentsInput, OrgUncheckedCreateWithoutPaymentsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutPaymentsInput, OrgUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrgUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type JobCreateWithoutRfpInput = {
    id?: string
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutJobsInput
    org: OrgCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutRfpInput = {
    id?: string
    orgId: string
    customerId?: string | null
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateOrConnectWithoutRfpInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutRfpInput, JobUncheckedCreateWithoutRfpInput>
  }

  export type JobCreateManyRfpInputEnvelope = {
    data: JobCreateManyRfpInput | JobCreateManyRfpInput[]
    skipDuplicates?: boolean
  }

  export type OrgCreateWithoutRfpsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutRfpsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutRfpsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutRfpsInput, OrgUncheckedCreateWithoutRfpsInput>
  }

  export type JobUpsertWithWhereUniqueWithoutRfpInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutRfpInput, JobUncheckedUpdateWithoutRfpInput>
    create: XOR<JobCreateWithoutRfpInput, JobUncheckedCreateWithoutRfpInput>
  }

  export type JobUpdateWithWhereUniqueWithoutRfpInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutRfpInput, JobUncheckedUpdateWithoutRfpInput>
  }

  export type JobUpdateManyWithWhereWithoutRfpInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutRfpInput>
  }

  export type OrgUpsertWithoutRfpsInput = {
    update: XOR<OrgUpdateWithoutRfpsInput, OrgUncheckedUpdateWithoutRfpsInput>
    create: XOR<OrgCreateWithoutRfpsInput, OrgUncheckedCreateWithoutRfpsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutRfpsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutRfpsInput, OrgUncheckedUpdateWithoutRfpsInput>
  }

  export type OrgUpdateWithoutRfpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutRfpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type CustomerCreateWithoutJobsInput = {
    id?: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutCustomersInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    opportunities?: OpportunityCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutJobsInput = {
    id?: string
    orgId: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutJobsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
  }

  export type OrgCreateWithoutJobsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutJobsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutJobsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutJobsInput, OrgUncheckedCreateWithoutJobsInput>
  }

  export type RfpCreateWithoutJobsInput = {
    id?: string
    publicId: string
    sourceSite: string
    title: string
    dueDate?: Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutRfpsInput
  }

  export type RfpUncheckedCreateWithoutJobsInput = {
    id?: string
    orgId: string
    publicId: string
    sourceSite: string
    title: string
    dueDate?: Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RfpCreateOrConnectWithoutJobsInput = {
    where: RfpWhereUniqueInput
    create: XOR<RfpCreateWithoutJobsInput, RfpUncheckedCreateWithoutJobsInput>
  }

  export type CustomerUpsertWithoutJobsInput = {
    update: XOR<CustomerUpdateWithoutJobsInput, CustomerUncheckedUpdateWithoutJobsInput>
    create: XOR<CustomerCreateWithoutJobsInput, CustomerUncheckedCreateWithoutJobsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutJobsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutJobsInput, CustomerUncheckedUpdateWithoutJobsInput>
  }

  export type CustomerUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutCustomersNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    opportunities?: OpportunityUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrgUpsertWithoutJobsInput = {
    update: XOR<OrgUpdateWithoutJobsInput, OrgUncheckedUpdateWithoutJobsInput>
    create: XOR<OrgCreateWithoutJobsInput, OrgUncheckedCreateWithoutJobsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutJobsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutJobsInput, OrgUncheckedUpdateWithoutJobsInput>
  }

  export type OrgUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type RfpUpsertWithoutJobsInput = {
    update: XOR<RfpUpdateWithoutJobsInput, RfpUncheckedUpdateWithoutJobsInput>
    create: XOR<RfpCreateWithoutJobsInput, RfpUncheckedCreateWithoutJobsInput>
    where?: RfpWhereInput
  }

  export type RfpUpdateToOneWithWhereWithoutJobsInput = {
    where?: RfpWhereInput
    data: XOR<RfpUpdateWithoutJobsInput, RfpUncheckedUpdateWithoutJobsInput>
  }

  export type RfpUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceSite?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: NullableIntFieldUpdateOperationsInput | number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutRfpsNestedInput
  }

  export type RfpUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceSite?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: NullableIntFieldUpdateOperationsInput | number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgCreateWithoutReferralsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutReferralsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutReferralsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutReferralsInput, OrgUncheckedCreateWithoutReferralsInput>
  }

  export type OrgUpsertWithoutReferralsInput = {
    update: XOR<OrgUpdateWithoutReferralsInput, OrgUncheckedUpdateWithoutReferralsInput>
    create: XOR<OrgCreateWithoutReferralsInput, OrgUncheckedCreateWithoutReferralsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutReferralsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutReferralsInput, OrgUncheckedUpdateWithoutReferralsInput>
  }

  export type OrgUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrgCreateWithoutLedgerInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutLedgerInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutLedgerInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutLedgerInput, OrgUncheckedCreateWithoutLedgerInput>
  }

  export type OrgUpsertWithoutLedgerInput = {
    update: XOR<OrgUpdateWithoutLedgerInput, OrgUncheckedUpdateWithoutLedgerInput>
    create: XOR<OrgCreateWithoutLedgerInput, OrgUncheckedCreateWithoutLedgerInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutLedgerInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutLedgerInput, OrgUncheckedUpdateWithoutLedgerInput>
  }

  export type OrgUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrgCreateWithoutLeadInvoicesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutLeadInvoicesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutLeadInvoicesInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutLeadInvoicesInput, OrgUncheckedCreateWithoutLeadInvoicesInput>
  }

  export type LeadInvoiceLineCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPriceCents: number
    amountCents: number
    source?: string | null
    createdAt?: Date | string
    lead?: LeadCreateNestedOneWithoutLeadInvoiceLineInput
  }

  export type LeadInvoiceLineUncheckedCreateWithoutInvoiceInput = {
    id?: string
    leadId?: string | null
    description: string
    quantity?: number
    unitPriceCents: number
    amountCents: number
    source?: string | null
    createdAt?: Date | string
  }

  export type LeadInvoiceLineCreateOrConnectWithoutInvoiceInput = {
    where: LeadInvoiceLineWhereUniqueInput
    create: XOR<LeadInvoiceLineCreateWithoutInvoiceInput, LeadInvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type LeadInvoiceLineCreateManyInvoiceInputEnvelope = {
    data: LeadInvoiceLineCreateManyInvoiceInput | LeadInvoiceLineCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type OrgUpsertWithoutLeadInvoicesInput = {
    update: XOR<OrgUpdateWithoutLeadInvoicesInput, OrgUncheckedUpdateWithoutLeadInvoicesInput>
    create: XOR<OrgCreateWithoutLeadInvoicesInput, OrgUncheckedCreateWithoutLeadInvoicesInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutLeadInvoicesInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutLeadInvoicesInput, OrgUncheckedUpdateWithoutLeadInvoicesInput>
  }

  export type OrgUpdateWithoutLeadInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutLeadInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type LeadInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: LeadInvoiceLineWhereUniqueInput
    update: XOR<LeadInvoiceLineUpdateWithoutInvoiceInput, LeadInvoiceLineUncheckedUpdateWithoutInvoiceInput>
    create: XOR<LeadInvoiceLineCreateWithoutInvoiceInput, LeadInvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type LeadInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: LeadInvoiceLineWhereUniqueInput
    data: XOR<LeadInvoiceLineUpdateWithoutInvoiceInput, LeadInvoiceLineUncheckedUpdateWithoutInvoiceInput>
  }

  export type LeadInvoiceLineUpdateManyWithWhereWithoutInvoiceInput = {
    where: LeadInvoiceLineScalarWhereInput
    data: XOR<LeadInvoiceLineUpdateManyMutationInput, LeadInvoiceLineUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type LeadInvoiceCreateWithoutLinesInput = {
    id?: string
    number: string
    periodFrom: Date | string
    periodTo: Date | string
    status: string
    subtotalCents: number
    taxCents?: number
    totalCents: number
    currency?: string
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadCount?: number
    org?: OrgCreateNestedOneWithoutLeadInvoicesInput
  }

  export type LeadInvoiceUncheckedCreateWithoutLinesInput = {
    id?: string
    orgId?: string | null
    number: string
    periodFrom: Date | string
    periodTo: Date | string
    status: string
    subtotalCents: number
    taxCents?: number
    totalCents: number
    currency?: string
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadCount?: number
  }

  export type LeadInvoiceCreateOrConnectWithoutLinesInput = {
    where: LeadInvoiceWhereUniqueInput
    create: XOR<LeadInvoiceCreateWithoutLinesInput, LeadInvoiceUncheckedCreateWithoutLinesInput>
  }

  export type LeadCreateWithoutLeadInvoiceLineInput = {
    id?: string
    publicId: string
    sourceType: $Enums.LeadSource
    identityHash: string
    company?: string | null
    contactName?: string | null
    email?: string | null
    phoneE164?: string | null
    website?: string | null
    serviceCode?: string | null
    zip?: string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: boolean
    convertedAt?: Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    notes?: string | null
    sourceDetail?: string | null
    state?: string | null
    postalCode?: string | null
    address?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    country?: string | null
    org: OrgCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutLeadInvoiceLineInput = {
    id?: string
    orgId: string
    publicId: string
    sourceType: $Enums.LeadSource
    identityHash: string
    company?: string | null
    contactName?: string | null
    email?: string | null
    phoneE164?: string | null
    website?: string | null
    serviceCode?: string | null
    zip?: string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: boolean
    convertedAt?: Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    notes?: string | null
    sourceDetail?: string | null
    state?: string | null
    postalCode?: string | null
    address?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    country?: string | null
  }

  export type LeadCreateOrConnectWithoutLeadInvoiceLineInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutLeadInvoiceLineInput, LeadUncheckedCreateWithoutLeadInvoiceLineInput>
  }

  export type LeadInvoiceUpsertWithoutLinesInput = {
    update: XOR<LeadInvoiceUpdateWithoutLinesInput, LeadInvoiceUncheckedUpdateWithoutLinesInput>
    create: XOR<LeadInvoiceCreateWithoutLinesInput, LeadInvoiceUncheckedCreateWithoutLinesInput>
    where?: LeadInvoiceWhereInput
  }

  export type LeadInvoiceUpdateToOneWithWhereWithoutLinesInput = {
    where?: LeadInvoiceWhereInput
    data: XOR<LeadInvoiceUpdateWithoutLinesInput, LeadInvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type LeadInvoiceUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    periodFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    periodTo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    taxCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadCount?: IntFieldUpdateOperationsInput | number
    org?: OrgUpdateOneWithoutLeadInvoicesNestedInput
  }

  export type LeadInvoiceUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    periodFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    periodTo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    taxCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadCount?: IntFieldUpdateOperationsInput | number
  }

  export type LeadUpsertWithoutLeadInvoiceLineInput = {
    update: XOR<LeadUpdateWithoutLeadInvoiceLineInput, LeadUncheckedUpdateWithoutLeadInvoiceLineInput>
    create: XOR<LeadCreateWithoutLeadInvoiceLineInput, LeadUncheckedCreateWithoutLeadInvoiceLineInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutLeadInvoiceLineInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutLeadInvoiceLineInput, LeadUncheckedUpdateWithoutLeadInvoiceLineInput>
  }

  export type LeadUpdateWithoutLeadInvoiceLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    identityHash?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneE164?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: IntFieldUpdateOperationsInput | number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: BoolFieldUpdateOperationsInput | boolean
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDetail?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrgUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutLeadInvoiceLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    identityHash?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneE164?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: IntFieldUpdateOperationsInput | number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: BoolFieldUpdateOperationsInput | boolean
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDetail?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrgCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutAuditLogsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutAuditLogsInput, OrgUncheckedCreateWithoutAuditLogsInput>
  }

  export type OrgUpsertWithoutAuditLogsInput = {
    update: XOR<OrgUpdateWithoutAuditLogsInput, OrgUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<OrgCreateWithoutAuditLogsInput, OrgUncheckedCreateWithoutAuditLogsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutAuditLogsInput, OrgUncheckedUpdateWithoutAuditLogsInput>
  }

  export type OrgUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type RbacRolePermissionCreateWithoutPermissionInput = {
    role: RbacRoleCreateNestedOneWithoutRolePermsInput
  }

  export type RbacRolePermissionUncheckedCreateWithoutPermissionInput = {
    roleId: string
  }

  export type RbacRolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RbacRolePermissionWhereUniqueInput
    create: XOR<RbacRolePermissionCreateWithoutPermissionInput, RbacRolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RbacRolePermissionCreateManyPermissionInputEnvelope = {
    data: RbacRolePermissionCreateManyPermissionInput | RbacRolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RbacRolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RbacRolePermissionWhereUniqueInput
    update: XOR<RbacRolePermissionUpdateWithoutPermissionInput, RbacRolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RbacRolePermissionCreateWithoutPermissionInput, RbacRolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RbacRolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RbacRolePermissionWhereUniqueInput
    data: XOR<RbacRolePermissionUpdateWithoutPermissionInput, RbacRolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RbacRolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RbacRolePermissionScalarWhereInput
    data: XOR<RbacRolePermissionUpdateManyMutationInput, RbacRolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RbacRolePermissionScalarWhereInput = {
    AND?: RbacRolePermissionScalarWhereInput | RbacRolePermissionScalarWhereInput[]
    OR?: RbacRolePermissionScalarWhereInput[]
    NOT?: RbacRolePermissionScalarWhereInput | RbacRolePermissionScalarWhereInput[]
    roleId?: StringFilter<"RbacRolePermission"> | string
    permissionId?: StringFilter<"RbacRolePermission"> | string
  }

  export type OrgCreateWithoutRbacRolesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutRbacRolesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutRbacRolesInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutRbacRolesInput, OrgUncheckedCreateWithoutRbacRolesInput>
  }

  export type RbacRolePermissionCreateWithoutRoleInput = {
    permission: RbacPermissionCreateNestedOneWithoutRolePermsInput
  }

  export type RbacRolePermissionUncheckedCreateWithoutRoleInput = {
    permissionId: string
  }

  export type RbacRolePermissionCreateOrConnectWithoutRoleInput = {
    where: RbacRolePermissionWhereUniqueInput
    create: XOR<RbacRolePermissionCreateWithoutRoleInput, RbacRolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RbacRolePermissionCreateManyRoleInputEnvelope = {
    data: RbacRolePermissionCreateManyRoleInput | RbacRolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RbacUserRoleCreateWithoutRoleInput = {
    id?: string
    user: UserCreateNestedOneWithoutRbacUserRolesInput
    org?: OrgCreateNestedOneWithoutRbacUserRolesInput
  }

  export type RbacUserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    orgId?: string | null
  }

  export type RbacUserRoleCreateOrConnectWithoutRoleInput = {
    where: RbacUserRoleWhereUniqueInput
    create: XOR<RbacUserRoleCreateWithoutRoleInput, RbacUserRoleUncheckedCreateWithoutRoleInput>
  }

  export type RbacUserRoleCreateManyRoleInputEnvelope = {
    data: RbacUserRoleCreateManyRoleInput | RbacUserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type OrgUpsertWithoutRbacRolesInput = {
    update: XOR<OrgUpdateWithoutRbacRolesInput, OrgUncheckedUpdateWithoutRbacRolesInput>
    create: XOR<OrgCreateWithoutRbacRolesInput, OrgUncheckedCreateWithoutRbacRolesInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutRbacRolesInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutRbacRolesInput, OrgUncheckedUpdateWithoutRbacRolesInput>
  }

  export type OrgUpdateWithoutRbacRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutRbacRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type RbacRolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RbacRolePermissionWhereUniqueInput
    update: XOR<RbacRolePermissionUpdateWithoutRoleInput, RbacRolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RbacRolePermissionCreateWithoutRoleInput, RbacRolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RbacRolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RbacRolePermissionWhereUniqueInput
    data: XOR<RbacRolePermissionUpdateWithoutRoleInput, RbacRolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RbacRolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RbacRolePermissionScalarWhereInput
    data: XOR<RbacRolePermissionUpdateManyMutationInput, RbacRolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RbacUserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: RbacUserRoleWhereUniqueInput
    update: XOR<RbacUserRoleUpdateWithoutRoleInput, RbacUserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<RbacUserRoleCreateWithoutRoleInput, RbacUserRoleUncheckedCreateWithoutRoleInput>
  }

  export type RbacUserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: RbacUserRoleWhereUniqueInput
    data: XOR<RbacUserRoleUpdateWithoutRoleInput, RbacUserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type RbacUserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: RbacUserRoleScalarWhereInput
    data: XOR<RbacUserRoleUpdateManyMutationInput, RbacUserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RbacRoleCreateWithoutRolePermsInput = {
    id?: string
    name: string
    slug: string
    isSystem?: boolean
    createdAt?: Date | string
    org?: OrgCreateNestedOneWithoutRbacRolesInput
    userRoles?: RbacUserRoleCreateNestedManyWithoutRoleInput
  }

  export type RbacRoleUncheckedCreateWithoutRolePermsInput = {
    id?: string
    orgId?: string | null
    name: string
    slug: string
    isSystem?: boolean
    createdAt?: Date | string
    userRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RbacRoleCreateOrConnectWithoutRolePermsInput = {
    where: RbacRoleWhereUniqueInput
    create: XOR<RbacRoleCreateWithoutRolePermsInput, RbacRoleUncheckedCreateWithoutRolePermsInput>
  }

  export type RbacPermissionCreateWithoutRolePermsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
  }

  export type RbacPermissionUncheckedCreateWithoutRolePermsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
  }

  export type RbacPermissionCreateOrConnectWithoutRolePermsInput = {
    where: RbacPermissionWhereUniqueInput
    create: XOR<RbacPermissionCreateWithoutRolePermsInput, RbacPermissionUncheckedCreateWithoutRolePermsInput>
  }

  export type RbacRoleUpsertWithoutRolePermsInput = {
    update: XOR<RbacRoleUpdateWithoutRolePermsInput, RbacRoleUncheckedUpdateWithoutRolePermsInput>
    create: XOR<RbacRoleCreateWithoutRolePermsInput, RbacRoleUncheckedCreateWithoutRolePermsInput>
    where?: RbacRoleWhereInput
  }

  export type RbacRoleUpdateToOneWithWhereWithoutRolePermsInput = {
    where?: RbacRoleWhereInput
    data: XOR<RbacRoleUpdateWithoutRolePermsInput, RbacRoleUncheckedUpdateWithoutRolePermsInput>
  }

  export type RbacRoleUpdateWithoutRolePermsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneWithoutRbacRolesNestedInput
    userRoles?: RbacUserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RbacRoleUncheckedUpdateWithoutRolePermsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: RbacUserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RbacPermissionUpsertWithoutRolePermsInput = {
    update: XOR<RbacPermissionUpdateWithoutRolePermsInput, RbacPermissionUncheckedUpdateWithoutRolePermsInput>
    create: XOR<RbacPermissionCreateWithoutRolePermsInput, RbacPermissionUncheckedCreateWithoutRolePermsInput>
    where?: RbacPermissionWhereInput
  }

  export type RbacPermissionUpdateToOneWithWhereWithoutRolePermsInput = {
    where?: RbacPermissionWhereInput
    data: XOR<RbacPermissionUpdateWithoutRolePermsInput, RbacPermissionUncheckedUpdateWithoutRolePermsInput>
  }

  export type RbacPermissionUpdateWithoutRolePermsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RbacPermissionUncheckedUpdateWithoutRolePermsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRbacUserRolesInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    org: OrgCreateNestedOneWithoutUsersInput
    recoveryCodes?: UserRecoveryCodeCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintCreateNestedManyWithoutUserInput
    importJobs?: ImportJobCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRbacUserRolesInput = {
    id?: string
    orgId: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    recoveryCodes?: UserRecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountUncheckedCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryUncheckedCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedCreateNestedManyWithoutUserInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRbacUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRbacUserRolesInput, UserUncheckedCreateWithoutRbacUserRolesInput>
  }

  export type OrgCreateWithoutRbacUserRolesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutRbacUserRolesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutRbacUserRolesInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutRbacUserRolesInput, OrgUncheckedCreateWithoutRbacUserRolesInput>
  }

  export type RbacRoleCreateWithoutUserRolesInput = {
    id?: string
    name: string
    slug: string
    isSystem?: boolean
    createdAt?: Date | string
    org?: OrgCreateNestedOneWithoutRbacRolesInput
    rolePerms?: RbacRolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RbacRoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    orgId?: string | null
    name: string
    slug: string
    isSystem?: boolean
    createdAt?: Date | string
    rolePerms?: RbacRolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RbacRoleCreateOrConnectWithoutUserRolesInput = {
    where: RbacRoleWhereUniqueInput
    create: XOR<RbacRoleCreateWithoutUserRolesInput, RbacRoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutRbacUserRolesInput = {
    update: XOR<UserUpdateWithoutRbacUserRolesInput, UserUncheckedUpdateWithoutRbacUserRolesInput>
    create: XOR<UserCreateWithoutRbacUserRolesInput, UserUncheckedCreateWithoutRbacUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRbacUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRbacUserRolesInput, UserUncheckedUpdateWithoutRbacUserRolesInput>
  }

  export type UserUpdateWithoutRbacUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrgUpdateOneRequiredWithoutUsersNestedInput
    recoveryCodes?: UserRecoveryCodeUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRbacUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryCodes?: UserRecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUncheckedUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrgUpsertWithoutRbacUserRolesInput = {
    update: XOR<OrgUpdateWithoutRbacUserRolesInput, OrgUncheckedUpdateWithoutRbacUserRolesInput>
    create: XOR<OrgCreateWithoutRbacUserRolesInput, OrgUncheckedCreateWithoutRbacUserRolesInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutRbacUserRolesInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutRbacUserRolesInput, OrgUncheckedUpdateWithoutRbacUserRolesInput>
  }

  export type OrgUpdateWithoutRbacUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutRbacUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type RbacRoleUpsertWithoutUserRolesInput = {
    update: XOR<RbacRoleUpdateWithoutUserRolesInput, RbacRoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RbacRoleCreateWithoutUserRolesInput, RbacRoleUncheckedCreateWithoutUserRolesInput>
    where?: RbacRoleWhereInput
  }

  export type RbacRoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RbacRoleWhereInput
    data: XOR<RbacRoleUpdateWithoutUserRolesInput, RbacRoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RbacRoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneWithoutRbacRolesNestedInput
    rolePerms?: RbacRolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RbacRoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePerms?: RbacRolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type OrgCreateWithoutPricingPlanInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutPricingPlanInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutPricingPlanInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutPricingPlanInput, OrgUncheckedCreateWithoutPricingPlanInput>
  }

  export type OrgUpsertWithoutPricingPlanInput = {
    update: XOR<OrgUpdateWithoutPricingPlanInput, OrgUncheckedUpdateWithoutPricingPlanInput>
    create: XOR<OrgCreateWithoutPricingPlanInput, OrgUncheckedCreateWithoutPricingPlanInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutPricingPlanInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutPricingPlanInput, OrgUncheckedUpdateWithoutPricingPlanInput>
  }

  export type OrgUpdateWithoutPricingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutPricingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrgCreateWithoutAiUsageEventsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutAiUsageEventsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutAiUsageEventsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutAiUsageEventsInput, OrgUncheckedCreateWithoutAiUsageEventsInput>
  }

  export type OrgUpsertWithoutAiUsageEventsInput = {
    update: XOR<OrgUpdateWithoutAiUsageEventsInput, OrgUncheckedUpdateWithoutAiUsageEventsInput>
    create: XOR<OrgCreateWithoutAiUsageEventsInput, OrgUncheckedCreateWithoutAiUsageEventsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutAiUsageEventsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutAiUsageEventsInput, OrgUncheckedUpdateWithoutAiUsageEventsInput>
  }

  export type OrgUpdateWithoutAiUsageEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutAiUsageEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrgCreateWithoutAiMonthlySummariesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutAiMonthlySummariesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutAiMonthlySummariesInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutAiMonthlySummariesInput, OrgUncheckedCreateWithoutAiMonthlySummariesInput>
  }

  export type OrgUpsertWithoutAiMonthlySummariesInput = {
    update: XOR<OrgUpdateWithoutAiMonthlySummariesInput, OrgUncheckedUpdateWithoutAiMonthlySummariesInput>
    create: XOR<OrgCreateWithoutAiMonthlySummariesInput, OrgUncheckedCreateWithoutAiMonthlySummariesInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutAiMonthlySummariesInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutAiMonthlySummariesInput, OrgUncheckedUpdateWithoutAiMonthlySummariesInput>
  }

  export type OrgUpdateWithoutAiMonthlySummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutAiMonthlySummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrgCreateWithoutActivitiesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutActivitiesInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutActivitiesInput, OrgUncheckedCreateWithoutActivitiesInput>
  }

  export type OrgUpsertWithoutActivitiesInput = {
    update: XOR<OrgUpdateWithoutActivitiesInput, OrgUncheckedUpdateWithoutActivitiesInput>
    create: XOR<OrgCreateWithoutActivitiesInput, OrgUncheckedCreateWithoutActivitiesInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutActivitiesInput, OrgUncheckedUpdateWithoutActivitiesInput>
  }

  export type OrgUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrgCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutSubscriptionsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutSubscriptionsInput, OrgUncheckedCreateWithoutSubscriptionsInput>
  }

  export type OrgUpsertWithoutSubscriptionsInput = {
    update: XOR<OrgUpdateWithoutSubscriptionsInput, OrgUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<OrgCreateWithoutSubscriptionsInput, OrgUncheckedCreateWithoutSubscriptionsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutSubscriptionsInput, OrgUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type OrgUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrgCreateWithoutUsageMetersInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutUsageMetersInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutUsageMetersInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutUsageMetersInput, OrgUncheckedCreateWithoutUsageMetersInput>
  }

  export type OrgUpsertWithoutUsageMetersInput = {
    update: XOR<OrgUpdateWithoutUsageMetersInput, OrgUncheckedUpdateWithoutUsageMetersInput>
    create: XOR<OrgCreateWithoutUsageMetersInput, OrgUncheckedCreateWithoutUsageMetersInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutUsageMetersInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutUsageMetersInput, OrgUncheckedUpdateWithoutUsageMetersInput>
  }

  export type OrgUpdateWithoutUsageMetersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutUsageMetersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrgCreateWithoutAddonPurchasesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutAddonPurchasesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutAddonPurchasesInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutAddonPurchasesInput, OrgUncheckedCreateWithoutAddonPurchasesInput>
  }

  export type OrgUpsertWithoutAddonPurchasesInput = {
    update: XOR<OrgUpdateWithoutAddonPurchasesInput, OrgUncheckedUpdateWithoutAddonPurchasesInput>
    create: XOR<OrgCreateWithoutAddonPurchasesInput, OrgUncheckedCreateWithoutAddonPurchasesInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutAddonPurchasesInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutAddonPurchasesInput, OrgUncheckedUpdateWithoutAddonPurchasesInput>
  }

  export type OrgUpdateWithoutAddonPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutAddonPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrgCreateWithoutIncidentsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutIncidentsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutIncidentsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutIncidentsInput, OrgUncheckedCreateWithoutIncidentsInput>
  }

  export type OrgUpsertWithoutIncidentsInput = {
    update: XOR<OrgUpdateWithoutIncidentsInput, OrgUncheckedUpdateWithoutIncidentsInput>
    create: XOR<OrgCreateWithoutIncidentsInput, OrgUncheckedCreateWithoutIncidentsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutIncidentsInput, OrgUncheckedUpdateWithoutIncidentsInput>
  }

  export type OrgUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type InvoiceCreateWithoutLineItemsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    org: OrgCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLineItemsInput = {
    id?: string
    orgId: string
    customerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLineItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
  }

  export type InvoiceUpsertWithoutLineItemsInput = {
    update: XOR<InvoiceUpdateWithoutLineItemsInput, InvoiceUncheckedUpdateWithoutLineItemsInput>
    create: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLineItemsInput, InvoiceUncheckedUpdateWithoutLineItemsInput>
  }

  export type InvoiceUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    org?: OrgUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type OrgCreateWithoutNotificationsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutNotificationsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutNotificationsInput, OrgUncheckedCreateWithoutNotificationsInput>
  }

  export type OrgUpsertWithoutNotificationsInput = {
    update: XOR<OrgUpdateWithoutNotificationsInput, OrgUncheckedUpdateWithoutNotificationsInput>
    create: XOR<OrgCreateWithoutNotificationsInput, OrgUncheckedCreateWithoutNotificationsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutNotificationsInput, OrgUncheckedUpdateWithoutNotificationsInput>
  }

  export type OrgUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type PlanPriceCreateWithoutPlanInput = {
    id?: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: TenantPriceOverrideCreateNestedManyWithoutPriceInput
    asDefaultFor?: GlobalMonetizationConfigCreateNestedManyWithoutDefaultPriceInput
    invites?: OnboardingInviteCreateNestedManyWithoutPriceInput
  }

  export type PlanPriceUncheckedCreateWithoutPlanInput = {
    id?: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutPriceInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPriceInput
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PlanPriceCreateOrConnectWithoutPlanInput = {
    where: PlanPriceWhereUniqueInput
    create: XOR<PlanPriceCreateWithoutPlanInput, PlanPriceUncheckedCreateWithoutPlanInput>
  }

  export type PlanPriceCreateManyPlanInputEnvelope = {
    data: PlanPriceCreateManyPlanInput | PlanPriceCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutAppliesToPlanInput = {
    id?: string
    name: string
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invites?: OnboardingInviteCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutAppliesToPlanInput = {
    id?: string
    name: string
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutAppliesToPlanInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutAppliesToPlanInput, OfferUncheckedCreateWithoutAppliesToPlanInput>
  }

  export type OfferCreateManyAppliesToPlanInputEnvelope = {
    data: OfferCreateManyAppliesToPlanInput | OfferCreateManyAppliesToPlanInput[]
    skipDuplicates?: boolean
  }

  export type TenantPriceOverrideCreateWithoutPlanInput = {
    id?: string
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutTenantOverridesInput
    price?: PlanPriceCreateNestedOneWithoutOverridesInput
  }

  export type TenantPriceOverrideUncheckedCreateWithoutPlanInput = {
    id?: string
    orgId: string
    priceId?: string | null
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantPriceOverrideCreateOrConnectWithoutPlanInput = {
    where: TenantPriceOverrideWhereUniqueInput
    create: XOR<TenantPriceOverrideCreateWithoutPlanInput, TenantPriceOverrideUncheckedCreateWithoutPlanInput>
  }

  export type TenantPriceOverrideCreateManyPlanInputEnvelope = {
    data: TenantPriceOverrideCreateManyPlanInput | TenantPriceOverrideCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type GlobalMonetizationConfigCreateWithoutDefaultPlanInput = {
    id?: string
    defaultTrialDays?: number | null
    publicOnboarding?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultPrice?: PlanPriceCreateNestedOneWithoutAsDefaultForInput
  }

  export type GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput = {
    id?: string
    defaultPriceId?: string | null
    defaultTrialDays?: number | null
    publicOnboarding?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalMonetizationConfigCreateOrConnectWithoutDefaultPlanInput = {
    where: GlobalMonetizationConfigWhereUniqueInput
    create: XOR<GlobalMonetizationConfigCreateWithoutDefaultPlanInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput>
  }

  export type GlobalMonetizationConfigCreateManyDefaultPlanInputEnvelope = {
    data: GlobalMonetizationConfigCreateManyDefaultPlanInput | GlobalMonetizationConfigCreateManyDefaultPlanInput[]
    skipDuplicates?: boolean
  }

  export type OnboardingInviteCreateWithoutPlanInput = {
    id?: string
    token: string
    email?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    price?: PlanPriceCreateNestedOneWithoutInvitesInput
    offer?: OfferCreateNestedOneWithoutInvitesInput
    coupon?: CouponCreateNestedOneWithoutInvitesInput
  }

  export type OnboardingInviteUncheckedCreateWithoutPlanInput = {
    id?: string
    token: string
    email?: string | null
    priceId?: string | null
    offerId?: string | null
    couponId?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type OnboardingInviteCreateOrConnectWithoutPlanInput = {
    where: OnboardingInviteWhereUniqueInput
    create: XOR<OnboardingInviteCreateWithoutPlanInput, OnboardingInviteUncheckedCreateWithoutPlanInput>
  }

  export type OnboardingInviteCreateManyPlanInputEnvelope = {
    data: OnboardingInviteCreateManyPlanInput | OnboardingInviteCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanPriceUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanPriceWhereUniqueInput
    update: XOR<PlanPriceUpdateWithoutPlanInput, PlanPriceUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanPriceCreateWithoutPlanInput, PlanPriceUncheckedCreateWithoutPlanInput>
  }

  export type PlanPriceUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanPriceWhereUniqueInput
    data: XOR<PlanPriceUpdateWithoutPlanInput, PlanPriceUncheckedUpdateWithoutPlanInput>
  }

  export type PlanPriceUpdateManyWithWhereWithoutPlanInput = {
    where: PlanPriceScalarWhereInput
    data: XOR<PlanPriceUpdateManyMutationInput, PlanPriceUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanPriceScalarWhereInput = {
    AND?: PlanPriceScalarWhereInput | PlanPriceScalarWhereInput[]
    OR?: PlanPriceScalarWhereInput[]
    NOT?: PlanPriceScalarWhereInput | PlanPriceScalarWhereInput[]
    id?: StringFilter<"PlanPrice"> | string
    planId?: StringFilter<"PlanPrice"> | string
    currency?: StringFilter<"PlanPrice"> | string
    unitAmountCents?: IntFilter<"PlanPrice"> | number
    cadence?: EnumBillingCadenceFilter<"PlanPrice"> | $Enums.BillingCadence
    trialDays?: IntNullableFilter<"PlanPrice"> | number | null
    active?: BoolFilter<"PlanPrice"> | boolean
    stripePriceId?: StringNullableFilter<"PlanPrice"> | string | null
    createdAt?: DateTimeFilter<"PlanPrice"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPrice"> | Date | string
  }

  export type OfferUpsertWithWhereUniqueWithoutAppliesToPlanInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutAppliesToPlanInput, OfferUncheckedUpdateWithoutAppliesToPlanInput>
    create: XOR<OfferCreateWithoutAppliesToPlanInput, OfferUncheckedCreateWithoutAppliesToPlanInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutAppliesToPlanInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutAppliesToPlanInput, OfferUncheckedUpdateWithoutAppliesToPlanInput>
  }

  export type OfferUpdateManyWithWhereWithoutAppliesToPlanInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutAppliesToPlanInput>
  }

  export type OfferScalarWhereInput = {
    AND?: OfferScalarWhereInput | OfferScalarWhereInput[]
    OR?: OfferScalarWhereInput[]
    NOT?: OfferScalarWhereInput | OfferScalarWhereInput[]
    id?: StringFilter<"Offer"> | string
    name?: StringFilter<"Offer"> | string
    percentOff?: IntNullableFilter<"Offer"> | number | null
    amountOffCents?: IntNullableFilter<"Offer"> | number | null
    duration?: StringNullableFilter<"Offer"> | string | null
    durationMonths?: IntNullableFilter<"Offer"> | number | null
    appliesToPlanId?: StringNullableFilter<"Offer"> | string | null
    startsAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    active?: BoolFilter<"Offer"> | boolean
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
  }

  export type TenantPriceOverrideUpsertWithWhereUniqueWithoutPlanInput = {
    where: TenantPriceOverrideWhereUniqueInput
    update: XOR<TenantPriceOverrideUpdateWithoutPlanInput, TenantPriceOverrideUncheckedUpdateWithoutPlanInput>
    create: XOR<TenantPriceOverrideCreateWithoutPlanInput, TenantPriceOverrideUncheckedCreateWithoutPlanInput>
  }

  export type TenantPriceOverrideUpdateWithWhereUniqueWithoutPlanInput = {
    where: TenantPriceOverrideWhereUniqueInput
    data: XOR<TenantPriceOverrideUpdateWithoutPlanInput, TenantPriceOverrideUncheckedUpdateWithoutPlanInput>
  }

  export type TenantPriceOverrideUpdateManyWithWhereWithoutPlanInput = {
    where: TenantPriceOverrideScalarWhereInput
    data: XOR<TenantPriceOverrideUpdateManyMutationInput, TenantPriceOverrideUncheckedUpdateManyWithoutPlanInput>
  }

  export type GlobalMonetizationConfigUpsertWithWhereUniqueWithoutDefaultPlanInput = {
    where: GlobalMonetizationConfigWhereUniqueInput
    update: XOR<GlobalMonetizationConfigUpdateWithoutDefaultPlanInput, GlobalMonetizationConfigUncheckedUpdateWithoutDefaultPlanInput>
    create: XOR<GlobalMonetizationConfigCreateWithoutDefaultPlanInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPlanInput>
  }

  export type GlobalMonetizationConfigUpdateWithWhereUniqueWithoutDefaultPlanInput = {
    where: GlobalMonetizationConfigWhereUniqueInput
    data: XOR<GlobalMonetizationConfigUpdateWithoutDefaultPlanInput, GlobalMonetizationConfigUncheckedUpdateWithoutDefaultPlanInput>
  }

  export type GlobalMonetizationConfigUpdateManyWithWhereWithoutDefaultPlanInput = {
    where: GlobalMonetizationConfigScalarWhereInput
    data: XOR<GlobalMonetizationConfigUpdateManyMutationInput, GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPlanInput>
  }

  export type GlobalMonetizationConfigScalarWhereInput = {
    AND?: GlobalMonetizationConfigScalarWhereInput | GlobalMonetizationConfigScalarWhereInput[]
    OR?: GlobalMonetizationConfigScalarWhereInput[]
    NOT?: GlobalMonetizationConfigScalarWhereInput | GlobalMonetizationConfigScalarWhereInput[]
    id?: StringFilter<"GlobalMonetizationConfig"> | string
    defaultPlanId?: StringNullableFilter<"GlobalMonetizationConfig"> | string | null
    defaultPriceId?: StringNullableFilter<"GlobalMonetizationConfig"> | string | null
    defaultTrialDays?: IntNullableFilter<"GlobalMonetizationConfig"> | number | null
    publicOnboarding?: BoolFilter<"GlobalMonetizationConfig"> | boolean
    createdAt?: DateTimeFilter<"GlobalMonetizationConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalMonetizationConfig"> | Date | string
  }

  export type OnboardingInviteUpsertWithWhereUniqueWithoutPlanInput = {
    where: OnboardingInviteWhereUniqueInput
    update: XOR<OnboardingInviteUpdateWithoutPlanInput, OnboardingInviteUncheckedUpdateWithoutPlanInput>
    create: XOR<OnboardingInviteCreateWithoutPlanInput, OnboardingInviteUncheckedCreateWithoutPlanInput>
  }

  export type OnboardingInviteUpdateWithWhereUniqueWithoutPlanInput = {
    where: OnboardingInviteWhereUniqueInput
    data: XOR<OnboardingInviteUpdateWithoutPlanInput, OnboardingInviteUncheckedUpdateWithoutPlanInput>
  }

  export type OnboardingInviteUpdateManyWithWhereWithoutPlanInput = {
    where: OnboardingInviteScalarWhereInput
    data: XOR<OnboardingInviteUpdateManyMutationInput, OnboardingInviteUncheckedUpdateManyWithoutPlanInput>
  }

  export type OnboardingInviteScalarWhereInput = {
    AND?: OnboardingInviteScalarWhereInput | OnboardingInviteScalarWhereInput[]
    OR?: OnboardingInviteScalarWhereInput[]
    NOT?: OnboardingInviteScalarWhereInput | OnboardingInviteScalarWhereInput[]
    id?: StringFilter<"OnboardingInvite"> | string
    token?: StringFilter<"OnboardingInvite"> | string
    email?: StringNullableFilter<"OnboardingInvite"> | string | null
    planId?: StringNullableFilter<"OnboardingInvite"> | string | null
    priceId?: StringNullableFilter<"OnboardingInvite"> | string | null
    offerId?: StringNullableFilter<"OnboardingInvite"> | string | null
    couponId?: StringNullableFilter<"OnboardingInvite"> | string | null
    trialDays?: IntNullableFilter<"OnboardingInvite"> | number | null
    expiresAt?: DateTimeFilter<"OnboardingInvite"> | Date | string
    usedAt?: DateTimeNullableFilter<"OnboardingInvite"> | Date | string | null
    note?: StringNullableFilter<"OnboardingInvite"> | string | null
    createdAt?: DateTimeFilter<"OnboardingInvite"> | Date | string
  }

  export type TenantPriceOverrideCreateWithoutPriceInput = {
    id?: string
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutTenantOverridesInput
    plan?: PricePlanCreateNestedOneWithoutOverridesInput
  }

  export type TenantPriceOverrideUncheckedCreateWithoutPriceInput = {
    id?: string
    orgId: string
    planId?: string | null
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantPriceOverrideCreateOrConnectWithoutPriceInput = {
    where: TenantPriceOverrideWhereUniqueInput
    create: XOR<TenantPriceOverrideCreateWithoutPriceInput, TenantPriceOverrideUncheckedCreateWithoutPriceInput>
  }

  export type TenantPriceOverrideCreateManyPriceInputEnvelope = {
    data: TenantPriceOverrideCreateManyPriceInput | TenantPriceOverrideCreateManyPriceInput[]
    skipDuplicates?: boolean
  }

  export type GlobalMonetizationConfigCreateWithoutDefaultPriceInput = {
    id?: string
    defaultTrialDays?: number | null
    publicOnboarding?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultPlan?: PricePlanCreateNestedOneWithoutAsDefaultForInput
  }

  export type GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput = {
    id?: string
    defaultPlanId?: string | null
    defaultTrialDays?: number | null
    publicOnboarding?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalMonetizationConfigCreateOrConnectWithoutDefaultPriceInput = {
    where: GlobalMonetizationConfigWhereUniqueInput
    create: XOR<GlobalMonetizationConfigCreateWithoutDefaultPriceInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput>
  }

  export type GlobalMonetizationConfigCreateManyDefaultPriceInputEnvelope = {
    data: GlobalMonetizationConfigCreateManyDefaultPriceInput | GlobalMonetizationConfigCreateManyDefaultPriceInput[]
    skipDuplicates?: boolean
  }

  export type OnboardingInviteCreateWithoutPriceInput = {
    id?: string
    token: string
    email?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    plan?: PricePlanCreateNestedOneWithoutInvitesInput
    offer?: OfferCreateNestedOneWithoutInvitesInput
    coupon?: CouponCreateNestedOneWithoutInvitesInput
  }

  export type OnboardingInviteUncheckedCreateWithoutPriceInput = {
    id?: string
    token: string
    email?: string | null
    planId?: string | null
    offerId?: string | null
    couponId?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type OnboardingInviteCreateOrConnectWithoutPriceInput = {
    where: OnboardingInviteWhereUniqueInput
    create: XOR<OnboardingInviteCreateWithoutPriceInput, OnboardingInviteUncheckedCreateWithoutPriceInput>
  }

  export type OnboardingInviteCreateManyPriceInputEnvelope = {
    data: OnboardingInviteCreateManyPriceInput | OnboardingInviteCreateManyPriceInput[]
    skipDuplicates?: boolean
  }

  export type PricePlanCreateWithoutPricesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: OfferCreateNestedManyWithoutAppliesToPlanInput
    overrides?: TenantPriceOverrideCreateNestedManyWithoutPlanInput
    asDefaultFor?: GlobalMonetizationConfigCreateNestedManyWithoutDefaultPlanInput
    invites?: OnboardingInviteCreateNestedManyWithoutPlanInput
  }

  export type PricePlanUncheckedCreateWithoutPricesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: OfferUncheckedCreateNestedManyWithoutAppliesToPlanInput
    overrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutPlanInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPlanInput
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PricePlanCreateOrConnectWithoutPricesInput = {
    where: PricePlanWhereUniqueInput
    create: XOR<PricePlanCreateWithoutPricesInput, PricePlanUncheckedCreateWithoutPricesInput>
  }

  export type TenantPriceOverrideUpsertWithWhereUniqueWithoutPriceInput = {
    where: TenantPriceOverrideWhereUniqueInput
    update: XOR<TenantPriceOverrideUpdateWithoutPriceInput, TenantPriceOverrideUncheckedUpdateWithoutPriceInput>
    create: XOR<TenantPriceOverrideCreateWithoutPriceInput, TenantPriceOverrideUncheckedCreateWithoutPriceInput>
  }

  export type TenantPriceOverrideUpdateWithWhereUniqueWithoutPriceInput = {
    where: TenantPriceOverrideWhereUniqueInput
    data: XOR<TenantPriceOverrideUpdateWithoutPriceInput, TenantPriceOverrideUncheckedUpdateWithoutPriceInput>
  }

  export type TenantPriceOverrideUpdateManyWithWhereWithoutPriceInput = {
    where: TenantPriceOverrideScalarWhereInput
    data: XOR<TenantPriceOverrideUpdateManyMutationInput, TenantPriceOverrideUncheckedUpdateManyWithoutPriceInput>
  }

  export type GlobalMonetizationConfigUpsertWithWhereUniqueWithoutDefaultPriceInput = {
    where: GlobalMonetizationConfigWhereUniqueInput
    update: XOR<GlobalMonetizationConfigUpdateWithoutDefaultPriceInput, GlobalMonetizationConfigUncheckedUpdateWithoutDefaultPriceInput>
    create: XOR<GlobalMonetizationConfigCreateWithoutDefaultPriceInput, GlobalMonetizationConfigUncheckedCreateWithoutDefaultPriceInput>
  }

  export type GlobalMonetizationConfigUpdateWithWhereUniqueWithoutDefaultPriceInput = {
    where: GlobalMonetizationConfigWhereUniqueInput
    data: XOR<GlobalMonetizationConfigUpdateWithoutDefaultPriceInput, GlobalMonetizationConfigUncheckedUpdateWithoutDefaultPriceInput>
  }

  export type GlobalMonetizationConfigUpdateManyWithWhereWithoutDefaultPriceInput = {
    where: GlobalMonetizationConfigScalarWhereInput
    data: XOR<GlobalMonetizationConfigUpdateManyMutationInput, GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPriceInput>
  }

  export type OnboardingInviteUpsertWithWhereUniqueWithoutPriceInput = {
    where: OnboardingInviteWhereUniqueInput
    update: XOR<OnboardingInviteUpdateWithoutPriceInput, OnboardingInviteUncheckedUpdateWithoutPriceInput>
    create: XOR<OnboardingInviteCreateWithoutPriceInput, OnboardingInviteUncheckedCreateWithoutPriceInput>
  }

  export type OnboardingInviteUpdateWithWhereUniqueWithoutPriceInput = {
    where: OnboardingInviteWhereUniqueInput
    data: XOR<OnboardingInviteUpdateWithoutPriceInput, OnboardingInviteUncheckedUpdateWithoutPriceInput>
  }

  export type OnboardingInviteUpdateManyWithWhereWithoutPriceInput = {
    where: OnboardingInviteScalarWhereInput
    data: XOR<OnboardingInviteUpdateManyMutationInput, OnboardingInviteUncheckedUpdateManyWithoutPriceInput>
  }

  export type PricePlanUpsertWithoutPricesInput = {
    update: XOR<PricePlanUpdateWithoutPricesInput, PricePlanUncheckedUpdateWithoutPricesInput>
    create: XOR<PricePlanCreateWithoutPricesInput, PricePlanUncheckedCreateWithoutPricesInput>
    where?: PricePlanWhereInput
  }

  export type PricePlanUpdateToOneWithWhereWithoutPricesInput = {
    where?: PricePlanWhereInput
    data: XOR<PricePlanUpdateWithoutPricesInput, PricePlanUncheckedUpdateWithoutPricesInput>
  }

  export type PricePlanUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: OfferUpdateManyWithoutAppliesToPlanNestedInput
    overrides?: TenantPriceOverrideUpdateManyWithoutPlanNestedInput
    asDefaultFor?: GlobalMonetizationConfigUpdateManyWithoutDefaultPlanNestedInput
    invites?: OnboardingInviteUpdateManyWithoutPlanNestedInput
  }

  export type PricePlanUncheckedUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: OfferUncheckedUpdateManyWithoutAppliesToPlanNestedInput
    overrides?: TenantPriceOverrideUncheckedUpdateManyWithoutPlanNestedInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPlanNestedInput
    invites?: OnboardingInviteUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PricePlanCreateWithoutOffersInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PlanPriceCreateNestedManyWithoutPlanInput
    overrides?: TenantPriceOverrideCreateNestedManyWithoutPlanInput
    asDefaultFor?: GlobalMonetizationConfigCreateNestedManyWithoutDefaultPlanInput
    invites?: OnboardingInviteCreateNestedManyWithoutPlanInput
  }

  export type PricePlanUncheckedCreateWithoutOffersInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PlanPriceUncheckedCreateNestedManyWithoutPlanInput
    overrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutPlanInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPlanInput
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PricePlanCreateOrConnectWithoutOffersInput = {
    where: PricePlanWhereUniqueInput
    create: XOR<PricePlanCreateWithoutOffersInput, PricePlanUncheckedCreateWithoutOffersInput>
  }

  export type OnboardingInviteCreateWithoutOfferInput = {
    id?: string
    token: string
    email?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    plan?: PricePlanCreateNestedOneWithoutInvitesInput
    price?: PlanPriceCreateNestedOneWithoutInvitesInput
    coupon?: CouponCreateNestedOneWithoutInvitesInput
  }

  export type OnboardingInviteUncheckedCreateWithoutOfferInput = {
    id?: string
    token: string
    email?: string | null
    planId?: string | null
    priceId?: string | null
    couponId?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type OnboardingInviteCreateOrConnectWithoutOfferInput = {
    where: OnboardingInviteWhereUniqueInput
    create: XOR<OnboardingInviteCreateWithoutOfferInput, OnboardingInviteUncheckedCreateWithoutOfferInput>
  }

  export type OnboardingInviteCreateManyOfferInputEnvelope = {
    data: OnboardingInviteCreateManyOfferInput | OnboardingInviteCreateManyOfferInput[]
    skipDuplicates?: boolean
  }

  export type PricePlanUpsertWithoutOffersInput = {
    update: XOR<PricePlanUpdateWithoutOffersInput, PricePlanUncheckedUpdateWithoutOffersInput>
    create: XOR<PricePlanCreateWithoutOffersInput, PricePlanUncheckedCreateWithoutOffersInput>
    where?: PricePlanWhereInput
  }

  export type PricePlanUpdateToOneWithWhereWithoutOffersInput = {
    where?: PricePlanWhereInput
    data: XOR<PricePlanUpdateWithoutOffersInput, PricePlanUncheckedUpdateWithoutOffersInput>
  }

  export type PricePlanUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PlanPriceUpdateManyWithoutPlanNestedInput
    overrides?: TenantPriceOverrideUpdateManyWithoutPlanNestedInput
    asDefaultFor?: GlobalMonetizationConfigUpdateManyWithoutDefaultPlanNestedInput
    invites?: OnboardingInviteUpdateManyWithoutPlanNestedInput
  }

  export type PricePlanUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PlanPriceUncheckedUpdateManyWithoutPlanNestedInput
    overrides?: TenantPriceOverrideUncheckedUpdateManyWithoutPlanNestedInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPlanNestedInput
    invites?: OnboardingInviteUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type OnboardingInviteUpsertWithWhereUniqueWithoutOfferInput = {
    where: OnboardingInviteWhereUniqueInput
    update: XOR<OnboardingInviteUpdateWithoutOfferInput, OnboardingInviteUncheckedUpdateWithoutOfferInput>
    create: XOR<OnboardingInviteCreateWithoutOfferInput, OnboardingInviteUncheckedCreateWithoutOfferInput>
  }

  export type OnboardingInviteUpdateWithWhereUniqueWithoutOfferInput = {
    where: OnboardingInviteWhereUniqueInput
    data: XOR<OnboardingInviteUpdateWithoutOfferInput, OnboardingInviteUncheckedUpdateWithoutOfferInput>
  }

  export type OnboardingInviteUpdateManyWithWhereWithoutOfferInput = {
    where: OnboardingInviteScalarWhereInput
    data: XOR<OnboardingInviteUpdateManyMutationInput, OnboardingInviteUncheckedUpdateManyWithoutOfferInput>
  }

  export type OnboardingInviteCreateWithoutCouponInput = {
    id?: string
    token: string
    email?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    plan?: PricePlanCreateNestedOneWithoutInvitesInput
    price?: PlanPriceCreateNestedOneWithoutInvitesInput
    offer?: OfferCreateNestedOneWithoutInvitesInput
  }

  export type OnboardingInviteUncheckedCreateWithoutCouponInput = {
    id?: string
    token: string
    email?: string | null
    planId?: string | null
    priceId?: string | null
    offerId?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type OnboardingInviteCreateOrConnectWithoutCouponInput = {
    where: OnboardingInviteWhereUniqueInput
    create: XOR<OnboardingInviteCreateWithoutCouponInput, OnboardingInviteUncheckedCreateWithoutCouponInput>
  }

  export type OnboardingInviteCreateManyCouponInputEnvelope = {
    data: OnboardingInviteCreateManyCouponInput | OnboardingInviteCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type OnboardingInviteUpsertWithWhereUniqueWithoutCouponInput = {
    where: OnboardingInviteWhereUniqueInput
    update: XOR<OnboardingInviteUpdateWithoutCouponInput, OnboardingInviteUncheckedUpdateWithoutCouponInput>
    create: XOR<OnboardingInviteCreateWithoutCouponInput, OnboardingInviteUncheckedCreateWithoutCouponInput>
  }

  export type OnboardingInviteUpdateWithWhereUniqueWithoutCouponInput = {
    where: OnboardingInviteWhereUniqueInput
    data: XOR<OnboardingInviteUpdateWithoutCouponInput, OnboardingInviteUncheckedUpdateWithoutCouponInput>
  }

  export type OnboardingInviteUpdateManyWithWhereWithoutCouponInput = {
    where: OnboardingInviteScalarWhereInput
    data: XOR<OnboardingInviteUpdateManyMutationInput, OnboardingInviteUncheckedUpdateManyWithoutCouponInput>
  }

  export type OrgCreateWithoutTenantOverridesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutTenantOverridesInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutTenantOverridesInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutTenantOverridesInput, OrgUncheckedCreateWithoutTenantOverridesInput>
  }

  export type PricePlanCreateWithoutOverridesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PlanPriceCreateNestedManyWithoutPlanInput
    offers?: OfferCreateNestedManyWithoutAppliesToPlanInput
    asDefaultFor?: GlobalMonetizationConfigCreateNestedManyWithoutDefaultPlanInput
    invites?: OnboardingInviteCreateNestedManyWithoutPlanInput
  }

  export type PricePlanUncheckedCreateWithoutOverridesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PlanPriceUncheckedCreateNestedManyWithoutPlanInput
    offers?: OfferUncheckedCreateNestedManyWithoutAppliesToPlanInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPlanInput
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PricePlanCreateOrConnectWithoutOverridesInput = {
    where: PricePlanWhereUniqueInput
    create: XOR<PricePlanCreateWithoutOverridesInput, PricePlanUncheckedCreateWithoutOverridesInput>
  }

  export type PlanPriceCreateWithoutOverridesInput = {
    id?: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asDefaultFor?: GlobalMonetizationConfigCreateNestedManyWithoutDefaultPriceInput
    invites?: OnboardingInviteCreateNestedManyWithoutPriceInput
    plan: PricePlanCreateNestedOneWithoutPricesInput
  }

  export type PlanPriceUncheckedCreateWithoutOverridesInput = {
    id?: string
    planId: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asDefaultFor?: GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPriceInput
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PlanPriceCreateOrConnectWithoutOverridesInput = {
    where: PlanPriceWhereUniqueInput
    create: XOR<PlanPriceCreateWithoutOverridesInput, PlanPriceUncheckedCreateWithoutOverridesInput>
  }

  export type OrgUpsertWithoutTenantOverridesInput = {
    update: XOR<OrgUpdateWithoutTenantOverridesInput, OrgUncheckedUpdateWithoutTenantOverridesInput>
    create: XOR<OrgCreateWithoutTenantOverridesInput, OrgUncheckedCreateWithoutTenantOverridesInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutTenantOverridesInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutTenantOverridesInput, OrgUncheckedUpdateWithoutTenantOverridesInput>
  }

  export type OrgUpdateWithoutTenantOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutTenantOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type PricePlanUpsertWithoutOverridesInput = {
    update: XOR<PricePlanUpdateWithoutOverridesInput, PricePlanUncheckedUpdateWithoutOverridesInput>
    create: XOR<PricePlanCreateWithoutOverridesInput, PricePlanUncheckedCreateWithoutOverridesInput>
    where?: PricePlanWhereInput
  }

  export type PricePlanUpdateToOneWithWhereWithoutOverridesInput = {
    where?: PricePlanWhereInput
    data: XOR<PricePlanUpdateWithoutOverridesInput, PricePlanUncheckedUpdateWithoutOverridesInput>
  }

  export type PricePlanUpdateWithoutOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PlanPriceUpdateManyWithoutPlanNestedInput
    offers?: OfferUpdateManyWithoutAppliesToPlanNestedInput
    asDefaultFor?: GlobalMonetizationConfigUpdateManyWithoutDefaultPlanNestedInput
    invites?: OnboardingInviteUpdateManyWithoutPlanNestedInput
  }

  export type PricePlanUncheckedUpdateWithoutOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PlanPriceUncheckedUpdateManyWithoutPlanNestedInput
    offers?: OfferUncheckedUpdateManyWithoutAppliesToPlanNestedInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPlanNestedInput
    invites?: OnboardingInviteUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanPriceUpsertWithoutOverridesInput = {
    update: XOR<PlanPriceUpdateWithoutOverridesInput, PlanPriceUncheckedUpdateWithoutOverridesInput>
    create: XOR<PlanPriceCreateWithoutOverridesInput, PlanPriceUncheckedCreateWithoutOverridesInput>
    where?: PlanPriceWhereInput
  }

  export type PlanPriceUpdateToOneWithWhereWithoutOverridesInput = {
    where?: PlanPriceWhereInput
    data: XOR<PlanPriceUpdateWithoutOverridesInput, PlanPriceUncheckedUpdateWithoutOverridesInput>
  }

  export type PlanPriceUpdateWithoutOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asDefaultFor?: GlobalMonetizationConfigUpdateManyWithoutDefaultPriceNestedInput
    invites?: OnboardingInviteUpdateManyWithoutPriceNestedInput
    plan?: PricePlanUpdateOneRequiredWithoutPricesNestedInput
  }

  export type PlanPriceUncheckedUpdateWithoutOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asDefaultFor?: GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPriceNestedInput
    invites?: OnboardingInviteUncheckedUpdateManyWithoutPriceNestedInput
  }

  export type PricePlanCreateWithoutAsDefaultForInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PlanPriceCreateNestedManyWithoutPlanInput
    offers?: OfferCreateNestedManyWithoutAppliesToPlanInput
    overrides?: TenantPriceOverrideCreateNestedManyWithoutPlanInput
    invites?: OnboardingInviteCreateNestedManyWithoutPlanInput
  }

  export type PricePlanUncheckedCreateWithoutAsDefaultForInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PlanPriceUncheckedCreateNestedManyWithoutPlanInput
    offers?: OfferUncheckedCreateNestedManyWithoutAppliesToPlanInput
    overrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutPlanInput
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PricePlanCreateOrConnectWithoutAsDefaultForInput = {
    where: PricePlanWhereUniqueInput
    create: XOR<PricePlanCreateWithoutAsDefaultForInput, PricePlanUncheckedCreateWithoutAsDefaultForInput>
  }

  export type PlanPriceCreateWithoutAsDefaultForInput = {
    id?: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: TenantPriceOverrideCreateNestedManyWithoutPriceInput
    invites?: OnboardingInviteCreateNestedManyWithoutPriceInput
    plan: PricePlanCreateNestedOneWithoutPricesInput
  }

  export type PlanPriceUncheckedCreateWithoutAsDefaultForInput = {
    id?: string
    planId: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutPriceInput
    invites?: OnboardingInviteUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PlanPriceCreateOrConnectWithoutAsDefaultForInput = {
    where: PlanPriceWhereUniqueInput
    create: XOR<PlanPriceCreateWithoutAsDefaultForInput, PlanPriceUncheckedCreateWithoutAsDefaultForInput>
  }

  export type PricePlanUpsertWithoutAsDefaultForInput = {
    update: XOR<PricePlanUpdateWithoutAsDefaultForInput, PricePlanUncheckedUpdateWithoutAsDefaultForInput>
    create: XOR<PricePlanCreateWithoutAsDefaultForInput, PricePlanUncheckedCreateWithoutAsDefaultForInput>
    where?: PricePlanWhereInput
  }

  export type PricePlanUpdateToOneWithWhereWithoutAsDefaultForInput = {
    where?: PricePlanWhereInput
    data: XOR<PricePlanUpdateWithoutAsDefaultForInput, PricePlanUncheckedUpdateWithoutAsDefaultForInput>
  }

  export type PricePlanUpdateWithoutAsDefaultForInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PlanPriceUpdateManyWithoutPlanNestedInput
    offers?: OfferUpdateManyWithoutAppliesToPlanNestedInput
    overrides?: TenantPriceOverrideUpdateManyWithoutPlanNestedInput
    invites?: OnboardingInviteUpdateManyWithoutPlanNestedInput
  }

  export type PricePlanUncheckedUpdateWithoutAsDefaultForInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PlanPriceUncheckedUpdateManyWithoutPlanNestedInput
    offers?: OfferUncheckedUpdateManyWithoutAppliesToPlanNestedInput
    overrides?: TenantPriceOverrideUncheckedUpdateManyWithoutPlanNestedInput
    invites?: OnboardingInviteUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanPriceUpsertWithoutAsDefaultForInput = {
    update: XOR<PlanPriceUpdateWithoutAsDefaultForInput, PlanPriceUncheckedUpdateWithoutAsDefaultForInput>
    create: XOR<PlanPriceCreateWithoutAsDefaultForInput, PlanPriceUncheckedCreateWithoutAsDefaultForInput>
    where?: PlanPriceWhereInput
  }

  export type PlanPriceUpdateToOneWithWhereWithoutAsDefaultForInput = {
    where?: PlanPriceWhereInput
    data: XOR<PlanPriceUpdateWithoutAsDefaultForInput, PlanPriceUncheckedUpdateWithoutAsDefaultForInput>
  }

  export type PlanPriceUpdateWithoutAsDefaultForInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: TenantPriceOverrideUpdateManyWithoutPriceNestedInput
    invites?: OnboardingInviteUpdateManyWithoutPriceNestedInput
    plan?: PricePlanUpdateOneRequiredWithoutPricesNestedInput
  }

  export type PlanPriceUncheckedUpdateWithoutAsDefaultForInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: TenantPriceOverrideUncheckedUpdateManyWithoutPriceNestedInput
    invites?: OnboardingInviteUncheckedUpdateManyWithoutPriceNestedInput
  }

  export type PricePlanCreateWithoutInvitesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PlanPriceCreateNestedManyWithoutPlanInput
    offers?: OfferCreateNestedManyWithoutAppliesToPlanInput
    overrides?: TenantPriceOverrideCreateNestedManyWithoutPlanInput
    asDefaultFor?: GlobalMonetizationConfigCreateNestedManyWithoutDefaultPlanInput
  }

  export type PricePlanUncheckedCreateWithoutInvitesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PlanPriceUncheckedCreateNestedManyWithoutPlanInput
    offers?: OfferUncheckedCreateNestedManyWithoutAppliesToPlanInput
    overrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutPlanInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPlanInput
  }

  export type PricePlanCreateOrConnectWithoutInvitesInput = {
    where: PricePlanWhereUniqueInput
    create: XOR<PricePlanCreateWithoutInvitesInput, PricePlanUncheckedCreateWithoutInvitesInput>
  }

  export type PlanPriceCreateWithoutInvitesInput = {
    id?: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: TenantPriceOverrideCreateNestedManyWithoutPriceInput
    asDefaultFor?: GlobalMonetizationConfigCreateNestedManyWithoutDefaultPriceInput
    plan: PricePlanCreateNestedOneWithoutPricesInput
  }

  export type PlanPriceUncheckedCreateWithoutInvitesInput = {
    id?: string
    planId: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutPriceInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedCreateNestedManyWithoutDefaultPriceInput
  }

  export type PlanPriceCreateOrConnectWithoutInvitesInput = {
    where: PlanPriceWhereUniqueInput
    create: XOR<PlanPriceCreateWithoutInvitesInput, PlanPriceUncheckedCreateWithoutInvitesInput>
  }

  export type OfferCreateWithoutInvitesInput = {
    id?: string
    name: string
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appliesToPlan?: PricePlanCreateNestedOneWithoutOffersInput
  }

  export type OfferUncheckedCreateWithoutInvitesInput = {
    id?: string
    name: string
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    appliesToPlanId?: string | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferCreateOrConnectWithoutInvitesInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutInvitesInput, OfferUncheckedCreateWithoutInvitesInput>
  }

  export type CouponCreateWithoutInvitesInput = {
    id?: string
    code: string
    name?: string | null
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxRedemptions?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUncheckedCreateWithoutInvitesInput = {
    id?: string
    code: string
    name?: string | null
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxRedemptions?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponCreateOrConnectWithoutInvitesInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutInvitesInput, CouponUncheckedCreateWithoutInvitesInput>
  }

  export type PricePlanUpsertWithoutInvitesInput = {
    update: XOR<PricePlanUpdateWithoutInvitesInput, PricePlanUncheckedUpdateWithoutInvitesInput>
    create: XOR<PricePlanCreateWithoutInvitesInput, PricePlanUncheckedCreateWithoutInvitesInput>
    where?: PricePlanWhereInput
  }

  export type PricePlanUpdateToOneWithWhereWithoutInvitesInput = {
    where?: PricePlanWhereInput
    data: XOR<PricePlanUpdateWithoutInvitesInput, PricePlanUncheckedUpdateWithoutInvitesInput>
  }

  export type PricePlanUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PlanPriceUpdateManyWithoutPlanNestedInput
    offers?: OfferUpdateManyWithoutAppliesToPlanNestedInput
    overrides?: TenantPriceOverrideUpdateManyWithoutPlanNestedInput
    asDefaultFor?: GlobalMonetizationConfigUpdateManyWithoutDefaultPlanNestedInput
  }

  export type PricePlanUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PlanPriceUncheckedUpdateManyWithoutPlanNestedInput
    offers?: OfferUncheckedUpdateManyWithoutAppliesToPlanNestedInput
    overrides?: TenantPriceOverrideUncheckedUpdateManyWithoutPlanNestedInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPlanNestedInput
  }

  export type PlanPriceUpsertWithoutInvitesInput = {
    update: XOR<PlanPriceUpdateWithoutInvitesInput, PlanPriceUncheckedUpdateWithoutInvitesInput>
    create: XOR<PlanPriceCreateWithoutInvitesInput, PlanPriceUncheckedCreateWithoutInvitesInput>
    where?: PlanPriceWhereInput
  }

  export type PlanPriceUpdateToOneWithWhereWithoutInvitesInput = {
    where?: PlanPriceWhereInput
    data: XOR<PlanPriceUpdateWithoutInvitesInput, PlanPriceUncheckedUpdateWithoutInvitesInput>
  }

  export type PlanPriceUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: TenantPriceOverrideUpdateManyWithoutPriceNestedInput
    asDefaultFor?: GlobalMonetizationConfigUpdateManyWithoutDefaultPriceNestedInput
    plan?: PricePlanUpdateOneRequiredWithoutPricesNestedInput
  }

  export type PlanPriceUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: TenantPriceOverrideUncheckedUpdateManyWithoutPriceNestedInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPriceNestedInput
  }

  export type OfferUpsertWithoutInvitesInput = {
    update: XOR<OfferUpdateWithoutInvitesInput, OfferUncheckedUpdateWithoutInvitesInput>
    create: XOR<OfferCreateWithoutInvitesInput, OfferUncheckedCreateWithoutInvitesInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutInvitesInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutInvitesInput, OfferUncheckedUpdateWithoutInvitesInput>
  }

  export type OfferUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appliesToPlan?: PricePlanUpdateOneWithoutOffersNestedInput
  }

  export type OfferUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    appliesToPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUpsertWithoutInvitesInput = {
    update: XOR<CouponUpdateWithoutInvitesInput, CouponUncheckedUpdateWithoutInvitesInput>
    create: XOR<CouponCreateWithoutInvitesInput, CouponUncheckedCreateWithoutInvitesInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutInvitesInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutInvitesInput, CouponUncheckedUpdateWithoutInvitesInput>
  }

  export type CouponUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgCreateWithoutImportJobsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutImportJobsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importMappings?: ImportMappingUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutImportJobsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutImportJobsInput, OrgUncheckedCreateWithoutImportJobsInput>
  }

  export type UserCreateWithoutImportJobsInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    org: OrgCreateNestedOneWithoutUsersInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutImportJobsInput = {
    id?: string
    orgId: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: UserRecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    breakglassAccount?: UserBreakglassAccountUncheckedCreateNestedOneWithoutUserInput
    securityQuestions?: UserSecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: UserLoginHistoryUncheckedCreateNestedManyWithoutUserInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutImportJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImportJobsInput, UserUncheckedCreateWithoutImportJobsInput>
  }

  export type ImportMappingCreateWithoutJobsInput = {
    id?: string
    name: string
    entityType: $Enums.ImportEntityType
    sourceFormat: string
    fieldMappings: JsonNullValueInput | InputJsonValue
    transformRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isTemplate?: boolean
    useCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutImportMappingsInput
  }

  export type ImportMappingUncheckedCreateWithoutJobsInput = {
    id?: string
    orgId: string
    name: string
    entityType: $Enums.ImportEntityType
    sourceFormat: string
    fieldMappings: JsonNullValueInput | InputJsonValue
    transformRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isTemplate?: boolean
    useCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportMappingCreateOrConnectWithoutJobsInput = {
    where: ImportMappingWhereUniqueInput
    create: XOR<ImportMappingCreateWithoutJobsInput, ImportMappingUncheckedCreateWithoutJobsInput>
  }

  export type ImportErrorCreateWithoutImportJobInput = {
    id?: string
    rowNumber: number
    fieldName?: string | null
    errorType: string
    errorMessage: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ImportErrorUncheckedCreateWithoutImportJobInput = {
    id?: string
    rowNumber: number
    fieldName?: string | null
    errorType: string
    errorMessage: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ImportErrorCreateOrConnectWithoutImportJobInput = {
    where: ImportErrorWhereUniqueInput
    create: XOR<ImportErrorCreateWithoutImportJobInput, ImportErrorUncheckedCreateWithoutImportJobInput>
  }

  export type ImportErrorCreateManyImportJobInputEnvelope = {
    data: ImportErrorCreateManyImportJobInput | ImportErrorCreateManyImportJobInput[]
    skipDuplicates?: boolean
  }

  export type OrgUpsertWithoutImportJobsInput = {
    update: XOR<OrgUpdateWithoutImportJobsInput, OrgUncheckedUpdateWithoutImportJobsInput>
    create: XOR<OrgCreateWithoutImportJobsInput, OrgUncheckedCreateWithoutImportJobsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutImportJobsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutImportJobsInput, OrgUncheckedUpdateWithoutImportJobsInput>
  }

  export type OrgUpdateWithoutImportJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutImportJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importMappings?: ImportMappingUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type UserUpsertWithoutImportJobsInput = {
    update: XOR<UserUpdateWithoutImportJobsInput, UserUncheckedUpdateWithoutImportJobsInput>
    create: XOR<UserCreateWithoutImportJobsInput, UserUncheckedCreateWithoutImportJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutImportJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutImportJobsInput, UserUncheckedUpdateWithoutImportJobsInput>
  }

  export type UserUpdateWithoutImportJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    org?: OrgUpdateOneRequiredWithoutUsersNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutImportJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUncheckedUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ImportMappingUpsertWithoutJobsInput = {
    update: XOR<ImportMappingUpdateWithoutJobsInput, ImportMappingUncheckedUpdateWithoutJobsInput>
    create: XOR<ImportMappingCreateWithoutJobsInput, ImportMappingUncheckedCreateWithoutJobsInput>
    where?: ImportMappingWhereInput
  }

  export type ImportMappingUpdateToOneWithWhereWithoutJobsInput = {
    where?: ImportMappingWhereInput
    data: XOR<ImportMappingUpdateWithoutJobsInput, ImportMappingUncheckedUpdateWithoutJobsInput>
  }

  export type ImportMappingUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    sourceFormat?: StringFieldUpdateOperationsInput | string
    fieldMappings?: JsonNullValueInput | InputJsonValue
    transformRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    useCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutImportMappingsNestedInput
  }

  export type ImportMappingUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    sourceFormat?: StringFieldUpdateOperationsInput | string
    fieldMappings?: JsonNullValueInput | InputJsonValue
    transformRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    useCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportErrorUpsertWithWhereUniqueWithoutImportJobInput = {
    where: ImportErrorWhereUniqueInput
    update: XOR<ImportErrorUpdateWithoutImportJobInput, ImportErrorUncheckedUpdateWithoutImportJobInput>
    create: XOR<ImportErrorCreateWithoutImportJobInput, ImportErrorUncheckedCreateWithoutImportJobInput>
  }

  export type ImportErrorUpdateWithWhereUniqueWithoutImportJobInput = {
    where: ImportErrorWhereUniqueInput
    data: XOR<ImportErrorUpdateWithoutImportJobInput, ImportErrorUncheckedUpdateWithoutImportJobInput>
  }

  export type ImportErrorUpdateManyWithWhereWithoutImportJobInput = {
    where: ImportErrorScalarWhereInput
    data: XOR<ImportErrorUpdateManyMutationInput, ImportErrorUncheckedUpdateManyWithoutImportJobInput>
  }

  export type ImportErrorScalarWhereInput = {
    AND?: ImportErrorScalarWhereInput | ImportErrorScalarWhereInput[]
    OR?: ImportErrorScalarWhereInput[]
    NOT?: ImportErrorScalarWhereInput | ImportErrorScalarWhereInput[]
    id?: StringFilter<"ImportError"> | string
    importJobId?: StringFilter<"ImportError"> | string
    rowNumber?: IntFilter<"ImportError"> | number
    fieldName?: StringNullableFilter<"ImportError"> | string | null
    errorType?: StringFilter<"ImportError"> | string
    errorMessage?: StringFilter<"ImportError"> | string
    rawData?: JsonNullableFilter<"ImportError">
    createdAt?: DateTimeFilter<"ImportError"> | Date | string
  }

  export type OrgCreateWithoutImportMappingsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerCreateNestedManyWithoutOrgInput
    customers?: CustomerCreateNestedManyWithoutOrgInput
    invoices?: InvoiceCreateNestedManyWithoutOrgInput
    jobs?: JobCreateNestedManyWithoutOrgInput
    leads?: LeadCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityCreateNestedManyWithoutOrgInput
    payments?: PaymentCreateNestedManyWithoutOrgInput
    referrals?: ReferralCreateNestedManyWithoutOrgInput
    rfps?: RfpCreateNestedManyWithoutOrgInput
    users?: UserCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryCreateNestedManyWithoutOrgInput
    activities?: ActivityCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideCreateNestedManyWithoutOrgInput
    incidents?: IncidentCreateNestedManyWithoutOrgInput
    notifications?: NotificationCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobCreateNestedManyWithoutOrgInput
  }

  export type OrgUncheckedCreateWithoutImportMappingsInput = {
    id?: string
    name: string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiMonthlyBudgetCents?: number
    aiCreditBalance?: number
    aiPlan?: $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrgInput
    ledger?: BillingLedgerUncheckedCreateNestedManyWithoutOrgInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrgInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrgInput
    jobs?: JobUncheckedCreateNestedManyWithoutOrgInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrgInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutOrgInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrgInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutOrgInput
    rfps?: RfpUncheckedCreateNestedManyWithoutOrgInput
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    rbacRoles?: RbacRoleUncheckedCreateNestedManyWithoutOrgInput
    rbacUserRoles?: RbacUserRoleUncheckedCreateNestedManyWithoutOrgInput
    leadInvoices?: LeadInvoiceUncheckedCreateNestedManyWithoutOrgInput
    pricingPlan?: PricingPlanUncheckedCreateNestedOneWithoutOrgInput
    aiUsageEvents?: AiUsageEventUncheckedCreateNestedManyWithoutOrgInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedCreateNestedManyWithoutOrgInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOrgInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutOrgInput
    usageMeters?: UsageMeterUncheckedCreateNestedManyWithoutOrgInput
    addonPurchases?: AddonPurchaseUncheckedCreateNestedManyWithoutOrgInput
    tenantOverrides?: TenantPriceOverrideUncheckedCreateNestedManyWithoutOrgInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrgInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrgInput
    importJobs?: ImportJobUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrgCreateOrConnectWithoutImportMappingsInput = {
    where: OrgWhereUniqueInput
    create: XOR<OrgCreateWithoutImportMappingsInput, OrgUncheckedCreateWithoutImportMappingsInput>
  }

  export type ImportJobCreateWithoutMappingInput = {
    id?: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutImportJobsInput
    user: UserCreateNestedOneWithoutImportJobsInput
    errors?: ImportErrorCreateNestedManyWithoutImportJobInput
  }

  export type ImportJobUncheckedCreateWithoutMappingInput = {
    id?: string
    orgId: string
    userId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    errors?: ImportErrorUncheckedCreateNestedManyWithoutImportJobInput
  }

  export type ImportJobCreateOrConnectWithoutMappingInput = {
    where: ImportJobWhereUniqueInput
    create: XOR<ImportJobCreateWithoutMappingInput, ImportJobUncheckedCreateWithoutMappingInput>
  }

  export type ImportJobCreateManyMappingInputEnvelope = {
    data: ImportJobCreateManyMappingInput | ImportJobCreateManyMappingInput[]
    skipDuplicates?: boolean
  }

  export type OrgUpsertWithoutImportMappingsInput = {
    update: XOR<OrgUpdateWithoutImportMappingsInput, OrgUncheckedUpdateWithoutImportMappingsInput>
    create: XOR<OrgCreateWithoutImportMappingsInput, OrgUncheckedCreateWithoutImportMappingsInput>
    where?: OrgWhereInput
  }

  export type OrgUpdateToOneWithWhereWithoutImportMappingsInput = {
    where?: OrgWhereInput
    data: XOR<OrgUpdateWithoutImportMappingsInput, OrgUncheckedUpdateWithoutImportMappingsInput>
  }

  export type OrgUpdateWithoutImportMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUpdateManyWithoutOrgNestedInput
    customers?: CustomerUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUpdateManyWithoutOrgNestedInput
    jobs?: JobUpdateManyWithoutOrgNestedInput
    leads?: LeadUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUpdateManyWithoutOrgNestedInput
    payments?: PaymentUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUpdateManyWithoutOrgNestedInput
    rfps?: RfpUpdateManyWithoutOrgNestedInput
    users?: UserUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUpdateManyWithoutOrgNestedInput
    activities?: ActivityUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUpdateManyWithoutOrgNestedInput
  }

  export type OrgUncheckedUpdateWithoutImportMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    featureFlags?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiMonthlyBudgetCents?: IntFieldUpdateOperationsInput | number
    aiCreditBalance?: IntFieldUpdateOperationsInput | number
    aiPlan?: EnumAiPlanFieldUpdateOperationsInput | $Enums.AiPlan
    aiAlerts?: JsonNullValueInput | InputJsonValue
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brandConfig?: NullableJsonNullValueInput | InputJsonValue
    settingsJson?: NullableJsonNullValueInput | InputJsonValue
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrgNestedInput
    ledger?: BillingLedgerUncheckedUpdateManyWithoutOrgNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrgNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrgNestedInput
    jobs?: JobUncheckedUpdateManyWithoutOrgNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrgNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutOrgNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrgNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutOrgNestedInput
    rfps?: RfpUncheckedUpdateManyWithoutOrgNestedInput
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    rbacRoles?: RbacRoleUncheckedUpdateManyWithoutOrgNestedInput
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutOrgNestedInput
    leadInvoices?: LeadInvoiceUncheckedUpdateManyWithoutOrgNestedInput
    pricingPlan?: PricingPlanUncheckedUpdateOneWithoutOrgNestedInput
    aiUsageEvents?: AiUsageEventUncheckedUpdateManyWithoutOrgNestedInput
    aiMonthlySummaries?: AiMonthlySummaryUncheckedUpdateManyWithoutOrgNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOrgNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutOrgNestedInput
    usageMeters?: UsageMeterUncheckedUpdateManyWithoutOrgNestedInput
    addonPurchases?: AddonPurchaseUncheckedUpdateManyWithoutOrgNestedInput
    tenantOverrides?: TenantPriceOverrideUncheckedUpdateManyWithoutOrgNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrgNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutOrgNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type ImportJobUpsertWithWhereUniqueWithoutMappingInput = {
    where: ImportJobWhereUniqueInput
    update: XOR<ImportJobUpdateWithoutMappingInput, ImportJobUncheckedUpdateWithoutMappingInput>
    create: XOR<ImportJobCreateWithoutMappingInput, ImportJobUncheckedCreateWithoutMappingInput>
  }

  export type ImportJobUpdateWithWhereUniqueWithoutMappingInput = {
    where: ImportJobWhereUniqueInput
    data: XOR<ImportJobUpdateWithoutMappingInput, ImportJobUncheckedUpdateWithoutMappingInput>
  }

  export type ImportJobUpdateManyWithWhereWithoutMappingInput = {
    where: ImportJobScalarWhereInput
    data: XOR<ImportJobUpdateManyMutationInput, ImportJobUncheckedUpdateManyWithoutMappingInput>
  }

  export type ImportJobCreateWithoutErrorsInput = {
    id?: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrgCreateNestedOneWithoutImportJobsInput
    user: UserCreateNestedOneWithoutImportJobsInput
    mapping?: ImportMappingCreateNestedOneWithoutJobsInput
  }

  export type ImportJobUncheckedCreateWithoutErrorsInput = {
    id?: string
    orgId: string
    userId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    mappingId?: string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportJobCreateOrConnectWithoutErrorsInput = {
    where: ImportJobWhereUniqueInput
    create: XOR<ImportJobCreateWithoutErrorsInput, ImportJobUncheckedCreateWithoutErrorsInput>
  }

  export type ImportJobUpsertWithoutErrorsInput = {
    update: XOR<ImportJobUpdateWithoutErrorsInput, ImportJobUncheckedUpdateWithoutErrorsInput>
    create: XOR<ImportJobCreateWithoutErrorsInput, ImportJobUncheckedCreateWithoutErrorsInput>
    where?: ImportJobWhereInput
  }

  export type ImportJobUpdateToOneWithWhereWithoutErrorsInput = {
    where?: ImportJobWhereInput
    data: XOR<ImportJobUpdateWithoutErrorsInput, ImportJobUncheckedUpdateWithoutErrorsInput>
  }

  export type ImportJobUpdateWithoutErrorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutImportJobsNestedInput
    user?: UserUpdateOneRequiredWithoutImportJobsNestedInput
    mapping?: ImportMappingUpdateOneWithoutJobsNestedInput
  }

  export type ImportJobUncheckedUpdateWithoutErrorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    mappingId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyOrgInput = {
    id?: string
    actorUserId?: string | null
    entity: string
    entityId?: string | null
    field?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    createdAt?: Date | string
  }

  export type BillingLedgerCreateManyOrgInput = {
    id?: string
    type: $Enums.LedgerType
    amount: Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CustomerCreateManyOrgInput = {
    id?: string
    publicId: string
    company?: string | null
    primaryName?: string | null
    primaryEmail?: string | null
    primaryPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyOrgInput = {
    id?: string
    customerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type JobCreateManyOrgInput = {
    id?: string
    customerId?: string | null
    rfpId?: string | null
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateManyOrgInput = {
    id?: string
    publicId: string
    sourceType: $Enums.LeadSource
    identityHash: string
    company?: string | null
    contactName?: string | null
    email?: string | null
    phoneE164?: string | null
    website?: string | null
    serviceCode?: string | null
    zip?: string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: boolean
    convertedAt?: Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: string | null
    notes?: string | null
    sourceDetail?: string | null
    state?: string | null
    postalCode?: string | null
    address?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    country?: string | null
  }

  export type OpportunityCreateManyOrgInput = {
    id?: string
    customerId: string
    valueType?: $Enums.ValueType
    estValue?: Decimal | DecimalJsLike | number | string | null
    stage?: string
    ownerId?: string | null
    sourceLeadId?: string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyOrgInput = {
    id?: string
    invoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: string
    receivedAt?: Date | string
    reference?: string | null
    status?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    failureReason?: string | null
    retryCount?: number
    lastRetryAt?: Date | string | null
  }

  export type ReferralCreateManyOrgInput = {
    id?: string
    employeeId?: string | null
    referredName: string
    referredEmail?: string | null
    referredPhone?: string | null
    status?: string
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RfpCreateManyOrgInput = {
    id?: string
    publicId: string
    sourceSite: string
    title: string
    dueDate?: Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyOrgInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    passwordHash?: string | null
    mustChangePassword?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    isLocked?: boolean
    lockedUntil?: Date | string | null
    failedLoginAttempts?: number
    lastFailedLogin?: Date | string | null
    lastSuccessfulLogin?: Date | string | null
    lastPasswordChange?: Date | string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    backupCodesHash?: string | null
  }

  export type RbacRoleCreateManyOrgInput = {
    id?: string
    name: string
    slug: string
    isSystem?: boolean
    createdAt?: Date | string
  }

  export type RbacUserRoleCreateManyOrgInput = {
    id?: string
    userId: string
    roleId: string
  }

  export type LeadInvoiceCreateManyOrgInput = {
    id?: string
    number: string
    periodFrom: Date | string
    periodTo: Date | string
    status: string
    subtotalCents: number
    taxCents?: number
    totalCents: number
    currency?: string
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadCount?: number
  }

  export type AiUsageEventCreateManyOrgInput = {
    id?: string
    userId?: string | null
    feature: string
    model: string
    tokensIn: number
    tokensOut: number
    costUsd: Decimal | DecimalJsLike | number | string
    creditsUsed: number
    requestId?: string | null
    createdAt?: Date | string
  }

  export type AiMonthlySummaryCreateManyOrgInput = {
    id?: string
    monthKey: string
    tokensIn?: number
    tokensOut?: number
    costUsd?: Decimal | DecimalJsLike | number | string
    creditsUsed?: number
    callCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyOrgInput = {
    id?: string
    actorType: string
    actorId?: string | null
    entityType: string
    entityId: string
    action: string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SubscriptionCreateManyOrgInput = {
    id?: string
    plan: string
    status: string
    startedAt: Date | string
    canceledAt?: Date | string | null
    renewsAt?: Date | string | null
    priceCents: number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageMeterCreateManyOrgInput = {
    id?: string
    meter: string
    quantity: number
    windowStart: Date | string
    windowEnd: Date | string
    createdAt?: Date | string
  }

  export type AddonPurchaseCreateManyOrgInput = {
    id?: string
    sku: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    purchasedAt?: Date | string
    refundedAt?: Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type TenantPriceOverrideCreateManyOrgInput = {
    id?: string
    planId?: string | null
    priceId?: string | null
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateManyOrgInput = {
    id?: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    assigneeUserId?: string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyOrgInput = {
    id?: string
    audience: string
    type: string
    title: string
    body: string
    severity: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ImportJobCreateManyOrgInput = {
    id?: string
    userId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    mappingId?: string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportMappingCreateManyOrgInput = {
    id?: string
    name: string
    entityType: $Enums.ImportEntityType
    sourceFormat: string
    fieldMappings: JsonNullValueInput | InputJsonValue
    transformRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isTemplate?: boolean
    useCount?: number
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    field?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingLedgerUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingLedgerUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingLedgerUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    jobs?: JobUpdateManyWithoutCustomerNestedInput
    opportunities?: OpportunityUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    jobs?: JobUncheckedUpdateManyWithoutCustomerNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    primaryName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type JobUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutJobsNestedInput
    rfp?: RfpUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    rfpId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    rfpId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    identityHash?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneE164?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: IntFieldUpdateOperationsInput | number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: BoolFieldUpdateOperationsInput | boolean
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDetail?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    LeadInvoiceLine?: LeadInvoiceLineUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    identityHash?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneE164?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: IntFieldUpdateOperationsInput | number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: BoolFieldUpdateOperationsInput | boolean
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDetail?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    LeadInvoiceLine?: LeadInvoiceLineUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    identityHash?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneE164?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    enrichmentJson?: JsonNullValueInput | InputJsonValue
    aiScore?: IntFieldUpdateOperationsInput | number
    scoreFactors?: JsonNullValueInput | InputJsonValue
    systemGenerated?: BoolFieldUpdateOperationsInput | boolean
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfp?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDetail?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpportunityUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    estValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    estValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    estValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferralUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    referredName?: StringFieldUpdateOperationsInput | string
    referredEmail?: NullableStringFieldUpdateOperationsInput | string | null
    referredPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    referredName?: StringFieldUpdateOperationsInput | string
    referredEmail?: NullableStringFieldUpdateOperationsInput | string | null
    referredPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    referredName?: StringFieldUpdateOperationsInput | string
    referredEmail?: NullableStringFieldUpdateOperationsInput | string | null
    referredPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RfpUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceSite?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: NullableIntFieldUpdateOperationsInput | number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutRfpNestedInput
  }

  export type RfpUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceSite?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: NullableIntFieldUpdateOperationsInput | number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutRfpNestedInput
  }

  export type RfpUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    sourceSite?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docs?: JsonNullValueInput | InputJsonValue
    aiBidFit?: NullableIntFieldUpdateOperationsInput | number | null
    aiPriceHint?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    rbacUserRoles?: RbacUserRoleUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
    rbacUserRoles?: RbacUserRoleUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: UserRecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    breakglassAccount?: UserBreakglassAccountUncheckedUpdateOneWithoutUserNestedInput
    securityQuestions?: UserSecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: UserLoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    deviceFingerprints?: UserDeviceFingerprintUncheckedUpdateManyWithoutUserNestedInput
    importJobs?: ImportJobUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccessfulLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    backupCodesHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RbacRoleUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePerms?: RbacRolePermissionUpdateManyWithoutRoleNestedInput
    userRoles?: RbacUserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RbacRoleUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePerms?: RbacRolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    userRoles?: RbacUserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RbacRoleUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RbacUserRoleUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutRbacUserRolesNestedInput
    role?: RbacRoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type RbacUserRoleUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type RbacUserRoleUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadInvoiceUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    periodFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    periodTo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    taxCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadCount?: IntFieldUpdateOperationsInput | number
    lines?: LeadInvoiceLineUpdateManyWithoutInvoiceNestedInput
  }

  export type LeadInvoiceUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    periodFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    periodTo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    taxCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadCount?: IntFieldUpdateOperationsInput | number
    lines?: LeadInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type LeadInvoiceUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    periodFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    periodTo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    taxCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadCount?: IntFieldUpdateOperationsInput | number
  }

  export type AiUsageEventUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiUsageEventUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiUsageEventUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMonthlySummaryUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthKey?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    callCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMonthlySummaryUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthKey?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    callCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMonthlySummaryUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthKey?: StringFieldUpdateOperationsInput | string
    tokensIn?: IntFieldUpdateOperationsInput | number
    tokensOut?: IntFieldUpdateOperationsInput | number
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creditsUsed?: IntFieldUpdateOperationsInput | number
    callCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorType?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMeterUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    meter?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMeterUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    meter?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMeterUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    meter?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddonPurchaseUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type AddonPurchaseUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type AddonPurchaseUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: JsonNullValueInput | InputJsonValue
  }

  export type TenantPriceOverrideUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PricePlanUpdateOneWithoutOverridesNestedInput
    price?: PlanPriceUpdateOneWithoutOverridesNestedInput
  }

  export type TenantPriceOverrideUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantPriceOverrideUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assigneeUserId?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assigneeUserId?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    assigneeUserId?: NullableStringFieldUpdateOperationsInput | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutImportJobsNestedInput
    mapping?: ImportMappingUpdateOneWithoutJobsNestedInput
    errors?: ImportErrorUpdateManyWithoutImportJobNestedInput
  }

  export type ImportJobUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    mappingId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: ImportErrorUncheckedUpdateManyWithoutImportJobNestedInput
  }

  export type ImportJobUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    mappingId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportMappingUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    sourceFormat?: StringFieldUpdateOperationsInput | string
    fieldMappings?: JsonNullValueInput | InputJsonValue
    transformRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    useCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: ImportJobUpdateManyWithoutMappingNestedInput
  }

  export type ImportMappingUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    sourceFormat?: StringFieldUpdateOperationsInput | string
    fieldMappings?: JsonNullValueInput | InputJsonValue
    transformRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    useCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: ImportJobUncheckedUpdateManyWithoutMappingNestedInput
  }

  export type ImportMappingUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    sourceFormat?: StringFieldUpdateOperationsInput | string
    fieldMappings?: JsonNullValueInput | InputJsonValue
    transformRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    useCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RbacUserRoleCreateManyUserInput = {
    id?: string
    orgId?: string | null
    roleId: string
  }

  export type UserRecoveryCodeCreateManyUserInput = {
    id?: string
    codeHash: string
    usedAt?: Date | string | null
    usedFrom?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type UserSecurityQuestionCreateManyUserInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
  }

  export type UserLoginHistoryCreateManyUserInput = {
    id?: string
    success: boolean
    method: string
    ipAddress: string
    userAgent: string
    deviceFingerprint?: string | null
    riskScore?: number
    riskFactors?: string | null
    country?: string | null
    city?: string | null
    timestamp?: Date | string
  }

  export type UserDeviceFingerprintCreateManyUserInput = {
    id?: string
    fingerprint: string
    ipAddress: string
    userAgent: string
    isTrusted?: boolean
    trustScore?: number
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    loginCount?: number
  }

  export type ImportJobCreateManyUserInput = {
    id?: string
    orgId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    mappingId?: string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RbacUserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    org?: OrgUpdateOneWithoutRbacUserRolesNestedInput
    role?: RbacRoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type RbacUserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type RbacUserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRecoveryCodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRecoveryCodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRecoveryCodeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSecurityQuestionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSecurityQuestionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSecurityQuestionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceFingerprintUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserDeviceFingerprintUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserDeviceFingerprintUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fingerprint?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginCount?: IntFieldUpdateOperationsInput | number
  }

  export type ImportJobUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutImportJobsNestedInput
    mapping?: ImportMappingUpdateOneWithoutJobsNestedInput
    errors?: ImportErrorUpdateManyWithoutImportJobNestedInput
  }

  export type ImportJobUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    mappingId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: ImportErrorUncheckedUpdateManyWithoutImportJobNestedInput
  }

  export type ImportJobUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    mappingId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadInvoiceLineCreateManyLeadInput = {
    id?: string
    invoiceId: string
    description: string
    quantity?: number
    unitPriceCents: number
    amountCents: number
    source?: string | null
    createdAt?: Date | string
  }

  export type LeadInvoiceLineUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: LeadInvoiceUpdateOneRequiredWithoutLinesNestedInput
  }

  export type LeadInvoiceLineUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadInvoiceLineUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyCustomerInput = {
    id?: string
    orgId: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    issuedAt?: Date | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type JobCreateManyCustomerInput = {
    id?: string
    orgId: string
    rfpId?: string | null
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityCreateManyCustomerInput = {
    id?: string
    orgId: string
    valueType?: $Enums.ValueType
    estValue?: Decimal | DecimalJsLike | number | string | null
    stage?: string
    ownerId?: string | null
    sourceLeadId?: string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    org?: OrgUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
    lineItems?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type JobUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutJobsNestedInput
    rfp?: RfpUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    rfpId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    rfpId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    estValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutOpportunitiesNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    estValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    estValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineCreateManyInvoiceInput = {
    id?: string
    description: string
    lineType: $Enums.InvoiceLineType
    quantity?: number
    unitPriceCents: number
    amountCents: number
    sourceType?: string | null
    sourceId?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    orgId: string
    amount: Decimal | DecimalJsLike | number | string
    method?: string
    receivedAt?: Date | string
    reference?: string | null
    status?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    failureReason?: string | null
    retryCount?: number
    lastRetryAt?: Date | string | null
  }

  export type InvoiceLineUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lineType?: EnumInvoiceLineTypeFieldUpdateOperationsInput | $Enums.InvoiceLineType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lineType?: EnumInvoiceLineTypeFieldUpdateOperationsInput | $Enums.InvoiceLineType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    lineType?: EnumInvoiceLineTypeFieldUpdateOperationsInput | $Enums.InvoiceLineType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrgUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobCreateManyRfpInput = {
    id?: string
    orgId: string
    customerId?: string | null
    status?: string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateWithoutRfpInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutJobsNestedInput
    org?: OrgUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutRfpInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyWithoutRfpInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadInvoiceLineCreateManyInvoiceInput = {
    id?: string
    leadId?: string | null
    description: string
    quantity?: number
    unitPriceCents: number
    amountCents: number
    source?: string | null
    createdAt?: Date | string
  }

  export type LeadInvoiceLineUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutLeadInvoiceLineNestedInput
  }

  export type LeadInvoiceLineUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadInvoiceLineUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    amountCents?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RbacRolePermissionCreateManyPermissionInput = {
    roleId: string
  }

  export type RbacRolePermissionUpdateWithoutPermissionInput = {
    role?: RbacRoleUpdateOneRequiredWithoutRolePermsNestedInput
  }

  export type RbacRolePermissionUncheckedUpdateWithoutPermissionInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type RbacRolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type RbacRolePermissionCreateManyRoleInput = {
    permissionId: string
  }

  export type RbacUserRoleCreateManyRoleInput = {
    id?: string
    userId: string
    orgId?: string | null
  }

  export type RbacRolePermissionUpdateWithoutRoleInput = {
    permission?: RbacPermissionUpdateOneRequiredWithoutRolePermsNestedInput
  }

  export type RbacRolePermissionUncheckedUpdateWithoutRoleInput = {
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RbacRolePermissionUncheckedUpdateManyWithoutRoleInput = {
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RbacUserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutRbacUserRolesNestedInput
    org?: OrgUpdateOneWithoutRbacUserRolesNestedInput
  }

  export type RbacUserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RbacUserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanPriceCreateManyPlanInput = {
    id?: string
    currency?: string
    unitAmountCents: number
    cadence?: $Enums.BillingCadence
    trialDays?: number | null
    active?: boolean
    stripePriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferCreateManyAppliesToPlanInput = {
    id?: string
    name: string
    percentOff?: number | null
    amountOffCents?: number | null
    duration?: string | null
    durationMonths?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantPriceOverrideCreateManyPlanInput = {
    id?: string
    orgId: string
    priceId?: string | null
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalMonetizationConfigCreateManyDefaultPlanInput = {
    id?: string
    defaultPriceId?: string | null
    defaultTrialDays?: number | null
    publicOnboarding?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingInviteCreateManyPlanInput = {
    id?: string
    token: string
    email?: string | null
    priceId?: string | null
    offerId?: string | null
    couponId?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type PlanPriceUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: TenantPriceOverrideUpdateManyWithoutPriceNestedInput
    asDefaultFor?: GlobalMonetizationConfigUpdateManyWithoutDefaultPriceNestedInput
    invites?: OnboardingInviteUpdateManyWithoutPriceNestedInput
  }

  export type PlanPriceUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overrides?: TenantPriceOverrideUncheckedUpdateManyWithoutPriceNestedInput
    asDefaultFor?: GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPriceNestedInput
    invites?: OnboardingInviteUncheckedUpdateManyWithoutPriceNestedInput
  }

  export type PlanPriceUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    unitAmountCents?: IntFieldUpdateOperationsInput | number
    cadence?: EnumBillingCadenceFieldUpdateOperationsInput | $Enums.BillingCadence
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUpdateWithoutAppliesToPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: OnboardingInviteUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutAppliesToPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: OnboardingInviteUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateManyWithoutAppliesToPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantPriceOverrideUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutTenantOverridesNestedInput
    price?: PlanPriceUpdateOneWithoutOverridesNestedInput
  }

  export type TenantPriceOverrideUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantPriceOverrideUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalMonetizationConfigUpdateWithoutDefaultPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultTrialDays?: NullableIntFieldUpdateOperationsInput | number | null
    publicOnboarding?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultPrice?: PlanPriceUpdateOneWithoutAsDefaultForNestedInput
  }

  export type GlobalMonetizationConfigUncheckedUpdateWithoutDefaultPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTrialDays?: NullableIntFieldUpdateOperationsInput | number | null
    publicOnboarding?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTrialDays?: NullableIntFieldUpdateOperationsInput | number | null
    publicOnboarding?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: PlanPriceUpdateOneWithoutInvitesNestedInput
    offer?: OfferUpdateOneWithoutInvitesNestedInput
    coupon?: CouponUpdateOneWithoutInvitesNestedInput
  }

  export type OnboardingInviteUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantPriceOverrideCreateManyPriceInput = {
    id?: string
    orgId: string
    planId?: string | null
    type?: $Enums.OverrideType
    percentOff?: number | null
    amountOffCents?: number | null
    priceCents?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalMonetizationConfigCreateManyDefaultPriceInput = {
    id?: string
    defaultPlanId?: string | null
    defaultTrialDays?: number | null
    publicOnboarding?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingInviteCreateManyPriceInput = {
    id?: string
    token: string
    email?: string | null
    planId?: string | null
    offerId?: string | null
    couponId?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type TenantPriceOverrideUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutTenantOverridesNestedInput
    plan?: PricePlanUpdateOneWithoutOverridesNestedInput
  }

  export type TenantPriceOverrideUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantPriceOverrideUncheckedUpdateManyWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOverrideTypeFieldUpdateOperationsInput | $Enums.OverrideType
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    priceCents?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalMonetizationConfigUpdateWithoutDefaultPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultTrialDays?: NullableIntFieldUpdateOperationsInput | number | null
    publicOnboarding?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultPlan?: PricePlanUpdateOneWithoutAsDefaultForNestedInput
  }

  export type GlobalMonetizationConfigUncheckedUpdateWithoutDefaultPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTrialDays?: NullableIntFieldUpdateOperationsInput | number | null
    publicOnboarding?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalMonetizationConfigUncheckedUpdateManyWithoutDefaultPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTrialDays?: NullableIntFieldUpdateOperationsInput | number | null
    publicOnboarding?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PricePlanUpdateOneWithoutInvitesNestedInput
    offer?: OfferUpdateOneWithoutInvitesNestedInput
    coupon?: CouponUpdateOneWithoutInvitesNestedInput
  }

  export type OnboardingInviteUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteUncheckedUpdateManyWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteCreateManyOfferInput = {
    id?: string
    token: string
    email?: string | null
    planId?: string | null
    priceId?: string | null
    couponId?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type OnboardingInviteUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PricePlanUpdateOneWithoutInvitesNestedInput
    price?: PlanPriceUpdateOneWithoutInvitesNestedInput
    coupon?: CouponUpdateOneWithoutInvitesNestedInput
  }

  export type OnboardingInviteUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteCreateManyCouponInput = {
    id?: string
    token: string
    email?: string | null
    planId?: string | null
    priceId?: string | null
    offerId?: string | null
    trialDays?: number | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type OnboardingInviteUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PricePlanUpdateOneWithoutInvitesNestedInput
    price?: PlanPriceUpdateOneWithoutInvitesNestedInput
    offer?: OfferUpdateOneWithoutInvitesNestedInput
  }

  export type OnboardingInviteUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInviteUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialDays?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportErrorCreateManyImportJobInput = {
    id?: string
    rowNumber: number
    fieldName?: string | null
    errorType: string
    errorMessage: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ImportErrorUpdateWithoutImportJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportErrorUncheckedUpdateWithoutImportJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportErrorUncheckedUpdateManyWithoutImportJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobCreateManyMappingInput = {
    id?: string
    orgId: string
    userId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportStatus
    fileName: string
    fileSize: number
    totalRecords?: number
    processedRecords?: number
    successCount?: number
    errorCount?: number
    skipCount?: number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportJobUpdateWithoutMappingInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrgUpdateOneRequiredWithoutImportJobsNestedInput
    user?: UserUpdateOneRequiredWithoutImportJobsNestedInput
    errors?: ImportErrorUpdateManyWithoutImportJobNestedInput
  }

  export type ImportJobUncheckedUpdateWithoutMappingInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: ImportErrorUncheckedUpdateManyWithoutImportJobNestedInput
  }

  export type ImportJobUncheckedUpdateManyWithoutMappingInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    processedRecords?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    skipCount?: IntFieldUpdateOperationsInput | number
    sampleData?: NullableJsonNullValueInput | InputJsonValue
    fieldMappings?: NullableJsonNullValueInput | InputJsonValue
    transformRules?: NullableJsonNullValueInput | InputJsonValue
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    progressPercent?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}